var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: !0, configurable: !0, writable: !0, value }) : obj[key] = value;
var __name = (target, value) => __defProp(target, "name", { value, configurable: !0 });
var __publicField = (obj, key, value) => __defNormalProp(obj, typeof key != "symbol" ? key + "" : key, value);
import * as React from "react";
import React__default, { createContext as createContext$1, forwardRef, createElement, isValidElement, version as version$2, useContext as useContext$1, useRef, useLayoutEffect as useLayoutEffect$2, useEffect, useState, useMemo as useMemo$1, Children, useCallback, useImperativeHandle, cloneElement as cloneElement$1, Component as Component$1 } from "react";
import * as ReactDOM from "react-dom";
import ReactDOM__default, { createPortal, unstable_batchedUpdates, flushSync } from "react-dom";
const consoleLogger = {
  type: "logger",
  log(args) {
    this.output("log", args);
  },
  warn(args) {
    this.output("warn", args);
  },
  error(args) {
    this.output("error", args);
  },
  output(type4, args) {
    console && console[type4] && console[type4].apply(console, args);
  }
}, _Logger = class _Logger {
  constructor(concreteLogger) {
    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    this.init(concreteLogger, options);
  }
  init(concreteLogger) {
    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    this.prefix = options.prefix || "i18next:", this.logger = concreteLogger || consoleLogger, this.options = options, this.debug = options.debug;
  }
  log() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++)
      args[_key] = arguments[_key];
    return this.forward(args, "log", "", !0);
  }
  warn() {
    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++)
      args[_key2] = arguments[_key2];
    return this.forward(args, "warn", "", !0);
  }
  error() {
    for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++)
      args[_key3] = arguments[_key3];
    return this.forward(args, "error", "");
  }
  deprecate() {
    for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++)
      args[_key4] = arguments[_key4];
    return this.forward(args, "warn", "WARNING DEPRECATED: ", !0);
  }
  forward(args, lvl, prefix, debugOnly) {
    return debugOnly && !this.debug ? null : (typeof args[0] == "string" && (args[0] = `${prefix}${this.prefix} ${args[0]}`), this.logger[lvl](args));
  }
  create(moduleName) {
    return new _Logger(this.logger, {
      prefix: `${this.prefix}:${moduleName}:`,
      ...this.options
    });
  }
  clone(options) {
    return options = options || this.options, options.prefix = options.prefix || this.prefix, new _Logger(this.logger, options);
  }
};
__name(_Logger, "Logger");
let Logger = _Logger;
var baseLogger = new Logger();
const _EventEmitter = class _EventEmitter {
  constructor() {
    this.observers = {};
  }
  on(events, listener) {
    return events.split(" ").forEach((event) => {
      this.observers[event] || (this.observers[event] = /* @__PURE__ */ new Map());
      const numListeners = this.observers[event].get(listener) || 0;
      this.observers[event].set(listener, numListeners + 1);
    }), this;
  }
  off(event, listener) {
    if (this.observers[event]) {
      if (!listener) {
        delete this.observers[event];
        return;
      }
      this.observers[event].delete(listener);
    }
  }
  emit(event) {
    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++)
      args[_key - 1] = arguments[_key];
    this.observers[event] && Array.from(this.observers[event].entries()).forEach((_ref) => {
      let [observer, numTimesAdded] = _ref;
      for (let i = 0; i < numTimesAdded; i++)
        observer(...args);
    }), this.observers["*"] && Array.from(this.observers["*"].entries()).forEach((_ref2) => {
      let [observer, numTimesAdded] = _ref2;
      for (let i = 0; i < numTimesAdded; i++)
        observer.apply(observer, [event, ...args]);
    });
  }
};
__name(_EventEmitter, "EventEmitter");
let EventEmitter = _EventEmitter;
function defer() {
  let res, rej;
  const promise = new Promise((resolve, reject) => {
    res = resolve, rej = reject;
  });
  return promise.resolve = res, promise.reject = rej, promise;
}
__name(defer, "defer");
function makeString(object4) {
  return object4 == null ? "" : "" + object4;
}
__name(makeString, "makeString");
function copy$2(a, s, t2) {
  a.forEach((m2) => {
    s[m2] && (t2[m2] = s[m2]);
  });
}
__name(copy$2, "copy$2");
const lastOfPathSeparatorRegExp = /###/g;
function getLastOfPath(object4, path2, Empty2) {
  function cleanKey(key) {
    return key && key.indexOf("###") > -1 ? key.replace(lastOfPathSeparatorRegExp, ".") : key;
  }
  __name(cleanKey, "cleanKey");
  function canNotTraverseDeeper() {
    return !object4 || typeof object4 == "string";
  }
  __name(canNotTraverseDeeper, "canNotTraverseDeeper");
  const stack = typeof path2 != "string" ? path2 : path2.split(".");
  let stackIndex = 0;
  for (; stackIndex < stack.length - 1; ) {
    if (canNotTraverseDeeper()) return {};
    const key = cleanKey(stack[stackIndex]);
    !object4[key] && Empty2 && (object4[key] = new Empty2()), Object.prototype.hasOwnProperty.call(object4, key) ? object4 = object4[key] : object4 = {}, ++stackIndex;
  }
  return canNotTraverseDeeper() ? {} : {
    obj: object4,
    k: cleanKey(stack[stackIndex])
  };
}
__name(getLastOfPath, "getLastOfPath");
function setPath(object4, path2, newValue) {
  const {
    obj,
    k
  } = getLastOfPath(object4, path2, Object);
  if (obj !== void 0 || path2.length === 1) {
    obj[k] = newValue;
    return;
  }
  let e2 = path2[path2.length - 1], p = path2.slice(0, path2.length - 1), last = getLastOfPath(object4, p, Object);
  for (; last.obj === void 0 && p.length; )
    e2 = `${p[p.length - 1]}.${e2}`, p = p.slice(0, p.length - 1), last = getLastOfPath(object4, p, Object), last && last.obj && typeof last.obj[`${last.k}.${e2}`] < "u" && (last.obj = void 0);
  last.obj[`${last.k}.${e2}`] = newValue;
}
__name(setPath, "setPath");
function pushPath(object4, path2, newValue, concat) {
  const {
    obj,
    k
  } = getLastOfPath(object4, path2, Object);
  obj[k] = obj[k] || [], obj[k].push(newValue);
}
__name(pushPath, "pushPath");
function getPath(object4, path2) {
  const {
    obj,
    k
  } = getLastOfPath(object4, path2);
  if (obj)
    return obj[k];
}
__name(getPath, "getPath");
function getPathWithDefaults(data, defaultData, key) {
  const value = getPath(data, key);
  return value !== void 0 ? value : getPath(defaultData, key);
}
__name(getPathWithDefaults, "getPathWithDefaults");
function deepExtend(target, source, overwrite) {
  for (const prop in source)
    prop !== "__proto__" && prop !== "constructor" && (prop in target ? typeof target[prop] == "string" || target[prop] instanceof String || typeof source[prop] == "string" || source[prop] instanceof String ? overwrite && (target[prop] = source[prop]) : deepExtend(target[prop], source[prop], overwrite) : target[prop] = source[prop]);
  return target;
}
__name(deepExtend, "deepExtend");
function regexEscape(str) {
  return str.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, "\\$&");
}
__name(regexEscape, "regexEscape");
var _entityMap = {
  "&": "&amp;",
  "<": "&lt;",
  ">": "&gt;",
  '"': "&quot;",
  "'": "&#39;",
  "/": "&#x2F;"
};
function escape(data) {
  return typeof data == "string" ? data.replace(/[&<>"'\/]/g, (s) => _entityMap[s]) : data;
}
__name(escape, "escape");
const _RegExpCache = class _RegExpCache {
  constructor(capacity) {
    this.capacity = capacity, this.regExpMap = /* @__PURE__ */ new Map(), this.regExpQueue = [];
  }
  getRegExp(pattern4) {
    const regExpFromCache = this.regExpMap.get(pattern4);
    if (regExpFromCache !== void 0)
      return regExpFromCache;
    const regExpNew = new RegExp(pattern4);
    return this.regExpQueue.length === this.capacity && this.regExpMap.delete(this.regExpQueue.shift()), this.regExpMap.set(pattern4, regExpNew), this.regExpQueue.push(pattern4), regExpNew;
  }
};
__name(_RegExpCache, "RegExpCache");
let RegExpCache = _RegExpCache;
const chars = [" ", ",", "?", "!", ";"], looksLikeObjectPathRegExpCache = new RegExpCache(20);
function looksLikeObjectPath(key, nsSeparator, keySeparator) {
  nsSeparator = nsSeparator || "", keySeparator = keySeparator || "";
  const possibleChars = chars.filter((c) => nsSeparator.indexOf(c) < 0 && keySeparator.indexOf(c) < 0);
  if (possibleChars.length === 0) return !0;
  const r2 = looksLikeObjectPathRegExpCache.getRegExp(`(${possibleChars.map((c) => c === "?" ? "\\?" : c).join("|")})`);
  let matched = !r2.test(key);
  if (!matched) {
    const ki = key.indexOf(keySeparator);
    ki > 0 && !r2.test(key.substring(0, ki)) && (matched = !0);
  }
  return matched;
}
__name(looksLikeObjectPath, "looksLikeObjectPath");
function deepFind(obj, path2) {
  let keySeparator = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : ".";
  if (!obj) return;
  if (obj[path2]) return obj[path2];
  const tokens = path2.split(keySeparator);
  let current = obj;
  for (let i = 0; i < tokens.length; ) {
    if (!current || typeof current != "object")
      return;
    let next2, nextPath = "";
    for (let j = i; j < tokens.length; ++j)
      if (j !== i && (nextPath += keySeparator), nextPath += tokens[j], next2 = current[nextPath], next2 !== void 0) {
        if (["string", "number", "boolean"].indexOf(typeof next2) > -1 && j < tokens.length - 1)
          continue;
        i += j - i + 1;
        break;
      }
    current = next2;
  }
  return current;
}
__name(deepFind, "deepFind");
function getCleanedCode(code) {
  return code && code.indexOf("_") > 0 ? code.replace("_", "-") : code;
}
__name(getCleanedCode, "getCleanedCode");
const _ResourceStore = class _ResourceStore extends EventEmitter {
  constructor(data) {
    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
      ns: ["translation"],
      defaultNS: "translation"
    };
    super(), this.data = data || {}, this.options = options, this.options.keySeparator === void 0 && (this.options.keySeparator = "."), this.options.ignoreJSONStructure === void 0 && (this.options.ignoreJSONStructure = !0);
  }
  addNamespaces(ns) {
    this.options.ns.indexOf(ns) < 0 && this.options.ns.push(ns);
  }
  removeNamespaces(ns) {
    const index2 = this.options.ns.indexOf(ns);
    index2 > -1 && this.options.ns.splice(index2, 1);
  }
  getResource(lng, ns, key) {
    let options = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
    const keySeparator = options.keySeparator !== void 0 ? options.keySeparator : this.options.keySeparator, ignoreJSONStructure = options.ignoreJSONStructure !== void 0 ? options.ignoreJSONStructure : this.options.ignoreJSONStructure;
    let path2;
    lng.indexOf(".") > -1 ? path2 = lng.split(".") : (path2 = [lng, ns], key && (Array.isArray(key) ? path2.push(...key) : typeof key == "string" && keySeparator ? path2.push(...key.split(keySeparator)) : path2.push(key)));
    const result = getPath(this.data, path2);
    return !result && !ns && !key && lng.indexOf(".") > -1 && (lng = path2[0], ns = path2[1], key = path2.slice(2).join(".")), result || !ignoreJSONStructure || typeof key != "string" ? result : deepFind(this.data && this.data[lng] && this.data[lng][ns], key, keySeparator);
  }
  addResource(lng, ns, key, value) {
    let options = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : {
      silent: !1
    };
    const keySeparator = options.keySeparator !== void 0 ? options.keySeparator : this.options.keySeparator;
    let path2 = [lng, ns];
    key && (path2 = path2.concat(keySeparator ? key.split(keySeparator) : key)), lng.indexOf(".") > -1 && (path2 = lng.split("."), value = ns, ns = path2[1]), this.addNamespaces(ns), setPath(this.data, path2, value), options.silent || this.emit("added", lng, ns, key, value);
  }
  addResources(lng, ns, resources) {
    let options = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {
      silent: !1
    };
    for (const m2 in resources)
      (typeof resources[m2] == "string" || Array.isArray(resources[m2])) && this.addResource(lng, ns, m2, resources[m2], {
        silent: !0
      });
    options.silent || this.emit("added", lng, ns, resources);
  }
  addResourceBundle(lng, ns, resources, deep, overwrite) {
    let options = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : {
      silent: !1,
      skipCopy: !1
    }, path2 = [lng, ns];
    lng.indexOf(".") > -1 && (path2 = lng.split("."), deep = resources, resources = ns, ns = path2[1]), this.addNamespaces(ns);
    let pack = getPath(this.data, path2) || {};
    options.skipCopy || (resources = JSON.parse(JSON.stringify(resources))), deep ? deepExtend(pack, resources, overwrite) : pack = {
      ...pack,
      ...resources
    }, setPath(this.data, path2, pack), options.silent || this.emit("added", lng, ns, resources);
  }
  removeResourceBundle(lng, ns) {
    this.hasResourceBundle(lng, ns) && delete this.data[lng][ns], this.removeNamespaces(ns), this.emit("removed", lng, ns);
  }
  hasResourceBundle(lng, ns) {
    return this.getResource(lng, ns) !== void 0;
  }
  getResourceBundle(lng, ns) {
    return ns || (ns = this.options.defaultNS), this.options.compatibilityAPI === "v1" ? {
      ...this.getResource(lng, ns)
    } : this.getResource(lng, ns);
  }
  getDataByLanguage(lng) {
    return this.data[lng];
  }
  hasLanguageSomeTranslations(lng) {
    const data = this.getDataByLanguage(lng);
    return !!(data && Object.keys(data) || []).find((v) => data[v] && Object.keys(data[v]).length > 0);
  }
  toJSON() {
    return this.data;
  }
};
__name(_ResourceStore, "ResourceStore");
let ResourceStore = _ResourceStore;
var postProcessor = {
  processors: {},
  addPostProcessor(module2) {
    this.processors[module2.name] = module2;
  },
  handle(processors, value, key, options, translator) {
    return processors.forEach((processor) => {
      this.processors[processor] && (value = this.processors[processor].process(value, key, options, translator));
    }), value;
  }
};
const checkedLoadedFor = {}, _Translator = class _Translator extends EventEmitter {
  constructor(services) {
    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    super(), copy$2(["resourceStore", "languageUtils", "pluralResolver", "interpolator", "backendConnector", "i18nFormat", "utils"], services, this), this.options = options, this.options.keySeparator === void 0 && (this.options.keySeparator = "."), this.logger = baseLogger.create("translator");
  }
  changeLanguage(lng) {
    lng && (this.language = lng);
  }
  exists(key) {
    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
      interpolation: {}
    };
    if (key == null)
      return !1;
    const resolved = this.resolve(key, options);
    return resolved && resolved.res !== void 0;
  }
  extractFromKey(key, options) {
    let nsSeparator = options.nsSeparator !== void 0 ? options.nsSeparator : this.options.nsSeparator;
    nsSeparator === void 0 && (nsSeparator = ":");
    const keySeparator = options.keySeparator !== void 0 ? options.keySeparator : this.options.keySeparator;
    let namespaces = options.ns || this.options.defaultNS || [];
    const wouldCheckForNsInKey = nsSeparator && key.indexOf(nsSeparator) > -1, seemsNaturalLanguage = !this.options.userDefinedKeySeparator && !options.keySeparator && !this.options.userDefinedNsSeparator && !options.nsSeparator && !looksLikeObjectPath(key, nsSeparator, keySeparator);
    if (wouldCheckForNsInKey && !seemsNaturalLanguage) {
      const m2 = key.match(this.interpolator.nestingRegexp);
      if (m2 && m2.length > 0)
        return {
          key,
          namespaces
        };
      const parts = key.split(nsSeparator);
      (nsSeparator !== keySeparator || nsSeparator === keySeparator && this.options.ns.indexOf(parts[0]) > -1) && (namespaces = parts.shift()), key = parts.join(keySeparator);
    }
    return typeof namespaces == "string" && (namespaces = [namespaces]), {
      key,
      namespaces
    };
  }
  translate(keys2, options, lastKey) {
    if (typeof options != "object" && this.options.overloadTranslationOptionHandler && (options = this.options.overloadTranslationOptionHandler(arguments)), typeof options == "object" && (options = {
      ...options
    }), options || (options = {}), keys2 == null) return "";
    Array.isArray(keys2) || (keys2 = [String(keys2)]);
    const returnDetails = options.returnDetails !== void 0 ? options.returnDetails : this.options.returnDetails, keySeparator = options.keySeparator !== void 0 ? options.keySeparator : this.options.keySeparator, {
      key,
      namespaces
    } = this.extractFromKey(keys2[keys2.length - 1], options), namespace = namespaces[namespaces.length - 1], lng = options.lng || this.language, appendNamespaceToCIMode = options.appendNamespaceToCIMode || this.options.appendNamespaceToCIMode;
    if (lng && lng.toLowerCase() === "cimode") {
      if (appendNamespaceToCIMode) {
        const nsSeparator = options.nsSeparator || this.options.nsSeparator;
        return returnDetails ? {
          res: `${namespace}${nsSeparator}${key}`,
          usedKey: key,
          exactUsedKey: key,
          usedLng: lng,
          usedNS: namespace,
          usedParams: this.getUsedParamsDetails(options)
        } : `${namespace}${nsSeparator}${key}`;
      }
      return returnDetails ? {
        res: key,
        usedKey: key,
        exactUsedKey: key,
        usedLng: lng,
        usedNS: namespace,
        usedParams: this.getUsedParamsDetails(options)
      } : key;
    }
    const resolved = this.resolve(keys2, options);
    let res = resolved && resolved.res;
    const resUsedKey = resolved && resolved.usedKey || key, resExactUsedKey = resolved && resolved.exactUsedKey || key, resType = Object.prototype.toString.apply(res), noObject = ["[object Number]", "[object Function]", "[object RegExp]"], joinArrays = options.joinArrays !== void 0 ? options.joinArrays : this.options.joinArrays, handleAsObjectInI18nFormat = !this.i18nFormat || this.i18nFormat.handleAsObject;
    if (handleAsObjectInI18nFormat && res && (typeof res != "string" && typeof res != "boolean" && typeof res != "number") && noObject.indexOf(resType) < 0 && !(typeof joinArrays == "string" && Array.isArray(res))) {
      if (!options.returnObjects && !this.options.returnObjects) {
        this.options.returnedObjectHandler || this.logger.warn("accessing an object - but returnObjects options is not enabled!");
        const r2 = this.options.returnedObjectHandler ? this.options.returnedObjectHandler(resUsedKey, res, {
          ...options,
          ns: namespaces
        }) : `key '${key} (${this.language})' returned an object instead of string.`;
        return returnDetails ? (resolved.res = r2, resolved.usedParams = this.getUsedParamsDetails(options), resolved) : r2;
      }
      if (keySeparator) {
        const resTypeIsArray = Array.isArray(res), copy2 = resTypeIsArray ? [] : {}, newKeyToUse = resTypeIsArray ? resExactUsedKey : resUsedKey;
        for (const m2 in res)
          if (Object.prototype.hasOwnProperty.call(res, m2)) {
            const deepKey = `${newKeyToUse}${keySeparator}${m2}`;
            copy2[m2] = this.translate(deepKey, {
              ...options,
              joinArrays: !1,
              ns: namespaces
            }), copy2[m2] === deepKey && (copy2[m2] = res[m2]);
          }
        res = copy2;
      }
    } else if (handleAsObjectInI18nFormat && typeof joinArrays == "string" && Array.isArray(res))
      res = res.join(joinArrays), res && (res = this.extendTranslation(res, keys2, options, lastKey));
    else {
      let usedDefault = !1, usedKey = !1;
      const needsPluralHandling = options.count !== void 0 && typeof options.count != "string", hasDefaultValue = _Translator.hasDefaultValue(options), defaultValueSuffix = needsPluralHandling ? this.pluralResolver.getSuffix(lng, options.count, options) : "", defaultValueSuffixOrdinalFallback = options.ordinal && needsPluralHandling ? this.pluralResolver.getSuffix(lng, options.count, {
        ordinal: !1
      }) : "", needsZeroSuffixLookup = needsPluralHandling && !options.ordinal && options.count === 0 && this.pluralResolver.shouldUseIntlApi(), defaultValue = needsZeroSuffixLookup && options[`defaultValue${this.options.pluralSeparator}zero`] || options[`defaultValue${defaultValueSuffix}`] || options[`defaultValue${defaultValueSuffixOrdinalFallback}`] || options.defaultValue;
      !this.isValidLookup(res) && hasDefaultValue && (usedDefault = !0, res = defaultValue), this.isValidLookup(res) || (usedKey = !0, res = key);
      const resForMissing = (options.missingKeyNoValueFallbackToKey || this.options.missingKeyNoValueFallbackToKey) && usedKey ? void 0 : res, updateMissing = hasDefaultValue && defaultValue !== res && this.options.updateMissing;
      if (usedKey || usedDefault || updateMissing) {
        if (this.logger.log(updateMissing ? "updateKey" : "missingKey", lng, namespace, key, updateMissing ? defaultValue : res), keySeparator) {
          const fk = this.resolve(key, {
            ...options,
            keySeparator: !1
          });
          fk && fk.res && this.logger.warn("Seems the loaded translations were in flat JSON format instead of nested. Either set keySeparator: false on init or make sure your translations are published in nested format.");
        }
        let lngs = [];
        const fallbackLngs = this.languageUtils.getFallbackCodes(this.options.fallbackLng, options.lng || this.language);
        if (this.options.saveMissingTo === "fallback" && fallbackLngs && fallbackLngs[0])
          for (let i = 0; i < fallbackLngs.length; i++)
            lngs.push(fallbackLngs[i]);
        else this.options.saveMissingTo === "all" ? lngs = this.languageUtils.toResolveHierarchy(options.lng || this.language) : lngs.push(options.lng || this.language);
        const send = /* @__PURE__ */ __name((l2, k, specificDefaultValue) => {
          const defaultForMissing = hasDefaultValue && specificDefaultValue !== res ? specificDefaultValue : resForMissing;
          this.options.missingKeyHandler ? this.options.missingKeyHandler(l2, namespace, k, defaultForMissing, updateMissing, options) : this.backendConnector && this.backendConnector.saveMissing && this.backendConnector.saveMissing(l2, namespace, k, defaultForMissing, updateMissing, options), this.emit("missingKey", l2, namespace, k, res);
        }, "send");
        this.options.saveMissing && (this.options.saveMissingPlurals && needsPluralHandling ? lngs.forEach((language) => {
          const suffixes = this.pluralResolver.getSuffixes(language, options);
          needsZeroSuffixLookup && options[`defaultValue${this.options.pluralSeparator}zero`] && suffixes.indexOf(`${this.options.pluralSeparator}zero`) < 0 && suffixes.push(`${this.options.pluralSeparator}zero`), suffixes.forEach((suffix) => {
            send([language], key + suffix, options[`defaultValue${suffix}`] || defaultValue);
          });
        }) : send(lngs, key, defaultValue));
      }
      res = this.extendTranslation(res, keys2, options, resolved, lastKey), usedKey && res === key && this.options.appendNamespaceToMissingKey && (res = `${namespace}:${key}`), (usedKey || usedDefault) && this.options.parseMissingKeyHandler && (this.options.compatibilityAPI !== "v1" ? res = this.options.parseMissingKeyHandler(this.options.appendNamespaceToMissingKey ? `${namespace}:${key}` : key, usedDefault ? res : void 0) : res = this.options.parseMissingKeyHandler(res));
    }
    return returnDetails ? (resolved.res = res, resolved.usedParams = this.getUsedParamsDetails(options), resolved) : res;
  }
  extendTranslation(res, key, options, resolved, lastKey) {
    var _this = this;
    if (this.i18nFormat && this.i18nFormat.parse)
      res = this.i18nFormat.parse(res, {
        ...this.options.interpolation.defaultVariables,
        ...options
      }, options.lng || this.language || resolved.usedLng, resolved.usedNS, resolved.usedKey, {
        resolved
      });
    else if (!options.skipInterpolation) {
      options.interpolation && this.interpolator.init({
        ...options,
        interpolation: {
          ...this.options.interpolation,
          ...options.interpolation
        }
      });
      const skipOnVariables = typeof res == "string" && (options && options.interpolation && options.interpolation.skipOnVariables !== void 0 ? options.interpolation.skipOnVariables : this.options.interpolation.skipOnVariables);
      let nestBef;
      if (skipOnVariables) {
        const nb = res.match(this.interpolator.nestingRegexp);
        nestBef = nb && nb.length;
      }
      let data = options.replace && typeof options.replace != "string" ? options.replace : options;
      if (this.options.interpolation.defaultVariables && (data = {
        ...this.options.interpolation.defaultVariables,
        ...data
      }), res = this.interpolator.interpolate(res, data, options.lng || this.language, options), skipOnVariables) {
        const na = res.match(this.interpolator.nestingRegexp), nestAft = na && na.length;
        nestBef < nestAft && (options.nest = !1);
      }
      !options.lng && this.options.compatibilityAPI !== "v1" && resolved && resolved.res && (options.lng = resolved.usedLng), options.nest !== !1 && (res = this.interpolator.nest(res, function() {
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++)
          args[_key] = arguments[_key];
        return lastKey && lastKey[0] === args[0] && !options.context ? (_this.logger.warn(`It seems you are nesting recursively key: ${args[0]} in key: ${key[0]}`), null) : _this.translate(...args, key);
      }, options)), options.interpolation && this.interpolator.reset();
    }
    const postProcess = options.postProcess || this.options.postProcess, postProcessorNames = typeof postProcess == "string" ? [postProcess] : postProcess;
    return res != null && postProcessorNames && postProcessorNames.length && options.applyPostProcessor !== !1 && (res = postProcessor.handle(postProcessorNames, res, key, this.options && this.options.postProcessPassResolved ? {
      i18nResolved: {
        ...resolved,
        usedParams: this.getUsedParamsDetails(options)
      },
      ...options
    } : options, this)), res;
  }
  resolve(keys2) {
    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, found, usedKey, exactUsedKey, usedLng, usedNS;
    return typeof keys2 == "string" && (keys2 = [keys2]), keys2.forEach((k) => {
      if (this.isValidLookup(found)) return;
      const extracted = this.extractFromKey(k, options), key = extracted.key;
      usedKey = key;
      let namespaces = extracted.namespaces;
      this.options.fallbackNS && (namespaces = namespaces.concat(this.options.fallbackNS));
      const needsPluralHandling = options.count !== void 0 && typeof options.count != "string", needsZeroSuffixLookup = needsPluralHandling && !options.ordinal && options.count === 0 && this.pluralResolver.shouldUseIntlApi(), needsContextHandling = options.context !== void 0 && (typeof options.context == "string" || typeof options.context == "number") && options.context !== "", codes = options.lngs ? options.lngs : this.languageUtils.toResolveHierarchy(options.lng || this.language, options.fallbackLng);
      namespaces.forEach((ns) => {
        this.isValidLookup(found) || (usedNS = ns, !checkedLoadedFor[`${codes[0]}-${ns}`] && this.utils && this.utils.hasLoadedNamespace && !this.utils.hasLoadedNamespace(usedNS) && (checkedLoadedFor[`${codes[0]}-${ns}`] = !0, this.logger.warn(`key "${usedKey}" for languages "${codes.join(", ")}" won't get resolved as namespace "${usedNS}" was not yet loaded`, "This means something IS WRONG in your setup. You access the t function before i18next.init / i18next.loadNamespace / i18next.changeLanguage was done. Wait for the callback or Promise to resolve before accessing it!!!")), codes.forEach((code) => {
          if (this.isValidLookup(found)) return;
          usedLng = code;
          const finalKeys = [key];
          if (this.i18nFormat && this.i18nFormat.addLookupKeys)
            this.i18nFormat.addLookupKeys(finalKeys, key, code, ns, options);
          else {
            let pluralSuffix;
            needsPluralHandling && (pluralSuffix = this.pluralResolver.getSuffix(code, options.count, options));
            const zeroSuffix = `${this.options.pluralSeparator}zero`, ordinalPrefix = `${this.options.pluralSeparator}ordinal${this.options.pluralSeparator}`;
            if (needsPluralHandling && (finalKeys.push(key + pluralSuffix), options.ordinal && pluralSuffix.indexOf(ordinalPrefix) === 0 && finalKeys.push(key + pluralSuffix.replace(ordinalPrefix, this.options.pluralSeparator)), needsZeroSuffixLookup && finalKeys.push(key + zeroSuffix)), needsContextHandling) {
              const contextKey = `${key}${this.options.contextSeparator}${options.context}`;
              finalKeys.push(contextKey), needsPluralHandling && (finalKeys.push(contextKey + pluralSuffix), options.ordinal && pluralSuffix.indexOf(ordinalPrefix) === 0 && finalKeys.push(contextKey + pluralSuffix.replace(ordinalPrefix, this.options.pluralSeparator)), needsZeroSuffixLookup && finalKeys.push(contextKey + zeroSuffix));
            }
          }
          let possibleKey;
          for (; possibleKey = finalKeys.pop(); )
            this.isValidLookup(found) || (exactUsedKey = possibleKey, found = this.getResource(code, ns, possibleKey, options));
        }));
      });
    }), {
      res: found,
      usedKey,
      exactUsedKey,
      usedLng,
      usedNS
    };
  }
  isValidLookup(res) {
    return res !== void 0 && !(!this.options.returnNull && res === null) && !(!this.options.returnEmptyString && res === "");
  }
  getResource(code, ns, key) {
    let options = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
    return this.i18nFormat && this.i18nFormat.getResource ? this.i18nFormat.getResource(code, ns, key, options) : this.resourceStore.getResource(code, ns, key, options);
  }
  getUsedParamsDetails() {
    let options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    const optionsKeys = ["defaultValue", "ordinal", "context", "replace", "lng", "lngs", "fallbackLng", "ns", "keySeparator", "nsSeparator", "returnObjects", "returnDetails", "joinArrays", "postProcess", "interpolation"], useOptionsReplaceForData = options.replace && typeof options.replace != "string";
    let data = useOptionsReplaceForData ? options.replace : options;
    if (useOptionsReplaceForData && typeof options.count < "u" && (data.count = options.count), this.options.interpolation.defaultVariables && (data = {
      ...this.options.interpolation.defaultVariables,
      ...data
    }), !useOptionsReplaceForData) {
      data = {
        ...data
      };
      for (const key of optionsKeys)
        delete data[key];
    }
    return data;
  }
  static hasDefaultValue(options) {
    const prefix = "defaultValue";
    for (const option in options)
      if (Object.prototype.hasOwnProperty.call(options, option) && prefix === option.substring(0, prefix.length) && options[option] !== void 0)
        return !0;
    return !1;
  }
};
__name(_Translator, "Translator");
let Translator = _Translator;
function capitalize(string3) {
  return string3.charAt(0).toUpperCase() + string3.slice(1);
}
__name(capitalize, "capitalize");
const _LanguageUtil = class _LanguageUtil {
  constructor(options) {
    this.options = options, this.supportedLngs = this.options.supportedLngs || !1, this.logger = baseLogger.create("languageUtils");
  }
  getScriptPartFromCode(code) {
    if (code = getCleanedCode(code), !code || code.indexOf("-") < 0) return null;
    const p = code.split("-");
    return p.length === 2 || (p.pop(), p[p.length - 1].toLowerCase() === "x") ? null : this.formatLanguageCode(p.join("-"));
  }
  getLanguagePartFromCode(code) {
    if (code = getCleanedCode(code), !code || code.indexOf("-") < 0) return code;
    const p = code.split("-");
    return this.formatLanguageCode(p[0]);
  }
  formatLanguageCode(code) {
    if (typeof code == "string" && code.indexOf("-") > -1) {
      const specialCases = ["hans", "hant", "latn", "cyrl", "cans", "mong", "arab"];
      let p = code.split("-");
      return this.options.lowerCaseLng ? p = p.map((part) => part.toLowerCase()) : p.length === 2 ? (p[0] = p[0].toLowerCase(), p[1] = p[1].toUpperCase(), specialCases.indexOf(p[1].toLowerCase()) > -1 && (p[1] = capitalize(p[1].toLowerCase()))) : p.length === 3 && (p[0] = p[0].toLowerCase(), p[1].length === 2 && (p[1] = p[1].toUpperCase()), p[0] !== "sgn" && p[2].length === 2 && (p[2] = p[2].toUpperCase()), specialCases.indexOf(p[1].toLowerCase()) > -1 && (p[1] = capitalize(p[1].toLowerCase())), specialCases.indexOf(p[2].toLowerCase()) > -1 && (p[2] = capitalize(p[2].toLowerCase()))), p.join("-");
    }
    return this.options.cleanCode || this.options.lowerCaseLng ? code.toLowerCase() : code;
  }
  isSupportedCode(code) {
    return (this.options.load === "languageOnly" || this.options.nonExplicitSupportedLngs) && (code = this.getLanguagePartFromCode(code)), !this.supportedLngs || !this.supportedLngs.length || this.supportedLngs.indexOf(code) > -1;
  }
  getBestMatchFromCodes(codes) {
    if (!codes) return null;
    let found;
    return codes.forEach((code) => {
      if (found) return;
      const cleanedLng = this.formatLanguageCode(code);
      (!this.options.supportedLngs || this.isSupportedCode(cleanedLng)) && (found = cleanedLng);
    }), !found && this.options.supportedLngs && codes.forEach((code) => {
      if (found) return;
      const lngOnly = this.getLanguagePartFromCode(code);
      if (this.isSupportedCode(lngOnly)) return found = lngOnly;
      found = this.options.supportedLngs.find((supportedLng) => {
        if (supportedLng === lngOnly) return supportedLng;
        if (!(supportedLng.indexOf("-") < 0 && lngOnly.indexOf("-") < 0) && (supportedLng.indexOf("-") > 0 && lngOnly.indexOf("-") < 0 && supportedLng.substring(0, supportedLng.indexOf("-")) === lngOnly || supportedLng.indexOf(lngOnly) === 0 && lngOnly.length > 1))
          return supportedLng;
      });
    }), found || (found = this.getFallbackCodes(this.options.fallbackLng)[0]), found;
  }
  getFallbackCodes(fallbacks, code) {
    if (!fallbacks) return [];
    if (typeof fallbacks == "function" && (fallbacks = fallbacks(code)), typeof fallbacks == "string" && (fallbacks = [fallbacks]), Array.isArray(fallbacks)) return fallbacks;
    if (!code) return fallbacks.default || [];
    let found = fallbacks[code];
    return found || (found = fallbacks[this.getScriptPartFromCode(code)]), found || (found = fallbacks[this.formatLanguageCode(code)]), found || (found = fallbacks[this.getLanguagePartFromCode(code)]), found || (found = fallbacks.default), found || [];
  }
  toResolveHierarchy(code, fallbackCode) {
    const fallbackCodes = this.getFallbackCodes(fallbackCode || this.options.fallbackLng || [], code), codes = [], addCode = /* @__PURE__ */ __name((c) => {
      c && (this.isSupportedCode(c) ? codes.push(c) : this.logger.warn(`rejecting language code not found in supportedLngs: ${c}`));
    }, "addCode");
    return typeof code == "string" && (code.indexOf("-") > -1 || code.indexOf("_") > -1) ? (this.options.load !== "languageOnly" && addCode(this.formatLanguageCode(code)), this.options.load !== "languageOnly" && this.options.load !== "currentOnly" && addCode(this.getScriptPartFromCode(code)), this.options.load !== "currentOnly" && addCode(this.getLanguagePartFromCode(code))) : typeof code == "string" && addCode(this.formatLanguageCode(code)), fallbackCodes.forEach((fc) => {
      codes.indexOf(fc) < 0 && addCode(this.formatLanguageCode(fc));
    }), codes;
  }
};
__name(_LanguageUtil, "LanguageUtil");
let LanguageUtil = _LanguageUtil, sets = [{
  lngs: ["ach", "ak", "am", "arn", "br", "fil", "gun", "ln", "mfe", "mg", "mi", "oc", "pt", "pt-BR", "tg", "tl", "ti", "tr", "uz", "wa"],
  nr: [1, 2],
  fc: 1
}, {
  lngs: ["af", "an", "ast", "az", "bg", "bn", "ca", "da", "de", "dev", "el", "en", "eo", "es", "et", "eu", "fi", "fo", "fur", "fy", "gl", "gu", "ha", "hi", "hu", "hy", "ia", "it", "kk", "kn", "ku", "lb", "mai", "ml", "mn", "mr", "nah", "nap", "nb", "ne", "nl", "nn", "no", "nso", "pa", "pap", "pms", "ps", "pt-PT", "rm", "sco", "se", "si", "so", "son", "sq", "sv", "sw", "ta", "te", "tk", "ur", "yo"],
  nr: [1, 2],
  fc: 2
}, {
  lngs: ["ay", "bo", "cgg", "fa", "ht", "id", "ja", "jbo", "ka", "km", "ko", "ky", "lo", "ms", "sah", "su", "th", "tt", "ug", "vi", "wo", "zh"],
  nr: [1],
  fc: 3
}, {
  lngs: ["be", "bs", "cnr", "dz", "hr", "ru", "sr", "uk"],
  nr: [1, 2, 5],
  fc: 4
}, {
  lngs: ["ar"],
  nr: [0, 1, 2, 3, 11, 100],
  fc: 5
}, {
  lngs: ["cs", "sk"],
  nr: [1, 2, 5],
  fc: 6
}, {
  lngs: ["csb", "pl"],
  nr: [1, 2, 5],
  fc: 7
}, {
  lngs: ["cy"],
  nr: [1, 2, 3, 8],
  fc: 8
}, {
  lngs: ["fr"],
  nr: [1, 2],
  fc: 9
}, {
  lngs: ["ga"],
  nr: [1, 2, 3, 7, 11],
  fc: 10
}, {
  lngs: ["gd"],
  nr: [1, 2, 3, 20],
  fc: 11
}, {
  lngs: ["is"],
  nr: [1, 2],
  fc: 12
}, {
  lngs: ["jv"],
  nr: [0, 1],
  fc: 13
}, {
  lngs: ["kw"],
  nr: [1, 2, 3, 4],
  fc: 14
}, {
  lngs: ["lt"],
  nr: [1, 2, 10],
  fc: 15
}, {
  lngs: ["lv"],
  nr: [1, 2, 0],
  fc: 16
}, {
  lngs: ["mk"],
  nr: [1, 2],
  fc: 17
}, {
  lngs: ["mnk"],
  nr: [0, 1, 2],
  fc: 18
}, {
  lngs: ["mt"],
  nr: [1, 2, 11, 20],
  fc: 19
}, {
  lngs: ["or"],
  nr: [2, 1],
  fc: 2
}, {
  lngs: ["ro"],
  nr: [1, 2, 20],
  fc: 20
}, {
  lngs: ["sl"],
  nr: [5, 1, 2, 3],
  fc: 21
}, {
  lngs: ["he", "iw"],
  nr: [1, 2, 20, 21],
  fc: 22
}], _rulesPluralsTypes = {
  1: function(n2) {
    return +(n2 > 1);
  },
  2: function(n2) {
    return +(n2 != 1);
  },
  3: function(n2) {
    return 0;
  },
  4: function(n2) {
    return n2 % 10 == 1 && n2 % 100 != 11 ? 0 : n2 % 10 >= 2 && n2 % 10 <= 4 && (n2 % 100 < 10 || n2 % 100 >= 20) ? 1 : 2;
  },
  5: function(n2) {
    return n2 == 0 ? 0 : n2 == 1 ? 1 : n2 == 2 ? 2 : n2 % 100 >= 3 && n2 % 100 <= 10 ? 3 : n2 % 100 >= 11 ? 4 : 5;
  },
  6: function(n2) {
    return n2 == 1 ? 0 : n2 >= 2 && n2 <= 4 ? 1 : 2;
  },
  7: function(n2) {
    return n2 == 1 ? 0 : n2 % 10 >= 2 && n2 % 10 <= 4 && (n2 % 100 < 10 || n2 % 100 >= 20) ? 1 : 2;
  },
  8: function(n2) {
    return n2 == 1 ? 0 : n2 == 2 ? 1 : n2 != 8 && n2 != 11 ? 2 : 3;
  },
  9: function(n2) {
    return +(n2 >= 2);
  },
  10: function(n2) {
    return n2 == 1 ? 0 : n2 == 2 ? 1 : n2 < 7 ? 2 : n2 < 11 ? 3 : 4;
  },
  11: function(n2) {
    return n2 == 1 || n2 == 11 ? 0 : n2 == 2 || n2 == 12 ? 1 : n2 > 2 && n2 < 20 ? 2 : 3;
  },
  12: function(n2) {
    return +(n2 % 10 != 1 || n2 % 100 == 11);
  },
  13: function(n2) {
    return +(n2 !== 0);
  },
  14: function(n2) {
    return n2 == 1 ? 0 : n2 == 2 ? 1 : n2 == 3 ? 2 : 3;
  },
  15: function(n2) {
    return n2 % 10 == 1 && n2 % 100 != 11 ? 0 : n2 % 10 >= 2 && (n2 % 100 < 10 || n2 % 100 >= 20) ? 1 : 2;
  },
  16: function(n2) {
    return n2 % 10 == 1 && n2 % 100 != 11 ? 0 : n2 !== 0 ? 1 : 2;
  },
  17: function(n2) {
    return n2 == 1 || n2 % 10 == 1 && n2 % 100 != 11 ? 0 : 1;
  },
  18: function(n2) {
    return n2 == 0 ? 0 : n2 == 1 ? 1 : 2;
  },
  19: function(n2) {
    return n2 == 1 ? 0 : n2 == 0 || n2 % 100 > 1 && n2 % 100 < 11 ? 1 : n2 % 100 > 10 && n2 % 100 < 20 ? 2 : 3;
  },
  20: function(n2) {
    return n2 == 1 ? 0 : n2 == 0 || n2 % 100 > 0 && n2 % 100 < 20 ? 1 : 2;
  },
  21: function(n2) {
    return n2 % 100 == 1 ? 1 : n2 % 100 == 2 ? 2 : n2 % 100 == 3 || n2 % 100 == 4 ? 3 : 0;
  },
  22: function(n2) {
    return n2 == 1 ? 0 : n2 == 2 ? 1 : (n2 < 0 || n2 > 10) && n2 % 10 == 0 ? 2 : 3;
  }
};
const nonIntlVersions = ["v1", "v2", "v3"], intlVersions = ["v4"], suffixesOrder = {
  zero: 0,
  one: 1,
  two: 2,
  few: 3,
  many: 4,
  other: 5
};
function createRules() {
  const rules2 = {};
  return sets.forEach((set2) => {
    set2.lngs.forEach((l2) => {
      rules2[l2] = {
        numbers: set2.nr,
        plurals: _rulesPluralsTypes[set2.fc]
      };
    });
  }), rules2;
}
__name(createRules, "createRules");
const _PluralResolver = class _PluralResolver {
  constructor(languageUtils) {
    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    this.languageUtils = languageUtils, this.options = options, this.logger = baseLogger.create("pluralResolver"), (!this.options.compatibilityJSON || intlVersions.includes(this.options.compatibilityJSON)) && (typeof Intl > "u" || !Intl.PluralRules) && (this.options.compatibilityJSON = "v3", this.logger.error("Your environment seems not to be Intl API compatible, use an Intl.PluralRules polyfill. Will fallback to the compatibilityJSON v3 format handling.")), this.rules = createRules();
  }
  addRule(lng, obj) {
    this.rules[lng] = obj;
  }
  getRule(code) {
    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    if (this.shouldUseIntlApi())
      try {
        return new Intl.PluralRules(getCleanedCode(code === "dev" ? "en" : code), {
          type: options.ordinal ? "ordinal" : "cardinal"
        });
      } catch {
        return;
      }
    return this.rules[code] || this.rules[this.languageUtils.getLanguagePartFromCode(code)];
  }
  needsPlural(code) {
    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    const rule = this.getRule(code, options);
    return this.shouldUseIntlApi() ? rule && rule.resolvedOptions().pluralCategories.length > 1 : rule && rule.numbers.length > 1;
  }
  getPluralFormsOfKey(code, key) {
    let options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return this.getSuffixes(code, options).map((suffix) => `${key}${suffix}`);
  }
  getSuffixes(code) {
    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    const rule = this.getRule(code, options);
    return rule ? this.shouldUseIntlApi() ? rule.resolvedOptions().pluralCategories.sort((pluralCategory1, pluralCategory2) => suffixesOrder[pluralCategory1] - suffixesOrder[pluralCategory2]).map((pluralCategory) => `${this.options.prepend}${options.ordinal ? `ordinal${this.options.prepend}` : ""}${pluralCategory}`) : rule.numbers.map((number4) => this.getSuffix(code, number4, options)) : [];
  }
  getSuffix(code, count) {
    let options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    const rule = this.getRule(code, options);
    return rule ? this.shouldUseIntlApi() ? `${this.options.prepend}${options.ordinal ? `ordinal${this.options.prepend}` : ""}${rule.select(count)}` : this.getSuffixRetroCompatible(rule, count) : (this.logger.warn(`no plural rule found for: ${code}`), "");
  }
  getSuffixRetroCompatible(rule, count) {
    const idx = rule.noAbs ? rule.plurals(count) : rule.plurals(Math.abs(count));
    let suffix = rule.numbers[idx];
    this.options.simplifyPluralSuffix && rule.numbers.length === 2 && rule.numbers[0] === 1 && (suffix === 2 ? suffix = "plural" : suffix === 1 && (suffix = ""));
    const returnSuffix = /* @__PURE__ */ __name(() => this.options.prepend && suffix.toString() ? this.options.prepend + suffix.toString() : suffix.toString(), "returnSuffix");
    return this.options.compatibilityJSON === "v1" ? suffix === 1 ? "" : typeof suffix == "number" ? `_plural_${suffix.toString()}` : returnSuffix() : this.options.compatibilityJSON === "v2" || this.options.simplifyPluralSuffix && rule.numbers.length === 2 && rule.numbers[0] === 1 ? returnSuffix() : this.options.prepend && idx.toString() ? this.options.prepend + idx.toString() : idx.toString();
  }
  shouldUseIntlApi() {
    return !nonIntlVersions.includes(this.options.compatibilityJSON);
  }
};
__name(_PluralResolver, "PluralResolver");
let PluralResolver = _PluralResolver;
function deepFindWithDefaults(data, defaultData, key) {
  let keySeparator = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : ".", ignoreJSONStructure = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : !0, path2 = getPathWithDefaults(data, defaultData, key);
  return !path2 && ignoreJSONStructure && typeof key == "string" && (path2 = deepFind(data, key, keySeparator), path2 === void 0 && (path2 = deepFind(defaultData, key, keySeparator))), path2;
}
__name(deepFindWithDefaults, "deepFindWithDefaults");
const _Interpolator = class _Interpolator {
  constructor() {
    let options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    this.logger = baseLogger.create("interpolator"), this.options = options, this.format = options.interpolation && options.interpolation.format || ((value) => value), this.init(options);
  }
  init() {
    let options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    options.interpolation || (options.interpolation = {
      escapeValue: !0
    });
    const {
      escape: escape$1,
      escapeValue,
      useRawValueToEscape,
      prefix,
      prefixEscaped,
      suffix,
      suffixEscaped,
      formatSeparator,
      unescapeSuffix,
      unescapePrefix,
      nestingPrefix,
      nestingPrefixEscaped,
      nestingSuffix,
      nestingSuffixEscaped,
      nestingOptionsSeparator,
      maxReplaces,
      alwaysFormat
    } = options.interpolation;
    this.escape = escape$1 !== void 0 ? escape$1 : escape, this.escapeValue = escapeValue !== void 0 ? escapeValue : !0, this.useRawValueToEscape = useRawValueToEscape !== void 0 ? useRawValueToEscape : !1, this.prefix = prefix ? regexEscape(prefix) : prefixEscaped || "{{", this.suffix = suffix ? regexEscape(suffix) : suffixEscaped || "}}", this.formatSeparator = formatSeparator || ",", this.unescapePrefix = unescapeSuffix ? "" : unescapePrefix || "-", this.unescapeSuffix = this.unescapePrefix ? "" : unescapeSuffix || "", this.nestingPrefix = nestingPrefix ? regexEscape(nestingPrefix) : nestingPrefixEscaped || regexEscape("$t("), this.nestingSuffix = nestingSuffix ? regexEscape(nestingSuffix) : nestingSuffixEscaped || regexEscape(")"), this.nestingOptionsSeparator = nestingOptionsSeparator || ",", this.maxReplaces = maxReplaces || 1e3, this.alwaysFormat = alwaysFormat !== void 0 ? alwaysFormat : !1, this.resetRegExp();
  }
  reset() {
    this.options && this.init(this.options);
  }
  resetRegExp() {
    const getOrResetRegExp = /* @__PURE__ */ __name((existingRegExp, pattern4) => existingRegExp && existingRegExp.source === pattern4 ? (existingRegExp.lastIndex = 0, existingRegExp) : new RegExp(pattern4, "g"), "getOrResetRegExp");
    this.regexp = getOrResetRegExp(this.regexp, `${this.prefix}(.+?)${this.suffix}`), this.regexpUnescape = getOrResetRegExp(this.regexpUnescape, `${this.prefix}${this.unescapePrefix}(.+?)${this.unescapeSuffix}${this.suffix}`), this.nestingRegexp = getOrResetRegExp(this.nestingRegexp, `${this.nestingPrefix}(.+?)${this.nestingSuffix}`);
  }
  interpolate(str, data, lng, options) {
    let match2, value, replaces;
    const defaultData = this.options && this.options.interpolation && this.options.interpolation.defaultVariables || {};
    function regexSafe(val) {
      return val.replace(/\$/g, "$$$$");
    }
    __name(regexSafe, "regexSafe");
    const handleFormat = /* @__PURE__ */ __name((key) => {
      if (key.indexOf(this.formatSeparator) < 0) {
        const path2 = deepFindWithDefaults(data, defaultData, key, this.options.keySeparator, this.options.ignoreJSONStructure);
        return this.alwaysFormat ? this.format(path2, void 0, lng, {
          ...options,
          ...data,
          interpolationkey: key
        }) : path2;
      }
      const p = key.split(this.formatSeparator), k = p.shift().trim(), f = p.join(this.formatSeparator).trim();
      return this.format(deepFindWithDefaults(data, defaultData, k, this.options.keySeparator, this.options.ignoreJSONStructure), f, lng, {
        ...options,
        ...data,
        interpolationkey: k
      });
    }, "handleFormat");
    this.resetRegExp();
    const missingInterpolationHandler = options && options.missingInterpolationHandler || this.options.missingInterpolationHandler, skipOnVariables = options && options.interpolation && options.interpolation.skipOnVariables !== void 0 ? options.interpolation.skipOnVariables : this.options.interpolation.skipOnVariables;
    return [{
      regex: this.regexpUnescape,
      safeValue: /* @__PURE__ */ __name((val) => regexSafe(val), "safeValue")
    }, {
      regex: this.regexp,
      safeValue: /* @__PURE__ */ __name((val) => this.escapeValue ? regexSafe(this.escape(val)) : regexSafe(val), "safeValue")
    }].forEach((todo) => {
      for (replaces = 0; match2 = todo.regex.exec(str); ) {
        const matchedVar = match2[1].trim();
        if (value = handleFormat(matchedVar), value === void 0)
          if (typeof missingInterpolationHandler == "function") {
            const temp = missingInterpolationHandler(str, match2, options);
            value = typeof temp == "string" ? temp : "";
          } else if (options && Object.prototype.hasOwnProperty.call(options, matchedVar))
            value = "";
          else if (skipOnVariables) {
            value = match2[0];
            continue;
          } else
            this.logger.warn(`missed to pass in variable ${matchedVar} for interpolating ${str}`), value = "";
        else typeof value != "string" && !this.useRawValueToEscape && (value = makeString(value));
        const safeValue = todo.safeValue(value);
        if (str = str.replace(match2[0], safeValue), skipOnVariables ? (todo.regex.lastIndex += value.length, todo.regex.lastIndex -= match2[0].length) : todo.regex.lastIndex = 0, replaces++, replaces >= this.maxReplaces)
          break;
      }
    }), str;
  }
  nest(str, fc) {
    let options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, match2, value, clonedOptions;
    function handleHasOptions(key, inheritedOptions) {
      const sep = this.nestingOptionsSeparator;
      if (key.indexOf(sep) < 0) return key;
      const c = key.split(new RegExp(`${sep}[ ]*{`));
      let optionsString = `{${c[1]}`;
      key = c[0], optionsString = this.interpolate(optionsString, clonedOptions);
      const matchedSingleQuotes = optionsString.match(/'/g), matchedDoubleQuotes = optionsString.match(/"/g);
      (matchedSingleQuotes && matchedSingleQuotes.length % 2 === 0 && !matchedDoubleQuotes || matchedDoubleQuotes.length % 2 !== 0) && (optionsString = optionsString.replace(/'/g, '"'));
      try {
        clonedOptions = JSON.parse(optionsString), inheritedOptions && (clonedOptions = {
          ...inheritedOptions,
          ...clonedOptions
        });
      } catch (e2) {
        return this.logger.warn(`failed parsing options string in nesting for key ${key}`, e2), `${key}${sep}${optionsString}`;
      }
      return clonedOptions.defaultValue && clonedOptions.defaultValue.indexOf(this.prefix) > -1 && delete clonedOptions.defaultValue, key;
    }
    for (__name(handleHasOptions, "handleHasOptions"); match2 = this.nestingRegexp.exec(str); ) {
      let formatters = [];
      clonedOptions = {
        ...options
      }, clonedOptions = clonedOptions.replace && typeof clonedOptions.replace != "string" ? clonedOptions.replace : clonedOptions, clonedOptions.applyPostProcessor = !1, delete clonedOptions.defaultValue;
      let doReduce = !1;
      if (match2[0].indexOf(this.formatSeparator) !== -1 && !/{.*}/.test(match2[1])) {
        const r2 = match2[1].split(this.formatSeparator).map((elem) => elem.trim());
        match2[1] = r2.shift(), formatters = r2, doReduce = !0;
      }
      if (value = fc(handleHasOptions.call(this, match2[1].trim(), clonedOptions), clonedOptions), value && match2[0] === str && typeof value != "string") return value;
      typeof value != "string" && (value = makeString(value)), value || (this.logger.warn(`missed to resolve ${match2[1]} for nesting ${str}`), value = ""), doReduce && (value = formatters.reduce((v, f) => this.format(v, f, options.lng, {
        ...options,
        interpolationkey: match2[1].trim()
      }), value.trim())), str = str.replace(match2[0], value), this.regexp.lastIndex = 0;
    }
    return str;
  }
};
__name(_Interpolator, "Interpolator");
let Interpolator = _Interpolator;
function parseFormatStr(formatStr) {
  let formatName = formatStr.toLowerCase().trim();
  const formatOptions = {};
  if (formatStr.indexOf("(") > -1) {
    const p = formatStr.split("(");
    formatName = p[0].toLowerCase().trim();
    const optStr = p[1].substring(0, p[1].length - 1);
    formatName === "currency" && optStr.indexOf(":") < 0 ? formatOptions.currency || (formatOptions.currency = optStr.trim()) : formatName === "relativetime" && optStr.indexOf(":") < 0 ? formatOptions.range || (formatOptions.range = optStr.trim()) : optStr.split(";").forEach((opt) => {
      if (opt) {
        const [key, ...rest] = opt.split(":"), val = rest.join(":").trim().replace(/^'+|'+$/g, ""), trimmedKey = key.trim();
        formatOptions[trimmedKey] || (formatOptions[trimmedKey] = val), val === "false" && (formatOptions[trimmedKey] = !1), val === "true" && (formatOptions[trimmedKey] = !0), isNaN(val) || (formatOptions[trimmedKey] = parseInt(val, 10));
      }
    });
  }
  return {
    formatName,
    formatOptions
  };
}
__name(parseFormatStr, "parseFormatStr");
function createCachedFormatter(fn) {
  const cache = {};
  return /* @__PURE__ */ __name(function(val, lng, options) {
    const key = lng + JSON.stringify(options);
    let formatter = cache[key];
    return formatter || (formatter = fn(getCleanedCode(lng), options), cache[key] = formatter), formatter(val);
  }, "invokeFormatter");
}
__name(createCachedFormatter, "createCachedFormatter");
const _Formatter = class _Formatter {
  constructor() {
    let options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    this.logger = baseLogger.create("formatter"), this.options = options, this.formats = {
      number: createCachedFormatter((lng, opt) => {
        const formatter = new Intl.NumberFormat(lng, {
          ...opt
        });
        return (val) => formatter.format(val);
      }),
      currency: createCachedFormatter((lng, opt) => {
        const formatter = new Intl.NumberFormat(lng, {
          ...opt,
          style: "currency"
        });
        return (val) => formatter.format(val);
      }),
      datetime: createCachedFormatter((lng, opt) => {
        const formatter = new Intl.DateTimeFormat(lng, {
          ...opt
        });
        return (val) => formatter.format(val);
      }),
      relativetime: createCachedFormatter((lng, opt) => {
        const formatter = new Intl.RelativeTimeFormat(lng, {
          ...opt
        });
        return (val) => formatter.format(val, opt.range || "day");
      }),
      list: createCachedFormatter((lng, opt) => {
        const formatter = new Intl.ListFormat(lng, {
          ...opt
        });
        return (val) => formatter.format(val);
      })
    }, this.init(options);
  }
  init(services) {
    const iOpts = (arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
      interpolation: {}
    }).interpolation;
    this.formatSeparator = iOpts.formatSeparator ? iOpts.formatSeparator : iOpts.formatSeparator || ",";
  }
  add(name, fc) {
    this.formats[name.toLowerCase().trim()] = fc;
  }
  addCached(name, fc) {
    this.formats[name.toLowerCase().trim()] = createCachedFormatter(fc);
  }
  format(value, format3, lng) {
    let options = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
    return format3.split(this.formatSeparator).reduce((mem, f) => {
      const {
        formatName,
        formatOptions
      } = parseFormatStr(f);
      if (this.formats[formatName]) {
        let formatted = mem;
        try {
          const valOptions = options && options.formatParams && options.formatParams[options.interpolationkey] || {}, l2 = valOptions.locale || valOptions.lng || options.locale || options.lng || lng;
          formatted = this.formats[formatName](mem, l2, {
            ...formatOptions,
            ...options,
            ...valOptions
          });
        } catch (error) {
          this.logger.warn(error);
        }
        return formatted;
      } else
        this.logger.warn(`there was no format function for ${formatName}`);
      return mem;
    }, value);
  }
};
__name(_Formatter, "Formatter");
let Formatter = _Formatter;
function removePending(q, name) {
  q.pending[name] !== void 0 && (delete q.pending[name], q.pendingCount--);
}
__name(removePending, "removePending");
const _Connector = class _Connector extends EventEmitter {
  constructor(backend, store, services) {
    let options = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
    super(), this.backend = backend, this.store = store, this.services = services, this.languageUtils = services.languageUtils, this.options = options, this.logger = baseLogger.create("backendConnector"), this.waitingReads = [], this.maxParallelReads = options.maxParallelReads || 10, this.readingCalls = 0, this.maxRetries = options.maxRetries >= 0 ? options.maxRetries : 5, this.retryTimeout = options.retryTimeout >= 1 ? options.retryTimeout : 350, this.state = {}, this.queue = [], this.backend && this.backend.init && this.backend.init(services, options.backend, options);
  }
  queueLoad(languages, namespaces, options, callback) {
    const toLoad = {}, pending = {}, toLoadLanguages = {}, toLoadNamespaces = {};
    return languages.forEach((lng) => {
      let hasAllNamespaces = !0;
      namespaces.forEach((ns) => {
        const name = `${lng}|${ns}`;
        !options.reload && this.store.hasResourceBundle(lng, ns) ? this.state[name] = 2 : this.state[name] < 0 || (this.state[name] === 1 ? pending[name] === void 0 && (pending[name] = !0) : (this.state[name] = 1, hasAllNamespaces = !1, pending[name] === void 0 && (pending[name] = !0), toLoad[name] === void 0 && (toLoad[name] = !0), toLoadNamespaces[ns] === void 0 && (toLoadNamespaces[ns] = !0)));
      }), hasAllNamespaces || (toLoadLanguages[lng] = !0);
    }), (Object.keys(toLoad).length || Object.keys(pending).length) && this.queue.push({
      pending,
      pendingCount: Object.keys(pending).length,
      loaded: {},
      errors: [],
      callback
    }), {
      toLoad: Object.keys(toLoad),
      pending: Object.keys(pending),
      toLoadLanguages: Object.keys(toLoadLanguages),
      toLoadNamespaces: Object.keys(toLoadNamespaces)
    };
  }
  loaded(name, err, data) {
    const s = name.split("|"), lng = s[0], ns = s[1];
    err && this.emit("failedLoading", lng, ns, err), data && this.store.addResourceBundle(lng, ns, data, void 0, void 0, {
      skipCopy: !0
    }), this.state[name] = err ? -1 : 2;
    const loaded = {};
    this.queue.forEach((q) => {
      pushPath(q.loaded, [lng], ns), removePending(q, name), err && q.errors.push(err), q.pendingCount === 0 && !q.done && (Object.keys(q.loaded).forEach((l2) => {
        loaded[l2] || (loaded[l2] = {});
        const loadedKeys = q.loaded[l2];
        loadedKeys.length && loadedKeys.forEach((n2) => {
          loaded[l2][n2] === void 0 && (loaded[l2][n2] = !0);
        });
      }), q.done = !0, q.errors.length ? q.callback(q.errors) : q.callback());
    }), this.emit("loaded", loaded), this.queue = this.queue.filter((q) => !q.done);
  }
  read(lng, ns, fcName) {
    let tried = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 0, wait = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : this.retryTimeout, callback = arguments.length > 5 ? arguments[5] : void 0;
    if (!lng.length) return callback(null, {});
    if (this.readingCalls >= this.maxParallelReads) {
      this.waitingReads.push({
        lng,
        ns,
        fcName,
        tried,
        wait,
        callback
      });
      return;
    }
    this.readingCalls++;
    const resolver = /* @__PURE__ */ __name((err, data) => {
      if (this.readingCalls--, this.waitingReads.length > 0) {
        const next2 = this.waitingReads.shift();
        this.read(next2.lng, next2.ns, next2.fcName, next2.tried, next2.wait, next2.callback);
      }
      if (err && data && tried < this.maxRetries) {
        setTimeout(() => {
          this.read.call(this, lng, ns, fcName, tried + 1, wait * 2, callback);
        }, wait);
        return;
      }
      callback(err, data);
    }, "resolver"), fc = this.backend[fcName].bind(this.backend);
    if (fc.length === 2) {
      try {
        const r2 = fc(lng, ns);
        r2 && typeof r2.then == "function" ? r2.then((data) => resolver(null, data)).catch(resolver) : resolver(null, r2);
      } catch (err) {
        resolver(err);
      }
      return;
    }
    return fc(lng, ns, resolver);
  }
  prepareLoading(languages, namespaces) {
    let options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, callback = arguments.length > 3 ? arguments[3] : void 0;
    if (!this.backend)
      return this.logger.warn("No backend was added via i18next.use. Will not load resources."), callback && callback();
    typeof languages == "string" && (languages = this.languageUtils.toResolveHierarchy(languages)), typeof namespaces == "string" && (namespaces = [namespaces]);
    const toLoad = this.queueLoad(languages, namespaces, options, callback);
    if (!toLoad.toLoad.length)
      return toLoad.pending.length || callback(), null;
    toLoad.toLoad.forEach((name) => {
      this.loadOne(name);
    });
  }
  load(languages, namespaces, callback) {
    this.prepareLoading(languages, namespaces, {}, callback);
  }
  reload(languages, namespaces, callback) {
    this.prepareLoading(languages, namespaces, {
      reload: !0
    }, callback);
  }
  loadOne(name) {
    let prefix = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
    const s = name.split("|"), lng = s[0], ns = s[1];
    this.read(lng, ns, "read", void 0, void 0, (err, data) => {
      err && this.logger.warn(`${prefix}loading namespace ${ns} for language ${lng} failed`, err), !err && data && this.logger.log(`${prefix}loaded namespace ${ns} for language ${lng}`, data), this.loaded(name, err, data);
    });
  }
  saveMissing(languages, namespace, key, fallbackValue, isUpdate) {
    let options = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : {}, clb = arguments.length > 6 && arguments[6] !== void 0 ? arguments[6] : () => {
    };
    if (this.services.utils && this.services.utils.hasLoadedNamespace && !this.services.utils.hasLoadedNamespace(namespace)) {
      this.logger.warn(`did not save key "${key}" as the namespace "${namespace}" was not yet loaded`, "This means something IS WRONG in your setup. You access the t function before i18next.init / i18next.loadNamespace / i18next.changeLanguage was done. Wait for the callback or Promise to resolve before accessing it!!!");
      return;
    }
    if (!(key == null || key === "")) {
      if (this.backend && this.backend.create) {
        const opts = {
          ...options,
          isUpdate
        }, fc = this.backend.create.bind(this.backend);
        if (fc.length < 6)
          try {
            let r2;
            fc.length === 5 ? r2 = fc(languages, namespace, key, fallbackValue, opts) : r2 = fc(languages, namespace, key, fallbackValue), r2 && typeof r2.then == "function" ? r2.then((data) => clb(null, data)).catch(clb) : clb(null, r2);
          } catch (err) {
            clb(err);
          }
        else
          fc(languages, namespace, key, fallbackValue, clb, opts);
      }
      !languages || !languages[0] || this.store.addResource(languages[0], namespace, key, fallbackValue);
    }
  }
};
__name(_Connector, "Connector");
let Connector = _Connector;
function get$1() {
  return {
    debug: !1,
    initImmediate: !0,
    ns: ["translation"],
    defaultNS: ["translation"],
    fallbackLng: ["dev"],
    fallbackNS: !1,
    supportedLngs: !1,
    nonExplicitSupportedLngs: !1,
    load: "all",
    preload: !1,
    simplifyPluralSuffix: !0,
    keySeparator: ".",
    nsSeparator: ":",
    pluralSeparator: "_",
    contextSeparator: "_",
    partialBundledLanguages: !1,
    saveMissing: !1,
    updateMissing: !1,
    saveMissingTo: "fallback",
    saveMissingPlurals: !0,
    missingKeyHandler: !1,
    missingInterpolationHandler: !1,
    postProcess: !1,
    postProcessPassResolved: !1,
    returnNull: !1,
    returnEmptyString: !0,
    returnObjects: !1,
    joinArrays: !1,
    returnedObjectHandler: !1,
    parseMissingKeyHandler: !1,
    appendNamespaceToMissingKey: !1,
    appendNamespaceToCIMode: !1,
    overloadTranslationOptionHandler: /* @__PURE__ */ __name(function(args) {
      let ret = {};
      if (typeof args[1] == "object" && (ret = args[1]), typeof args[1] == "string" && (ret.defaultValue = args[1]), typeof args[2] == "string" && (ret.tDescription = args[2]), typeof args[2] == "object" || typeof args[3] == "object") {
        const options = args[3] || args[2];
        Object.keys(options).forEach((key) => {
          ret[key] = options[key];
        });
      }
      return ret;
    }, "handle"),
    interpolation: {
      escapeValue: !0,
      format: /* @__PURE__ */ __name((value) => value, "format"),
      prefix: "{{",
      suffix: "}}",
      formatSeparator: ",",
      unescapePrefix: "-",
      nestingPrefix: "$t(",
      nestingSuffix: ")",
      nestingOptionsSeparator: ",",
      maxReplaces: 1e3,
      skipOnVariables: !0
    }
  };
}
__name(get$1, "get$1");
function transformOptions(options) {
  return typeof options.ns == "string" && (options.ns = [options.ns]), typeof options.fallbackLng == "string" && (options.fallbackLng = [options.fallbackLng]), typeof options.fallbackNS == "string" && (options.fallbackNS = [options.fallbackNS]), options.supportedLngs && options.supportedLngs.indexOf("cimode") < 0 && (options.supportedLngs = options.supportedLngs.concat(["cimode"])), options;
}
__name(transformOptions, "transformOptions");
function noop$5() {
}
__name(noop$5, "noop$5");
function bindMemberFunctions(inst) {
  Object.getOwnPropertyNames(Object.getPrototypeOf(inst)).forEach((mem) => {
    typeof inst[mem] == "function" && (inst[mem] = inst[mem].bind(inst));
  });
}
__name(bindMemberFunctions, "bindMemberFunctions");
const _I18n = class _I18n extends EventEmitter {
  constructor() {
    let options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, callback = arguments.length > 1 ? arguments[1] : void 0;
    if (super(), this.options = transformOptions(options), this.services = {}, this.logger = baseLogger, this.modules = {
      external: []
    }, bindMemberFunctions(this), callback && !this.isInitialized && !options.isClone) {
      if (!this.options.initImmediate)
        return this.init(options, callback), this;
      setTimeout(() => {
        this.init(options, callback);
      }, 0);
    }
  }
  init() {
    var _this = this;
    let options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, callback = arguments.length > 1 ? arguments[1] : void 0;
    this.isInitializing = !0, typeof options == "function" && (callback = options, options = {}), !options.defaultNS && options.defaultNS !== !1 && options.ns && (typeof options.ns == "string" ? options.defaultNS = options.ns : options.ns.indexOf("translation") < 0 && (options.defaultNS = options.ns[0]));
    const defOpts = get$1();
    this.options = {
      ...defOpts,
      ...this.options,
      ...transformOptions(options)
    }, this.options.compatibilityAPI !== "v1" && (this.options.interpolation = {
      ...defOpts.interpolation,
      ...this.options.interpolation
    }), options.keySeparator !== void 0 && (this.options.userDefinedKeySeparator = options.keySeparator), options.nsSeparator !== void 0 && (this.options.userDefinedNsSeparator = options.nsSeparator);
    function createClassOnDemand(ClassOrObject) {
      return ClassOrObject ? typeof ClassOrObject == "function" ? new ClassOrObject() : ClassOrObject : null;
    }
    if (__name(createClassOnDemand, "createClassOnDemand"), !this.options.isClone) {
      this.modules.logger ? baseLogger.init(createClassOnDemand(this.modules.logger), this.options) : baseLogger.init(null, this.options);
      let formatter;
      this.modules.formatter ? formatter = this.modules.formatter : typeof Intl < "u" && (formatter = Formatter);
      const lu = new LanguageUtil(this.options);
      this.store = new ResourceStore(this.options.resources, this.options);
      const s = this.services;
      s.logger = baseLogger, s.resourceStore = this.store, s.languageUtils = lu, s.pluralResolver = new PluralResolver(lu, {
        prepend: this.options.pluralSeparator,
        compatibilityJSON: this.options.compatibilityJSON,
        simplifyPluralSuffix: this.options.simplifyPluralSuffix
      }), formatter && (!this.options.interpolation.format || this.options.interpolation.format === defOpts.interpolation.format) && (s.formatter = createClassOnDemand(formatter), s.formatter.init(s, this.options), this.options.interpolation.format = s.formatter.format.bind(s.formatter)), s.interpolator = new Interpolator(this.options), s.utils = {
        hasLoadedNamespace: this.hasLoadedNamespace.bind(this)
      }, s.backendConnector = new Connector(createClassOnDemand(this.modules.backend), s.resourceStore, s, this.options), s.backendConnector.on("*", function(event) {
        for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++)
          args[_key - 1] = arguments[_key];
        _this.emit(event, ...args);
      }), this.modules.languageDetector && (s.languageDetector = createClassOnDemand(this.modules.languageDetector), s.languageDetector.init && s.languageDetector.init(s, this.options.detection, this.options)), this.modules.i18nFormat && (s.i18nFormat = createClassOnDemand(this.modules.i18nFormat), s.i18nFormat.init && s.i18nFormat.init(this)), this.translator = new Translator(this.services, this.options), this.translator.on("*", function(event) {
        for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++)
          args[_key2 - 1] = arguments[_key2];
        _this.emit(event, ...args);
      }), this.modules.external.forEach((m2) => {
        m2.init && m2.init(this);
      });
    }
    if (this.format = this.options.interpolation.format, callback || (callback = noop$5), this.options.fallbackLng && !this.services.languageDetector && !this.options.lng) {
      const codes = this.services.languageUtils.getFallbackCodes(this.options.fallbackLng);
      codes.length > 0 && codes[0] !== "dev" && (this.options.lng = codes[0]);
    }
    !this.services.languageDetector && !this.options.lng && this.logger.warn("init: no languageDetector is used and no lng is defined"), ["getResource", "hasResourceBundle", "getResourceBundle", "getDataByLanguage"].forEach((fcName) => {
      this[fcName] = function() {
        return _this.store[fcName](...arguments);
      };
    }), ["addResource", "addResources", "addResourceBundle", "removeResourceBundle"].forEach((fcName) => {
      this[fcName] = function() {
        return _this.store[fcName](...arguments), _this;
      };
    });
    const deferred = defer(), load = /* @__PURE__ */ __name(() => {
      const finish = /* @__PURE__ */ __name((err, t2) => {
        this.isInitializing = !1, this.isInitialized && !this.initializedStoreOnce && this.logger.warn("init: i18next is already initialized. You should call init just once!"), this.isInitialized = !0, this.options.isClone || this.logger.log("initialized", this.options), this.emit("initialized", this.options), deferred.resolve(t2), callback(err, t2);
      }, "finish");
      if (this.languages && this.options.compatibilityAPI !== "v1" && !this.isInitialized) return finish(null, this.t.bind(this));
      this.changeLanguage(this.options.lng, finish);
    }, "load");
    return this.options.resources || !this.options.initImmediate ? load() : setTimeout(load, 0), deferred;
  }
  loadResources(language) {
    let usedCallback = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : noop$5;
    const usedLng = typeof language == "string" ? language : this.language;
    if (typeof language == "function" && (usedCallback = language), !this.options.resources || this.options.partialBundledLanguages) {
      if (usedLng && usedLng.toLowerCase() === "cimode" && (!this.options.preload || this.options.preload.length === 0)) return usedCallback();
      const toLoad = [], append2 = /* @__PURE__ */ __name((lng) => {
        if (!lng || lng === "cimode") return;
        this.services.languageUtils.toResolveHierarchy(lng).forEach((l2) => {
          l2 !== "cimode" && toLoad.indexOf(l2) < 0 && toLoad.push(l2);
        });
      }, "append");
      usedLng ? append2(usedLng) : this.services.languageUtils.getFallbackCodes(this.options.fallbackLng).forEach((l2) => append2(l2)), this.options.preload && this.options.preload.forEach((l2) => append2(l2)), this.services.backendConnector.load(toLoad, this.options.ns, (e2) => {
        !e2 && !this.resolvedLanguage && this.language && this.setResolvedLanguage(this.language), usedCallback(e2);
      });
    } else
      usedCallback(null);
  }
  reloadResources(lngs, ns, callback) {
    const deferred = defer();
    return lngs || (lngs = this.languages), ns || (ns = this.options.ns), callback || (callback = noop$5), this.services.backendConnector.reload(lngs, ns, (err) => {
      deferred.resolve(), callback(err);
    }), deferred;
  }
  use(module2) {
    if (!module2) throw new Error("You are passing an undefined module! Please check the object you are passing to i18next.use()");
    if (!module2.type) throw new Error("You are passing a wrong module! Please check the object you are passing to i18next.use()");
    return module2.type === "backend" && (this.modules.backend = module2), (module2.type === "logger" || module2.log && module2.warn && module2.error) && (this.modules.logger = module2), module2.type === "languageDetector" && (this.modules.languageDetector = module2), module2.type === "i18nFormat" && (this.modules.i18nFormat = module2), module2.type === "postProcessor" && postProcessor.addPostProcessor(module2), module2.type === "formatter" && (this.modules.formatter = module2), module2.type === "3rdParty" && this.modules.external.push(module2), this;
  }
  setResolvedLanguage(l2) {
    if (!(!l2 || !this.languages) && !(["cimode", "dev"].indexOf(l2) > -1))
      for (let li = 0; li < this.languages.length; li++) {
        const lngInLngs = this.languages[li];
        if (!(["cimode", "dev"].indexOf(lngInLngs) > -1) && this.store.hasLanguageSomeTranslations(lngInLngs)) {
          this.resolvedLanguage = lngInLngs;
          break;
        }
      }
  }
  changeLanguage(lng, callback) {
    var _this2 = this;
    this.isLanguageChangingTo = lng;
    const deferred = defer();
    this.emit("languageChanging", lng);
    const setLngProps = /* @__PURE__ */ __name((l2) => {
      this.language = l2, this.languages = this.services.languageUtils.toResolveHierarchy(l2), this.resolvedLanguage = void 0, this.setResolvedLanguage(l2);
    }, "setLngProps"), done = /* @__PURE__ */ __name((err, l2) => {
      l2 ? (setLngProps(l2), this.translator.changeLanguage(l2), this.isLanguageChangingTo = void 0, this.emit("languageChanged", l2), this.logger.log("languageChanged", l2)) : this.isLanguageChangingTo = void 0, deferred.resolve(function() {
        return _this2.t(...arguments);
      }), callback && callback(err, function() {
        return _this2.t(...arguments);
      });
    }, "done"), setLng = /* @__PURE__ */ __name((lngs) => {
      !lng && !lngs && this.services.languageDetector && (lngs = []);
      const l2 = typeof lngs == "string" ? lngs : this.services.languageUtils.getBestMatchFromCodes(lngs);
      l2 && (this.language || setLngProps(l2), this.translator.language || this.translator.changeLanguage(l2), this.services.languageDetector && this.services.languageDetector.cacheUserLanguage && this.services.languageDetector.cacheUserLanguage(l2)), this.loadResources(l2, (err) => {
        done(err, l2);
      });
    }, "setLng");
    return !lng && this.services.languageDetector && !this.services.languageDetector.async ? setLng(this.services.languageDetector.detect()) : !lng && this.services.languageDetector && this.services.languageDetector.async ? this.services.languageDetector.detect.length === 0 ? this.services.languageDetector.detect().then(setLng) : this.services.languageDetector.detect(setLng) : setLng(lng), deferred;
  }
  getFixedT(lng, ns, keyPrefix) {
    var _this3 = this;
    const fixedT = /* @__PURE__ */ __name(function(key, opts) {
      let options;
      if (typeof opts != "object") {
        for (var _len3 = arguments.length, rest = new Array(_len3 > 2 ? _len3 - 2 : 0), _key3 = 2; _key3 < _len3; _key3++)
          rest[_key3 - 2] = arguments[_key3];
        options = _this3.options.overloadTranslationOptionHandler([key, opts].concat(rest));
      } else
        options = {
          ...opts
        };
      options.lng = options.lng || fixedT.lng, options.lngs = options.lngs || fixedT.lngs, options.ns = options.ns || fixedT.ns, options.keyPrefix = options.keyPrefix || keyPrefix || fixedT.keyPrefix;
      const keySeparator = _this3.options.keySeparator || ".";
      let resultKey;
      return options.keyPrefix && Array.isArray(key) ? resultKey = key.map((k) => `${options.keyPrefix}${keySeparator}${k}`) : resultKey = options.keyPrefix ? `${options.keyPrefix}${keySeparator}${key}` : key, _this3.t(resultKey, options);
    }, "fixedT");
    return typeof lng == "string" ? fixedT.lng = lng : fixedT.lngs = lng, fixedT.ns = ns, fixedT.keyPrefix = keyPrefix, fixedT;
  }
  t() {
    return this.translator && this.translator.translate(...arguments);
  }
  exists() {
    return this.translator && this.translator.exists(...arguments);
  }
  setDefaultNamespace(ns) {
    this.options.defaultNS = ns;
  }
  hasLoadedNamespace(ns) {
    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    if (!this.isInitialized)
      return this.logger.warn("hasLoadedNamespace: i18next was not initialized", this.languages), !1;
    if (!this.languages || !this.languages.length)
      return this.logger.warn("hasLoadedNamespace: i18n.languages were undefined or empty", this.languages), !1;
    const lng = options.lng || this.resolvedLanguage || this.languages[0], fallbackLng = this.options ? this.options.fallbackLng : !1, lastLng = this.languages[this.languages.length - 1];
    if (lng.toLowerCase() === "cimode") return !0;
    const loadNotPending = /* @__PURE__ */ __name((l2, n2) => {
      const loadState = this.services.backendConnector.state[`${l2}|${n2}`];
      return loadState === -1 || loadState === 2;
    }, "loadNotPending");
    if (options.precheck) {
      const preResult = options.precheck(this, loadNotPending);
      if (preResult !== void 0) return preResult;
    }
    return !!(this.hasResourceBundle(lng, ns) || !this.services.backendConnector.backend || this.options.resources && !this.options.partialBundledLanguages || loadNotPending(lng, ns) && (!fallbackLng || loadNotPending(lastLng, ns)));
  }
  loadNamespaces(ns, callback) {
    const deferred = defer();
    return this.options.ns ? (typeof ns == "string" && (ns = [ns]), ns.forEach((n2) => {
      this.options.ns.indexOf(n2) < 0 && this.options.ns.push(n2);
    }), this.loadResources((err) => {
      deferred.resolve(), callback && callback(err);
    }), deferred) : (callback && callback(), Promise.resolve());
  }
  loadLanguages(lngs, callback) {
    const deferred = defer();
    typeof lngs == "string" && (lngs = [lngs]);
    const preloaded = this.options.preload || [], newLngs = lngs.filter((lng) => preloaded.indexOf(lng) < 0 && this.services.languageUtils.isSupportedCode(lng));
    return newLngs.length ? (this.options.preload = preloaded.concat(newLngs), this.loadResources((err) => {
      deferred.resolve(), callback && callback(err);
    }), deferred) : (callback && callback(), Promise.resolve());
  }
  dir(lng) {
    if (lng || (lng = this.resolvedLanguage || (this.languages && this.languages.length > 0 ? this.languages[0] : this.language)), !lng) return "rtl";
    const rtlLngs = ["ar", "shu", "sqr", "ssh", "xaa", "yhd", "yud", "aao", "abh", "abv", "acm", "acq", "acw", "acx", "acy", "adf", "ads", "aeb", "aec", "afb", "ajp", "apc", "apd", "arb", "arq", "ars", "ary", "arz", "auz", "avl", "ayh", "ayl", "ayn", "ayp", "bbz", "pga", "he", "iw", "ps", "pbt", "pbu", "pst", "prp", "prd", "ug", "ur", "ydd", "yds", "yih", "ji", "yi", "hbo", "men", "xmn", "fa", "jpr", "peo", "pes", "prs", "dv", "sam", "ckb"], languageUtils = this.services && this.services.languageUtils || new LanguageUtil(get$1());
    return rtlLngs.indexOf(languageUtils.getLanguagePartFromCode(lng)) > -1 || lng.toLowerCase().indexOf("-arab") > 1 ? "rtl" : "ltr";
  }
  static createInstance() {
    let options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, callback = arguments.length > 1 ? arguments[1] : void 0;
    return new _I18n(options, callback);
  }
  cloneInstance() {
    let options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, callback = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : noop$5;
    const forkResourceStore = options.forkResourceStore;
    forkResourceStore && delete options.forkResourceStore;
    const mergedOptions = {
      ...this.options,
      ...options,
      isClone: !0
    }, clone = new _I18n(mergedOptions);
    return (options.debug !== void 0 || options.prefix !== void 0) && (clone.logger = clone.logger.clone(options)), ["store", "services", "language"].forEach((m2) => {
      clone[m2] = this[m2];
    }), clone.services = {
      ...this.services
    }, clone.services.utils = {
      hasLoadedNamespace: clone.hasLoadedNamespace.bind(clone)
    }, forkResourceStore && (clone.store = new ResourceStore(this.store.data, mergedOptions), clone.services.resourceStore = clone.store), clone.translator = new Translator(clone.services, mergedOptions), clone.translator.on("*", function(event) {
      for (var _len4 = arguments.length, args = new Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++)
        args[_key4 - 1] = arguments[_key4];
      clone.emit(event, ...args);
    }), clone.init(mergedOptions, callback), clone.translator.options = mergedOptions, clone.translator.backendConnector.services.utils = {
      hasLoadedNamespace: clone.hasLoadedNamespace.bind(clone)
    }, clone;
  }
  toJSON() {
    return {
      options: this.options,
      store: this.store,
      language: this.language,
      languages: this.languages,
      resolvedLanguage: this.resolvedLanguage
    };
  }
};
__name(_I18n, "I18n");
let I18n = _I18n;
const instance = I18n.createInstance();
instance.createInstance = I18n.createInstance;
instance.createInstance;
instance.dir;
instance.init;
instance.loadResources;
instance.reloadResources;
instance.use;
instance.changeLanguage;
instance.getFixedT;
instance.t;
instance.exists;
instance.setDefaultNamespace;
instance.hasLoadedNamespace;
instance.loadNamespaces;
instance.loadLanguages;
const noop$4 = /* @__PURE__ */ __name(() => {
}, "noop$4"), GlobalNotificationContext = createContext$1({
  notificationApi: {
    success: noop$4,
    error: noop$4,
    warning: noop$4,
    info: noop$4,
    open: noop$4,
    destroy: noop$4
  }
});
var commonjsGlobal = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function getDefaultExportFromCjs(x) {
  return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, "default") ? x.default : x;
}
__name(getDefaultExportFromCjs, "getDefaultExportFromCjs");
var jsxRuntime = { exports: {} }, reactJsxRuntime_production_min = {};
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var hasRequiredReactJsxRuntime_production_min;
function requireReactJsxRuntime_production_min() {
  if (hasRequiredReactJsxRuntime_production_min) return reactJsxRuntime_production_min;
  hasRequiredReactJsxRuntime_production_min = 1;
  var f = React__default, k = Symbol.for("react.element"), l2 = Symbol.for("react.fragment"), m2 = Object.prototype.hasOwnProperty, n2 = f.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, p = { key: !0, ref: !0, __self: !0, __source: !0 };
  function q(c, a, g) {
    var b, d = {}, e2 = null, h = null;
    g !== void 0 && (e2 = "" + g), a.key !== void 0 && (e2 = "" + a.key), a.ref !== void 0 && (h = a.ref);
    for (b in a) m2.call(a, b) && !p.hasOwnProperty(b) && (d[b] = a[b]);
    if (c && c.defaultProps) for (b in a = c.defaultProps, a) d[b] === void 0 && (d[b] = a[b]);
    return { $$typeof: k, type: c, key: e2, ref: h, props: d, _owner: n2.current };
  }
  return __name(q, "q"), reactJsxRuntime_production_min.Fragment = l2, reactJsxRuntime_production_min.jsx = q, reactJsxRuntime_production_min.jsxs = q, reactJsxRuntime_production_min;
}
__name(requireReactJsxRuntime_production_min, "requireReactJsxRuntime_production_min");
var reactJsxRuntime_development = {};
/**
 * @license React
 * react-jsx-runtime.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var hasRequiredReactJsxRuntime_development;
function requireReactJsxRuntime_development() {
  return hasRequiredReactJsxRuntime_development || (hasRequiredReactJsxRuntime_development = 1, process.env.NODE_ENV !== "production" && function() {
    var React2 = React__default, REACT_ELEMENT_TYPE = Symbol.for("react.element"), REACT_PORTAL_TYPE = Symbol.for("react.portal"), REACT_FRAGMENT_TYPE2 = Symbol.for("react.fragment"), REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode"), REACT_PROFILER_TYPE = Symbol.for("react.profiler"), REACT_PROVIDER_TYPE = Symbol.for("react.provider"), REACT_CONTEXT_TYPE = Symbol.for("react.context"), REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref"), REACT_SUSPENSE_TYPE = Symbol.for("react.suspense"), REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list"), REACT_MEMO_TYPE = Symbol.for("react.memo"), REACT_LAZY_TYPE = Symbol.for("react.lazy"), REACT_OFFSCREEN_TYPE = Symbol.for("react.offscreen"), MAYBE_ITERATOR_SYMBOL = Symbol.iterator, FAUX_ITERATOR_SYMBOL = "@@iterator";
    function getIteratorFn(maybeIterable) {
      if (maybeIterable === null || typeof maybeIterable != "object")
        return null;
      var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];
      return typeof maybeIterator == "function" ? maybeIterator : null;
    }
    __name(getIteratorFn, "getIteratorFn");
    var ReactSharedInternals = React2.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
    function error(format3) {
      {
        for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++)
          args[_key2 - 1] = arguments[_key2];
        printWarning("error", format3, args);
      }
    }
    __name(error, "error");
    function printWarning(level, format3, args) {
      {
        var ReactDebugCurrentFrame2 = ReactSharedInternals.ReactDebugCurrentFrame, stack = ReactDebugCurrentFrame2.getStackAddendum();
        stack !== "" && (format3 += "%s", args = args.concat([stack]));
        var argsWithFormat = args.map(function(item) {
          return String(item);
        });
        argsWithFormat.unshift("Warning: " + format3), Function.prototype.apply.call(console[level], console, argsWithFormat);
      }
    }
    __name(printWarning, "printWarning");
    var enableScopeAPI = !1, enableCacheElement = !1, enableTransitionTracing = !1, enableLegacyHidden = !1, enableDebugTracing = !1, REACT_MODULE_REFERENCE;
    REACT_MODULE_REFERENCE = Symbol.for("react.module.reference");
    function isValidElementType(type4) {
      return !!(typeof type4 == "string" || typeof type4 == "function" || type4 === REACT_FRAGMENT_TYPE2 || type4 === REACT_PROFILER_TYPE || enableDebugTracing || type4 === REACT_STRICT_MODE_TYPE || type4 === REACT_SUSPENSE_TYPE || type4 === REACT_SUSPENSE_LIST_TYPE || enableLegacyHidden || type4 === REACT_OFFSCREEN_TYPE || enableScopeAPI || enableCacheElement || enableTransitionTracing || typeof type4 == "object" && type4 !== null && (type4.$$typeof === REACT_LAZY_TYPE || type4.$$typeof === REACT_MEMO_TYPE || type4.$$typeof === REACT_PROVIDER_TYPE || type4.$$typeof === REACT_CONTEXT_TYPE || type4.$$typeof === REACT_FORWARD_REF_TYPE || // This needs to include all possible module reference object
      // types supported by any Flight configuration anywhere since
      // we don't know which Flight build this will end up being used
      // with.
      type4.$$typeof === REACT_MODULE_REFERENCE || type4.getModuleId !== void 0));
    }
    __name(isValidElementType, "isValidElementType");
    function getWrappedName(outerType, innerType, wrapperName) {
      var displayName = outerType.displayName;
      if (displayName)
        return displayName;
      var functionName = innerType.displayName || innerType.name || "";
      return functionName !== "" ? wrapperName + "(" + functionName + ")" : wrapperName;
    }
    __name(getWrappedName, "getWrappedName");
    function getContextName(type4) {
      return type4.displayName || "Context";
    }
    __name(getContextName, "getContextName");
    function getComponentNameFromType(type4) {
      if (type4 == null)
        return null;
      if (typeof type4.tag == "number" && error("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), typeof type4 == "function")
        return type4.displayName || type4.name || null;
      if (typeof type4 == "string")
        return type4;
      switch (type4) {
        case REACT_FRAGMENT_TYPE2:
          return "Fragment";
        case REACT_PORTAL_TYPE:
          return "Portal";
        case REACT_PROFILER_TYPE:
          return "Profiler";
        case REACT_STRICT_MODE_TYPE:
          return "StrictMode";
        case REACT_SUSPENSE_TYPE:
          return "Suspense";
        case REACT_SUSPENSE_LIST_TYPE:
          return "SuspenseList";
      }
      if (typeof type4 == "object")
        switch (type4.$$typeof) {
          case REACT_CONTEXT_TYPE:
            var context = type4;
            return getContextName(context) + ".Consumer";
          case REACT_PROVIDER_TYPE:
            var provider = type4;
            return getContextName(provider._context) + ".Provider";
          case REACT_FORWARD_REF_TYPE:
            return getWrappedName(type4, type4.render, "ForwardRef");
          case REACT_MEMO_TYPE:
            var outerName = type4.displayName || null;
            return outerName !== null ? outerName : getComponentNameFromType(type4.type) || "Memo";
          case REACT_LAZY_TYPE: {
            var lazyComponent = type4, payload = lazyComponent._payload, init = lazyComponent._init;
            try {
              return getComponentNameFromType(init(payload));
            } catch {
              return null;
            }
          }
        }
      return null;
    }
    __name(getComponentNameFromType, "getComponentNameFromType");
    var assign = Object.assign, disabledDepth = 0, prevLog, prevInfo, prevWarn, prevError, prevGroup, prevGroupCollapsed, prevGroupEnd;
    function disabledLog() {
    }
    __name(disabledLog, "disabledLog"), disabledLog.__reactDisabledLog = !0;
    function disableLogs() {
      {
        if (disabledDepth === 0) {
          prevLog = console.log, prevInfo = console.info, prevWarn = console.warn, prevError = console.error, prevGroup = console.group, prevGroupCollapsed = console.groupCollapsed, prevGroupEnd = console.groupEnd;
          var props = {
            configurable: !0,
            enumerable: !0,
            value: disabledLog,
            writable: !0
          };
          Object.defineProperties(console, {
            info: props,
            log: props,
            warn: props,
            error: props,
            group: props,
            groupCollapsed: props,
            groupEnd: props
          });
        }
        disabledDepth++;
      }
    }
    __name(disableLogs, "disableLogs");
    function reenableLogs() {
      {
        if (disabledDepth--, disabledDepth === 0) {
          var props = {
            configurable: !0,
            enumerable: !0,
            writable: !0
          };
          Object.defineProperties(console, {
            log: assign({}, props, {
              value: prevLog
            }),
            info: assign({}, props, {
              value: prevInfo
            }),
            warn: assign({}, props, {
              value: prevWarn
            }),
            error: assign({}, props, {
              value: prevError
            }),
            group: assign({}, props, {
              value: prevGroup
            }),
            groupCollapsed: assign({}, props, {
              value: prevGroupCollapsed
            }),
            groupEnd: assign({}, props, {
              value: prevGroupEnd
            })
          });
        }
        disabledDepth < 0 && error("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
      }
    }
    __name(reenableLogs, "reenableLogs");
    var ReactCurrentDispatcher = ReactSharedInternals.ReactCurrentDispatcher, prefix;
    function describeBuiltInComponentFrame(name, source, ownerFn) {
      {
        if (prefix === void 0)
          try {
            throw Error();
          } catch (x) {
            var match2 = x.stack.trim().match(/\n( *(at )?)/);
            prefix = match2 && match2[1] || "";
          }
        return `
` + prefix + name;
      }
    }
    __name(describeBuiltInComponentFrame, "describeBuiltInComponentFrame");
    var reentry = !1, componentFrameCache;
    {
      var PossiblyWeakMap = typeof WeakMap == "function" ? WeakMap : Map;
      componentFrameCache = new PossiblyWeakMap();
    }
    function describeNativeComponentFrame(fn, construct) {
      if (!fn || reentry)
        return "";
      {
        var frame = componentFrameCache.get(fn);
        if (frame !== void 0)
          return frame;
      }
      var control;
      reentry = !0;
      var previousPrepareStackTrace = Error.prepareStackTrace;
      Error.prepareStackTrace = void 0;
      var previousDispatcher;
      previousDispatcher = ReactCurrentDispatcher.current, ReactCurrentDispatcher.current = null, disableLogs();
      try {
        if (construct) {
          var Fake = /* @__PURE__ */ __name(function() {
            throw Error();
          }, "Fake");
          if (Object.defineProperty(Fake.prototype, "props", {
            set: /* @__PURE__ */ __name(function() {
              throw Error();
            }, "set")
          }), typeof Reflect == "object" && Reflect.construct) {
            try {
              Reflect.construct(Fake, []);
            } catch (x) {
              control = x;
            }
            Reflect.construct(fn, [], Fake);
          } else {
            try {
              Fake.call();
            } catch (x) {
              control = x;
            }
            fn.call(Fake.prototype);
          }
        } else {
          try {
            throw Error();
          } catch (x) {
            control = x;
          }
          fn();
        }
      } catch (sample) {
        if (sample && control && typeof sample.stack == "string") {
          for (var sampleLines = sample.stack.split(`
`), controlLines = control.stack.split(`
`), s = sampleLines.length - 1, c = controlLines.length - 1; s >= 1 && c >= 0 && sampleLines[s] !== controlLines[c]; )
            c--;
          for (; s >= 1 && c >= 0; s--, c--)
            if (sampleLines[s] !== controlLines[c]) {
              if (s !== 1 || c !== 1)
                do
                  if (s--, c--, c < 0 || sampleLines[s] !== controlLines[c]) {
                    var _frame = `
` + sampleLines[s].replace(" at new ", " at ");
                    return fn.displayName && _frame.includes("<anonymous>") && (_frame = _frame.replace("<anonymous>", fn.displayName)), typeof fn == "function" && componentFrameCache.set(fn, _frame), _frame;
                  }
                while (s >= 1 && c >= 0);
              break;
            }
        }
      } finally {
        reentry = !1, ReactCurrentDispatcher.current = previousDispatcher, reenableLogs(), Error.prepareStackTrace = previousPrepareStackTrace;
      }
      var name = fn ? fn.displayName || fn.name : "", syntheticFrame = name ? describeBuiltInComponentFrame(name) : "";
      return typeof fn == "function" && componentFrameCache.set(fn, syntheticFrame), syntheticFrame;
    }
    __name(describeNativeComponentFrame, "describeNativeComponentFrame");
    function describeFunctionComponentFrame(fn, source, ownerFn) {
      return describeNativeComponentFrame(fn, !1);
    }
    __name(describeFunctionComponentFrame, "describeFunctionComponentFrame");
    function shouldConstruct(Component2) {
      var prototype = Component2.prototype;
      return !!(prototype && prototype.isReactComponent);
    }
    __name(shouldConstruct, "shouldConstruct");
    function describeUnknownElementTypeFrameInDEV(type4, source, ownerFn) {
      if (type4 == null)
        return "";
      if (typeof type4 == "function")
        return describeNativeComponentFrame(type4, shouldConstruct(type4));
      if (typeof type4 == "string")
        return describeBuiltInComponentFrame(type4);
      switch (type4) {
        case REACT_SUSPENSE_TYPE:
          return describeBuiltInComponentFrame("Suspense");
        case REACT_SUSPENSE_LIST_TYPE:
          return describeBuiltInComponentFrame("SuspenseList");
      }
      if (typeof type4 == "object")
        switch (type4.$$typeof) {
          case REACT_FORWARD_REF_TYPE:
            return describeFunctionComponentFrame(type4.render);
          case REACT_MEMO_TYPE:
            return describeUnknownElementTypeFrameInDEV(type4.type, source, ownerFn);
          case REACT_LAZY_TYPE: {
            var lazyComponent = type4, payload = lazyComponent._payload, init = lazyComponent._init;
            try {
              return describeUnknownElementTypeFrameInDEV(init(payload), source, ownerFn);
            } catch {
            }
          }
        }
      return "";
    }
    __name(describeUnknownElementTypeFrameInDEV, "describeUnknownElementTypeFrameInDEV");
    var hasOwnProperty = Object.prototype.hasOwnProperty, loggedTypeFailures = {}, ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;
    function setCurrentlyValidatingElement(element) {
      if (element) {
        var owner = element._owner, stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);
        ReactDebugCurrentFrame.setExtraStackFrame(stack);
      } else
        ReactDebugCurrentFrame.setExtraStackFrame(null);
    }
    __name(setCurrentlyValidatingElement, "setCurrentlyValidatingElement");
    function checkPropTypes(typeSpecs, values, location, componentName, element) {
      {
        var has = Function.call.bind(hasOwnProperty);
        for (var typeSpecName in typeSpecs)
          if (has(typeSpecs, typeSpecName)) {
            var error$1 = void 0;
            try {
              if (typeof typeSpecs[typeSpecName] != "function") {
                var err = Error((componentName || "React class") + ": " + location + " type `" + typeSpecName + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof typeSpecs[typeSpecName] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                throw err.name = "Invariant Violation", err;
              }
              error$1 = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
            } catch (ex) {
              error$1 = ex;
            }
            error$1 && !(error$1 instanceof Error) && (setCurrentlyValidatingElement(element), error("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", componentName || "React class", location, typeSpecName, typeof error$1), setCurrentlyValidatingElement(null)), error$1 instanceof Error && !(error$1.message in loggedTypeFailures) && (loggedTypeFailures[error$1.message] = !0, setCurrentlyValidatingElement(element), error("Failed %s type: %s", location, error$1.message), setCurrentlyValidatingElement(null));
          }
      }
    }
    __name(checkPropTypes, "checkPropTypes");
    var isArrayImpl = Array.isArray;
    function isArray(a) {
      return isArrayImpl(a);
    }
    __name(isArray, "isArray");
    function typeName(value) {
      {
        var hasToStringTag = typeof Symbol == "function" && Symbol.toStringTag, type4 = hasToStringTag && value[Symbol.toStringTag] || value.constructor.name || "Object";
        return type4;
      }
    }
    __name(typeName, "typeName");
    function willCoercionThrow(value) {
      try {
        return testStringCoercion(value), !1;
      } catch {
        return !0;
      }
    }
    __name(willCoercionThrow, "willCoercionThrow");
    function testStringCoercion(value) {
      return "" + value;
    }
    __name(testStringCoercion, "testStringCoercion");
    function checkKeyStringCoercion(value) {
      if (willCoercionThrow(value))
        return error("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.", typeName(value)), testStringCoercion(value);
    }
    __name(checkKeyStringCoercion, "checkKeyStringCoercion");
    var ReactCurrentOwner = ReactSharedInternals.ReactCurrentOwner, RESERVED_PROPS = {
      key: !0,
      ref: !0,
      __self: !0,
      __source: !0
    }, specialPropKeyWarningShown, specialPropRefWarningShown;
    function hasValidRef(config) {
      if (hasOwnProperty.call(config, "ref")) {
        var getter = Object.getOwnPropertyDescriptor(config, "ref").get;
        if (getter && getter.isReactWarning)
          return !1;
      }
      return config.ref !== void 0;
    }
    __name(hasValidRef, "hasValidRef");
    function hasValidKey(config) {
      if (hasOwnProperty.call(config, "key")) {
        var getter = Object.getOwnPropertyDescriptor(config, "key").get;
        if (getter && getter.isReactWarning)
          return !1;
      }
      return config.key !== void 0;
    }
    __name(hasValidKey, "hasValidKey");
    function warnIfStringRefCannotBeAutoConverted(config, self2) {
      typeof config.ref == "string" && ReactCurrentOwner.current;
    }
    __name(warnIfStringRefCannotBeAutoConverted, "warnIfStringRefCannotBeAutoConverted");
    function defineKeyPropWarningGetter(props, displayName) {
      {
        var warnAboutAccessingKey = /* @__PURE__ */ __name(function() {
          specialPropKeyWarningShown || (specialPropKeyWarningShown = !0, error("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", displayName));
        }, "warnAboutAccessingKey");
        warnAboutAccessingKey.isReactWarning = !0, Object.defineProperty(props, "key", {
          get: warnAboutAccessingKey,
          configurable: !0
        });
      }
    }
    __name(defineKeyPropWarningGetter, "defineKeyPropWarningGetter");
    function defineRefPropWarningGetter(props, displayName) {
      {
        var warnAboutAccessingRef = /* @__PURE__ */ __name(function() {
          specialPropRefWarningShown || (specialPropRefWarningShown = !0, error("%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", displayName));
        }, "warnAboutAccessingRef");
        warnAboutAccessingRef.isReactWarning = !0, Object.defineProperty(props, "ref", {
          get: warnAboutAccessingRef,
          configurable: !0
        });
      }
    }
    __name(defineRefPropWarningGetter, "defineRefPropWarningGetter");
    var ReactElement = /* @__PURE__ */ __name(function(type4, key, ref, self2, source, owner, props) {
      var element = {
        // This tag allows us to uniquely identify this as a React Element
        $$typeof: REACT_ELEMENT_TYPE,
        // Built-in properties that belong on the element
        type: type4,
        key,
        ref,
        props,
        // Record the component responsible for creating this element.
        _owner: owner
      };
      return element._store = {}, Object.defineProperty(element._store, "validated", {
        configurable: !1,
        enumerable: !1,
        writable: !0,
        value: !1
      }), Object.defineProperty(element, "_self", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: self2
      }), Object.defineProperty(element, "_source", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: source
      }), Object.freeze && (Object.freeze(element.props), Object.freeze(element)), element;
    }, "ReactElement");
    function jsxDEV(type4, config, maybeKey, source, self2) {
      {
        var propName, props = {}, key = null, ref = null;
        maybeKey !== void 0 && (checkKeyStringCoercion(maybeKey), key = "" + maybeKey), hasValidKey(config) && (checkKeyStringCoercion(config.key), key = "" + config.key), hasValidRef(config) && (ref = config.ref, warnIfStringRefCannotBeAutoConverted(config, self2));
        for (propName in config)
          hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName) && (props[propName] = config[propName]);
        if (type4 && type4.defaultProps) {
          var defaultProps2 = type4.defaultProps;
          for (propName in defaultProps2)
            props[propName] === void 0 && (props[propName] = defaultProps2[propName]);
        }
        if (key || ref) {
          var displayName = typeof type4 == "function" ? type4.displayName || type4.name || "Unknown" : type4;
          key && defineKeyPropWarningGetter(props, displayName), ref && defineRefPropWarningGetter(props, displayName);
        }
        return ReactElement(type4, key, ref, self2, source, ReactCurrentOwner.current, props);
      }
    }
    __name(jsxDEV, "jsxDEV");
    var ReactCurrentOwner$1 = ReactSharedInternals.ReactCurrentOwner, ReactDebugCurrentFrame$1 = ReactSharedInternals.ReactDebugCurrentFrame;
    function setCurrentlyValidatingElement$1(element) {
      if (element) {
        var owner = element._owner, stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);
        ReactDebugCurrentFrame$1.setExtraStackFrame(stack);
      } else
        ReactDebugCurrentFrame$1.setExtraStackFrame(null);
    }
    __name(setCurrentlyValidatingElement$1, "setCurrentlyValidatingElement$1");
    var propTypesMisspellWarningShown;
    propTypesMisspellWarningShown = !1;
    function isValidElement2(object4) {
      return typeof object4 == "object" && object4 !== null && object4.$$typeof === REACT_ELEMENT_TYPE;
    }
    __name(isValidElement2, "isValidElement");
    function getDeclarationErrorAddendum() {
      {
        if (ReactCurrentOwner$1.current) {
          var name = getComponentNameFromType(ReactCurrentOwner$1.current.type);
          if (name)
            return `

Check the render method of \`` + name + "`.";
        }
        return "";
      }
    }
    __name(getDeclarationErrorAddendum, "getDeclarationErrorAddendum");
    function getSourceInfoErrorAddendum(source) {
      return "";
    }
    __name(getSourceInfoErrorAddendum, "getSourceInfoErrorAddendum");
    var ownerHasKeyUseWarning = {};
    function getCurrentComponentErrorInfo(parentType) {
      {
        var info = getDeclarationErrorAddendum();
        if (!info) {
          var parentName = typeof parentType == "string" ? parentType : parentType.displayName || parentType.name;
          parentName && (info = `

Check the top-level render call using <` + parentName + ">.");
        }
        return info;
      }
    }
    __name(getCurrentComponentErrorInfo, "getCurrentComponentErrorInfo");
    function validateExplicitKey(element, parentType) {
      {
        if (!element._store || element._store.validated || element.key != null)
          return;
        element._store.validated = !0;
        var currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType);
        if (ownerHasKeyUseWarning[currentComponentErrorInfo])
          return;
        ownerHasKeyUseWarning[currentComponentErrorInfo] = !0;
        var childOwner = "";
        element && element._owner && element._owner !== ReactCurrentOwner$1.current && (childOwner = " It was passed a child from " + getComponentNameFromType(element._owner.type) + "."), setCurrentlyValidatingElement$1(element), error('Each child in a list should have a unique "key" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', currentComponentErrorInfo, childOwner), setCurrentlyValidatingElement$1(null);
      }
    }
    __name(validateExplicitKey, "validateExplicitKey");
    function validateChildKeys(node2, parentType) {
      {
        if (typeof node2 != "object")
          return;
        if (isArray(node2))
          for (var i = 0; i < node2.length; i++) {
            var child = node2[i];
            isValidElement2(child) && validateExplicitKey(child, parentType);
          }
        else if (isValidElement2(node2))
          node2._store && (node2._store.validated = !0);
        else if (node2) {
          var iteratorFn = getIteratorFn(node2);
          if (typeof iteratorFn == "function" && iteratorFn !== node2.entries)
            for (var iterator = iteratorFn.call(node2), step; !(step = iterator.next()).done; )
              isValidElement2(step.value) && validateExplicitKey(step.value, parentType);
        }
      }
    }
    __name(validateChildKeys, "validateChildKeys");
    function validatePropTypes(element) {
      {
        var type4 = element.type;
        if (type4 == null || typeof type4 == "string")
          return;
        var propTypes;
        if (typeof type4 == "function")
          propTypes = type4.propTypes;
        else if (typeof type4 == "object" && (type4.$$typeof === REACT_FORWARD_REF_TYPE || // Note: Memo only checks outer props here.
        // Inner props are checked in the reconciler.
        type4.$$typeof === REACT_MEMO_TYPE))
          propTypes = type4.propTypes;
        else
          return;
        if (propTypes) {
          var name = getComponentNameFromType(type4);
          checkPropTypes(propTypes, element.props, "prop", name, element);
        } else if (type4.PropTypes !== void 0 && !propTypesMisspellWarningShown) {
          propTypesMisspellWarningShown = !0;
          var _name = getComponentNameFromType(type4);
          error("Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?", _name || "Unknown");
        }
        typeof type4.getDefaultProps == "function" && !type4.getDefaultProps.isReactClassApproved && error("getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.");
      }
    }
    __name(validatePropTypes, "validatePropTypes");
    function validateFragmentProps(fragment) {
      {
        for (var keys2 = Object.keys(fragment.props), i = 0; i < keys2.length; i++) {
          var key = keys2[i];
          if (key !== "children" && key !== "key") {
            setCurrentlyValidatingElement$1(fragment), error("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.", key), setCurrentlyValidatingElement$1(null);
            break;
          }
        }
        fragment.ref !== null && (setCurrentlyValidatingElement$1(fragment), error("Invalid attribute `ref` supplied to `React.Fragment`."), setCurrentlyValidatingElement$1(null));
      }
    }
    __name(validateFragmentProps, "validateFragmentProps");
    var didWarnAboutKeySpread = {};
    function jsxWithValidation(type4, props, key, isStaticChildren, source, self2) {
      {
        var validType = isValidElementType(type4);
        if (!validType) {
          var info = "";
          (type4 === void 0 || typeof type4 == "object" && type4 !== null && Object.keys(type4).length === 0) && (info += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.");
          var sourceInfo = getSourceInfoErrorAddendum();
          sourceInfo ? info += sourceInfo : info += getDeclarationErrorAddendum();
          var typeString;
          type4 === null ? typeString = "null" : isArray(type4) ? typeString = "array" : type4 !== void 0 && type4.$$typeof === REACT_ELEMENT_TYPE ? (typeString = "<" + (getComponentNameFromType(type4.type) || "Unknown") + " />", info = " Did you accidentally export a JSX literal instead of a component?") : typeString = typeof type4, error("React.jsx: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", typeString, info);
        }
        var element = jsxDEV(type4, props, key, source, self2);
        if (element == null)
          return element;
        if (validType) {
          var children = props.children;
          if (children !== void 0)
            if (isStaticChildren)
              if (isArray(children)) {
                for (var i = 0; i < children.length; i++)
                  validateChildKeys(children[i], type4);
                Object.freeze && Object.freeze(children);
              } else
                error("React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.");
            else
              validateChildKeys(children, type4);
        }
        if (hasOwnProperty.call(props, "key")) {
          var componentName = getComponentNameFromType(type4), keys2 = Object.keys(props).filter(function(k) {
            return k !== "key";
          }), beforeExample = keys2.length > 0 ? "{key: someKey, " + keys2.join(": ..., ") + ": ...}" : "{key: someKey}";
          if (!didWarnAboutKeySpread[componentName + beforeExample]) {
            var afterExample = keys2.length > 0 ? "{" + keys2.join(": ..., ") + ": ...}" : "{}";
            error(`A props object containing a "key" prop is being spread into JSX:
  let props = %s;
  <%s {...props} />
React keys must be passed directly to JSX without using spread:
  let props = %s;
  <%s key={someKey} {...props} />`, beforeExample, componentName, afterExample, componentName), didWarnAboutKeySpread[componentName + beforeExample] = !0;
          }
        }
        return type4 === REACT_FRAGMENT_TYPE2 ? validateFragmentProps(element) : validatePropTypes(element), element;
      }
    }
    __name(jsxWithValidation, "jsxWithValidation");
    function jsxWithValidationStatic(type4, props, key) {
      return jsxWithValidation(type4, props, key, !0);
    }
    __name(jsxWithValidationStatic, "jsxWithValidationStatic");
    function jsxWithValidationDynamic(type4, props, key) {
      return jsxWithValidation(type4, props, key, !1);
    }
    __name(jsxWithValidationDynamic, "jsxWithValidationDynamic");
    var jsx = jsxWithValidationDynamic, jsxs = jsxWithValidationStatic;
    reactJsxRuntime_development.Fragment = REACT_FRAGMENT_TYPE2, reactJsxRuntime_development.jsx = jsx, reactJsxRuntime_development.jsxs = jsxs;
  }()), reactJsxRuntime_development;
}
__name(requireReactJsxRuntime_development, "requireReactJsxRuntime_development");
process.env.NODE_ENV === "production" ? jsxRuntime.exports = requireReactJsxRuntime_production_min() : jsxRuntime.exports = requireReactJsxRuntime_development();
var jsxRuntimeExports = jsxRuntime.exports;
/**
 * @license @tabler/icons-react v3.21.0 - MIT
 *
 * This source code is licensed under the MIT license.
 * See the LICENSE file in the root directory of this source tree.
 */
var defaultAttributes = {
  outline: {
    xmlns: "http://www.w3.org/2000/svg",
    width: 24,
    height: 24,
    viewBox: "0 0 24 24",
    fill: "none",
    stroke: "currentColor",
    strokeWidth: 2,
    strokeLinecap: "round",
    strokeLinejoin: "round"
  },
  filled: {
    xmlns: "http://www.w3.org/2000/svg",
    width: 24,
    height: 24,
    viewBox: "0 0 24 24",
    fill: "currentColor",
    stroke: "none"
  }
};
/**
 * @license @tabler/icons-react v3.21.0 - MIT
 *
 * This source code is licensed under the MIT license.
 * See the LICENSE file in the root directory of this source tree.
 */
const createReactComponent = /* @__PURE__ */ __name((type4, iconName, iconNamePascal, iconNode) => {
  const Component2 = forwardRef(
    ({ color = "currentColor", size = 24, stroke = 2, title: title2, className, children, ...rest }, ref) => createElement(
      "svg",
      {
        ref,
        ...defaultAttributes[type4],
        width: size,
        height: size,
        className: ["tabler-icon", `tabler-icon-${iconName}`, className].join(" "),
        ...type4 === "filled" ? {
          fill: color
        } : {
          strokeWidth: stroke,
          stroke: color
        },
        ...rest
      },
      [
        title2 && createElement("title", { key: "svg-title" }, title2),
        ...iconNode.map(([tag, attrs]) => createElement(tag, attrs)),
        ...Array.isArray(children) ? children : [children]
      ]
    )
  );
  return Component2.displayName = `${iconNamePascal}`, Component2;
}, "createReactComponent");
/**
 * @license @tabler/icons-react v3.21.0 - MIT
 *
 * This source code is licensed under the MIT license.
 * See the LICENSE file in the root directory of this source tree.
 */
var IconArrowNarrowRight = createReactComponent("outline", "arrow-narrow-right", "IconArrowNarrowRight", [["path", { d: "M5 12l14 0", key: "svg-0" }], ["path", { d: "M15 16l4 -4", key: "svg-1" }], ["path", { d: "M15 8l4 4", key: "svg-2" }]]);
/**
 * @license @tabler/icons-react v3.21.0 - MIT
 *
 * This source code is licensed under the MIT license.
 * See the LICENSE file in the root directory of this source tree.
 */
var IconBell = createReactComponent("outline", "bell", "IconBell", [["path", { d: "M10 5a2 2 0 1 1 4 0a7 7 0 0 1 4 6v3a4 4 0 0 0 2 3h-16a4 4 0 0 0 2 -3v-3a7 7 0 0 1 4 -6", key: "svg-0" }], ["path", { d: "M9 17v1a3 3 0 0 0 6 0v-1", key: "svg-1" }]]);
/**
 * @license @tabler/icons-react v3.21.0 - MIT
 *
 * This source code is licensed under the MIT license.
 * See the LICENSE file in the root directory of this source tree.
 */
var IconCalendarEvent = createReactComponent("outline", "calendar-event", "IconCalendarEvent", [["path", { d: "M4 5m0 2a2 2 0 0 1 2 -2h12a2 2 0 0 1 2 2v12a2 2 0 0 1 -2 2h-12a2 2 0 0 1 -2 -2z", key: "svg-0" }], ["path", { d: "M16 3l0 4", key: "svg-1" }], ["path", { d: "M8 3l0 4", key: "svg-2" }], ["path", { d: "M4 11l16 0", key: "svg-3" }], ["path", { d: "M8 15h2v2h-2z", key: "svg-4" }]]);
/**
 * @license @tabler/icons-react v3.21.0 - MIT
 *
 * This source code is licensed under the MIT license.
 * See the LICENSE file in the root directory of this source tree.
 */
var IconCheck = createReactComponent("outline", "check", "IconCheck", [["path", { d: "M5 12l5 5l10 -10", key: "svg-0" }]]);
/**
 * @license @tabler/icons-react v3.21.0 - MIT
 *
 * This source code is licensed under the MIT license.
 * See the LICENSE file in the root directory of this source tree.
 */
var IconChevronDown = createReactComponent("outline", "chevron-down", "IconChevronDown", [["path", { d: "M6 9l6 6l6 -6", key: "svg-0" }]]);
/**
 * @license @tabler/icons-react v3.21.0 - MIT
 *
 * This source code is licensed under the MIT license.
 * See the LICENSE file in the root directory of this source tree.
 */
var IconChevronLeft = createReactComponent("outline", "chevron-left", "IconChevronLeft", [["path", { d: "M15 6l-6 6l6 6", key: "svg-0" }]]);
/**
 * @license @tabler/icons-react v3.21.0 - MIT
 *
 * This source code is licensed under the MIT license.
 * See the LICENSE file in the root directory of this source tree.
 */
var IconChevronRight = createReactComponent("outline", "chevron-right", "IconChevronRight", [["path", { d: "M9 6l6 6l-6 6", key: "svg-0" }]]);
/**
 * @license @tabler/icons-react v3.21.0 - MIT
 *
 * This source code is licensed under the MIT license.
 * See the LICENSE file in the root directory of this source tree.
 */
var IconChevronsLeft = createReactComponent("outline", "chevrons-left", "IconChevronsLeft", [["path", { d: "M11 7l-5 5l5 5", key: "svg-0" }], ["path", { d: "M17 7l-5 5l5 5", key: "svg-1" }]]);
/**
 * @license @tabler/icons-react v3.21.0 - MIT
 *
 * This source code is licensed under the MIT license.
 * See the LICENSE file in the root directory of this source tree.
 */
var IconChevronsRight = createReactComponent("outline", "chevrons-right", "IconChevronsRight", [["path", { d: "M7 7l5 5l-5 5", key: "svg-0" }], ["path", { d: "M13 7l5 5l-5 5", key: "svg-1" }]]);
/**
 * @license @tabler/icons-react v3.21.0 - MIT
 *
 * This source code is licensed under the MIT license.
 * See the LICENSE file in the root directory of this source tree.
 */
var IconClock = createReactComponent("outline", "clock", "IconClock", [["path", { d: "M3 12a9 9 0 1 0 18 0a9 9 0 0 0 -18 0", key: "svg-0" }], ["path", { d: "M12 7v5l3 3", key: "svg-1" }]]);
/**
 * @license @tabler/icons-react v3.21.0 - MIT
 *
 * This source code is licensed under the MIT license.
 * See the LICENSE file in the root directory of this source tree.
 */
var IconLogout = createReactComponent("outline", "logout", "IconLogout", [["path", { d: "M14 8v-2a2 2 0 0 0 -2 -2h-7a2 2 0 0 0 -2 2v12a2 2 0 0 0 2 2h7a2 2 0 0 0 2 -2v-2", key: "svg-0" }], ["path", { d: "M9 12h12l-3 -3", key: "svg-1" }], ["path", { d: "M18 15l3 -3", key: "svg-2" }]]);
/**
 * @license @tabler/icons-react v3.21.0 - MIT
 *
 * This source code is licensed under the MIT license.
 * See the LICENSE file in the root directory of this source tree.
 */
var IconSettings = createReactComponent("outline", "settings", "IconSettings", [["path", { d: "M10.325 4.317c.426 -1.756 2.924 -1.756 3.35 0a1.724 1.724 0 0 0 2.573 1.066c1.543 -.94 3.31 .826 2.37 2.37a1.724 1.724 0 0 0 1.065 2.572c1.756 .426 1.756 2.924 0 3.35a1.724 1.724 0 0 0 -1.066 2.573c.94 1.543 -.826 3.31 -2.37 2.37a1.724 1.724 0 0 0 -2.572 1.065c-.426 1.756 -2.924 1.756 -3.35 0a1.724 1.724 0 0 0 -2.573 -1.066c-1.543 .94 -3.31 -.826 -2.37 -2.37a1.724 1.724 0 0 0 -1.065 -2.572c-1.756 -.426 -1.756 -2.924 0 -3.35a1.724 1.724 0 0 0 1.066 -2.573c-.94 -1.543 .826 -3.31 2.37 -2.37c1 .608 2.296 .07 2.572 -1.065z", key: "svg-0" }], ["path", { d: "M9 12a3 3 0 1 0 6 0a3 3 0 0 0 -6 0", key: "svg-1" }]]);
/**
 * @license @tabler/icons-react v3.21.0 - MIT
 *
 * This source code is licensed under the MIT license.
 * See the LICENSE file in the root directory of this source tree.
 */
var IconUser = createReactComponent("outline", "user", "IconUser", [["path", { d: "M8 7a4 4 0 1 0 8 0a4 4 0 0 0 -8 0", key: "svg-0" }], ["path", { d: "M6 21v-2a4 4 0 0 1 4 -4h4a4 4 0 0 1 4 4v2", key: "svg-1" }]]);
/**
 * @license @tabler/icons-react v3.21.0 - MIT
 *
 * This source code is licensed under the MIT license.
 * See the LICENSE file in the root directory of this source tree.
 */
var IconX = createReactComponent("outline", "x", "IconX", [["path", { d: "M18 6l-12 12", key: "svg-0" }], ["path", { d: "M6 6l12 12", key: "svg-1" }]]);
/**
 * @license @tabler/icons-react v3.21.0 - MIT
 *
 * This source code is licensed under the MIT license.
 * See the LICENSE file in the root directory of this source tree.
 */
var IconCircleXFilled = createReactComponent("filled", "circle-x-filled", "IconCircleXFilled", [["path", { d: "M17 3.34a10 10 0 1 1 -14.995 8.984l-.005 -.324l.005 -.324a10 10 0 0 1 14.995 -8.336zm-6.489 5.8a1 1 0 0 0 -1.218 1.567l1.292 1.293l-1.292 1.293l-.083 .094a1 1 0 0 0 1.497 1.32l1.293 -1.292l1.293 1.292l.094 .083a1 1 0 0 0 1.32 -1.497l-1.292 -1.293l1.292 -1.293l.083 -.094a1 1 0 0 0 -1.497 -1.32l-1.293 1.292l-1.293 -1.292l-.094 -.083z", key: "svg-0" }]]), classnames = { exports: {} };
/*!
	Copyright (c) 2018 Jed Watson.
	Licensed under the MIT License (MIT), see
	http://jedwatson.github.io/classnames
*/
(function(module2) {
  (function() {
    var hasOwn = {}.hasOwnProperty;
    function classNames() {
      for (var classes = "", i = 0; i < arguments.length; i++) {
        var arg = arguments[i];
        arg && (classes = appendClass(classes, parseValue(arg)));
      }
      return classes;
    }
    __name(classNames, "classNames");
    function parseValue(arg) {
      if (typeof arg == "string" || typeof arg == "number")
        return arg;
      if (typeof arg != "object")
        return "";
      if (Array.isArray(arg))
        return classNames.apply(null, arg);
      if (arg.toString !== Object.prototype.toString && !arg.toString.toString().includes("[native code]"))
        return arg.toString();
      var classes = "";
      for (var key in arg)
        hasOwn.call(arg, key) && arg[key] && (classes = appendClass(classes, key));
      return classes;
    }
    __name(parseValue, "parseValue");
    function appendClass(value, newClass) {
      return newClass ? value ? value + " " + newClass : value + newClass : value;
    }
    __name(appendClass, "appendClass"), module2.exports ? (classNames.default = classNames, module2.exports = classNames) : window.classNames = classNames;
  })();
})(classnames);
var classnamesExports = classnames.exports;
const cn = /* @__PURE__ */ getDefaultExportFromCjs(classnamesExports);
function _extends() {
  return _extends = Object.assign ? Object.assign.bind() : function(n2) {
    for (var e2 = 1; e2 < arguments.length; e2++) {
      var t2 = arguments[e2];
      for (var r2 in t2) ({}).hasOwnProperty.call(t2, r2) && (n2[r2] = t2[r2]);
    }
    return n2;
  }, _extends.apply(null, arguments);
}
__name(_extends, "_extends");
function _typeof$4(o2) {
  "@babel/helpers - typeof";
  return _typeof$4 = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(o3) {
    return typeof o3;
  } : function(o3) {
    return o3 && typeof Symbol == "function" && o3.constructor === Symbol && o3 !== Symbol.prototype ? "symbol" : typeof o3;
  }, _typeof$4(o2);
}
__name(_typeof$4, "_typeof$4");
var REACT_ELEMENT_TYPE_18 = Symbol.for("react.element"), REACT_ELEMENT_TYPE_19 = Symbol.for("react.transitional.element"), REACT_FRAGMENT_TYPE = Symbol.for("react.fragment");
function isFragment$1(object4) {
  return (
    // Base object type
    object4 && _typeof$4(object4) === "object" && // React Element type
    (object4.$$typeof === REACT_ELEMENT_TYPE_18 || object4.$$typeof === REACT_ELEMENT_TYPE_19) && // React Fragment type
    object4.type === REACT_FRAGMENT_TYPE
  );
}
__name(isFragment$1, "isFragment$1");
function toArray$7(children) {
  var option = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, ret = [];
  return React__default.Children.forEach(children, function(child) {
    child == null && !option.keepEmpty || (Array.isArray(child) ? ret = ret.concat(toArray$7(child)) : isFragment$1(child) && child.props ? ret = ret.concat(toArray$7(child.props.children, option)) : ret.push(child));
  }), ret;
}
__name(toArray$7, "toArray$7");
var warned = {}, preWarningFns = [], preMessage = /* @__PURE__ */ __name(function(fn) {
  preWarningFns.push(fn);
}, "preMessage");
function warning$3(valid, message) {
  if (process.env.NODE_ENV !== "production" && !valid && console !== void 0) {
    var finalMessage = preWarningFns.reduce(function(msg, preMessageFn) {
      return preMessageFn(msg ?? "", "warning");
    }, message);
    finalMessage && console.error("Warning: ".concat(finalMessage));
  }
}
__name(warning$3, "warning$3");
function note(valid, message) {
  if (process.env.NODE_ENV !== "production" && !valid && console !== void 0) {
    var finalMessage = preWarningFns.reduce(function(msg, preMessageFn) {
      return preMessageFn(msg ?? "", "note");
    }, message);
    finalMessage && console.warn("Note: ".concat(finalMessage));
  }
}
__name(note, "note");
function resetWarned$1() {
  warned = {};
}
__name(resetWarned$1, "resetWarned$1");
function call(method4, valid, message) {
  !valid && !warned[message] && (method4(!1, message), warned[message] = !0);
}
__name(call, "call");
function warningOnce(valid, message) {
  call(warning$3, valid, message);
}
__name(warningOnce, "warningOnce");
function noteOnce(valid, message) {
  call(note, valid, message);
}
__name(noteOnce, "noteOnce");
warningOnce.preMessage = preMessage;
warningOnce.resetWarned = resetWarned$1;
warningOnce.noteOnce = noteOnce;
function toPrimitive$1(t2, r2) {
  if (_typeof$4(t2) != "object" || !t2) return t2;
  var e2 = t2[Symbol.toPrimitive];
  if (e2 !== void 0) {
    var i = e2.call(t2, r2);
    if (_typeof$4(i) != "object") return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (r2 === "string" ? String : Number)(t2);
}
__name(toPrimitive$1, "toPrimitive$1");
function toPropertyKey$1(t2) {
  var i = toPrimitive$1(t2, "string");
  return _typeof$4(i) == "symbol" ? i : i + "";
}
__name(toPropertyKey$1, "toPropertyKey$1");
function _defineProperty$2(e2, r2, t2) {
  return (r2 = toPropertyKey$1(r2)) in e2 ? Object.defineProperty(e2, r2, {
    value: t2,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e2[r2] = t2, e2;
}
__name(_defineProperty$2, "_defineProperty$2");
function ownKeys$2(e2, r2) {
  var t2 = Object.keys(e2);
  if (Object.getOwnPropertySymbols) {
    var o2 = Object.getOwnPropertySymbols(e2);
    r2 && (o2 = o2.filter(function(r3) {
      return Object.getOwnPropertyDescriptor(e2, r3).enumerable;
    })), t2.push.apply(t2, o2);
  }
  return t2;
}
__name(ownKeys$2, "ownKeys$2");
function _objectSpread2$1(e2) {
  for (var r2 = 1; r2 < arguments.length; r2++) {
    var t2 = arguments[r2] != null ? arguments[r2] : {};
    r2 % 2 ? ownKeys$2(Object(t2), !0).forEach(function(r3) {
      _defineProperty$2(e2, r3, t2[r3]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(t2)) : ownKeys$2(Object(t2)).forEach(function(r3) {
      Object.defineProperty(e2, r3, Object.getOwnPropertyDescriptor(t2, r3));
    });
  }
  return e2;
}
__name(_objectSpread2$1, "_objectSpread2$1");
function isDOM(node2) {
  return node2 instanceof HTMLElement || node2 instanceof SVGElement;
}
__name(isDOM, "isDOM");
function getDOM(node2) {
  return node2 && _typeof$4(node2) === "object" && isDOM(node2.nativeElement) ? node2.nativeElement : isDOM(node2) ? node2 : null;
}
__name(getDOM, "getDOM");
function findDOMNode(node2) {
  var domNode = getDOM(node2);
  if (domNode)
    return domNode;
  if (node2 instanceof React__default.Component) {
    var _ReactDOM$findDOMNode;
    return (_ReactDOM$findDOMNode = ReactDOM__default.findDOMNode) === null || _ReactDOM$findDOMNode === void 0 ? void 0 : _ReactDOM$findDOMNode.call(ReactDOM__default, node2);
  }
  return null;
}
__name(findDOMNode, "findDOMNode");
var reactIs = { exports: {} }, reactIs_production_min = {};
/**
 * @license React
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var hasRequiredReactIs_production_min;
function requireReactIs_production_min() {
  if (hasRequiredReactIs_production_min) return reactIs_production_min;
  hasRequiredReactIs_production_min = 1;
  var b = Symbol.for("react.element"), c = Symbol.for("react.portal"), d = Symbol.for("react.fragment"), e2 = Symbol.for("react.strict_mode"), f = Symbol.for("react.profiler"), g = Symbol.for("react.provider"), h = Symbol.for("react.context"), k = Symbol.for("react.server_context"), l2 = Symbol.for("react.forward_ref"), m2 = Symbol.for("react.suspense"), n2 = Symbol.for("react.suspense_list"), p = Symbol.for("react.memo"), q = Symbol.for("react.lazy"), t2 = Symbol.for("react.offscreen"), u;
  u = Symbol.for("react.module.reference");
  function v(a) {
    if (typeof a == "object" && a !== null) {
      var r2 = a.$$typeof;
      switch (r2) {
        case b:
          switch (a = a.type, a) {
            case d:
            case f:
            case e2:
            case m2:
            case n2:
              return a;
            default:
              switch (a = a && a.$$typeof, a) {
                case k:
                case h:
                case l2:
                case q:
                case p:
                case g:
                  return a;
                default:
                  return r2;
              }
          }
        case c:
          return r2;
      }
    }
  }
  return __name(v, "v"), reactIs_production_min.ContextConsumer = h, reactIs_production_min.ContextProvider = g, reactIs_production_min.Element = b, reactIs_production_min.ForwardRef = l2, reactIs_production_min.Fragment = d, reactIs_production_min.Lazy = q, reactIs_production_min.Memo = p, reactIs_production_min.Portal = c, reactIs_production_min.Profiler = f, reactIs_production_min.StrictMode = e2, reactIs_production_min.Suspense = m2, reactIs_production_min.SuspenseList = n2, reactIs_production_min.isAsyncMode = function() {
    return !1;
  }, reactIs_production_min.isConcurrentMode = function() {
    return !1;
  }, reactIs_production_min.isContextConsumer = function(a) {
    return v(a) === h;
  }, reactIs_production_min.isContextProvider = function(a) {
    return v(a) === g;
  }, reactIs_production_min.isElement = function(a) {
    return typeof a == "object" && a !== null && a.$$typeof === b;
  }, reactIs_production_min.isForwardRef = function(a) {
    return v(a) === l2;
  }, reactIs_production_min.isFragment = function(a) {
    return v(a) === d;
  }, reactIs_production_min.isLazy = function(a) {
    return v(a) === q;
  }, reactIs_production_min.isMemo = function(a) {
    return v(a) === p;
  }, reactIs_production_min.isPortal = function(a) {
    return v(a) === c;
  }, reactIs_production_min.isProfiler = function(a) {
    return v(a) === f;
  }, reactIs_production_min.isStrictMode = function(a) {
    return v(a) === e2;
  }, reactIs_production_min.isSuspense = function(a) {
    return v(a) === m2;
  }, reactIs_production_min.isSuspenseList = function(a) {
    return v(a) === n2;
  }, reactIs_production_min.isValidElementType = function(a) {
    return typeof a == "string" || typeof a == "function" || a === d || a === f || a === e2 || a === m2 || a === n2 || a === t2 || typeof a == "object" && a !== null && (a.$$typeof === q || a.$$typeof === p || a.$$typeof === g || a.$$typeof === h || a.$$typeof === l2 || a.$$typeof === u || a.getModuleId !== void 0);
  }, reactIs_production_min.typeOf = v, reactIs_production_min;
}
__name(requireReactIs_production_min, "requireReactIs_production_min");
var reactIs_development = {};
/**
 * @license React
 * react-is.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var hasRequiredReactIs_development;
function requireReactIs_development() {
  return hasRequiredReactIs_development || (hasRequiredReactIs_development = 1, process.env.NODE_ENV !== "production" && function() {
    var REACT_ELEMENT_TYPE = Symbol.for("react.element"), REACT_PORTAL_TYPE = Symbol.for("react.portal"), REACT_FRAGMENT_TYPE2 = Symbol.for("react.fragment"), REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode"), REACT_PROFILER_TYPE = Symbol.for("react.profiler"), REACT_PROVIDER_TYPE = Symbol.for("react.provider"), REACT_CONTEXT_TYPE = Symbol.for("react.context"), REACT_SERVER_CONTEXT_TYPE = Symbol.for("react.server_context"), REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref"), REACT_SUSPENSE_TYPE = Symbol.for("react.suspense"), REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list"), REACT_MEMO_TYPE = Symbol.for("react.memo"), REACT_LAZY_TYPE = Symbol.for("react.lazy"), REACT_OFFSCREEN_TYPE = Symbol.for("react.offscreen"), enableScopeAPI = !1, enableCacheElement = !1, enableTransitionTracing = !1, enableLegacyHidden = !1, enableDebugTracing = !1, REACT_MODULE_REFERENCE;
    REACT_MODULE_REFERENCE = Symbol.for("react.module.reference");
    function isValidElementType(type4) {
      return !!(typeof type4 == "string" || typeof type4 == "function" || type4 === REACT_FRAGMENT_TYPE2 || type4 === REACT_PROFILER_TYPE || enableDebugTracing || type4 === REACT_STRICT_MODE_TYPE || type4 === REACT_SUSPENSE_TYPE || type4 === REACT_SUSPENSE_LIST_TYPE || enableLegacyHidden || type4 === REACT_OFFSCREEN_TYPE || enableScopeAPI || enableCacheElement || enableTransitionTracing || typeof type4 == "object" && type4 !== null && (type4.$$typeof === REACT_LAZY_TYPE || type4.$$typeof === REACT_MEMO_TYPE || type4.$$typeof === REACT_PROVIDER_TYPE || type4.$$typeof === REACT_CONTEXT_TYPE || type4.$$typeof === REACT_FORWARD_REF_TYPE || // This needs to include all possible module reference object
      // types supported by any Flight configuration anywhere since
      // we don't know which Flight build this will end up being used
      // with.
      type4.$$typeof === REACT_MODULE_REFERENCE || type4.getModuleId !== void 0));
    }
    __name(isValidElementType, "isValidElementType");
    function typeOf(object4) {
      if (typeof object4 == "object" && object4 !== null) {
        var $$typeof = object4.$$typeof;
        switch ($$typeof) {
          case REACT_ELEMENT_TYPE:
            var type4 = object4.type;
            switch (type4) {
              case REACT_FRAGMENT_TYPE2:
              case REACT_PROFILER_TYPE:
              case REACT_STRICT_MODE_TYPE:
              case REACT_SUSPENSE_TYPE:
              case REACT_SUSPENSE_LIST_TYPE:
                return type4;
              default:
                var $$typeofType = type4 && type4.$$typeof;
                switch ($$typeofType) {
                  case REACT_SERVER_CONTEXT_TYPE:
                  case REACT_CONTEXT_TYPE:
                  case REACT_FORWARD_REF_TYPE:
                  case REACT_LAZY_TYPE:
                  case REACT_MEMO_TYPE:
                  case REACT_PROVIDER_TYPE:
                    return $$typeofType;
                  default:
                    return $$typeof;
                }
            }
          case REACT_PORTAL_TYPE:
            return $$typeof;
        }
      }
    }
    __name(typeOf, "typeOf");
    var ContextConsumer = REACT_CONTEXT_TYPE, ContextProvider = REACT_PROVIDER_TYPE, Element2 = REACT_ELEMENT_TYPE, ForwardRef = REACT_FORWARD_REF_TYPE, Fragment = REACT_FRAGMENT_TYPE2, Lazy = REACT_LAZY_TYPE, Memo = REACT_MEMO_TYPE, Portal2 = REACT_PORTAL_TYPE, Profiler = REACT_PROFILER_TYPE, StrictMode = REACT_STRICT_MODE_TYPE, Suspense = REACT_SUSPENSE_TYPE, SuspenseList = REACT_SUSPENSE_LIST_TYPE, hasWarnedAboutDeprecatedIsAsyncMode = !1, hasWarnedAboutDeprecatedIsConcurrentMode = !1;
    function isAsyncMode(object4) {
      return hasWarnedAboutDeprecatedIsAsyncMode || (hasWarnedAboutDeprecatedIsAsyncMode = !0, console.warn("The ReactIs.isAsyncMode() alias has been deprecated, and will be removed in React 18+.")), !1;
    }
    __name(isAsyncMode, "isAsyncMode");
    function isConcurrentMode(object4) {
      return hasWarnedAboutDeprecatedIsConcurrentMode || (hasWarnedAboutDeprecatedIsConcurrentMode = !0, console.warn("The ReactIs.isConcurrentMode() alias has been deprecated, and will be removed in React 18+.")), !1;
    }
    __name(isConcurrentMode, "isConcurrentMode");
    function isContextConsumer(object4) {
      return typeOf(object4) === REACT_CONTEXT_TYPE;
    }
    __name(isContextConsumer, "isContextConsumer");
    function isContextProvider(object4) {
      return typeOf(object4) === REACT_PROVIDER_TYPE;
    }
    __name(isContextProvider, "isContextProvider");
    function isElement(object4) {
      return typeof object4 == "object" && object4 !== null && object4.$$typeof === REACT_ELEMENT_TYPE;
    }
    __name(isElement, "isElement");
    function isForwardRef(object4) {
      return typeOf(object4) === REACT_FORWARD_REF_TYPE;
    }
    __name(isForwardRef, "isForwardRef");
    function isFragment2(object4) {
      return typeOf(object4) === REACT_FRAGMENT_TYPE2;
    }
    __name(isFragment2, "isFragment");
    function isLazy(object4) {
      return typeOf(object4) === REACT_LAZY_TYPE;
    }
    __name(isLazy, "isLazy");
    function isMemo(object4) {
      return typeOf(object4) === REACT_MEMO_TYPE;
    }
    __name(isMemo, "isMemo");
    function isPortal(object4) {
      return typeOf(object4) === REACT_PORTAL_TYPE;
    }
    __name(isPortal, "isPortal");
    function isProfiler(object4) {
      return typeOf(object4) === REACT_PROFILER_TYPE;
    }
    __name(isProfiler, "isProfiler");
    function isStrictMode(object4) {
      return typeOf(object4) === REACT_STRICT_MODE_TYPE;
    }
    __name(isStrictMode, "isStrictMode");
    function isSuspense(object4) {
      return typeOf(object4) === REACT_SUSPENSE_TYPE;
    }
    __name(isSuspense, "isSuspense");
    function isSuspenseList(object4) {
      return typeOf(object4) === REACT_SUSPENSE_LIST_TYPE;
    }
    __name(isSuspenseList, "isSuspenseList"), reactIs_development.ContextConsumer = ContextConsumer, reactIs_development.ContextProvider = ContextProvider, reactIs_development.Element = Element2, reactIs_development.ForwardRef = ForwardRef, reactIs_development.Fragment = Fragment, reactIs_development.Lazy = Lazy, reactIs_development.Memo = Memo, reactIs_development.Portal = Portal2, reactIs_development.Profiler = Profiler, reactIs_development.StrictMode = StrictMode, reactIs_development.Suspense = Suspense, reactIs_development.SuspenseList = SuspenseList, reactIs_development.isAsyncMode = isAsyncMode, reactIs_development.isConcurrentMode = isConcurrentMode, reactIs_development.isContextConsumer = isContextConsumer, reactIs_development.isContextProvider = isContextProvider, reactIs_development.isElement = isElement, reactIs_development.isForwardRef = isForwardRef, reactIs_development.isFragment = isFragment2, reactIs_development.isLazy = isLazy, reactIs_development.isMemo = isMemo, reactIs_development.isPortal = isPortal, reactIs_development.isProfiler = isProfiler, reactIs_development.isStrictMode = isStrictMode, reactIs_development.isSuspense = isSuspense, reactIs_development.isSuspenseList = isSuspenseList, reactIs_development.isValidElementType = isValidElementType, reactIs_development.typeOf = typeOf;
  }()), reactIs_development;
}
__name(requireReactIs_development, "requireReactIs_development");
process.env.NODE_ENV === "production" ? reactIs.exports = requireReactIs_production_min() : reactIs.exports = requireReactIs_development();
var reactIsExports = reactIs.exports;
function useMemo(getValue2, condition, shouldUpdate) {
  var cacheRef = React.useRef({});
  return (!("value" in cacheRef.current) || shouldUpdate(cacheRef.current.condition, condition)) && (cacheRef.current.value = getValue2(), cacheRef.current.condition = condition), cacheRef.current.value;
}
__name(useMemo, "useMemo");
var ReactMajorVersion = Number(version$2.split(".")[0]), fillRef = /* @__PURE__ */ __name(function(ref, node2) {
  typeof ref == "function" ? ref(node2) : _typeof$4(ref) === "object" && ref && "current" in ref && (ref.current = node2);
}, "fillRef"), composeRef = /* @__PURE__ */ __name(function() {
  for (var _len = arguments.length, refs = new Array(_len), _key = 0; _key < _len; _key++)
    refs[_key] = arguments[_key];
  var refList = refs.filter(Boolean);
  return refList.length <= 1 ? refList[0] : function(node2) {
    refs.forEach(function(ref) {
      fillRef(ref, node2);
    });
  };
}, "composeRef"), useComposeRef = /* @__PURE__ */ __name(function() {
  for (var _len2 = arguments.length, refs = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++)
    refs[_key2] = arguments[_key2];
  return useMemo(function() {
    return composeRef.apply(void 0, refs);
  }, refs, function(prev2, next2) {
    return prev2.length !== next2.length || prev2.every(function(ref, i) {
      return ref !== next2[i];
    });
  });
}, "useComposeRef"), supportRef = /* @__PURE__ */ __name(function(nodeOrComponent) {
  var _type$prototype, _nodeOrComponent$prot;
  if (!nodeOrComponent)
    return !1;
  if (isReactElement(nodeOrComponent) && ReactMajorVersion >= 19)
    return !0;
  var type4 = reactIsExports.isMemo(nodeOrComponent) ? nodeOrComponent.type.type : nodeOrComponent.type;
  return !(typeof type4 == "function" && !((_type$prototype = type4.prototype) !== null && _type$prototype !== void 0 && _type$prototype.render) && type4.$$typeof !== reactIsExports.ForwardRef || typeof nodeOrComponent == "function" && !((_nodeOrComponent$prot = nodeOrComponent.prototype) !== null && _nodeOrComponent$prot !== void 0 && _nodeOrComponent$prot.render) && nodeOrComponent.$$typeof !== reactIsExports.ForwardRef);
}, "supportRef");
function isReactElement(node2) {
  return /* @__PURE__ */ isValidElement(node2) && !isFragment$1(node2);
}
__name(isReactElement, "isReactElement");
var supportNodeRef = /* @__PURE__ */ __name(function(node2) {
  return isReactElement(node2) && supportRef(node2);
}, "supportNodeRef"), getNodeRef = /* @__PURE__ */ __name(function(node2) {
  if (node2 && isReactElement(node2)) {
    var ele = node2;
    return ele.props.propertyIsEnumerable("ref") ? ele.props.ref : ele.ref;
  }
  return null;
}, "getNodeRef"), CollectionContext = /* @__PURE__ */ React.createContext(null);
function Collection(_ref) {
  var children = _ref.children, onBatchResize = _ref.onBatchResize, resizeIdRef = React.useRef(0), resizeInfosRef = React.useRef([]), onCollectionResize = React.useContext(CollectionContext), onResize2 = React.useCallback(function(size, element, data) {
    resizeIdRef.current += 1;
    var currentId = resizeIdRef.current;
    resizeInfosRef.current.push({
      size,
      element,
      data
    }), Promise.resolve().then(function() {
      currentId === resizeIdRef.current && (onBatchResize == null || onBatchResize(resizeInfosRef.current), resizeInfosRef.current = []);
    }), onCollectionResize == null || onCollectionResize(size, element, data);
  }, [onBatchResize, onCollectionResize]);
  return /* @__PURE__ */ React.createElement(CollectionContext.Provider, {
    value: onResize2
  }, children);
}
__name(Collection, "Collection");
var MapShim = function() {
  if (typeof Map < "u")
    return Map;
  function getIndex(arr, key) {
    var result = -1;
    return arr.some(function(entry, index2) {
      return entry[0] === key ? (result = index2, !0) : !1;
    }), result;
  }
  return __name(getIndex, "getIndex"), /** @class */
  function() {
    function class_1() {
      this.__entries__ = [];
    }
    return __name(class_1, "class_1"), Object.defineProperty(class_1.prototype, "size", {
      /**
       * @returns {boolean}
       */
      get: /* @__PURE__ */ __name(function() {
        return this.__entries__.length;
      }, "get"),
      enumerable: !0,
      configurable: !0
    }), class_1.prototype.get = function(key) {
      var index2 = getIndex(this.__entries__, key), entry = this.__entries__[index2];
      return entry && entry[1];
    }, class_1.prototype.set = function(key, value) {
      var index2 = getIndex(this.__entries__, key);
      ~index2 ? this.__entries__[index2][1] = value : this.__entries__.push([key, value]);
    }, class_1.prototype.delete = function(key) {
      var entries = this.__entries__, index2 = getIndex(entries, key);
      ~index2 && entries.splice(index2, 1);
    }, class_1.prototype.has = function(key) {
      return !!~getIndex(this.__entries__, key);
    }, class_1.prototype.clear = function() {
      this.__entries__.splice(0);
    }, class_1.prototype.forEach = function(callback, ctx) {
      ctx === void 0 && (ctx = null);
      for (var _i = 0, _a = this.__entries__; _i < _a.length; _i++) {
        var entry = _a[_i];
        callback.call(ctx, entry[1], entry[0]);
      }
    }, class_1;
  }();
}(), isBrowser = typeof window < "u" && typeof document < "u" && window.document === document, global$1 = function() {
  return typeof global < "u" && global.Math === Math ? global : typeof self < "u" && self.Math === Math ? self : typeof window < "u" && window.Math === Math ? window : Function("return this")();
}(), requestAnimationFrame$1 = function() {
  return typeof requestAnimationFrame == "function" ? requestAnimationFrame.bind(global$1) : function(callback) {
    return setTimeout(function() {
      return callback(Date.now());
    }, 1e3 / 60);
  };
}(), trailingTimeout = 2;
function throttle$1(callback, delay) {
  var leadingCall = !1, trailingCall = !1, lastCallTime = 0;
  function resolvePending() {
    leadingCall && (leadingCall = !1, callback()), trailingCall && proxy();
  }
  __name(resolvePending, "resolvePending");
  function timeoutCallback() {
    requestAnimationFrame$1(resolvePending);
  }
  __name(timeoutCallback, "timeoutCallback");
  function proxy() {
    var timeStamp = Date.now();
    if (leadingCall) {
      if (timeStamp - lastCallTime < trailingTimeout)
        return;
      trailingCall = !0;
    } else
      leadingCall = !0, trailingCall = !1, setTimeout(timeoutCallback, delay);
    lastCallTime = timeStamp;
  }
  return __name(proxy, "proxy"), proxy;
}
__name(throttle$1, "throttle$1");
var REFRESH_DELAY = 20, transitionKeys = ["top", "right", "bottom", "left", "width", "height", "size", "weight"], mutationObserverSupported = typeof MutationObserver < "u", ResizeObserverController = (
  /** @class */
  function() {
    function ResizeObserverController2() {
      this.connected_ = !1, this.mutationEventsAdded_ = !1, this.mutationsObserver_ = null, this.observers_ = [], this.onTransitionEnd_ = this.onTransitionEnd_.bind(this), this.refresh = throttle$1(this.refresh.bind(this), REFRESH_DELAY);
    }
    return __name(ResizeObserverController2, "ResizeObserverController"), ResizeObserverController2.prototype.addObserver = function(observer) {
      ~this.observers_.indexOf(observer) || this.observers_.push(observer), this.connected_ || this.connect_();
    }, ResizeObserverController2.prototype.removeObserver = function(observer) {
      var observers2 = this.observers_, index2 = observers2.indexOf(observer);
      ~index2 && observers2.splice(index2, 1), !observers2.length && this.connected_ && this.disconnect_();
    }, ResizeObserverController2.prototype.refresh = function() {
      var changesDetected = this.updateObservers_();
      changesDetected && this.refresh();
    }, ResizeObserverController2.prototype.updateObservers_ = function() {
      var activeObservers = this.observers_.filter(function(observer) {
        return observer.gatherActive(), observer.hasActive();
      });
      return activeObservers.forEach(function(observer) {
        return observer.broadcastActive();
      }), activeObservers.length > 0;
    }, ResizeObserverController2.prototype.connect_ = function() {
      !isBrowser || this.connected_ || (document.addEventListener("transitionend", this.onTransitionEnd_), window.addEventListener("resize", this.refresh), mutationObserverSupported ? (this.mutationsObserver_ = new MutationObserver(this.refresh), this.mutationsObserver_.observe(document, {
        attributes: !0,
        childList: !0,
        characterData: !0,
        subtree: !0
      })) : (document.addEventListener("DOMSubtreeModified", this.refresh), this.mutationEventsAdded_ = !0), this.connected_ = !0);
    }, ResizeObserverController2.prototype.disconnect_ = function() {
      !isBrowser || !this.connected_ || (document.removeEventListener("transitionend", this.onTransitionEnd_), window.removeEventListener("resize", this.refresh), this.mutationsObserver_ && this.mutationsObserver_.disconnect(), this.mutationEventsAdded_ && document.removeEventListener("DOMSubtreeModified", this.refresh), this.mutationsObserver_ = null, this.mutationEventsAdded_ = !1, this.connected_ = !1);
    }, ResizeObserverController2.prototype.onTransitionEnd_ = function(_a) {
      var _b = _a.propertyName, propertyName = _b === void 0 ? "" : _b, isReflowProperty = transitionKeys.some(function(key) {
        return !!~propertyName.indexOf(key);
      });
      isReflowProperty && this.refresh();
    }, ResizeObserverController2.getInstance = function() {
      return this.instance_ || (this.instance_ = new ResizeObserverController2()), this.instance_;
    }, ResizeObserverController2.instance_ = null, ResizeObserverController2;
  }()
), defineConfigurable = /* @__PURE__ */ __name(function(target, props) {
  for (var _i = 0, _a = Object.keys(props); _i < _a.length; _i++) {
    var key = _a[_i];
    Object.defineProperty(target, key, {
      value: props[key],
      enumerable: !1,
      writable: !1,
      configurable: !0
    });
  }
  return target;
}, "defineConfigurable"), getWindowOf = /* @__PURE__ */ __name(function(target) {
  var ownerGlobal = target && target.ownerDocument && target.ownerDocument.defaultView;
  return ownerGlobal || global$1;
}, "getWindowOf"), emptyRect = createRectInit(0, 0, 0, 0);
function toFloat(value) {
  return parseFloat(value) || 0;
}
__name(toFloat, "toFloat");
function getBordersSize(styles2) {
  for (var positions = [], _i = 1; _i < arguments.length; _i++)
    positions[_i - 1] = arguments[_i];
  return positions.reduce(function(size, position2) {
    var value = styles2["border-" + position2 + "-width"];
    return size + toFloat(value);
  }, 0);
}
__name(getBordersSize, "getBordersSize");
function getPaddings(styles2) {
  for (var positions = ["top", "right", "bottom", "left"], paddings = {}, _i = 0, positions_1 = positions; _i < positions_1.length; _i++) {
    var position2 = positions_1[_i], value = styles2["padding-" + position2];
    paddings[position2] = toFloat(value);
  }
  return paddings;
}
__name(getPaddings, "getPaddings");
function getSVGContentRect(target) {
  var bbox = target.getBBox();
  return createRectInit(0, 0, bbox.width, bbox.height);
}
__name(getSVGContentRect, "getSVGContentRect");
function getHTMLElementContentRect(target) {
  var clientWidth = target.clientWidth, clientHeight = target.clientHeight;
  if (!clientWidth && !clientHeight)
    return emptyRect;
  var styles2 = getWindowOf(target).getComputedStyle(target), paddings = getPaddings(styles2), horizPad = paddings.left + paddings.right, vertPad = paddings.top + paddings.bottom, width = toFloat(styles2.width), height = toFloat(styles2.height);
  if (styles2.boxSizing === "border-box" && (Math.round(width + horizPad) !== clientWidth && (width -= getBordersSize(styles2, "left", "right") + horizPad), Math.round(height + vertPad) !== clientHeight && (height -= getBordersSize(styles2, "top", "bottom") + vertPad)), !isDocumentElement(target)) {
    var vertScrollbar = Math.round(width + horizPad) - clientWidth, horizScrollbar = Math.round(height + vertPad) - clientHeight;
    Math.abs(vertScrollbar) !== 1 && (width -= vertScrollbar), Math.abs(horizScrollbar) !== 1 && (height -= horizScrollbar);
  }
  return createRectInit(paddings.left, paddings.top, width, height);
}
__name(getHTMLElementContentRect, "getHTMLElementContentRect");
var isSVGGraphicsElement = /* @__PURE__ */ function() {
  return typeof SVGGraphicsElement < "u" ? function(target) {
    return target instanceof getWindowOf(target).SVGGraphicsElement;
  } : function(target) {
    return target instanceof getWindowOf(target).SVGElement && typeof target.getBBox == "function";
  };
}();
function isDocumentElement(target) {
  return target === getWindowOf(target).document.documentElement;
}
__name(isDocumentElement, "isDocumentElement");
function getContentRect(target) {
  return isBrowser ? isSVGGraphicsElement(target) ? getSVGContentRect(target) : getHTMLElementContentRect(target) : emptyRect;
}
__name(getContentRect, "getContentRect");
function createReadOnlyRect(_a) {
  var x = _a.x, y = _a.y, width = _a.width, height = _a.height, Constr = typeof DOMRectReadOnly < "u" ? DOMRectReadOnly : Object, rect = Object.create(Constr.prototype);
  return defineConfigurable(rect, {
    x,
    y,
    width,
    height,
    top: y,
    right: x + width,
    bottom: height + y,
    left: x
  }), rect;
}
__name(createReadOnlyRect, "createReadOnlyRect");
function createRectInit(x, y, width, height) {
  return { x, y, width, height };
}
__name(createRectInit, "createRectInit");
var ResizeObservation = (
  /** @class */
  function() {
    function ResizeObservation2(target) {
      this.broadcastWidth = 0, this.broadcastHeight = 0, this.contentRect_ = createRectInit(0, 0, 0, 0), this.target = target;
    }
    return __name(ResizeObservation2, "ResizeObservation"), ResizeObservation2.prototype.isActive = function() {
      var rect = getContentRect(this.target);
      return this.contentRect_ = rect, rect.width !== this.broadcastWidth || rect.height !== this.broadcastHeight;
    }, ResizeObservation2.prototype.broadcastRect = function() {
      var rect = this.contentRect_;
      return this.broadcastWidth = rect.width, this.broadcastHeight = rect.height, rect;
    }, ResizeObservation2;
  }()
), ResizeObserverEntry = (
  /** @class */
  function() {
    function ResizeObserverEntry2(target, rectInit) {
      var contentRect = createReadOnlyRect(rectInit);
      defineConfigurable(this, { target, contentRect });
    }
    return __name(ResizeObserverEntry2, "ResizeObserverEntry"), ResizeObserverEntry2;
  }()
), ResizeObserverSPI = (
  /** @class */
  function() {
    function ResizeObserverSPI2(callback, controller, callbackCtx) {
      if (this.activeObservations_ = [], this.observations_ = new MapShim(), typeof callback != "function")
        throw new TypeError("The callback provided as parameter 1 is not a function.");
      this.callback_ = callback, this.controller_ = controller, this.callbackCtx_ = callbackCtx;
    }
    return __name(ResizeObserverSPI2, "ResizeObserverSPI"), ResizeObserverSPI2.prototype.observe = function(target) {
      if (!arguments.length)
        throw new TypeError("1 argument required, but only 0 present.");
      if (!(typeof Element > "u" || !(Element instanceof Object))) {
        if (!(target instanceof getWindowOf(target).Element))
          throw new TypeError('parameter 1 is not of type "Element".');
        var observations = this.observations_;
        observations.has(target) || (observations.set(target, new ResizeObservation(target)), this.controller_.addObserver(this), this.controller_.refresh());
      }
    }, ResizeObserverSPI2.prototype.unobserve = function(target) {
      if (!arguments.length)
        throw new TypeError("1 argument required, but only 0 present.");
      if (!(typeof Element > "u" || !(Element instanceof Object))) {
        if (!(target instanceof getWindowOf(target).Element))
          throw new TypeError('parameter 1 is not of type "Element".');
        var observations = this.observations_;
        observations.has(target) && (observations.delete(target), observations.size || this.controller_.removeObserver(this));
      }
    }, ResizeObserverSPI2.prototype.disconnect = function() {
      this.clearActive(), this.observations_.clear(), this.controller_.removeObserver(this);
    }, ResizeObserverSPI2.prototype.gatherActive = function() {
      var _this = this;
      this.clearActive(), this.observations_.forEach(function(observation) {
        observation.isActive() && _this.activeObservations_.push(observation);
      });
    }, ResizeObserverSPI2.prototype.broadcastActive = function() {
      if (this.hasActive()) {
        var ctx = this.callbackCtx_, entries = this.activeObservations_.map(function(observation) {
          return new ResizeObserverEntry(observation.target, observation.broadcastRect());
        });
        this.callback_.call(ctx, entries, ctx), this.clearActive();
      }
    }, ResizeObserverSPI2.prototype.clearActive = function() {
      this.activeObservations_.splice(0);
    }, ResizeObserverSPI2.prototype.hasActive = function() {
      return this.activeObservations_.length > 0;
    }, ResizeObserverSPI2;
  }()
), observers = typeof WeakMap < "u" ? /* @__PURE__ */ new WeakMap() : new MapShim(), ResizeObserver$2 = (
  /** @class */
  function() {
    function ResizeObserver2(callback) {
      if (!(this instanceof ResizeObserver2))
        throw new TypeError("Cannot call a class as a function.");
      if (!arguments.length)
        throw new TypeError("1 argument required, but only 0 present.");
      var controller = ResizeObserverController.getInstance(), observer = new ResizeObserverSPI(callback, controller, this);
      observers.set(this, observer);
    }
    return __name(ResizeObserver2, "ResizeObserver"), ResizeObserver2;
  }()
);
[
  "observe",
  "unobserve",
  "disconnect"
].forEach(function(method4) {
  ResizeObserver$2.prototype[method4] = function() {
    var _a;
    return (_a = observers.get(this))[method4].apply(_a, arguments);
  };
});
var index$1 = function() {
  return typeof global$1.ResizeObserver < "u" ? global$1.ResizeObserver : ResizeObserver$2;
}(), elementListeners = /* @__PURE__ */ new Map();
function onResize(entities) {
  entities.forEach(function(entity) {
    var _elementListeners$get, target = entity.target;
    (_elementListeners$get = elementListeners.get(target)) === null || _elementListeners$get === void 0 || _elementListeners$get.forEach(function(listener) {
      return listener(target);
    });
  });
}
__name(onResize, "onResize");
var resizeObserver = new index$1(onResize);
process.env.NODE_ENV;
process.env.NODE_ENV;
function observe(element, callback) {
  elementListeners.has(element) || (elementListeners.set(element, /* @__PURE__ */ new Set()), resizeObserver.observe(element)), elementListeners.get(element).add(callback);
}
__name(observe, "observe");
function unobserve(element, callback) {
  elementListeners.has(element) && (elementListeners.get(element).delete(callback), elementListeners.get(element).size || (resizeObserver.unobserve(element), elementListeners.delete(element)));
}
__name(unobserve, "unobserve");
function _classCallCheck$1(a, n2) {
  if (!(a instanceof n2)) throw new TypeError("Cannot call a class as a function");
}
__name(_classCallCheck$1, "_classCallCheck$1");
function _defineProperties$1(e2, r2) {
  for (var t2 = 0; t2 < r2.length; t2++) {
    var o2 = r2[t2];
    o2.enumerable = o2.enumerable || !1, o2.configurable = !0, "value" in o2 && (o2.writable = !0), Object.defineProperty(e2, toPropertyKey$1(o2.key), o2);
  }
}
__name(_defineProperties$1, "_defineProperties$1");
function _createClass$1(e2, r2, t2) {
  return r2 && _defineProperties$1(e2.prototype, r2), t2 && _defineProperties$1(e2, t2), Object.defineProperty(e2, "prototype", {
    writable: !1
  }), e2;
}
__name(_createClass$1, "_createClass$1");
function _setPrototypeOf(t2, e2) {
  return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t3, e3) {
    return t3.__proto__ = e3, t3;
  }, _setPrototypeOf(t2, e2);
}
__name(_setPrototypeOf, "_setPrototypeOf");
function _inherits(t2, e2) {
  if (typeof e2 != "function" && e2 !== null) throw new TypeError("Super expression must either be null or a function");
  t2.prototype = Object.create(e2 && e2.prototype, {
    constructor: {
      value: t2,
      writable: !0,
      configurable: !0
    }
  }), Object.defineProperty(t2, "prototype", {
    writable: !1
  }), e2 && _setPrototypeOf(t2, e2);
}
__name(_inherits, "_inherits");
function _getPrototypeOf(t2) {
  return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(t3) {
    return t3.__proto__ || Object.getPrototypeOf(t3);
  }, _getPrototypeOf(t2);
}
__name(_getPrototypeOf, "_getPrototypeOf");
function _isNativeReflectConstruct() {
  try {
    var t2 = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
  } catch {
  }
  return (_isNativeReflectConstruct = /* @__PURE__ */ __name(function() {
    return !!t2;
  }, "_isNativeReflectConstruct"))();
}
__name(_isNativeReflectConstruct, "_isNativeReflectConstruct");
function _assertThisInitialized(e2) {
  if (e2 === void 0) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return e2;
}
__name(_assertThisInitialized, "_assertThisInitialized");
function _possibleConstructorReturn(t2, e2) {
  if (e2 && (_typeof$4(e2) == "object" || typeof e2 == "function")) return e2;
  if (e2 !== void 0) throw new TypeError("Derived constructors may only return object or undefined");
  return _assertThisInitialized(t2);
}
__name(_possibleConstructorReturn, "_possibleConstructorReturn");
function _createSuper(t2) {
  var r2 = _isNativeReflectConstruct();
  return function() {
    var e2, o2 = _getPrototypeOf(t2);
    if (r2) {
      var s = _getPrototypeOf(this).constructor;
      e2 = Reflect.construct(o2, arguments, s);
    } else e2 = o2.apply(this, arguments);
    return _possibleConstructorReturn(this, e2);
  };
}
__name(_createSuper, "_createSuper");
var DomWrapper$1 = /* @__PURE__ */ function(_React$Component) {
  _inherits(DomWrapper2, _React$Component);
  var _super = _createSuper(DomWrapper2);
  function DomWrapper2() {
    return _classCallCheck$1(this, DomWrapper2), _super.apply(this, arguments);
  }
  return __name(DomWrapper2, "DomWrapper"), _createClass$1(DomWrapper2, [{
    key: "render",
    value: /* @__PURE__ */ __name(function() {
      return this.props.children;
    }, "render")
  }]), DomWrapper2;
}(React.Component);
function SingleObserver(props, ref) {
  var children = props.children, disabled = props.disabled, elementRef = React.useRef(null), wrapperRef = React.useRef(null), onCollectionResize = React.useContext(CollectionContext), isRenderProps = typeof children == "function", mergedChildren = isRenderProps ? children(elementRef) : children, sizeRef = React.useRef({
    width: -1,
    height: -1,
    offsetWidth: -1,
    offsetHeight: -1
  }), canRef = !isRenderProps && /* @__PURE__ */ React.isValidElement(mergedChildren) && supportRef(mergedChildren), originRef = canRef ? mergedChildren.ref : null, mergedRef = useComposeRef(originRef, elementRef), getDom = /* @__PURE__ */ __name(function() {
    var _elementRef$current;
    return findDOMNode(elementRef.current) || // Support `nativeElement` format
    (elementRef.current && _typeof$4(elementRef.current) === "object" ? findDOMNode((_elementRef$current = elementRef.current) === null || _elementRef$current === void 0 ? void 0 : _elementRef$current.nativeElement) : null) || findDOMNode(wrapperRef.current);
  }, "getDom");
  React.useImperativeHandle(ref, function() {
    return getDom();
  });
  var propsRef = React.useRef(props);
  propsRef.current = props;
  var onInternalResize = React.useCallback(function(target) {
    var _propsRef$current = propsRef.current, onResize2 = _propsRef$current.onResize, data = _propsRef$current.data, _target$getBoundingCl = target.getBoundingClientRect(), width = _target$getBoundingCl.width, height = _target$getBoundingCl.height, offsetWidth = target.offsetWidth, offsetHeight = target.offsetHeight, fixedWidth = Math.floor(width), fixedHeight = Math.floor(height);
    if (sizeRef.current.width !== fixedWidth || sizeRef.current.height !== fixedHeight || sizeRef.current.offsetWidth !== offsetWidth || sizeRef.current.offsetHeight !== offsetHeight) {
      var size = {
        width: fixedWidth,
        height: fixedHeight,
        offsetWidth,
        offsetHeight
      };
      sizeRef.current = size;
      var mergedOffsetWidth = offsetWidth === Math.round(width) ? width : offsetWidth, mergedOffsetHeight = offsetHeight === Math.round(height) ? height : offsetHeight, sizeInfo = _objectSpread2$1(_objectSpread2$1({}, size), {}, {
        offsetWidth: mergedOffsetWidth,
        offsetHeight: mergedOffsetHeight
      });
      onCollectionResize == null || onCollectionResize(sizeInfo, target, data), onResize2 && Promise.resolve().then(function() {
        onResize2(sizeInfo, target);
      });
    }
  }, []);
  return React.useEffect(function() {
    var currentElement = getDom();
    return currentElement && !disabled && observe(currentElement, onInternalResize), function() {
      return unobserve(currentElement, onInternalResize);
    };
  }, [elementRef.current, disabled]), /* @__PURE__ */ React.createElement(DomWrapper$1, {
    ref: wrapperRef
  }, canRef ? /* @__PURE__ */ React.cloneElement(mergedChildren, {
    ref: mergedRef
  }) : mergedChildren);
}
__name(SingleObserver, "SingleObserver");
var RefSingleObserver = /* @__PURE__ */ React.forwardRef(SingleObserver);
process.env.NODE_ENV !== "production" && (RefSingleObserver.displayName = "SingleObserver");
var INTERNAL_PREFIX_KEY = "rc-observer-key";
function ResizeObserver$1(props, ref) {
  var children = props.children, childNodes = typeof children == "function" ? [children] : toArray$7(children);
  return process.env.NODE_ENV !== "production" && (childNodes.length > 1 ? warning$3(!1, "Find more than one child node with `children` in ResizeObserver. Please use ResizeObserver.Collection instead.") : childNodes.length === 0 && warning$3(!1, "`children` of ResizeObserver is empty. Nothing is in observe.")), childNodes.map(function(child, index2) {
    var key = (child == null ? void 0 : child.key) || "".concat(INTERNAL_PREFIX_KEY, "-").concat(index2);
    return /* @__PURE__ */ React.createElement(RefSingleObserver, _extends({}, props, {
      key,
      ref: index2 === 0 ? ref : void 0
    }), child);
  });
}
__name(ResizeObserver$1, "ResizeObserver$1");
var RefResizeObserver = /* @__PURE__ */ React.forwardRef(ResizeObserver$1);
process.env.NODE_ENV !== "production" && (RefResizeObserver.displayName = "ResizeObserver");
RefResizeObserver.Collection = Collection;
function omit(obj, fields) {
  var clone = Object.assign({}, obj);
  return Array.isArray(fields) && fields.forEach(function(key) {
    delete clone[key];
  }), clone;
}
__name(omit, "omit");
function _arrayLikeToArray(r2, a) {
  (a == null || a > r2.length) && (a = r2.length);
  for (var e2 = 0, n2 = Array(a); e2 < a; e2++) n2[e2] = r2[e2];
  return n2;
}
__name(_arrayLikeToArray, "_arrayLikeToArray");
function _arrayWithoutHoles(r2) {
  if (Array.isArray(r2)) return _arrayLikeToArray(r2);
}
__name(_arrayWithoutHoles, "_arrayWithoutHoles");
function _iterableToArray(r2) {
  if (typeof Symbol < "u" && r2[Symbol.iterator] != null || r2["@@iterator"] != null) return Array.from(r2);
}
__name(_iterableToArray, "_iterableToArray");
function _unsupportedIterableToArray(r2, a) {
  if (r2) {
    if (typeof r2 == "string") return _arrayLikeToArray(r2, a);
    var t2 = {}.toString.call(r2).slice(8, -1);
    return t2 === "Object" && r2.constructor && (t2 = r2.constructor.name), t2 === "Map" || t2 === "Set" ? Array.from(r2) : t2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t2) ? _arrayLikeToArray(r2, a) : void 0;
  }
}
__name(_unsupportedIterableToArray, "_unsupportedIterableToArray");
function _nonIterableSpread() {
  throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
__name(_nonIterableSpread, "_nonIterableSpread");
function _toConsumableArray(r2) {
  return _arrayWithoutHoles(r2) || _iterableToArray(r2) || _unsupportedIterableToArray(r2) || _nonIterableSpread();
}
__name(_toConsumableArray, "_toConsumableArray");
var raf = /* @__PURE__ */ __name(function(callback) {
  return +setTimeout(callback, 16);
}, "raf"), caf = /* @__PURE__ */ __name(function(num) {
  return clearTimeout(num);
}, "caf");
typeof window < "u" && "requestAnimationFrame" in window && (raf = /* @__PURE__ */ __name(function(callback) {
  return window.requestAnimationFrame(callback);
}, "raf"), caf = /* @__PURE__ */ __name(function(handle) {
  return window.cancelAnimationFrame(handle);
}, "caf"));
var rafUUID = 0, rafIds = /* @__PURE__ */ new Map();
function cleanup(id2) {
  rafIds.delete(id2);
}
__name(cleanup, "cleanup");
var wrapperRaf = /* @__PURE__ */ __name(function(callback) {
  var times = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;
  rafUUID += 1;
  var id2 = rafUUID;
  function callRef(leftTimes) {
    if (leftTimes === 0)
      cleanup(id2), callback();
    else {
      var realId = raf(function() {
        callRef(leftTimes - 1);
      });
      rafIds.set(id2, realId);
    }
  }
  return __name(callRef, "callRef"), callRef(times), id2;
}, "wrapperRaf");
wrapperRaf.cancel = function(id2) {
  var realId = rafIds.get(id2);
  return cleanup(id2), caf(realId);
};
process.env.NODE_ENV !== "production" && (wrapperRaf.ids = function() {
  return rafIds;
});
function _arrayWithHoles(r2) {
  if (Array.isArray(r2)) return r2;
}
__name(_arrayWithHoles, "_arrayWithHoles");
function _iterableToArrayLimit(r2, l2) {
  var t2 = r2 == null ? null : typeof Symbol < "u" && r2[Symbol.iterator] || r2["@@iterator"];
  if (t2 != null) {
    var e2, n2, i, u, a = [], f = !0, o2 = !1;
    try {
      if (i = (t2 = t2.call(r2)).next, l2 === 0) {
        if (Object(t2) !== t2) return;
        f = !1;
      } else for (; !(f = (e2 = i.call(t2)).done) && (a.push(e2.value), a.length !== l2); f = !0) ;
    } catch (r3) {
      o2 = !0, n2 = r3;
    } finally {
      try {
        if (!f && t2.return != null && (u = t2.return(), Object(u) !== u)) return;
      } finally {
        if (o2) throw n2;
      }
    }
    return a;
  }
}
__name(_iterableToArrayLimit, "_iterableToArrayLimit");
function _nonIterableRest() {
  throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
__name(_nonIterableRest, "_nonIterableRest");
function _slicedToArray(r2, e2) {
  return _arrayWithHoles(r2) || _iterableToArrayLimit(r2, e2) || _unsupportedIterableToArray(r2, e2) || _nonIterableRest();
}
__name(_slicedToArray, "_slicedToArray");
function murmur2(str) {
  for (var h = 0, k, i = 0, len = str.length; len >= 4; ++i, len -= 4)
    k = str.charCodeAt(i) & 255 | (str.charCodeAt(++i) & 255) << 8 | (str.charCodeAt(++i) & 255) << 16 | (str.charCodeAt(++i) & 255) << 24, k = /* Math.imul(k, m): */
    (k & 65535) * 1540483477 + ((k >>> 16) * 59797 << 16), k ^= /* k >>> r: */
    k >>> 24, h = /* Math.imul(k, m): */
    (k & 65535) * 1540483477 + ((k >>> 16) * 59797 << 16) ^ /* Math.imul(h, m): */
    (h & 65535) * 1540483477 + ((h >>> 16) * 59797 << 16);
  switch (len) {
    case 3:
      h ^= (str.charCodeAt(i + 2) & 255) << 16;
    case 2:
      h ^= (str.charCodeAt(i + 1) & 255) << 8;
    case 1:
      h ^= str.charCodeAt(i) & 255, h = /* Math.imul(h, m): */
      (h & 65535) * 1540483477 + ((h >>> 16) * 59797 << 16);
  }
  return h ^= h >>> 13, h = /* Math.imul(h, m): */
  (h & 65535) * 1540483477 + ((h >>> 16) * 59797 << 16), ((h ^ h >>> 15) >>> 0).toString(36);
}
__name(murmur2, "murmur2");
function canUseDom() {
  return !!(typeof window < "u" && window.document && window.document.createElement);
}
__name(canUseDom, "canUseDom");
function contains(root, n2) {
  if (!root)
    return !1;
  if (root.contains)
    return root.contains(n2);
  for (var node2 = n2; node2; ) {
    if (node2 === root)
      return !0;
    node2 = node2.parentNode;
  }
  return !1;
}
__name(contains, "contains");
var APPEND_ORDER = "data-rc-order", APPEND_PRIORITY = "data-rc-priority", MARK_KEY = "rc-util-key", containerCache = /* @__PURE__ */ new Map();
function getMark() {
  var _ref = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, mark = _ref.mark;
  return mark ? mark.startsWith("data-") ? mark : "data-".concat(mark) : MARK_KEY;
}
__name(getMark, "getMark");
function getContainer(option) {
  if (option.attachTo)
    return option.attachTo;
  var head = document.querySelector("head");
  return head || document.body;
}
__name(getContainer, "getContainer");
function getOrder(prepend) {
  return prepend === "queue" ? "prependQueue" : prepend ? "prepend" : "append";
}
__name(getOrder, "getOrder");
function findStyles(container2) {
  return Array.from((containerCache.get(container2) || container2).children).filter(function(node2) {
    return node2.tagName === "STYLE";
  });
}
__name(findStyles, "findStyles");
function injectCSS(css) {
  var option = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  if (!canUseDom())
    return null;
  var csp = option.csp, prepend = option.prepend, _option$priority = option.priority, priority = _option$priority === void 0 ? 0 : _option$priority, mergedOrder = getOrder(prepend), isPrependQueue = mergedOrder === "prependQueue", styleNode = document.createElement("style");
  styleNode.setAttribute(APPEND_ORDER, mergedOrder), isPrependQueue && priority && styleNode.setAttribute(APPEND_PRIORITY, "".concat(priority)), csp != null && csp.nonce && (styleNode.nonce = csp == null ? void 0 : csp.nonce), styleNode.innerHTML = css;
  var container2 = getContainer(option), firstChild = container2.firstChild;
  if (prepend) {
    if (isPrependQueue) {
      var existStyle = (option.styles || findStyles(container2)).filter(function(node2) {
        if (!["prepend", "prependQueue"].includes(node2.getAttribute(APPEND_ORDER)))
          return !1;
        var nodePriority = Number(node2.getAttribute(APPEND_PRIORITY) || 0);
        return priority >= nodePriority;
      });
      if (existStyle.length)
        return container2.insertBefore(styleNode, existStyle[existStyle.length - 1].nextSibling), styleNode;
    }
    container2.insertBefore(styleNode, firstChild);
  } else
    container2.appendChild(styleNode);
  return styleNode;
}
__name(injectCSS, "injectCSS");
function findExistNode(key) {
  var option = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, container2 = getContainer(option);
  return (option.styles || findStyles(container2)).find(function(node2) {
    return node2.getAttribute(getMark(option)) === key;
  });
}
__name(findExistNode, "findExistNode");
function removeCSS(key) {
  var option = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, existNode = findExistNode(key, option);
  if (existNode) {
    var container2 = getContainer(option);
    container2.removeChild(existNode);
  }
}
__name(removeCSS, "removeCSS");
function syncRealContainer(container2, option) {
  var cachedRealContainer = containerCache.get(container2);
  if (!cachedRealContainer || !contains(document, cachedRealContainer)) {
    var placeholderStyle = injectCSS("", option), parentNode = placeholderStyle.parentNode;
    containerCache.set(container2, parentNode), container2.removeChild(placeholderStyle);
  }
}
__name(syncRealContainer, "syncRealContainer");
function updateCSS(css, key) {
  var originOption = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, container2 = getContainer(originOption), styles2 = findStyles(container2), option = _objectSpread2$1(_objectSpread2$1({}, originOption), {}, {
    styles: styles2
  });
  syncRealContainer(container2, option);
  var existNode = findExistNode(key, option);
  if (existNode) {
    var _option$csp, _option$csp2;
    if ((_option$csp = option.csp) !== null && _option$csp !== void 0 && _option$csp.nonce && existNode.nonce !== ((_option$csp2 = option.csp) === null || _option$csp2 === void 0 ? void 0 : _option$csp2.nonce)) {
      var _option$csp3;
      existNode.nonce = (_option$csp3 = option.csp) === null || _option$csp3 === void 0 ? void 0 : _option$csp3.nonce;
    }
    return existNode.innerHTML !== css && (existNode.innerHTML = css), existNode;
  }
  var newNode = injectCSS(css, option);
  return newNode.setAttribute(getMark(option), key), newNode;
}
__name(updateCSS, "updateCSS");
function _objectWithoutPropertiesLoose(r2, e2) {
  if (r2 == null) return {};
  var t2 = {};
  for (var n2 in r2) if ({}.hasOwnProperty.call(r2, n2)) {
    if (e2.indexOf(n2) !== -1) continue;
    t2[n2] = r2[n2];
  }
  return t2;
}
__name(_objectWithoutPropertiesLoose, "_objectWithoutPropertiesLoose");
function _objectWithoutProperties(e2, t2) {
  if (e2 == null) return {};
  var o2, r2, i = _objectWithoutPropertiesLoose(e2, t2);
  if (Object.getOwnPropertySymbols) {
    var n2 = Object.getOwnPropertySymbols(e2);
    for (r2 = 0; r2 < n2.length; r2++) o2 = n2[r2], t2.indexOf(o2) === -1 && {}.propertyIsEnumerable.call(e2, o2) && (i[o2] = e2[o2]);
  }
  return i;
}
__name(_objectWithoutProperties, "_objectWithoutProperties");
function isEqual(obj1, obj2) {
  var shallow = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !1, refSet = /* @__PURE__ */ new Set();
  function deepEqual(a, b) {
    var level = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1, circular = refSet.has(a);
    if (warningOnce(!circular, "Warning: There may be circular references"), circular)
      return !1;
    if (a === b)
      return !0;
    if (shallow && level > 1)
      return !1;
    refSet.add(a);
    var newLevel = level + 1;
    if (Array.isArray(a)) {
      if (!Array.isArray(b) || a.length !== b.length)
        return !1;
      for (var i = 0; i < a.length; i++)
        if (!deepEqual(a[i], b[i], newLevel))
          return !1;
      return !0;
    }
    if (a && b && _typeof$4(a) === "object" && _typeof$4(b) === "object") {
      var keys2 = Object.keys(a);
      return keys2.length !== Object.keys(b).length ? !1 : keys2.every(function(key) {
        return deepEqual(a[key], b[key], newLevel);
      });
    }
    return !1;
  }
  return __name(deepEqual, "deepEqual"), deepEqual(obj1, obj2);
}
__name(isEqual, "isEqual");
var SPLIT$1 = "%";
function pathKey(keys2) {
  return keys2.join(SPLIT$1);
}
__name(pathKey, "pathKey");
var Entity = /* @__PURE__ */ function() {
  function Entity2(instanceId) {
    _classCallCheck$1(this, Entity2), _defineProperty$2(this, "instanceId", void 0), _defineProperty$2(this, "cache", /* @__PURE__ */ new Map()), this.instanceId = instanceId;
  }
  return __name(Entity2, "Entity"), _createClass$1(Entity2, [{
    key: "get",
    value: /* @__PURE__ */ __name(function(keys2) {
      return this.opGet(pathKey(keys2));
    }, "get")
    /** A fast get cache with `get` concat. */
  }, {
    key: "opGet",
    value: /* @__PURE__ */ __name(function(keyPathStr) {
      return this.cache.get(keyPathStr) || null;
    }, "opGet")
  }, {
    key: "update",
    value: /* @__PURE__ */ __name(function(keys2, valueFn) {
      return this.opUpdate(pathKey(keys2), valueFn);
    }, "update")
    /** A fast get cache with `get` concat. */
  }, {
    key: "opUpdate",
    value: /* @__PURE__ */ __name(function(keyPathStr, valueFn) {
      var prevValue = this.cache.get(keyPathStr), nextValue = valueFn(prevValue);
      nextValue === null ? this.cache.delete(keyPathStr) : this.cache.set(keyPathStr, nextValue);
    }, "opUpdate")
  }]), Entity2;
}(), ATTR_TOKEN = "data-token-hash", ATTR_MARK = "data-css-hash", ATTR_CACHE_PATH = "data-cache-path", CSS_IN_JS_INSTANCE = "__cssinjs_instance__";
function createCache() {
  var cssinjsInstanceId = Math.random().toString(12).slice(2);
  if (typeof document < "u" && document.head && document.body) {
    var styles2 = document.body.querySelectorAll("style[".concat(ATTR_MARK, "]")) || [], firstChild = document.head.firstChild;
    Array.from(styles2).forEach(function(style2) {
      style2[CSS_IN_JS_INSTANCE] = style2[CSS_IN_JS_INSTANCE] || cssinjsInstanceId, style2[CSS_IN_JS_INSTANCE] === cssinjsInstanceId && document.head.insertBefore(style2, firstChild);
    });
    var styleHash = {};
    Array.from(document.querySelectorAll("style[".concat(ATTR_MARK, "]"))).forEach(function(style2) {
      var hash = style2.getAttribute(ATTR_MARK);
      if (styleHash[hash]) {
        if (style2[CSS_IN_JS_INSTANCE] === cssinjsInstanceId) {
          var _style$parentNode;
          (_style$parentNode = style2.parentNode) === null || _style$parentNode === void 0 || _style$parentNode.removeChild(style2);
        }
      } else
        styleHash[hash] = !0;
    });
  }
  return new Entity(cssinjsInstanceId);
}
__name(createCache, "createCache");
var StyleContext = /* @__PURE__ */ React.createContext({
  hashPriority: "low",
  cache: createCache(),
  defaultCache: !0
});
function sameDerivativeOption(left, right) {
  if (left.length !== right.length)
    return !1;
  for (var i = 0; i < left.length; i++)
    if (left[i] !== right[i])
      return !1;
  return !0;
}
__name(sameDerivativeOption, "sameDerivativeOption");
var ThemeCache = /* @__PURE__ */ function() {
  function ThemeCache2() {
    _classCallCheck$1(this, ThemeCache2), _defineProperty$2(this, "cache", void 0), _defineProperty$2(this, "keys", void 0), _defineProperty$2(this, "cacheCallTimes", void 0), this.cache = /* @__PURE__ */ new Map(), this.keys = [], this.cacheCallTimes = 0;
  }
  return __name(ThemeCache2, "ThemeCache"), _createClass$1(ThemeCache2, [{
    key: "size",
    value: /* @__PURE__ */ __name(function() {
      return this.keys.length;
    }, "size")
  }, {
    key: "internalGet",
    value: /* @__PURE__ */ __name(function(derivativeOption) {
      var _cache2, _cache3, updateCallTimes = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1, cache = {
        map: this.cache
      };
      return derivativeOption.forEach(function(derivative2) {
        if (!cache)
          cache = void 0;
        else {
          var _cache;
          cache = (_cache = cache) === null || _cache === void 0 || (_cache = _cache.map) === null || _cache === void 0 ? void 0 : _cache.get(derivative2);
        }
      }), (_cache2 = cache) !== null && _cache2 !== void 0 && _cache2.value && updateCallTimes && (cache.value[1] = this.cacheCallTimes++), (_cache3 = cache) === null || _cache3 === void 0 ? void 0 : _cache3.value;
    }, "internalGet")
  }, {
    key: "get",
    value: /* @__PURE__ */ __name(function(derivativeOption) {
      var _this$internalGet;
      return (_this$internalGet = this.internalGet(derivativeOption, !0)) === null || _this$internalGet === void 0 ? void 0 : _this$internalGet[0];
    }, "get")
  }, {
    key: "has",
    value: /* @__PURE__ */ __name(function(derivativeOption) {
      return !!this.internalGet(derivativeOption);
    }, "has")
  }, {
    key: "set",
    value: /* @__PURE__ */ __name(function(derivativeOption, value) {
      var _this = this;
      if (!this.has(derivativeOption)) {
        if (this.size() + 1 > ThemeCache2.MAX_CACHE_SIZE + ThemeCache2.MAX_CACHE_OFFSET) {
          var _this$keys$reduce = this.keys.reduce(function(result, key) {
            var _result = _slicedToArray(result, 2), callTimes = _result[1];
            return _this.internalGet(key)[1] < callTimes ? [key, _this.internalGet(key)[1]] : result;
          }, [this.keys[0], this.cacheCallTimes]), _this$keys$reduce2 = _slicedToArray(_this$keys$reduce, 1), targetKey = _this$keys$reduce2[0];
          this.delete(targetKey);
        }
        this.keys.push(derivativeOption);
      }
      var cache = this.cache;
      derivativeOption.forEach(function(derivative2, index2) {
        if (index2 === derivativeOption.length - 1)
          cache.set(derivative2, {
            value: [value, _this.cacheCallTimes++]
          });
        else {
          var cacheValue = cache.get(derivative2);
          cacheValue ? cacheValue.map || (cacheValue.map = /* @__PURE__ */ new Map()) : cache.set(derivative2, {
            map: /* @__PURE__ */ new Map()
          }), cache = cache.get(derivative2).map;
        }
      });
    }, "set")
  }, {
    key: "deleteByPath",
    value: /* @__PURE__ */ __name(function(currentCache, derivatives) {
      var cache = currentCache.get(derivatives[0]);
      if (derivatives.length === 1) {
        var _cache$value;
        return cache.map ? currentCache.set(derivatives[0], {
          map: cache.map
        }) : currentCache.delete(derivatives[0]), (_cache$value = cache.value) === null || _cache$value === void 0 ? void 0 : _cache$value[0];
      }
      var result = this.deleteByPath(cache.map, derivatives.slice(1));
      return (!cache.map || cache.map.size === 0) && !cache.value && currentCache.delete(derivatives[0]), result;
    }, "deleteByPath")
  }, {
    key: "delete",
    value: /* @__PURE__ */ __name(function(derivativeOption) {
      if (this.has(derivativeOption))
        return this.keys = this.keys.filter(function(item) {
          return !sameDerivativeOption(item, derivativeOption);
        }), this.deleteByPath(this.cache, derivativeOption);
    }, "_delete")
  }]), ThemeCache2;
}();
_defineProperty$2(ThemeCache, "MAX_CACHE_SIZE", 20);
_defineProperty$2(ThemeCache, "MAX_CACHE_OFFSET", 5);
var uuid$5 = 0, Theme = /* @__PURE__ */ function() {
  function Theme2(derivatives) {
    _classCallCheck$1(this, Theme2), _defineProperty$2(this, "derivatives", void 0), _defineProperty$2(this, "id", void 0), this.derivatives = Array.isArray(derivatives) ? derivatives : [derivatives], this.id = uuid$5, derivatives.length === 0 && warning$3(derivatives.length > 0, "[Ant Design CSS-in-JS] Theme should have at least one derivative function."), uuid$5 += 1;
  }
  return __name(Theme2, "Theme"), _createClass$1(Theme2, [{
    key: "getDerivativeToken",
    value: /* @__PURE__ */ __name(function(token2) {
      return this.derivatives.reduce(function(result, derivative2) {
        return derivative2(token2, result);
      }, void 0);
    }, "getDerivativeToken")
  }]), Theme2;
}(), cacheThemes = new ThemeCache();
function createTheme(derivatives) {
  var derivativeArr = Array.isArray(derivatives) ? derivatives : [derivatives];
  return cacheThemes.has(derivativeArr) || cacheThemes.set(derivativeArr, new Theme(derivativeArr)), cacheThemes.get(derivativeArr);
}
__name(createTheme, "createTheme");
var resultCache = /* @__PURE__ */ new WeakMap(), RESULT_VALUE = {};
function memoResult(callback, deps) {
  for (var current = resultCache, i = 0; i < deps.length; i += 1) {
    var dep = deps[i];
    current.has(dep) || current.set(dep, /* @__PURE__ */ new WeakMap()), current = current.get(dep);
  }
  return current.has(RESULT_VALUE) || current.set(RESULT_VALUE, callback()), current.get(RESULT_VALUE);
}
__name(memoResult, "memoResult");
var flattenTokenCache = /* @__PURE__ */ new WeakMap();
function flattenToken(token2) {
  var str = flattenTokenCache.get(token2) || "";
  return str || (Object.keys(token2).forEach(function(key) {
    var value = token2[key];
    str += key, value instanceof Theme ? str += value.id : value && _typeof$4(value) === "object" ? str += flattenToken(value) : str += value;
  }), str = murmur2(str), flattenTokenCache.set(token2, str)), str;
}
__name(flattenToken, "flattenToken");
function token2key(token2, salt) {
  return murmur2("".concat(salt, "_").concat(flattenToken(token2)));
}
__name(token2key, "token2key");
var isClientSide = canUseDom();
function unit$1(num) {
  return typeof num == "number" ? "".concat(num, "px") : num;
}
__name(unit$1, "unit$1");
function toStyleStr(style2, tokenKey, styleId) {
  var _objectSpread22, customizeAttrs = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {}, plain = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : !1;
  if (plain)
    return style2;
  var attrs = _objectSpread2$1(_objectSpread2$1({}, customizeAttrs), {}, (_objectSpread22 = {}, _defineProperty$2(_objectSpread22, ATTR_TOKEN, tokenKey), _defineProperty$2(_objectSpread22, ATTR_MARK, styleId), _objectSpread22)), attrStr = Object.keys(attrs).map(function(attr) {
    var val = attrs[attr];
    return val ? "".concat(attr, '="').concat(val, '"') : null;
  }).filter(function(v) {
    return v;
  }).join(" ");
  return "<style ".concat(attrStr, ">").concat(style2, "</style>");
}
__name(toStyleStr, "toStyleStr");
var token2CSSVar = /* @__PURE__ */ __name(function(token2) {
  var prefix = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
  return "--".concat(prefix ? "".concat(prefix, "-") : "").concat(token2).replace(/([a-z0-9])([A-Z])/g, "$1-$2").replace(/([A-Z]+)([A-Z][a-z0-9]+)/g, "$1-$2").replace(/([a-z])([A-Z0-9])/g, "$1-$2").toLowerCase();
}, "token2CSSVar"), serializeCSSVar = /* @__PURE__ */ __name(function(cssVars, hashId, options) {
  return Object.keys(cssVars).length ? ".".concat(hashId).concat(options != null && options.scope ? ".".concat(options.scope) : "", "{").concat(Object.entries(cssVars).map(function(_ref) {
    var _ref2 = _slicedToArray(_ref, 2), key = _ref2[0], value = _ref2[1];
    return "".concat(key, ":").concat(value, ";");
  }).join(""), "}") : "";
}, "serializeCSSVar"), transformToken = /* @__PURE__ */ __name(function(token2, themeKey, config) {
  var cssVars = {}, result = {};
  return Object.entries(token2).forEach(function(_ref3) {
    var _config$preserve, _config$ignore, _ref4 = _slicedToArray(_ref3, 2), key = _ref4[0], value = _ref4[1];
    if (config != null && (_config$preserve = config.preserve) !== null && _config$preserve !== void 0 && _config$preserve[key])
      result[key] = value;
    else if ((typeof value == "string" || typeof value == "number") && !(config != null && (_config$ignore = config.ignore) !== null && _config$ignore !== void 0 && _config$ignore[key])) {
      var _config$unitless, cssVar = token2CSSVar(key, config == null ? void 0 : config.prefix);
      cssVars[cssVar] = typeof value == "number" && !(config != null && (_config$unitless = config.unitless) !== null && _config$unitless !== void 0 && _config$unitless[key]) ? "".concat(value, "px") : String(value), result[key] = "var(".concat(cssVar, ")");
    }
  }), [result, serializeCSSVar(cssVars, themeKey, {
    scope: config == null ? void 0 : config.scope
  })];
}, "transformToken"), useInternalLayoutEffect = process.env.NODE_ENV !== "test" && canUseDom() ? React.useLayoutEffect : React.useEffect, useLayoutEffect$1 = /* @__PURE__ */ __name(function(callback, deps) {
  var firstMountRef = React.useRef(!0);
  useInternalLayoutEffect(function() {
    return callback(firstMountRef.current);
  }, deps), useInternalLayoutEffect(function() {
    return firstMountRef.current = !1, function() {
      firstMountRef.current = !0;
    };
  }, []);
}, "useLayoutEffect"), useLayoutUpdateEffect = /* @__PURE__ */ __name(function(callback, deps) {
  useLayoutEffect$1(function(firstMount) {
    if (!firstMount)
      return callback();
  }, deps);
}, "useLayoutUpdateEffect"), fullClone$3 = _objectSpread2$1({}, React), useInsertionEffect$1 = fullClone$3.useInsertionEffect, useInsertionEffectPolyfill = /* @__PURE__ */ __name(function(renderEffect, effect, deps) {
  React.useMemo(renderEffect, deps), useLayoutEffect$1(function() {
    return effect(!0);
  }, deps);
}, "useInsertionEffectPolyfill"), useCompatibleInsertionEffect = useInsertionEffect$1 ? function(renderEffect, effect, deps) {
  return useInsertionEffect$1(function() {
    return renderEffect(), effect();
  }, deps);
} : useInsertionEffectPolyfill, fullClone$2 = _objectSpread2$1({}, React), useInsertionEffect = fullClone$2.useInsertionEffect, useCleanupRegister = /* @__PURE__ */ __name(function(deps) {
  var effectCleanups = [], cleanupFlag = !1;
  function register2(fn) {
    if (cleanupFlag) {
      process.env.NODE_ENV !== "production" && warning$3(!1, "[Ant Design CSS-in-JS] You are registering a cleanup function after unmount, which will not have any effect.");
      return;
    }
    effectCleanups.push(fn);
  }
  return __name(register2, "register"), React.useEffect(function() {
    return cleanupFlag = !1, function() {
      cleanupFlag = !0, effectCleanups.length && effectCleanups.forEach(function(fn) {
        return fn();
      });
    };
  }, deps), register2;
}, "useCleanupRegister"), useRun = /* @__PURE__ */ __name(function() {
  return function(fn) {
    fn();
  };
}, "useRun"), useEffectCleanupRegister = typeof useInsertionEffect < "u" ? useCleanupRegister : useRun;
function useProdHMR() {
  return !1;
}
__name(useProdHMR, "useProdHMR");
var webpackHMR = !1;
function useDevHMR() {
  return webpackHMR;
}
__name(useDevHMR, "useDevHMR");
const useHMR = process.env.NODE_ENV === "production" ? useProdHMR : useDevHMR;
if (process.env.NODE_ENV !== "production" && typeof module < "u" && module && module.hot && typeof window < "u") {
  var win = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : null;
  if (win && typeof win.webpackHotUpdate == "function") {
    var originWebpackHotUpdate = win.webpackHotUpdate;
    win.webpackHotUpdate = function() {
      return webpackHMR = !0, setTimeout(function() {
        webpackHMR = !1;
      }, 0), originWebpackHotUpdate.apply(void 0, arguments);
    };
  }
}
function useGlobalCache(prefix, keyPath, cacheFn, onCacheRemove, onCacheEffect) {
  var _React$useContext = React.useContext(StyleContext), globalCache = _React$useContext.cache, fullPath = [prefix].concat(_toConsumableArray(keyPath)), fullPathStr = pathKey(fullPath), register2 = useEffectCleanupRegister([fullPathStr]), HMRUpdate = useHMR(), buildCache = /* @__PURE__ */ __name(function(updater) {
    globalCache.opUpdate(fullPathStr, function(prevCache) {
      var _ref = prevCache || [void 0, void 0], _ref2 = _slicedToArray(_ref, 2), _ref2$ = _ref2[0], times = _ref2$ === void 0 ? 0 : _ref2$, cache = _ref2[1], tmpCache = cache;
      process.env.NODE_ENV !== "production" && cache && HMRUpdate && (onCacheRemove == null || onCacheRemove(tmpCache, HMRUpdate), tmpCache = null);
      var mergedCache = tmpCache || cacheFn(), data = [times, mergedCache];
      return updater ? updater(data) : data;
    });
  }, "buildCache");
  React.useMemo(
    function() {
      buildCache();
    },
    /* eslint-disable react-hooks/exhaustive-deps */
    [fullPathStr]
    /* eslint-enable */
  );
  var cacheEntity = globalCache.opGet(fullPathStr);
  process.env.NODE_ENV !== "production" && !cacheEntity && (buildCache(), cacheEntity = globalCache.opGet(fullPathStr));
  var cacheContent = cacheEntity[1];
  return useCompatibleInsertionEffect(function() {
    onCacheEffect == null || onCacheEffect(cacheContent);
  }, function(polyfill) {
    return buildCache(function(_ref3) {
      var _ref4 = _slicedToArray(_ref3, 2), times = _ref4[0], cache = _ref4[1];
      return polyfill && times === 0 && (onCacheEffect == null || onCacheEffect(cacheContent)), [times + 1, cache];
    }), function() {
      globalCache.opUpdate(fullPathStr, function(prevCache) {
        var _ref5 = prevCache || [], _ref6 = _slicedToArray(_ref5, 2), _ref6$ = _ref6[0], times = _ref6$ === void 0 ? 0 : _ref6$, cache = _ref6[1], nextCount = times - 1;
        return nextCount === 0 ? (register2(function() {
          (polyfill || !globalCache.opGet(fullPathStr)) && (onCacheRemove == null || onCacheRemove(cache, !1));
        }), null) : [times - 1, cache];
      });
    };
  }, [fullPathStr]), cacheContent;
}
__name(useGlobalCache, "useGlobalCache");
var EMPTY_OVERRIDE = {}, hashPrefix = process.env.NODE_ENV !== "production" ? "css-dev-only-do-not-override" : "css", tokenKeys = /* @__PURE__ */ new Map();
function recordCleanToken(tokenKey) {
  tokenKeys.set(tokenKey, (tokenKeys.get(tokenKey) || 0) + 1);
}
__name(recordCleanToken, "recordCleanToken");
function removeStyleTags(key, instanceId) {
  if (typeof document < "u") {
    var styles2 = document.querySelectorAll("style[".concat(ATTR_TOKEN, '="').concat(key, '"]'));
    styles2.forEach(function(style2) {
      if (style2[CSS_IN_JS_INSTANCE] === instanceId) {
        var _style$parentNode;
        (_style$parentNode = style2.parentNode) === null || _style$parentNode === void 0 || _style$parentNode.removeChild(style2);
      }
    });
  }
}
__name(removeStyleTags, "removeStyleTags");
var TOKEN_THRESHOLD = 0;
function cleanTokenStyle(tokenKey, instanceId) {
  tokenKeys.set(tokenKey, (tokenKeys.get(tokenKey) || 0) - 1);
  var tokenKeyList = Array.from(tokenKeys.keys()), cleanableKeyList = tokenKeyList.filter(function(key) {
    var count = tokenKeys.get(key) || 0;
    return count <= 0;
  });
  tokenKeyList.length - cleanableKeyList.length > TOKEN_THRESHOLD && cleanableKeyList.forEach(function(key) {
    removeStyleTags(key, instanceId), tokenKeys.delete(key);
  });
}
__name(cleanTokenStyle, "cleanTokenStyle");
var getComputedToken$1 = /* @__PURE__ */ __name(function(originToken, overrideToken, theme2, format3) {
  var derivativeToken = theme2.getDerivativeToken(originToken), mergedDerivativeToken = _objectSpread2$1(_objectSpread2$1({}, derivativeToken), overrideToken);
  return format3 && (mergedDerivativeToken = format3(mergedDerivativeToken)), mergedDerivativeToken;
}, "getComputedToken"), TOKEN_PREFIX = "token";
function useCacheToken(theme2, tokens) {
  var option = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, _useContext = useContext$1(StyleContext), instanceId = _useContext.cache.instanceId, container2 = _useContext.container, _option$salt = option.salt, salt = _option$salt === void 0 ? "" : _option$salt, _option$override = option.override, override = _option$override === void 0 ? EMPTY_OVERRIDE : _option$override, formatToken2 = option.formatToken, compute = option.getComputedToken, cssVar = option.cssVar, mergedToken = memoResult(function() {
    return Object.assign.apply(Object, [{}].concat(_toConsumableArray(tokens)));
  }, tokens), tokenStr = flattenToken(mergedToken), overrideTokenStr = flattenToken(override), cssVarStr = cssVar ? flattenToken(cssVar) : "", cachedToken = useGlobalCache(TOKEN_PREFIX, [salt, theme2.id, tokenStr, overrideTokenStr, cssVarStr], function() {
    var _cssVar$key, mergedDerivativeToken = compute ? compute(mergedToken, override, theme2) : getComputedToken$1(mergedToken, override, theme2, formatToken2), actualToken = _objectSpread2$1({}, mergedDerivativeToken), cssVarsStr = "";
    if (cssVar) {
      var _transformToken = transformToken(mergedDerivativeToken, cssVar.key, {
        prefix: cssVar.prefix,
        ignore: cssVar.ignore,
        unitless: cssVar.unitless,
        preserve: cssVar.preserve
      }), _transformToken2 = _slicedToArray(_transformToken, 2);
      mergedDerivativeToken = _transformToken2[0], cssVarsStr = _transformToken2[1];
    }
    var tokenKey = token2key(mergedDerivativeToken, salt);
    mergedDerivativeToken._tokenKey = tokenKey, actualToken._tokenKey = token2key(actualToken, salt);
    var themeKey = (_cssVar$key = cssVar == null ? void 0 : cssVar.key) !== null && _cssVar$key !== void 0 ? _cssVar$key : tokenKey;
    mergedDerivativeToken._themeKey = themeKey, recordCleanToken(themeKey);
    var hashId = "".concat(hashPrefix, "-").concat(murmur2(tokenKey));
    return mergedDerivativeToken._hashId = hashId, [mergedDerivativeToken, hashId, actualToken, cssVarsStr, (cssVar == null ? void 0 : cssVar.key) || ""];
  }, function(cache) {
    cleanTokenStyle(cache[0]._themeKey, instanceId);
  }, function(_ref) {
    var _ref2 = _slicedToArray(_ref, 4), token2 = _ref2[0], cssVarsStr = _ref2[3];
    if (cssVar && cssVarsStr) {
      var style2 = updateCSS(cssVarsStr, murmur2("css-variables-".concat(token2._themeKey)), {
        mark: ATTR_MARK,
        prepend: "queue",
        attachTo: container2,
        priority: -999
      });
      style2[CSS_IN_JS_INSTANCE] = instanceId, style2.setAttribute(ATTR_TOKEN, token2._themeKey);
    }
  });
  return cachedToken;
}
__name(useCacheToken, "useCacheToken");
var extract$2 = /* @__PURE__ */ __name(function(cache, effectStyles, options) {
  var _cache = _slicedToArray(cache, 5), realToken = _cache[2], styleStr = _cache[3], cssVarKey = _cache[4], _ref3 = options || {}, plain = _ref3.plain;
  if (!styleStr)
    return null;
  var styleId = realToken._tokenKey, order2 = -999, sharedAttrs = {
    "data-rc-order": "prependQueue",
    "data-rc-priority": "".concat(order2)
  }, styleText = toStyleStr(styleStr, cssVarKey, styleId, sharedAttrs, plain);
  return [order2, styleId, styleText];
}, "extract"), unitlessKeys = {
  animationIterationCount: 1,
  borderImageOutset: 1,
  borderImageSlice: 1,
  borderImageWidth: 1,
  boxFlex: 1,
  boxFlexGroup: 1,
  boxOrdinalGroup: 1,
  columnCount: 1,
  columns: 1,
  flex: 1,
  flexGrow: 1,
  flexPositive: 1,
  flexShrink: 1,
  flexNegative: 1,
  flexOrder: 1,
  gridRow: 1,
  gridRowEnd: 1,
  gridRowSpan: 1,
  gridRowStart: 1,
  gridColumn: 1,
  gridColumnEnd: 1,
  gridColumnSpan: 1,
  gridColumnStart: 1,
  msGridRow: 1,
  msGridRowSpan: 1,
  msGridColumn: 1,
  msGridColumnSpan: 1,
  fontWeight: 1,
  lineHeight: 1,
  opacity: 1,
  order: 1,
  orphans: 1,
  tabSize: 1,
  widows: 1,
  zIndex: 1,
  zoom: 1,
  WebkitLineClamp: 1,
  // SVG-related properties
  fillOpacity: 1,
  floodOpacity: 1,
  stopOpacity: 1,
  strokeDasharray: 1,
  strokeDashoffset: 1,
  strokeMiterlimit: 1,
  strokeOpacity: 1,
  strokeWidth: 1
}, COMMENT = "comm", RULESET = "rule", DECLARATION = "decl", IMPORT = "@import", NAMESPACE = "@namespace", KEYFRAMES = "@keyframes", LAYER = "@layer", abs = Math.abs, from = String.fromCharCode;
function trim(value) {
  return value.trim();
}
__name(trim, "trim");
function replace(value, pattern4, replacement) {
  return value.replace(pattern4, replacement);
}
__name(replace, "replace");
function indexof(value, search, position2) {
  return value.indexOf(search, position2);
}
__name(indexof, "indexof");
function charat(value, index2) {
  return value.charCodeAt(index2) | 0;
}
__name(charat, "charat");
function substr(value, begin, end) {
  return value.slice(begin, end);
}
__name(substr, "substr");
function strlen(value) {
  return value.length;
}
__name(strlen, "strlen");
function sizeof(value) {
  return value.length;
}
__name(sizeof, "sizeof");
function append(value, array4) {
  return array4.push(value), value;
}
__name(append, "append");
var line = 1, column = 1, length = 0, position$1 = 0, character = 0, characters = "";
function node(value, root, parent, type4, props, children, length2, siblings) {
  return { value, root, parent, type: type4, props, children, line, column, length: length2, return: "", siblings };
}
__name(node, "node");
function char() {
  return character;
}
__name(char, "char");
function prev() {
  return character = position$1 > 0 ? charat(characters, --position$1) : 0, column--, character === 10 && (column = 1, line--), character;
}
__name(prev, "prev");
function next() {
  return character = position$1 < length ? charat(characters, position$1++) : 0, column++, character === 10 && (column = 1, line++), character;
}
__name(next, "next");
function peek() {
  return charat(characters, position$1);
}
__name(peek, "peek");
function caret() {
  return position$1;
}
__name(caret, "caret");
function slice$1(begin, end) {
  return substr(characters, begin, end);
}
__name(slice$1, "slice$1");
function token$1(type4) {
  switch (type4) {
    case 0:
    case 9:
    case 10:
    case 13:
    case 32:
      return 5;
    case 33:
    case 43:
    case 44:
    case 47:
    case 62:
    case 64:
    case 126:
    case 59:
    case 123:
    case 125:
      return 4;
    case 58:
      return 3;
    case 34:
    case 39:
    case 40:
    case 91:
      return 2;
    case 41:
    case 93:
      return 1;
  }
  return 0;
}
__name(token$1, "token$1");
function alloc(value) {
  return line = column = 1, length = strlen(characters = value), position$1 = 0, [];
}
__name(alloc, "alloc");
function dealloc(value) {
  return characters = "", value;
}
__name(dealloc, "dealloc");
function delimit(type4) {
  return trim(slice$1(position$1 - 1, delimiter(type4 === 91 ? type4 + 2 : type4 === 40 ? type4 + 1 : type4)));
}
__name(delimit, "delimit");
function whitespace$1(type4) {
  for (; (character = peek()) && character < 33; )
    next();
  return token$1(type4) > 2 || token$1(character) > 3 ? "" : " ";
}
__name(whitespace$1, "whitespace$1");
function escaping(index2, count) {
  for (; --count && next() && !(character < 48 || character > 102 || character > 57 && character < 65 || character > 70 && character < 97); )
    ;
  return slice$1(index2, caret() + (count < 6 && peek() == 32 && next() == 32));
}
__name(escaping, "escaping");
function delimiter(type4) {
  for (; next(); )
    switch (character) {
      case type4:
        return position$1;
      case 34:
      case 39:
        type4 !== 34 && type4 !== 39 && delimiter(character);
        break;
      case 40:
        type4 === 41 && delimiter(type4);
        break;
      case 92:
        next();
        break;
    }
  return position$1;
}
__name(delimiter, "delimiter");
function commenter(type4, index2) {
  for (; next() && type4 + character !== 57; )
    if (type4 + character === 84 && peek() === 47)
      break;
  return "/*" + slice$1(index2, position$1 - 1) + "*" + from(type4 === 47 ? type4 : next());
}
__name(commenter, "commenter");
function identifier(index2) {
  for (; !token$1(peek()); )
    next();
  return slice$1(index2, position$1);
}
__name(identifier, "identifier");
function compile(value) {
  return dealloc(parse("", null, null, null, [""], value = alloc(value), 0, [0], value));
}
__name(compile, "compile");
function parse(value, root, parent, rule, rules2, rulesets, pseudo, points, declarations) {
  for (var index2 = 0, offset2 = 0, length2 = pseudo, atrule = 0, property = 0, previous = 0, variable = 1, scanning = 1, ampersand = 1, character2 = 0, type4 = "", props = rules2, children = rulesets, reference = rule, characters2 = type4; scanning; )
    switch (previous = character2, character2 = next()) {
      case 40:
        if (previous != 108 && charat(characters2, length2 - 1) == 58) {
          indexof(characters2 += replace(delimit(character2), "&", "&\f"), "&\f", abs(index2 ? points[index2 - 1] : 0)) != -1 && (ampersand = -1);
          break;
        }
      case 34:
      case 39:
      case 91:
        characters2 += delimit(character2);
        break;
      case 9:
      case 10:
      case 13:
      case 32:
        characters2 += whitespace$1(previous);
        break;
      case 92:
        characters2 += escaping(caret() - 1, 7);
        continue;
      case 47:
        switch (peek()) {
          case 42:
          case 47:
            append(comment(commenter(next(), caret()), root, parent, declarations), declarations), (token$1(previous || 1) == 5 || token$1(peek() || 1) == 5) && strlen(characters2) && substr(characters2, -1, void 0) !== " " && (characters2 += " ");
            break;
          default:
            characters2 += "/";
        }
        break;
      case 123 * variable:
        points[index2++] = strlen(characters2) * ampersand;
      case 125 * variable:
      case 59:
      case 0:
        switch (character2) {
          case 0:
          case 125:
            scanning = 0;
          case 59 + offset2:
            ampersand == -1 && (characters2 = replace(characters2, /\f/g, "")), property > 0 && (strlen(characters2) - length2 || variable === 0 && previous === 47) && append(property > 32 ? declaration(characters2 + ";", rule, parent, length2 - 1, declarations) : declaration(replace(characters2, " ", "") + ";", rule, parent, length2 - 2, declarations), declarations);
            break;
          case 59:
            characters2 += ";";
          default:
            if (append(reference = ruleset(characters2, root, parent, index2, offset2, rules2, points, type4, props = [], children = [], length2, rulesets), rulesets), character2 === 123)
              if (offset2 === 0)
                parse(characters2, root, reference, reference, props, rulesets, length2, points, children);
              else {
                switch (atrule) {
                  case 99:
                    if (charat(characters2, 3) === 110) break;
                  case 108:
                    if (charat(characters2, 2) === 97) break;
                  default:
                    offset2 = 0;
                  case 100:
                  case 109:
                  case 115:
                }
                offset2 ? parse(value, reference, reference, rule && append(ruleset(value, reference, reference, 0, 0, rules2, points, type4, rules2, props = [], length2, children), children), rules2, children, length2, points, rule ? props : children) : parse(characters2, reference, reference, reference, [""], children, 0, points, children);
              }
        }
        index2 = offset2 = property = 0, variable = ampersand = 1, type4 = characters2 = "", length2 = pseudo;
        break;
      case 58:
        length2 = 1 + strlen(characters2), property = previous;
      default:
        if (variable < 1) {
          if (character2 == 123)
            --variable;
          else if (character2 == 125 && variable++ == 0 && prev() == 125)
            continue;
        }
        switch (characters2 += from(character2), character2 * variable) {
          case 38:
            ampersand = offset2 > 0 ? 1 : (characters2 += "\f", -1);
            break;
          case 44:
            points[index2++] = (strlen(characters2) - 1) * ampersand, ampersand = 1;
            break;
          case 64:
            peek() === 45 && (characters2 += delimit(next())), atrule = peek(), offset2 = length2 = strlen(type4 = characters2 += identifier(caret())), character2++;
            break;
          case 45:
            previous === 45 && strlen(characters2) == 2 && (variable = 0);
        }
    }
  return rulesets;
}
__name(parse, "parse");
function ruleset(value, root, parent, index2, offset2, rules2, points, type4, props, children, length2, siblings) {
  for (var post = offset2 - 1, rule = offset2 === 0 ? rules2 : [""], size = sizeof(rule), i = 0, j = 0, k = 0; i < index2; ++i)
    for (var x = 0, y = substr(value, post + 1, post = abs(j = points[i])), z = value; x < size; ++x)
      (z = trim(j > 0 ? rule[x] + " " + y : replace(y, /&\f/g, rule[x]))) && (props[k++] = z);
  return node(value, root, parent, offset2 === 0 ? RULESET : type4, props, children, length2, siblings);
}
__name(ruleset, "ruleset");
function comment(value, root, parent, siblings) {
  return node(value, root, parent, COMMENT, from(char()), substr(value, 2, -2), 0, siblings);
}
__name(comment, "comment");
function declaration(value, root, parent, length2, siblings) {
  return node(value, root, parent, DECLARATION, substr(value, 0, length2), substr(value, length2 + 1, -1), length2, siblings);
}
__name(declaration, "declaration");
function serialize(children, callback) {
  for (var output = "", i = 0; i < children.length; i++)
    output += callback(children[i], i, children, callback) || "";
  return output;
}
__name(serialize, "serialize");
function stringify$2(element, index2, children, callback) {
  switch (element.type) {
    case LAYER:
      if (element.children.length) break;
    case IMPORT:
    case NAMESPACE:
    case DECLARATION:
      return element.return = element.return || element.value;
    case COMMENT:
      return "";
    case KEYFRAMES:
      return element.return = element.value + "{" + serialize(element.children, callback) + "}";
    case RULESET:
      if (!strlen(element.value = element.props.join(","))) return "";
  }
  return strlen(children = serialize(element.children, callback)) ? element.return = element.value + "{" + children + "}" : "";
}
__name(stringify$2, "stringify$2");
function lintWarning(message, info) {
  var path2 = info.path, parentSelectors = info.parentSelectors;
  warningOnce(!1, "[Ant Design CSS-in-JS] ".concat(path2 ? "Error in ".concat(path2, ": ") : "").concat(message).concat(parentSelectors.length ? " Selector: ".concat(parentSelectors.join(" | ")) : ""));
}
__name(lintWarning, "lintWarning");
var linter$1 = /* @__PURE__ */ __name(function(key, value, info) {
  if (key === "content") {
    var contentValuePattern = /(attr|counters?|url|(((repeating-)?(linear|radial))|conic)-gradient)\(|(no-)?(open|close)-quote/, contentValues = ["normal", "none", "initial", "inherit", "unset"];
    (typeof value != "string" || contentValues.indexOf(value) === -1 && !contentValuePattern.test(value) && (value.charAt(0) !== value.charAt(value.length - 1) || value.charAt(0) !== '"' && value.charAt(0) !== "'")) && lintWarning("You seem to be using a value for 'content' without quotes, try replacing it with `content: '\"".concat(value, "\"'`."), info);
  }
}, "linter"), linter2 = /* @__PURE__ */ __name(function(key, value, info) {
  key === "animation" && info.hashId && value !== "none" && lintWarning("You seem to be using hashed animation '".concat(value, "', in which case 'animationName' with Keyframe as value is recommended."), info);
}, "linter"), ATTR_CACHE_MAP = "data-ant-cssinjs-cache-path", CSS_FILE_STYLE = "_FILE_STYLE__", cachePathMap, fromCSSFile = !0;
function prepare() {
  if (!cachePathMap && (cachePathMap = {}, canUseDom())) {
    var div = document.createElement("div");
    div.className = ATTR_CACHE_MAP, div.style.position = "fixed", div.style.visibility = "hidden", div.style.top = "-9999px", document.body.appendChild(div);
    var content = getComputedStyle(div).content || "";
    content = content.replace(/^"/, "").replace(/"$/, ""), content.split(";").forEach(function(item) {
      var _item$split = item.split(":"), _item$split2 = _slicedToArray(_item$split, 2), path2 = _item$split2[0], hash = _item$split2[1];
      cachePathMap[path2] = hash;
    });
    var inlineMapStyle = document.querySelector("style[".concat(ATTR_CACHE_MAP, "]"));
    if (inlineMapStyle) {
      var _inlineMapStyle$paren;
      fromCSSFile = !1, (_inlineMapStyle$paren = inlineMapStyle.parentNode) === null || _inlineMapStyle$paren === void 0 || _inlineMapStyle$paren.removeChild(inlineMapStyle);
    }
    document.body.removeChild(div);
  }
}
__name(prepare, "prepare");
function existPath(path2) {
  return prepare(), !!cachePathMap[path2];
}
__name(existPath, "existPath");
function getStyleAndHash(path2) {
  var hash = cachePathMap[path2], styleStr = null;
  if (hash && canUseDom())
    if (fromCSSFile)
      styleStr = CSS_FILE_STYLE;
    else {
      var _style = document.querySelector("style[".concat(ATTR_MARK, '="').concat(cachePathMap[path2], '"]'));
      _style ? styleStr = _style.innerHTML : delete cachePathMap[path2];
    }
  return [styleStr, hash];
}
__name(getStyleAndHash, "getStyleAndHash");
var SKIP_CHECK = "_skip_check_", MULTI_VALUE = "_multi_value_";
function normalizeStyle(styleStr) {
  var serialized = serialize(compile(styleStr), stringify$2);
  return serialized.replace(/\{%%%\:[^;];}/g, ";");
}
__name(normalizeStyle, "normalizeStyle");
function isCompoundCSSProperty(value) {
  return _typeof$4(value) === "object" && value && (SKIP_CHECK in value || MULTI_VALUE in value);
}
__name(isCompoundCSSProperty, "isCompoundCSSProperty");
function injectSelectorHash(key, hashId, hashPriority) {
  if (!hashId)
    return key;
  var hashClassName = ".".concat(hashId), hashSelector = hashPriority === "low" ? ":where(".concat(hashClassName, ")") : hashClassName, keys2 = key.split(",").map(function(k) {
    var _firstPath$match, fullPath = k.trim().split(/\s+/), firstPath = fullPath[0] || "", htmlElement = ((_firstPath$match = firstPath.match(/^\w+/)) === null || _firstPath$match === void 0 ? void 0 : _firstPath$match[0]) || "";
    return firstPath = "".concat(htmlElement).concat(hashSelector).concat(firstPath.slice(htmlElement.length)), [firstPath].concat(_toConsumableArray(fullPath.slice(1))).join(" ");
  });
  return keys2.join(",");
}
__name(injectSelectorHash, "injectSelectorHash");
var parseStyle = /* @__PURE__ */ __name(function parseStyle2(interpolation) {
  var config = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, _ref = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {
    root: !0,
    parentSelectors: []
  }, root = _ref.root, injectHash = _ref.injectHash, parentSelectors = _ref.parentSelectors, hashId = config.hashId, layer = config.layer, path2 = config.path, hashPriority = config.hashPriority, _config$transformers = config.transformers, transformers = _config$transformers === void 0 ? [] : _config$transformers, _config$linters = config.linters, linters = _config$linters === void 0 ? [] : _config$linters, styleStr = "", effectStyle = {};
  function parseKeyframes(keyframes) {
    var animationName = keyframes.getName(hashId);
    if (!effectStyle[animationName]) {
      var _parseStyle = parseStyle2(keyframes.style, config, {
        root: !1,
        parentSelectors
      }), _parseStyle2 = _slicedToArray(_parseStyle, 1), _parsedStr = _parseStyle2[0];
      effectStyle[animationName] = "@keyframes ".concat(keyframes.getName(hashId)).concat(_parsedStr);
    }
  }
  __name(parseKeyframes, "parseKeyframes");
  function flattenList(list) {
    var fullList = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
    return list.forEach(function(item) {
      Array.isArray(item) ? flattenList(item, fullList) : item && fullList.push(item);
    }), fullList;
  }
  __name(flattenList, "flattenList");
  var flattenStyleList = flattenList(Array.isArray(interpolation) ? interpolation : [interpolation]);
  return flattenStyleList.forEach(function(originStyle) {
    var style2 = typeof originStyle == "string" && !root ? {} : originStyle;
    if (typeof style2 == "string")
      styleStr += "".concat(style2, `
`);
    else if (style2._keyframe)
      parseKeyframes(style2);
    else {
      var mergedStyle = transformers.reduce(function(prev2, trans) {
        var _trans$visit;
        return (trans == null || (_trans$visit = trans.visit) === null || _trans$visit === void 0 ? void 0 : _trans$visit.call(trans, prev2)) || prev2;
      }, style2);
      Object.keys(mergedStyle).forEach(function(key) {
        var value = mergedStyle[key];
        if (_typeof$4(value) === "object" && value && (key !== "animationName" || !value._keyframe) && !isCompoundCSSProperty(value)) {
          var subInjectHash = !1, mergedKey = key.trim(), nextRoot = !1;
          (root || injectHash) && hashId ? mergedKey.startsWith("@") ? subInjectHash = !0 : mergedKey === "&" ? mergedKey = injectSelectorHash("", hashId, hashPriority) : mergedKey = injectSelectorHash(key, hashId, hashPriority) : root && !hashId && (mergedKey === "&" || mergedKey === "") && (mergedKey = "", nextRoot = !0);
          var _parseStyle3 = parseStyle2(value, config, {
            root: nextRoot,
            injectHash: subInjectHash,
            parentSelectors: [].concat(_toConsumableArray(parentSelectors), [mergedKey])
          }), _parseStyle4 = _slicedToArray(_parseStyle3, 2), _parsedStr2 = _parseStyle4[0], childEffectStyle = _parseStyle4[1];
          effectStyle = _objectSpread2$1(_objectSpread2$1({}, effectStyle), childEffectStyle), styleStr += "".concat(mergedKey).concat(_parsedStr2);
        } else {
          let appendStyle = function(cssKey, cssValue) {
            process.env.NODE_ENV !== "production" && (_typeof$4(value) !== "object" || !(value != null && value[SKIP_CHECK])) && [linter$1, linter2].concat(_toConsumableArray(linters)).forEach(function(linter4) {
              return linter4(cssKey, cssValue, {
                path: path2,
                hashId,
                parentSelectors
              });
            });
            var styleName = cssKey.replace(/[A-Z]/g, function(match2) {
              return "-".concat(match2.toLowerCase());
            }), formatValue2 = cssValue;
            !unitlessKeys[cssKey] && typeof formatValue2 == "number" && formatValue2 !== 0 && (formatValue2 = "".concat(formatValue2, "px")), cssKey === "animationName" && cssValue !== null && cssValue !== void 0 && cssValue._keyframe && (parseKeyframes(cssValue), formatValue2 = cssValue.getName(hashId)), styleStr += "".concat(styleName, ":").concat(formatValue2, ";");
          };
          __name(appendStyle, "appendStyle");
          var _value, actualValue = (_value = value == null ? void 0 : value.value) !== null && _value !== void 0 ? _value : value;
          _typeof$4(value) === "object" && value !== null && value !== void 0 && value[MULTI_VALUE] && Array.isArray(actualValue) ? actualValue.forEach(function(item) {
            appendStyle(key, item);
          }) : appendStyle(key, actualValue);
        }
      });
    }
  }), root ? layer && (styleStr && (styleStr = "@layer ".concat(layer.name, " {").concat(styleStr, "}")), layer.dependencies && (effectStyle["@layer ".concat(layer.name)] = layer.dependencies.map(function(deps) {
    return "@layer ".concat(deps, ", ").concat(layer.name, ";");
  }).join(`
`))) : styleStr = "{".concat(styleStr, "}"), [styleStr, effectStyle];
}, "parseStyle");
function uniqueHash(path2, styleStr) {
  return murmur2("".concat(path2.join("%")).concat(styleStr));
}
__name(uniqueHash, "uniqueHash");
function Empty$3() {
  return null;
}
__name(Empty$3, "Empty$3");
var STYLE_PREFIX = "style";
function useStyleRegister(info, styleFn) {
  var token2 = info.token, path2 = info.path, hashId = info.hashId, layer = info.layer, nonce = info.nonce, clientOnly = info.clientOnly, _info$order = info.order, order2 = _info$order === void 0 ? 0 : _info$order, _React$useContext = React.useContext(StyleContext), autoClear = _React$useContext.autoClear, mock = _React$useContext.mock, defaultCache = _React$useContext.defaultCache, hashPriority = _React$useContext.hashPriority, container2 = _React$useContext.container, ssrInline = _React$useContext.ssrInline, transformers = _React$useContext.transformers, linters = _React$useContext.linters, cache = _React$useContext.cache, enableLayer = _React$useContext.layer, tokenKey = token2._tokenKey, fullPath = [tokenKey];
  enableLayer && fullPath.push("layer"), fullPath.push.apply(fullPath, _toConsumableArray(path2));
  var isMergedClientSide = isClientSide;
  process.env.NODE_ENV !== "production" && mock !== void 0 && (isMergedClientSide = mock === "client");
  var _useGlobalCache = useGlobalCache(
    STYLE_PREFIX,
    fullPath,
    // Create cache if needed
    function() {
      var cachePath = fullPath.join("|");
      if (existPath(cachePath)) {
        var _getStyleAndHash = getStyleAndHash(cachePath), _getStyleAndHash2 = _slicedToArray(_getStyleAndHash, 2), inlineCacheStyleStr = _getStyleAndHash2[0], styleHash = _getStyleAndHash2[1];
        if (inlineCacheStyleStr)
          return [inlineCacheStyleStr, tokenKey, styleHash, {}, clientOnly, order2];
      }
      var styleObj = styleFn(), _parseStyle5 = parseStyle(styleObj, {
        hashId,
        hashPriority,
        layer: enableLayer ? layer : void 0,
        path: path2.join("-"),
        transformers,
        linters
      }), _parseStyle6 = _slicedToArray(_parseStyle5, 2), parsedStyle = _parseStyle6[0], effectStyle = _parseStyle6[1], styleStr = normalizeStyle(parsedStyle), styleId = uniqueHash(fullPath, styleStr);
      return [styleStr, tokenKey, styleId, effectStyle, clientOnly, order2];
    },
    // Remove cache if no need
    function(_ref2, fromHMR) {
      var _ref3 = _slicedToArray(_ref2, 3), styleId = _ref3[2];
      (fromHMR || autoClear) && isClientSide && removeCSS(styleId, {
        mark: ATTR_MARK
      });
    },
    // Effect: Inject style here
    function(_ref4) {
      var _ref5 = _slicedToArray(_ref4, 4), styleStr = _ref5[0];
      _ref5[1];
      var styleId = _ref5[2], effectStyle = _ref5[3];
      if (isMergedClientSide && styleStr !== CSS_FILE_STYLE) {
        var mergedCSSConfig = {
          mark: ATTR_MARK,
          prepend: enableLayer ? !1 : "queue",
          attachTo: container2,
          priority: order2
        }, nonceStr = typeof nonce == "function" ? nonce() : nonce;
        nonceStr && (mergedCSSConfig.csp = {
          nonce: nonceStr
        });
        var effectLayerKeys = [], effectRestKeys = [];
        Object.keys(effectStyle).forEach(function(key) {
          key.startsWith("@layer") ? effectLayerKeys.push(key) : effectRestKeys.push(key);
        }), effectLayerKeys.forEach(function(effectKey) {
          updateCSS(normalizeStyle(effectStyle[effectKey]), "_layer-".concat(effectKey), _objectSpread2$1(_objectSpread2$1({}, mergedCSSConfig), {}, {
            prepend: !0
          }));
        });
        var style2 = updateCSS(styleStr, styleId, mergedCSSConfig);
        style2[CSS_IN_JS_INSTANCE] = cache.instanceId, style2.setAttribute(ATTR_TOKEN, tokenKey), process.env.NODE_ENV !== "production" && style2.setAttribute(ATTR_CACHE_PATH, fullPath.join("|")), effectRestKeys.forEach(function(effectKey) {
          updateCSS(normalizeStyle(effectStyle[effectKey]), "_effect-".concat(effectKey), mergedCSSConfig);
        });
      }
    }
  ), _useGlobalCache2 = _slicedToArray(_useGlobalCache, 3), cachedStyleStr = _useGlobalCache2[0], cachedTokenKey = _useGlobalCache2[1], cachedStyleId = _useGlobalCache2[2];
  return function(node2) {
    var styleNode;
    if (!ssrInline || isMergedClientSide || !defaultCache)
      styleNode = /* @__PURE__ */ React.createElement(Empty$3, null);
    else {
      var _ref6;
      styleNode = /* @__PURE__ */ React.createElement("style", _extends({}, (_ref6 = {}, _defineProperty$2(_ref6, ATTR_TOKEN, cachedTokenKey), _defineProperty$2(_ref6, ATTR_MARK, cachedStyleId), _ref6), {
        dangerouslySetInnerHTML: {
          __html: cachedStyleStr
        }
      }));
    }
    return /* @__PURE__ */ React.createElement(React.Fragment, null, styleNode, node2);
  };
}
__name(useStyleRegister, "useStyleRegister");
var extract$1 = /* @__PURE__ */ __name(function(cache, effectStyles, options) {
  var _cache = _slicedToArray(cache, 6), styleStr = _cache[0], tokenKey = _cache[1], styleId = _cache[2], effectStyle = _cache[3], clientOnly = _cache[4], order2 = _cache[5], _ref7 = options || {}, plain = _ref7.plain;
  if (clientOnly)
    return null;
  var keyStyleText = styleStr, sharedAttrs = {
    "data-rc-order": "prependQueue",
    "data-rc-priority": "".concat(order2)
  };
  return keyStyleText = toStyleStr(styleStr, tokenKey, styleId, sharedAttrs, plain), effectStyle && Object.keys(effectStyle).forEach(function(effectKey) {
    if (!effectStyles[effectKey]) {
      effectStyles[effectKey] = !0;
      var effectStyleStr = normalizeStyle(effectStyle[effectKey]), effectStyleHTML = toStyleStr(effectStyleStr, tokenKey, "_effect-".concat(effectKey), sharedAttrs, plain);
      effectKey.startsWith("@layer") ? keyStyleText = effectStyleHTML + keyStyleText : keyStyleText += effectStyleHTML;
    }
  }), [order2, styleId, keyStyleText];
}, "extract"), CSS_VAR_PREFIX = "cssVar", useCSSVarRegister = /* @__PURE__ */ __name(function(config, fn) {
  var key = config.key, prefix = config.prefix, unitless2 = config.unitless, ignore2 = config.ignore, token2 = config.token, _config$scope = config.scope, scope = _config$scope === void 0 ? "" : _config$scope, _useContext = useContext$1(StyleContext), instanceId = _useContext.cache.instanceId, container2 = _useContext.container, tokenKey = token2._tokenKey, stylePath = [].concat(_toConsumableArray(config.path), [key, scope, tokenKey]), cache = useGlobalCache(CSS_VAR_PREFIX, stylePath, function() {
    var originToken = fn(), _transformToken = transformToken(originToken, key, {
      prefix,
      unitless: unitless2,
      ignore: ignore2,
      scope
    }), _transformToken2 = _slicedToArray(_transformToken, 2), mergedToken = _transformToken2[0], cssVarsStr = _transformToken2[1], styleId = uniqueHash(stylePath, cssVarsStr);
    return [mergedToken, cssVarsStr, styleId, key];
  }, function(_ref) {
    var _ref2 = _slicedToArray(_ref, 3), styleId = _ref2[2];
    isClientSide && removeCSS(styleId, {
      mark: ATTR_MARK
    });
  }, function(_ref3) {
    var _ref4 = _slicedToArray(_ref3, 3), cssVarsStr = _ref4[1], styleId = _ref4[2];
    if (cssVarsStr) {
      var style2 = updateCSS(cssVarsStr, styleId, {
        mark: ATTR_MARK,
        prepend: "queue",
        attachTo: container2,
        priority: -999
      });
      style2[CSS_IN_JS_INSTANCE] = instanceId, style2.setAttribute(ATTR_TOKEN, key);
    }
  });
  return cache;
}, "useCSSVarRegister"), extract3 = /* @__PURE__ */ __name(function(cache, effectStyles, options) {
  var _cache = _slicedToArray(cache, 4), styleStr = _cache[1], styleId = _cache[2], cssVarKey = _cache[3], _ref5 = options || {}, plain = _ref5.plain;
  if (!styleStr)
    return null;
  var order2 = -999, sharedAttrs = {
    "data-rc-order": "prependQueue",
    "data-rc-priority": "".concat(order2)
  }, styleText = toStyleStr(styleStr, cssVarKey, styleId, sharedAttrs, plain);
  return [order2, styleId, styleText];
}, "extract"), _ExtractStyleFns;
_ExtractStyleFns = {}, _defineProperty$2(_ExtractStyleFns, STYLE_PREFIX, extract$1), _defineProperty$2(_ExtractStyleFns, TOKEN_PREFIX, extract$2), _defineProperty$2(_ExtractStyleFns, CSS_VAR_PREFIX, extract3);
var Keyframe = /* @__PURE__ */ function() {
  function Keyframe2(name, style2) {
    _classCallCheck$1(this, Keyframe2), _defineProperty$2(this, "name", void 0), _defineProperty$2(this, "style", void 0), _defineProperty$2(this, "_keyframe", !0), this.name = name, this.style = style2;
  }
  return __name(Keyframe2, "Keyframe"), _createClass$1(Keyframe2, [{
    key: "getName",
    value: /* @__PURE__ */ __name(function() {
      var hashId = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "";
      return hashId ? "".concat(hashId, "-").concat(this.name) : this.name;
    }, "getName")
  }]), Keyframe2;
}();
function noSplit(list) {
  return list.notSplit = !0, list;
}
__name(noSplit, "noSplit");
noSplit(["borderTop", "borderBottom"]), noSplit(["borderTop"]), noSplit(["borderBottom"]), noSplit(["borderLeft", "borderRight"]), noSplit(["borderLeft"]), noSplit(["borderRight"]);
var IconContext = /* @__PURE__ */ createContext$1({});
function _toArray(r2) {
  return _arrayWithHoles(r2) || _iterableToArray(r2) || _unsupportedIterableToArray(r2) || _nonIterableRest();
}
__name(_toArray, "_toArray");
function get(entity, path2) {
  for (var current = entity, i = 0; i < path2.length; i += 1) {
    if (current == null)
      return;
    current = current[path2[i]];
  }
  return current;
}
__name(get, "get");
function internalSet(entity, paths, value, removeIfUndefined) {
  if (!paths.length)
    return value;
  var _paths = _toArray(paths), path2 = _paths[0], restPath = _paths.slice(1), clone;
  return !entity && typeof path2 == "number" ? clone = [] : Array.isArray(entity) ? clone = _toConsumableArray(entity) : clone = _objectSpread2$1({}, entity), removeIfUndefined && value === void 0 && restPath.length === 1 ? delete clone[path2][restPath[0]] : clone[path2] = internalSet(clone[path2], restPath, value, removeIfUndefined), clone;
}
__name(internalSet, "internalSet");
function set(entity, paths, value) {
  var removeIfUndefined = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : !1;
  return paths.length && removeIfUndefined && value === void 0 && !get(entity, paths.slice(0, -1)) ? entity : internalSet(entity, paths, value, removeIfUndefined);
}
__name(set, "set");
function isObject$1(obj) {
  return _typeof$4(obj) === "object" && obj !== null && Object.getPrototypeOf(obj) === Object.prototype;
}
__name(isObject$1, "isObject$1");
function createEmpty(source) {
  return Array.isArray(source) ? [] : {};
}
__name(createEmpty, "createEmpty");
var keys = typeof Reflect > "u" ? Object.keys : Reflect.ownKeys;
function merge$1() {
  for (var _len = arguments.length, sources = new Array(_len), _key = 0; _key < _len; _key++)
    sources[_key] = arguments[_key];
  var clone = createEmpty(sources[0]);
  return sources.forEach(function(src) {
    function internalMerge(path2, parentLoopSet) {
      var loopSet = new Set(parentLoopSet), value = get(src, path2), isArr = Array.isArray(value);
      if (isArr || isObject$1(value)) {
        if (!loopSet.has(value)) {
          loopSet.add(value);
          var originValue = get(clone, path2);
          isArr ? clone = set(clone, path2, []) : (!originValue || _typeof$4(originValue) !== "object") && (clone = set(clone, path2, createEmpty(value))), keys(value).forEach(function(key) {
            internalMerge([].concat(_toConsumableArray(path2), [key]), loopSet);
          });
        }
      } else
        clone = set(clone, path2, value);
    }
    __name(internalMerge, "internalMerge"), internalMerge([]);
  }), clone;
}
__name(merge$1, "merge$1");
function noop$3() {
}
__name(noop$3, "noop$3");
let deprecatedWarnList = null;
function resetWarned() {
  deprecatedWarnList = null, resetWarned$1();
}
__name(resetWarned, "resetWarned");
let warning$2 = noop$3;
process.env.NODE_ENV !== "production" && (warning$2 = /* @__PURE__ */ __name((valid, component, message) => {
  warningOnce(valid, `[antd: ${component}] ${message}`), process.env.NODE_ENV === "test" && resetWarned();
}, "warning$2"));
const WarningContext = /* @__PURE__ */ React.createContext({}), devUseWarning = process.env.NODE_ENV !== "production" ? (component) => {
  const {
    strict
  } = React.useContext(WarningContext), typeWarning = /* @__PURE__ */ __name((valid, type4, message) => {
    if (!valid)
      if (strict === !1 && type4 === "deprecated") {
        const existWarning = deprecatedWarnList;
        deprecatedWarnList || (deprecatedWarnList = {}), deprecatedWarnList[component] = deprecatedWarnList[component] || [], deprecatedWarnList[component].includes(message || "") || deprecatedWarnList[component].push(message || ""), existWarning || console.warn("[antd] There exists deprecated usage in your code:", deprecatedWarnList);
      } else
        process.env.NODE_ENV !== "production" && warning$2(valid, component, message);
  }, "typeWarning");
  return typeWarning.deprecated = (valid, oldProp, newProp, message) => {
    typeWarning(valid, "deprecated", `\`${oldProp}\` is deprecated. Please use \`${newProp}\` instead.${message ? ` ${message}` : ""}`);
  }, typeWarning;
} : () => {
  const noopWarning = /* @__PURE__ */ __name(() => {
  }, "noopWarning");
  return noopWarning.deprecated = noop$3, noopWarning;
}, ValidateMessagesContext = /* @__PURE__ */ createContext$1(void 0);
var locale$8 = {
  // Options
  items_per_page: "/ page",
  jump_to: "Go to",
  jump_to_confirm: "confirm",
  page: "Page",
  // Pagination
  prev_page: "Previous Page",
  next_page: "Next Page",
  prev_5: "Previous 5 Pages",
  next_5: "Next 5 Pages",
  prev_3: "Previous 3 Pages",
  next_3: "Next 3 Pages",
  page_size: "Page Size"
}, commonLocale = {
  yearFormat: "YYYY",
  dayFormat: "D",
  cellMeridiemFormat: "A",
  monthBeforeYear: !0
}, locale$7 = _objectSpread2$1(_objectSpread2$1({}, commonLocale), {}, {
  locale: "en_US",
  today: "Today",
  now: "Now",
  backToToday: "Back to today",
  ok: "OK",
  clear: "Clear",
  month: "Month",
  year: "Year",
  timeSelect: "select time",
  dateSelect: "select date",
  weekSelect: "Choose a week",
  monthSelect: "Choose a month",
  yearSelect: "Choose a year",
  decadeSelect: "Choose a decade",
  dateFormat: "M/D/YYYY",
  dateTimeFormat: "M/D/YYYY HH:mm:ss",
  previousMonth: "Previous month (PageUp)",
  nextMonth: "Next month (PageDown)",
  previousYear: "Last year (Control + left)",
  nextYear: "Next year (Control + right)",
  previousDecade: "Last decade",
  nextDecade: "Next decade",
  previousCentury: "Last century",
  nextCentury: "Next century"
});
const locale$6 = {
  placeholder: "Select time",
  rangePlaceholder: ["Start time", "End time"]
}, locale$5 = {
  lang: Object.assign({
    placeholder: "Select date",
    yearPlaceholder: "Select year",
    quarterPlaceholder: "Select quarter",
    monthPlaceholder: "Select month",
    weekPlaceholder: "Select week",
    rangePlaceholder: ["Start date", "End date"],
    rangeYearPlaceholder: ["Start year", "End year"],
    rangeQuarterPlaceholder: ["Start quarter", "End quarter"],
    rangeMonthPlaceholder: ["Start month", "End month"],
    rangeWeekPlaceholder: ["Start week", "End week"]
  }, locale$7),
  timePickerLocale: Object.assign({}, locale$6)
}, typeTemplate$2 = "${label} is not a valid ${type}", localeValues$1 = {
  locale: "en",
  Pagination: locale$8,
  DatePicker: locale$5,
  TimePicker: locale$6,
  Calendar: locale$5,
  global: {
    placeholder: "Please select"
  },
  Table: {
    filterTitle: "Filter menu",
    filterConfirm: "OK",
    filterReset: "Reset",
    filterEmptyText: "No filters",
    filterCheckall: "Select all items",
    filterSearchPlaceholder: "Search in filters",
    emptyText: "No data",
    selectAll: "Select current page",
    selectInvert: "Invert current page",
    selectNone: "Clear all data",
    selectionAll: "Select all data",
    sortTitle: "Sort",
    expand: "Expand row",
    collapse: "Collapse row",
    triggerDesc: "Click to sort descending",
    triggerAsc: "Click to sort ascending",
    cancelSort: "Click to cancel sorting"
  },
  Tour: {
    Next: "Next",
    Previous: "Previous",
    Finish: "Finish"
  },
  Modal: {
    okText: "OK",
    cancelText: "Cancel",
    justOkText: "OK"
  },
  Popconfirm: {
    okText: "OK",
    cancelText: "Cancel"
  },
  Transfer: {
    titles: ["", ""],
    searchPlaceholder: "Search here",
    itemUnit: "item",
    itemsUnit: "items",
    remove: "Remove",
    selectCurrent: "Select current page",
    removeCurrent: "Remove current page",
    selectAll: "Select all data",
    deselectAll: "Deselect all data",
    removeAll: "Remove all data",
    selectInvert: "Invert current page"
  },
  Upload: {
    uploading: "Uploading...",
    removeFile: "Remove file",
    uploadError: "Upload error",
    previewFile: "Preview file",
    downloadFile: "Download file"
  },
  Empty: {
    description: "No data"
  },
  Icon: {
    icon: "icon"
  },
  Text: {
    edit: "Edit",
    copy: "Copy",
    copied: "Copied",
    expand: "Expand",
    collapse: "Collapse"
  },
  Form: {
    optional: "(optional)",
    defaultValidateMessages: {
      default: "Field validation error for ${label}",
      required: "Please enter ${label}",
      enum: "${label} must be one of [${enum}]",
      whitespace: "${label} cannot be a blank character",
      date: {
        format: "${label} date format is invalid",
        parse: "${label} cannot be converted to a date",
        invalid: "${label} is an invalid date"
      },
      types: {
        string: typeTemplate$2,
        method: typeTemplate$2,
        array: typeTemplate$2,
        object: typeTemplate$2,
        number: typeTemplate$2,
        date: typeTemplate$2,
        boolean: typeTemplate$2,
        integer: typeTemplate$2,
        float: typeTemplate$2,
        regexp: typeTemplate$2,
        email: typeTemplate$2,
        url: typeTemplate$2,
        hex: typeTemplate$2
      },
      string: {
        len: "${label} must be ${len} characters",
        min: "${label} must be at least ${min} characters",
        max: "${label} must be up to ${max} characters",
        range: "${label} must be between ${min}-${max} characters"
      },
      number: {
        len: "${label} must be equal to ${len}",
        min: "${label} must be minimum ${min}",
        max: "${label} must be maximum ${max}",
        range: "${label} must be between ${min}-${max}"
      },
      array: {
        len: "Must be ${len} ${label}",
        min: "At least ${min} ${label}",
        max: "At most ${max} ${label}",
        range: "The amount of ${label} must be between ${min}-${max}"
      },
      pattern: {
        mismatch: "${label} does not match the pattern ${pattern}"
      }
    }
  },
  Image: {
    preview: "Preview"
  },
  QRCode: {
    expired: "QR code expired",
    refresh: "Refresh",
    scanned: "Scanned"
  },
  ColorPicker: {
    presetEmpty: "Empty",
    transparent: "Transparent",
    singleColor: "Single",
    gradientColor: "Gradient"
  }
};
let runtimeLocale = Object.assign({}, localeValues$1.Modal), localeList = [];
const generateLocale = /* @__PURE__ */ __name(() => localeList.reduce((merged, locale2) => Object.assign(Object.assign({}, merged), locale2), localeValues$1.Modal), "generateLocale");
function changeConfirmLocale(newLocale) {
  if (newLocale) {
    const cloneLocale = Object.assign({}, newLocale);
    return localeList.push(cloneLocale), runtimeLocale = generateLocale(), () => {
      localeList = localeList.filter((locale2) => locale2 !== cloneLocale), runtimeLocale = generateLocale();
    };
  }
  runtimeLocale = Object.assign({}, localeValues$1.Modal);
}
__name(changeConfirmLocale, "changeConfirmLocale");
function getConfirmLocale() {
  return runtimeLocale;
}
__name(getConfirmLocale, "getConfirmLocale");
const LocaleContext = /* @__PURE__ */ createContext$1(void 0), useLocale$1 = /* @__PURE__ */ __name((componentName, defaultLocale) => {
  const fullLocale = React.useContext(LocaleContext), getLocale = React.useMemo(() => {
    var _a;
    const locale2 = defaultLocale || localeValues$1[componentName], localeFromContext = (_a = fullLocale == null ? void 0 : fullLocale[componentName]) !== null && _a !== void 0 ? _a : {};
    return Object.assign(Object.assign({}, typeof locale2 == "function" ? locale2() : locale2), localeFromContext || {});
  }, [componentName, defaultLocale, fullLocale]), getLocaleCode = React.useMemo(() => {
    const localeCode = fullLocale == null ? void 0 : fullLocale.locale;
    return fullLocale != null && fullLocale.exist && !localeCode ? localeValues$1.locale : localeCode;
  }, [fullLocale]);
  return [getLocale, getLocaleCode];
}, "useLocale$1"), ANT_MARK = "internalMark", LocaleProvider = /* @__PURE__ */ __name((props) => {
  const {
    locale: locale2 = {},
    children,
    _ANT_MARK__
  } = props;
  if (process.env.NODE_ENV !== "production") {
    const warning3 = devUseWarning("LocaleProvider");
    process.env.NODE_ENV !== "production" && warning3(_ANT_MARK__ === ANT_MARK, "deprecated", "`LocaleProvider` is deprecated. Please use `locale` with `ConfigProvider` instead: http://u.ant.design/locale");
  }
  React.useEffect(() => changeConfirmLocale(locale2 == null ? void 0 : locale2.Modal), [locale2]);
  const getMemoizedContextValue = React.useMemo(() => Object.assign(Object.assign({}, locale2), {
    exist: !0
  }), [locale2]);
  return /* @__PURE__ */ React.createElement(LocaleContext.Provider, {
    value: getMemoizedContextValue
  }, children);
}, "LocaleProvider");
process.env.NODE_ENV !== "production" && (LocaleProvider.displayName = "LocaleProvider");
const round = Math.round;
function splitColorStr(str, parseNum) {
  const match2 = str.replace(/^[^(]*\((.*)/, "$1").replace(/\).*/, "").match(/\d*\.?\d+%?/g) || [], numList = match2.map((item) => parseFloat(item));
  for (let i = 0; i < 3; i += 1)
    numList[i] = parseNum(numList[i] || 0, match2[i] || "", i);
  return match2[3] ? numList[3] = match2[3].includes("%") ? numList[3] / 100 : numList[3] : numList[3] = 1, numList;
}
__name(splitColorStr, "splitColorStr");
const parseHSVorHSL = /* @__PURE__ */ __name((num, _2, index2) => index2 === 0 ? num : num / 100, "parseHSVorHSL");
function limitRange(value, max) {
  const mergedMax = max || 255;
  return value > mergedMax ? mergedMax : value < 0 ? 0 : value;
}
__name(limitRange, "limitRange");
const _FastColor = class _FastColor {
  constructor(input) {
    _defineProperty$2(this, "isValid", !0), _defineProperty$2(this, "r", 0), _defineProperty$2(this, "g", 0), _defineProperty$2(this, "b", 0), _defineProperty$2(this, "a", 1), _defineProperty$2(this, "_h", void 0), _defineProperty$2(this, "_s", void 0), _defineProperty$2(this, "_l", void 0), _defineProperty$2(this, "_v", void 0), _defineProperty$2(this, "_max", void 0), _defineProperty$2(this, "_min", void 0), _defineProperty$2(this, "_brightness", void 0);
    function matchFormat(str) {
      return str[0] in input && str[1] in input && str[2] in input;
    }
    if (__name(matchFormat, "matchFormat"), input) if (typeof input == "string") {
      let matchPrefix = function(prefix) {
        return trimStr.startsWith(prefix);
      };
      __name(matchPrefix, "matchPrefix");
      const trimStr = input.trim();
      /^#?[A-F\d]{3,8}$/i.test(trimStr) ? this.fromHexString(trimStr) : matchPrefix("rgb") ? this.fromRgbString(trimStr) : matchPrefix("hsl") ? this.fromHslString(trimStr) : (matchPrefix("hsv") || matchPrefix("hsb")) && this.fromHsvString(trimStr);
    } else if (input instanceof _FastColor)
      this.r = input.r, this.g = input.g, this.b = input.b, this.a = input.a, this._h = input._h, this._s = input._s, this._l = input._l, this._v = input._v;
    else if (matchFormat("rgb"))
      this.r = limitRange(input.r), this.g = limitRange(input.g), this.b = limitRange(input.b), this.a = typeof input.a == "number" ? limitRange(input.a, 1) : 1;
    else if (matchFormat("hsl"))
      this.fromHsl(input);
    else if (matchFormat("hsv"))
      this.fromHsv(input);
    else
      throw new Error("@ant-design/fast-color: unsupported input " + JSON.stringify(input));
  }
  // ======================= Setter =======================
  setR(value) {
    return this._sc("r", value);
  }
  setG(value) {
    return this._sc("g", value);
  }
  setB(value) {
    return this._sc("b", value);
  }
  setA(value) {
    return this._sc("a", value, 1);
  }
  setHue(value) {
    const hsv = this.toHsv();
    return hsv.h = value, this._c(hsv);
  }
  // ======================= Getter =======================
  /**
   * Returns the perceived luminance of a color, from 0-1.
   * @see http://www.w3.org/TR/2008/REC-WCAG20-20081211/#relativeluminancedef
   */
  getLuminance() {
    function adjustGamma(raw) {
      const val = raw / 255;
      return val <= 0.03928 ? val / 12.92 : Math.pow((val + 0.055) / 1.055, 2.4);
    }
    __name(adjustGamma, "adjustGamma");
    const R = adjustGamma(this.r), G = adjustGamma(this.g), B = adjustGamma(this.b);
    return 0.2126 * R + 0.7152 * G + 0.0722 * B;
  }
  getHue() {
    if (typeof this._h > "u") {
      const delta = this.getMax() - this.getMin();
      delta === 0 ? this._h = 0 : this._h = round(60 * (this.r === this.getMax() ? (this.g - this.b) / delta + (this.g < this.b ? 6 : 0) : this.g === this.getMax() ? (this.b - this.r) / delta + 2 : (this.r - this.g) / delta + 4));
    }
    return this._h;
  }
  getSaturation() {
    if (typeof this._s > "u") {
      const delta = this.getMax() - this.getMin();
      delta === 0 ? this._s = 0 : this._s = delta / this.getMax();
    }
    return this._s;
  }
  getLightness() {
    return typeof this._l > "u" && (this._l = (this.getMax() + this.getMin()) / 510), this._l;
  }
  getValue() {
    return typeof this._v > "u" && (this._v = this.getMax() / 255), this._v;
  }
  /**
   * Returns the perceived brightness of the color, from 0-255.
   * Note: this is not the b of HSB
   * @see http://www.w3.org/TR/AERT#color-contrast
   */
  getBrightness() {
    return typeof this._brightness > "u" && (this._brightness = (this.r * 299 + this.g * 587 + this.b * 114) / 1e3), this._brightness;
  }
  // ======================== Func ========================
  darken(amount = 10) {
    const h = this.getHue(), s = this.getSaturation();
    let l2 = this.getLightness() - amount / 100;
    return l2 < 0 && (l2 = 0), this._c({
      h,
      s,
      l: l2,
      a: this.a
    });
  }
  lighten(amount = 10) {
    const h = this.getHue(), s = this.getSaturation();
    let l2 = this.getLightness() + amount / 100;
    return l2 > 1 && (l2 = 1), this._c({
      h,
      s,
      l: l2,
      a: this.a
    });
  }
  /**
   * Mix the current color a given amount with another color, from 0 to 100.
   * 0 means no mixing (return current color).
   */
  mix(input, amount = 50) {
    const color = this._c(input), p = amount / 100, calc = /* @__PURE__ */ __name((key) => (color[key] - this[key]) * p + this[key], "calc"), rgba = {
      r: round(calc("r")),
      g: round(calc("g")),
      b: round(calc("b")),
      a: round(calc("a") * 100) / 100
    };
    return this._c(rgba);
  }
  /**
   * Mix the color with pure white, from 0 to 100.
   * Providing 0 will do nothing, providing 100 will always return white.
   */
  tint(amount = 10) {
    return this.mix({
      r: 255,
      g: 255,
      b: 255,
      a: 1
    }, amount);
  }
  /**
   * Mix the color with pure black, from 0 to 100.
   * Providing 0 will do nothing, providing 100 will always return black.
   */
  shade(amount = 10) {
    return this.mix({
      r: 0,
      g: 0,
      b: 0,
      a: 1
    }, amount);
  }
  onBackground(background) {
    const bg = this._c(background), alpha = this.a + bg.a * (1 - this.a), calc = /* @__PURE__ */ __name((key) => round((this[key] * this.a + bg[key] * bg.a * (1 - this.a)) / alpha), "calc");
    return this._c({
      r: calc("r"),
      g: calc("g"),
      b: calc("b"),
      a: alpha
    });
  }
  // ======================= Status =======================
  isDark() {
    return this.getBrightness() < 128;
  }
  isLight() {
    return this.getBrightness() >= 128;
  }
  // ======================== MISC ========================
  equals(other) {
    return this.r === other.r && this.g === other.g && this.b === other.b && this.a === other.a;
  }
  clone() {
    return this._c(this);
  }
  // ======================= Format =======================
  toHexString() {
    let hex2 = "#";
    const rHex = (this.r || 0).toString(16);
    hex2 += rHex.length === 2 ? rHex : "0" + rHex;
    const gHex = (this.g || 0).toString(16);
    hex2 += gHex.length === 2 ? gHex : "0" + gHex;
    const bHex = (this.b || 0).toString(16);
    if (hex2 += bHex.length === 2 ? bHex : "0" + bHex, typeof this.a == "number" && this.a >= 0 && this.a < 1) {
      const aHex = round(this.a * 255).toString(16);
      hex2 += aHex.length === 2 ? aHex : "0" + aHex;
    }
    return hex2;
  }
  /** CSS support color pattern */
  toHsl() {
    return {
      h: this.getHue(),
      s: this.getSaturation(),
      l: this.getLightness(),
      a: this.a
    };
  }
  /** CSS support color pattern */
  toHslString() {
    const h = this.getHue(), s = round(this.getSaturation() * 100), l2 = round(this.getLightness() * 100);
    return this.a !== 1 ? `hsla(${h},${s}%,${l2}%,${this.a})` : `hsl(${h},${s}%,${l2}%)`;
  }
  /** Same as toHsb */
  toHsv() {
    return {
      h: this.getHue(),
      s: this.getSaturation(),
      v: this.getValue(),
      a: this.a
    };
  }
  toRgb() {
    return {
      r: this.r,
      g: this.g,
      b: this.b,
      a: this.a
    };
  }
  toRgbString() {
    return this.a !== 1 ? `rgba(${this.r},${this.g},${this.b},${this.a})` : `rgb(${this.r},${this.g},${this.b})`;
  }
  toString() {
    return this.toRgbString();
  }
  // ====================== Privates ======================
  /** Return a new FastColor object with one channel changed */
  _sc(rgb, value, max) {
    const clone = this.clone();
    return clone[rgb] = limitRange(value, max), clone;
  }
  _c(input) {
    return new this.constructor(input);
  }
  getMax() {
    return typeof this._max > "u" && (this._max = Math.max(this.r, this.g, this.b)), this._max;
  }
  getMin() {
    return typeof this._min > "u" && (this._min = Math.min(this.r, this.g, this.b)), this._min;
  }
  fromHexString(trimStr) {
    const withoutPrefix = trimStr.replace("#", "");
    function connectNum(index1, index2) {
      return parseInt(withoutPrefix[index1] + withoutPrefix[index2 || index1], 16);
    }
    __name(connectNum, "connectNum"), withoutPrefix.length < 6 ? (this.r = connectNum(0), this.g = connectNum(1), this.b = connectNum(2), this.a = withoutPrefix[3] ? connectNum(3) / 255 : 1) : (this.r = connectNum(0, 1), this.g = connectNum(2, 3), this.b = connectNum(4, 5), this.a = withoutPrefix[6] ? connectNum(6, 7) / 255 : 1);
  }
  fromHsl({
    h,
    s,
    l: l2,
    a
  }) {
    if (this._h = h % 360, this._s = s, this._l = l2, this.a = typeof a == "number" ? a : 1, s <= 0) {
      const rgb = round(l2 * 255);
      this.r = rgb, this.g = rgb, this.b = rgb;
    }
    let r2 = 0, g = 0, b = 0;
    const huePrime = h / 60, chroma = (1 - Math.abs(2 * l2 - 1)) * s, secondComponent = chroma * (1 - Math.abs(huePrime % 2 - 1));
    huePrime >= 0 && huePrime < 1 ? (r2 = chroma, g = secondComponent) : huePrime >= 1 && huePrime < 2 ? (r2 = secondComponent, g = chroma) : huePrime >= 2 && huePrime < 3 ? (g = chroma, b = secondComponent) : huePrime >= 3 && huePrime < 4 ? (g = secondComponent, b = chroma) : huePrime >= 4 && huePrime < 5 ? (r2 = secondComponent, b = chroma) : huePrime >= 5 && huePrime < 6 && (r2 = chroma, b = secondComponent);
    const lightnessModification = l2 - chroma / 2;
    this.r = round((r2 + lightnessModification) * 255), this.g = round((g + lightnessModification) * 255), this.b = round((b + lightnessModification) * 255);
  }
  fromHsv({
    h,
    s,
    v,
    a
  }) {
    this._h = h % 360, this._s = s, this._v = v, this.a = typeof a == "number" ? a : 1;
    const vv = round(v * 255);
    if (this.r = vv, this.g = vv, this.b = vv, s <= 0)
      return;
    const hh = h / 60, i = Math.floor(hh), ff = hh - i, p = round(v * (1 - s) * 255), q = round(v * (1 - s * ff) * 255), t2 = round(v * (1 - s * (1 - ff)) * 255);
    switch (i) {
      case 0:
        this.g = t2, this.b = p;
        break;
      case 1:
        this.r = q, this.b = p;
        break;
      case 2:
        this.r = p, this.b = t2;
        break;
      case 3:
        this.r = p, this.g = q;
        break;
      case 4:
        this.r = t2, this.g = p;
        break;
      case 5:
      default:
        this.g = p, this.b = q;
        break;
    }
  }
  fromHsvString(trimStr) {
    const cells = splitColorStr(trimStr, parseHSVorHSL);
    this.fromHsv({
      h: cells[0],
      s: cells[1],
      v: cells[2],
      a: cells[3]
    });
  }
  fromHslString(trimStr) {
    const cells = splitColorStr(trimStr, parseHSVorHSL);
    this.fromHsl({
      h: cells[0],
      s: cells[1],
      l: cells[2],
      a: cells[3]
    });
  }
  fromRgbString(trimStr) {
    const cells = splitColorStr(trimStr, (num, txt) => (
      // Convert percentage to number. e.g. 50% -> 128
      txt.includes("%") ? round(num / 100 * 255) : num
    ));
    this.r = cells[0], this.g = cells[1], this.b = cells[2], this.a = cells[3];
  }
};
__name(_FastColor, "FastColor");
let FastColor = _FastColor;
var hueStep = 2, saturationStep = 0.16, saturationStep2 = 0.05, brightnessStep1 = 0.05, brightnessStep2 = 0.15, lightColorCount = 5, darkColorCount = 4, darkColorMap = [{
  index: 7,
  amount: 15
}, {
  index: 6,
  amount: 25
}, {
  index: 5,
  amount: 30
}, {
  index: 5,
  amount: 45
}, {
  index: 5,
  amount: 65
}, {
  index: 5,
  amount: 85
}, {
  index: 4,
  amount: 90
}, {
  index: 3,
  amount: 95
}, {
  index: 2,
  amount: 97
}, {
  index: 1,
  amount: 98
}];
function getHue(hsv, i, light) {
  var hue;
  return Math.round(hsv.h) >= 60 && Math.round(hsv.h) <= 240 ? hue = light ? Math.round(hsv.h) - hueStep * i : Math.round(hsv.h) + hueStep * i : hue = light ? Math.round(hsv.h) + hueStep * i : Math.round(hsv.h) - hueStep * i, hue < 0 ? hue += 360 : hue >= 360 && (hue -= 360), hue;
}
__name(getHue, "getHue");
function getSaturation(hsv, i, light) {
  if (hsv.h === 0 && hsv.s === 0)
    return hsv.s;
  var saturation;
  return light ? saturation = hsv.s - saturationStep * i : i === darkColorCount ? saturation = hsv.s + saturationStep : saturation = hsv.s + saturationStep2 * i, saturation > 1 && (saturation = 1), light && i === lightColorCount && saturation > 0.1 && (saturation = 0.1), saturation < 0.06 && (saturation = 0.06), Math.round(saturation * 100) / 100;
}
__name(getSaturation, "getSaturation");
function getValue$1(hsv, i, light) {
  var value;
  return light ? value = hsv.v + brightnessStep1 * i : value = hsv.v - brightnessStep2 * i, value = Math.max(0, Math.min(1, value)), Math.round(value * 100) / 100;
}
__name(getValue$1, "getValue$1");
function generate$1(color) {
  for (var opts = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, patterns = [], pColor = new FastColor(color), hsv = pColor.toHsv(), i = lightColorCount; i > 0; i -= 1) {
    var c = new FastColor({
      h: getHue(hsv, i, !0),
      s: getSaturation(hsv, i, !0),
      v: getValue$1(hsv, i, !0)
    });
    patterns.push(c);
  }
  patterns.push(pColor);
  for (var _i = 1; _i <= darkColorCount; _i += 1) {
    var _c = new FastColor({
      h: getHue(hsv, _i),
      s: getSaturation(hsv, _i),
      v: getValue$1(hsv, _i)
    });
    patterns.push(_c);
  }
  return opts.theme === "dark" ? darkColorMap.map(function(_ref) {
    var index2 = _ref.index, amount = _ref.amount;
    return new FastColor(opts.backgroundColor || "#141414").mix(patterns[index2], amount).toHexString();
  }) : patterns.map(function(c2) {
    return c2.toHexString();
  });
}
__name(generate$1, "generate$1");
var presetPrimaryColors = {
  red: "#F5222D",
  volcano: "#FA541C",
  orange: "#FA8C16",
  gold: "#FAAD14",
  yellow: "#FADB14",
  lime: "#A0D911",
  green: "#52C41A",
  cyan: "#13C2C2",
  blue: "#1677FF",
  geekblue: "#2F54EB",
  purple: "#722ED1",
  magenta: "#EB2F96",
  grey: "#666666"
}, red = ["#fff1f0", "#ffccc7", "#ffa39e", "#ff7875", "#ff4d4f", "#f5222d", "#cf1322", "#a8071a", "#820014", "#5c0011"];
red.primary = red[5];
var volcano = ["#fff2e8", "#ffd8bf", "#ffbb96", "#ff9c6e", "#ff7a45", "#fa541c", "#d4380d", "#ad2102", "#871400", "#610b00"];
volcano.primary = volcano[5];
var orange = ["#fff7e6", "#ffe7ba", "#ffd591", "#ffc069", "#ffa940", "#fa8c16", "#d46b08", "#ad4e00", "#873800", "#612500"];
orange.primary = orange[5];
var gold = ["#fffbe6", "#fff1b8", "#ffe58f", "#ffd666", "#ffc53d", "#faad14", "#d48806", "#ad6800", "#874d00", "#613400"];
gold.primary = gold[5];
var yellow = ["#feffe6", "#ffffb8", "#fffb8f", "#fff566", "#ffec3d", "#fadb14", "#d4b106", "#ad8b00", "#876800", "#614700"];
yellow.primary = yellow[5];
var lime = ["#fcffe6", "#f4ffb8", "#eaff8f", "#d3f261", "#bae637", "#a0d911", "#7cb305", "#5b8c00", "#3f6600", "#254000"];
lime.primary = lime[5];
var green = ["#f6ffed", "#d9f7be", "#b7eb8f", "#95de64", "#73d13d", "#52c41a", "#389e0d", "#237804", "#135200", "#092b00"];
green.primary = green[5];
var cyan = ["#e6fffb", "#b5f5ec", "#87e8de", "#5cdbd3", "#36cfc9", "#13c2c2", "#08979c", "#006d75", "#00474f", "#002329"];
cyan.primary = cyan[5];
var blue = ["#e6f4ff", "#bae0ff", "#91caff", "#69b1ff", "#4096ff", "#1677ff", "#0958d9", "#003eb3", "#002c8c", "#001d66"];
blue.primary = blue[5];
var geekblue = ["#f0f5ff", "#d6e4ff", "#adc6ff", "#85a5ff", "#597ef7", "#2f54eb", "#1d39c4", "#10239e", "#061178", "#030852"];
geekblue.primary = geekblue[5];
var purple = ["#f9f0ff", "#efdbff", "#d3adf7", "#b37feb", "#9254de", "#722ed1", "#531dab", "#391085", "#22075e", "#120338"];
purple.primary = purple[5];
var magenta = ["#fff0f6", "#ffd6e7", "#ffadd2", "#ff85c0", "#f759ab", "#eb2f96", "#c41d7f", "#9e1068", "#780650", "#520339"];
magenta.primary = magenta[5];
var grey = ["#a6a6a6", "#999999", "#8c8c8c", "#808080", "#737373", "#666666", "#404040", "#1a1a1a", "#000000", "#000000"];
grey.primary = grey[5];
var presetPalettes = {
  red,
  volcano,
  orange,
  gold,
  yellow,
  lime,
  green,
  cyan,
  blue,
  geekblue,
  purple,
  magenta,
  grey
};
const defaultPresetColors = {
  blue: "#1677FF",
  purple: "#722ED1",
  cyan: "#13C2C2",
  green: "#52C41A",
  magenta: "#EB2F96",
  /**
   * @deprecated Use magenta instead
   */
  pink: "#EB2F96",
  red: "#F5222D",
  orange: "#FA8C16",
  yellow: "#FADB14",
  volcano: "#FA541C",
  geekblue: "#2F54EB",
  gold: "#FAAD14",
  lime: "#A0D911"
}, seedToken = Object.assign(Object.assign({}, defaultPresetColors), {
  // Color
  colorPrimary: "#1677ff",
  colorSuccess: "#52c41a",
  colorWarning: "#faad14",
  colorError: "#ff4d4f",
  colorInfo: "#1677ff",
  colorLink: "",
  colorTextBase: "",
  colorBgBase: "",
  // Font
  fontFamily: `-apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial,
'Noto Sans', sans-serif, 'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol',
'Noto Color Emoji'`,
  fontFamilyCode: "'SFMono-Regular', Consolas, 'Liberation Mono', Menlo, Courier, monospace",
  fontSize: 14,
  // Line
  lineWidth: 1,
  lineType: "solid",
  // Motion
  motionUnit: 0.1,
  motionBase: 0,
  motionEaseOutCirc: "cubic-bezier(0.08, 0.82, 0.17, 1)",
  motionEaseInOutCirc: "cubic-bezier(0.78, 0.14, 0.15, 0.86)",
  motionEaseOut: "cubic-bezier(0.215, 0.61, 0.355, 1)",
  motionEaseInOut: "cubic-bezier(0.645, 0.045, 0.355, 1)",
  motionEaseOutBack: "cubic-bezier(0.12, 0.4, 0.29, 1.46)",
  motionEaseInBack: "cubic-bezier(0.71, -0.46, 0.88, 0.6)",
  motionEaseInQuint: "cubic-bezier(0.755, 0.05, 0.855, 0.06)",
  motionEaseOutQuint: "cubic-bezier(0.23, 1, 0.32, 1)",
  // Radius
  borderRadius: 6,
  // Size
  sizeUnit: 4,
  sizeStep: 4,
  sizePopupArrow: 16,
  // Control Base
  controlHeight: 32,
  // zIndex
  zIndexBase: 0,
  zIndexPopupBase: 1e3,
  // Image
  opacityImage: 1,
  // Wireframe
  wireframe: !1,
  // Motion
  motion: !0
});
function bound01(n2, max) {
  isOnePointZero(n2) && (n2 = "100%");
  var isPercent = isPercentage(n2);
  return n2 = max === 360 ? n2 : Math.min(max, Math.max(0, parseFloat(n2))), isPercent && (n2 = parseInt(String(n2 * max), 10) / 100), Math.abs(n2 - max) < 1e-6 ? 1 : (max === 360 ? n2 = (n2 < 0 ? n2 % max + max : n2 % max) / parseFloat(String(max)) : n2 = n2 % max / parseFloat(String(max)), n2);
}
__name(bound01, "bound01");
function clamp01(val) {
  return Math.min(1, Math.max(0, val));
}
__name(clamp01, "clamp01");
function isOnePointZero(n2) {
  return typeof n2 == "string" && n2.indexOf(".") !== -1 && parseFloat(n2) === 1;
}
__name(isOnePointZero, "isOnePointZero");
function isPercentage(n2) {
  return typeof n2 == "string" && n2.indexOf("%") !== -1;
}
__name(isPercentage, "isPercentage");
function boundAlpha(a) {
  return a = parseFloat(a), (isNaN(a) || a < 0 || a > 1) && (a = 1), a;
}
__name(boundAlpha, "boundAlpha");
function convertToPercentage(n2) {
  return n2 <= 1 ? "".concat(Number(n2) * 100, "%") : n2;
}
__name(convertToPercentage, "convertToPercentage");
function pad2(c) {
  return c.length === 1 ? "0" + c : String(c);
}
__name(pad2, "pad2");
function rgbToRgb(r2, g, b) {
  return {
    r: bound01(r2, 255) * 255,
    g: bound01(g, 255) * 255,
    b: bound01(b, 255) * 255
  };
}
__name(rgbToRgb, "rgbToRgb");
function rgbToHsl(r2, g, b) {
  r2 = bound01(r2, 255), g = bound01(g, 255), b = bound01(b, 255);
  var max = Math.max(r2, g, b), min = Math.min(r2, g, b), h = 0, s = 0, l2 = (max + min) / 2;
  if (max === min)
    s = 0, h = 0;
  else {
    var d = max - min;
    switch (s = l2 > 0.5 ? d / (2 - max - min) : d / (max + min), max) {
      case r2:
        h = (g - b) / d + (g < b ? 6 : 0);
        break;
      case g:
        h = (b - r2) / d + 2;
        break;
      case b:
        h = (r2 - g) / d + 4;
        break;
    }
    h /= 6;
  }
  return { h, s, l: l2 };
}
__name(rgbToHsl, "rgbToHsl");
function hue2rgb(p, q, t2) {
  return t2 < 0 && (t2 += 1), t2 > 1 && (t2 -= 1), t2 < 1 / 6 ? p + (q - p) * (6 * t2) : t2 < 1 / 2 ? q : t2 < 2 / 3 ? p + (q - p) * (2 / 3 - t2) * 6 : p;
}
__name(hue2rgb, "hue2rgb");
function hslToRgb(h, s, l2) {
  var r2, g, b;
  if (h = bound01(h, 360), s = bound01(s, 100), l2 = bound01(l2, 100), s === 0)
    g = l2, b = l2, r2 = l2;
  else {
    var q = l2 < 0.5 ? l2 * (1 + s) : l2 + s - l2 * s, p = 2 * l2 - q;
    r2 = hue2rgb(p, q, h + 1 / 3), g = hue2rgb(p, q, h), b = hue2rgb(p, q, h - 1 / 3);
  }
  return { r: r2 * 255, g: g * 255, b: b * 255 };
}
__name(hslToRgb, "hslToRgb");
function rgbToHsv(r2, g, b) {
  r2 = bound01(r2, 255), g = bound01(g, 255), b = bound01(b, 255);
  var max = Math.max(r2, g, b), min = Math.min(r2, g, b), h = 0, v = max, d = max - min, s = max === 0 ? 0 : d / max;
  if (max === min)
    h = 0;
  else {
    switch (max) {
      case r2:
        h = (g - b) / d + (g < b ? 6 : 0);
        break;
      case g:
        h = (b - r2) / d + 2;
        break;
      case b:
        h = (r2 - g) / d + 4;
        break;
    }
    h /= 6;
  }
  return { h, s, v };
}
__name(rgbToHsv, "rgbToHsv");
function hsvToRgb(h, s, v) {
  h = bound01(h, 360) * 6, s = bound01(s, 100), v = bound01(v, 100);
  var i = Math.floor(h), f = h - i, p = v * (1 - s), q = v * (1 - f * s), t2 = v * (1 - (1 - f) * s), mod = i % 6, r2 = [v, q, p, p, t2, v][mod], g = [t2, v, v, q, p, p][mod], b = [p, p, t2, v, v, q][mod];
  return { r: r2 * 255, g: g * 255, b: b * 255 };
}
__name(hsvToRgb, "hsvToRgb");
function rgbToHex(r2, g, b, allow3Char) {
  var hex2 = [
    pad2(Math.round(r2).toString(16)),
    pad2(Math.round(g).toString(16)),
    pad2(Math.round(b).toString(16))
  ];
  return allow3Char && hex2[0].startsWith(hex2[0].charAt(1)) && hex2[1].startsWith(hex2[1].charAt(1)) && hex2[2].startsWith(hex2[2].charAt(1)) ? hex2[0].charAt(0) + hex2[1].charAt(0) + hex2[2].charAt(0) : hex2.join("");
}
__name(rgbToHex, "rgbToHex");
function rgbaToHex(r2, g, b, a, allow4Char) {
  var hex2 = [
    pad2(Math.round(r2).toString(16)),
    pad2(Math.round(g).toString(16)),
    pad2(Math.round(b).toString(16)),
    pad2(convertDecimalToHex(a))
  ];
  return allow4Char && hex2[0].startsWith(hex2[0].charAt(1)) && hex2[1].startsWith(hex2[1].charAt(1)) && hex2[2].startsWith(hex2[2].charAt(1)) && hex2[3].startsWith(hex2[3].charAt(1)) ? hex2[0].charAt(0) + hex2[1].charAt(0) + hex2[2].charAt(0) + hex2[3].charAt(0) : hex2.join("");
}
__name(rgbaToHex, "rgbaToHex");
function convertDecimalToHex(d) {
  return Math.round(parseFloat(d) * 255).toString(16);
}
__name(convertDecimalToHex, "convertDecimalToHex");
function convertHexToDecimal(h) {
  return parseIntFromHex(h) / 255;
}
__name(convertHexToDecimal, "convertHexToDecimal");
function parseIntFromHex(val) {
  return parseInt(val, 16);
}
__name(parseIntFromHex, "parseIntFromHex");
function numberInputToObject(color) {
  return {
    r: color >> 16,
    g: (color & 65280) >> 8,
    b: color & 255
  };
}
__name(numberInputToObject, "numberInputToObject");
var names$1 = {
  aliceblue: "#f0f8ff",
  antiquewhite: "#faebd7",
  aqua: "#00ffff",
  aquamarine: "#7fffd4",
  azure: "#f0ffff",
  beige: "#f5f5dc",
  bisque: "#ffe4c4",
  black: "#000000",
  blanchedalmond: "#ffebcd",
  blue: "#0000ff",
  blueviolet: "#8a2be2",
  brown: "#a52a2a",
  burlywood: "#deb887",
  cadetblue: "#5f9ea0",
  chartreuse: "#7fff00",
  chocolate: "#d2691e",
  coral: "#ff7f50",
  cornflowerblue: "#6495ed",
  cornsilk: "#fff8dc",
  crimson: "#dc143c",
  cyan: "#00ffff",
  darkblue: "#00008b",
  darkcyan: "#008b8b",
  darkgoldenrod: "#b8860b",
  darkgray: "#a9a9a9",
  darkgreen: "#006400",
  darkgrey: "#a9a9a9",
  darkkhaki: "#bdb76b",
  darkmagenta: "#8b008b",
  darkolivegreen: "#556b2f",
  darkorange: "#ff8c00",
  darkorchid: "#9932cc",
  darkred: "#8b0000",
  darksalmon: "#e9967a",
  darkseagreen: "#8fbc8f",
  darkslateblue: "#483d8b",
  darkslategray: "#2f4f4f",
  darkslategrey: "#2f4f4f",
  darkturquoise: "#00ced1",
  darkviolet: "#9400d3",
  deeppink: "#ff1493",
  deepskyblue: "#00bfff",
  dimgray: "#696969",
  dimgrey: "#696969",
  dodgerblue: "#1e90ff",
  firebrick: "#b22222",
  floralwhite: "#fffaf0",
  forestgreen: "#228b22",
  fuchsia: "#ff00ff",
  gainsboro: "#dcdcdc",
  ghostwhite: "#f8f8ff",
  goldenrod: "#daa520",
  gold: "#ffd700",
  gray: "#808080",
  green: "#008000",
  greenyellow: "#adff2f",
  grey: "#808080",
  honeydew: "#f0fff0",
  hotpink: "#ff69b4",
  indianred: "#cd5c5c",
  indigo: "#4b0082",
  ivory: "#fffff0",
  khaki: "#f0e68c",
  lavenderblush: "#fff0f5",
  lavender: "#e6e6fa",
  lawngreen: "#7cfc00",
  lemonchiffon: "#fffacd",
  lightblue: "#add8e6",
  lightcoral: "#f08080",
  lightcyan: "#e0ffff",
  lightgoldenrodyellow: "#fafad2",
  lightgray: "#d3d3d3",
  lightgreen: "#90ee90",
  lightgrey: "#d3d3d3",
  lightpink: "#ffb6c1",
  lightsalmon: "#ffa07a",
  lightseagreen: "#20b2aa",
  lightskyblue: "#87cefa",
  lightslategray: "#778899",
  lightslategrey: "#778899",
  lightsteelblue: "#b0c4de",
  lightyellow: "#ffffe0",
  lime: "#00ff00",
  limegreen: "#32cd32",
  linen: "#faf0e6",
  magenta: "#ff00ff",
  maroon: "#800000",
  mediumaquamarine: "#66cdaa",
  mediumblue: "#0000cd",
  mediumorchid: "#ba55d3",
  mediumpurple: "#9370db",
  mediumseagreen: "#3cb371",
  mediumslateblue: "#7b68ee",
  mediumspringgreen: "#00fa9a",
  mediumturquoise: "#48d1cc",
  mediumvioletred: "#c71585",
  midnightblue: "#191970",
  mintcream: "#f5fffa",
  mistyrose: "#ffe4e1",
  moccasin: "#ffe4b5",
  navajowhite: "#ffdead",
  navy: "#000080",
  oldlace: "#fdf5e6",
  olive: "#808000",
  olivedrab: "#6b8e23",
  orange: "#ffa500",
  orangered: "#ff4500",
  orchid: "#da70d6",
  palegoldenrod: "#eee8aa",
  palegreen: "#98fb98",
  paleturquoise: "#afeeee",
  palevioletred: "#db7093",
  papayawhip: "#ffefd5",
  peachpuff: "#ffdab9",
  peru: "#cd853f",
  pink: "#ffc0cb",
  plum: "#dda0dd",
  powderblue: "#b0e0e6",
  purple: "#800080",
  rebeccapurple: "#663399",
  red: "#ff0000",
  rosybrown: "#bc8f8f",
  royalblue: "#4169e1",
  saddlebrown: "#8b4513",
  salmon: "#fa8072",
  sandybrown: "#f4a460",
  seagreen: "#2e8b57",
  seashell: "#fff5ee",
  sienna: "#a0522d",
  silver: "#c0c0c0",
  skyblue: "#87ceeb",
  slateblue: "#6a5acd",
  slategray: "#708090",
  slategrey: "#708090",
  snow: "#fffafa",
  springgreen: "#00ff7f",
  steelblue: "#4682b4",
  tan: "#d2b48c",
  teal: "#008080",
  thistle: "#d8bfd8",
  tomato: "#ff6347",
  turquoise: "#40e0d0",
  violet: "#ee82ee",
  wheat: "#f5deb3",
  white: "#ffffff",
  whitesmoke: "#f5f5f5",
  yellow: "#ffff00",
  yellowgreen: "#9acd32"
};
function inputToRGB(color) {
  var rgb = { r: 0, g: 0, b: 0 }, a = 1, s = null, v = null, l2 = null, ok = !1, format3 = !1;
  return typeof color == "string" && (color = stringInputToObject(color)), typeof color == "object" && (isValidCSSUnit(color.r) && isValidCSSUnit(color.g) && isValidCSSUnit(color.b) ? (rgb = rgbToRgb(color.r, color.g, color.b), ok = !0, format3 = String(color.r).substr(-1) === "%" ? "prgb" : "rgb") : isValidCSSUnit(color.h) && isValidCSSUnit(color.s) && isValidCSSUnit(color.v) ? (s = convertToPercentage(color.s), v = convertToPercentage(color.v), rgb = hsvToRgb(color.h, s, v), ok = !0, format3 = "hsv") : isValidCSSUnit(color.h) && isValidCSSUnit(color.s) && isValidCSSUnit(color.l) && (s = convertToPercentage(color.s), l2 = convertToPercentage(color.l), rgb = hslToRgb(color.h, s, l2), ok = !0, format3 = "hsl"), Object.prototype.hasOwnProperty.call(color, "a") && (a = color.a)), a = boundAlpha(a), {
    ok,
    format: color.format || format3,
    r: Math.min(255, Math.max(rgb.r, 0)),
    g: Math.min(255, Math.max(rgb.g, 0)),
    b: Math.min(255, Math.max(rgb.b, 0)),
    a
  };
}
__name(inputToRGB, "inputToRGB");
var CSS_INTEGER = "[-\\+]?\\d+%?", CSS_NUMBER = "[-\\+]?\\d*\\.\\d+%?", CSS_UNIT = "(?:".concat(CSS_NUMBER, ")|(?:").concat(CSS_INTEGER, ")"), PERMISSIVE_MATCH3 = "[\\s|\\(]+(".concat(CSS_UNIT, ")[,|\\s]+(").concat(CSS_UNIT, ")[,|\\s]+(").concat(CSS_UNIT, ")\\s*\\)?"), PERMISSIVE_MATCH4 = "[\\s|\\(]+(".concat(CSS_UNIT, ")[,|\\s]+(").concat(CSS_UNIT, ")[,|\\s]+(").concat(CSS_UNIT, ")[,|\\s]+(").concat(CSS_UNIT, ")\\s*\\)?"), matchers = {
  CSS_UNIT: new RegExp(CSS_UNIT),
  rgb: new RegExp("rgb" + PERMISSIVE_MATCH3),
  rgba: new RegExp("rgba" + PERMISSIVE_MATCH4),
  hsl: new RegExp("hsl" + PERMISSIVE_MATCH3),
  hsla: new RegExp("hsla" + PERMISSIVE_MATCH4),
  hsv: new RegExp("hsv" + PERMISSIVE_MATCH3),
  hsva: new RegExp("hsva" + PERMISSIVE_MATCH4),
  hex3: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
  hex6: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/,
  hex4: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
  hex8: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/
};
function stringInputToObject(color) {
  if (color = color.trim().toLowerCase(), color.length === 0)
    return !1;
  var named = !1;
  if (names$1[color])
    color = names$1[color], named = !0;
  else if (color === "transparent")
    return { r: 0, g: 0, b: 0, a: 0, format: "name" };
  var match2 = matchers.rgb.exec(color);
  return match2 ? { r: match2[1], g: match2[2], b: match2[3] } : (match2 = matchers.rgba.exec(color), match2 ? { r: match2[1], g: match2[2], b: match2[3], a: match2[4] } : (match2 = matchers.hsl.exec(color), match2 ? { h: match2[1], s: match2[2], l: match2[3] } : (match2 = matchers.hsla.exec(color), match2 ? { h: match2[1], s: match2[2], l: match2[3], a: match2[4] } : (match2 = matchers.hsv.exec(color), match2 ? { h: match2[1], s: match2[2], v: match2[3] } : (match2 = matchers.hsva.exec(color), match2 ? { h: match2[1], s: match2[2], v: match2[3], a: match2[4] } : (match2 = matchers.hex8.exec(color), match2 ? {
    r: parseIntFromHex(match2[1]),
    g: parseIntFromHex(match2[2]),
    b: parseIntFromHex(match2[3]),
    a: convertHexToDecimal(match2[4]),
    format: named ? "name" : "hex8"
  } : (match2 = matchers.hex6.exec(color), match2 ? {
    r: parseIntFromHex(match2[1]),
    g: parseIntFromHex(match2[2]),
    b: parseIntFromHex(match2[3]),
    format: named ? "name" : "hex"
  } : (match2 = matchers.hex4.exec(color), match2 ? {
    r: parseIntFromHex(match2[1] + match2[1]),
    g: parseIntFromHex(match2[2] + match2[2]),
    b: parseIntFromHex(match2[3] + match2[3]),
    a: convertHexToDecimal(match2[4] + match2[4]),
    format: named ? "name" : "hex8"
  } : (match2 = matchers.hex3.exec(color), match2 ? {
    r: parseIntFromHex(match2[1] + match2[1]),
    g: parseIntFromHex(match2[2] + match2[2]),
    b: parseIntFromHex(match2[3] + match2[3]),
    format: named ? "name" : "hex"
  } : !1)))))))));
}
__name(stringInputToObject, "stringInputToObject");
function isValidCSSUnit(color) {
  return !!matchers.CSS_UNIT.exec(String(color));
}
__name(isValidCSSUnit, "isValidCSSUnit");
var TinyColor = (
  /** @class */
  function() {
    function TinyColor2(color, opts) {
      color === void 0 && (color = ""), opts === void 0 && (opts = {});
      var _a;
      if (color instanceof TinyColor2)
        return color;
      typeof color == "number" && (color = numberInputToObject(color)), this.originalInput = color;
      var rgb = inputToRGB(color);
      this.originalInput = color, this.r = rgb.r, this.g = rgb.g, this.b = rgb.b, this.a = rgb.a, this.roundA = Math.round(100 * this.a) / 100, this.format = (_a = opts.format) !== null && _a !== void 0 ? _a : rgb.format, this.gradientType = opts.gradientType, this.r < 1 && (this.r = Math.round(this.r)), this.g < 1 && (this.g = Math.round(this.g)), this.b < 1 && (this.b = Math.round(this.b)), this.isValid = rgb.ok;
    }
    return __name(TinyColor2, "TinyColor"), TinyColor2.prototype.isDark = function() {
      return this.getBrightness() < 128;
    }, TinyColor2.prototype.isLight = function() {
      return !this.isDark();
    }, TinyColor2.prototype.getBrightness = function() {
      var rgb = this.toRgb();
      return (rgb.r * 299 + rgb.g * 587 + rgb.b * 114) / 1e3;
    }, TinyColor2.prototype.getLuminance = function() {
      var rgb = this.toRgb(), R, G, B, RsRGB = rgb.r / 255, GsRGB = rgb.g / 255, BsRGB = rgb.b / 255;
      return RsRGB <= 0.03928 ? R = RsRGB / 12.92 : R = Math.pow((RsRGB + 0.055) / 1.055, 2.4), GsRGB <= 0.03928 ? G = GsRGB / 12.92 : G = Math.pow((GsRGB + 0.055) / 1.055, 2.4), BsRGB <= 0.03928 ? B = BsRGB / 12.92 : B = Math.pow((BsRGB + 0.055) / 1.055, 2.4), 0.2126 * R + 0.7152 * G + 0.0722 * B;
    }, TinyColor2.prototype.getAlpha = function() {
      return this.a;
    }, TinyColor2.prototype.setAlpha = function(alpha) {
      return this.a = boundAlpha(alpha), this.roundA = Math.round(100 * this.a) / 100, this;
    }, TinyColor2.prototype.isMonochrome = function() {
      var s = this.toHsl().s;
      return s === 0;
    }, TinyColor2.prototype.toHsv = function() {
      var hsv = rgbToHsv(this.r, this.g, this.b);
      return { h: hsv.h * 360, s: hsv.s, v: hsv.v, a: this.a };
    }, TinyColor2.prototype.toHsvString = function() {
      var hsv = rgbToHsv(this.r, this.g, this.b), h = Math.round(hsv.h * 360), s = Math.round(hsv.s * 100), v = Math.round(hsv.v * 100);
      return this.a === 1 ? "hsv(".concat(h, ", ").concat(s, "%, ").concat(v, "%)") : "hsva(".concat(h, ", ").concat(s, "%, ").concat(v, "%, ").concat(this.roundA, ")");
    }, TinyColor2.prototype.toHsl = function() {
      var hsl = rgbToHsl(this.r, this.g, this.b);
      return { h: hsl.h * 360, s: hsl.s, l: hsl.l, a: this.a };
    }, TinyColor2.prototype.toHslString = function() {
      var hsl = rgbToHsl(this.r, this.g, this.b), h = Math.round(hsl.h * 360), s = Math.round(hsl.s * 100), l2 = Math.round(hsl.l * 100);
      return this.a === 1 ? "hsl(".concat(h, ", ").concat(s, "%, ").concat(l2, "%)") : "hsla(".concat(h, ", ").concat(s, "%, ").concat(l2, "%, ").concat(this.roundA, ")");
    }, TinyColor2.prototype.toHex = function(allow3Char) {
      return allow3Char === void 0 && (allow3Char = !1), rgbToHex(this.r, this.g, this.b, allow3Char);
    }, TinyColor2.prototype.toHexString = function(allow3Char) {
      return allow3Char === void 0 && (allow3Char = !1), "#" + this.toHex(allow3Char);
    }, TinyColor2.prototype.toHex8 = function(allow4Char) {
      return allow4Char === void 0 && (allow4Char = !1), rgbaToHex(this.r, this.g, this.b, this.a, allow4Char);
    }, TinyColor2.prototype.toHex8String = function(allow4Char) {
      return allow4Char === void 0 && (allow4Char = !1), "#" + this.toHex8(allow4Char);
    }, TinyColor2.prototype.toHexShortString = function(allowShortChar) {
      return allowShortChar === void 0 && (allowShortChar = !1), this.a === 1 ? this.toHexString(allowShortChar) : this.toHex8String(allowShortChar);
    }, TinyColor2.prototype.toRgb = function() {
      return {
        r: Math.round(this.r),
        g: Math.round(this.g),
        b: Math.round(this.b),
        a: this.a
      };
    }, TinyColor2.prototype.toRgbString = function() {
      var r2 = Math.round(this.r), g = Math.round(this.g), b = Math.round(this.b);
      return this.a === 1 ? "rgb(".concat(r2, ", ").concat(g, ", ").concat(b, ")") : "rgba(".concat(r2, ", ").concat(g, ", ").concat(b, ", ").concat(this.roundA, ")");
    }, TinyColor2.prototype.toPercentageRgb = function() {
      var fmt = /* @__PURE__ */ __name(function(x) {
        return "".concat(Math.round(bound01(x, 255) * 100), "%");
      }, "fmt");
      return {
        r: fmt(this.r),
        g: fmt(this.g),
        b: fmt(this.b),
        a: this.a
      };
    }, TinyColor2.prototype.toPercentageRgbString = function() {
      var rnd = /* @__PURE__ */ __name(function(x) {
        return Math.round(bound01(x, 255) * 100);
      }, "rnd");
      return this.a === 1 ? "rgb(".concat(rnd(this.r), "%, ").concat(rnd(this.g), "%, ").concat(rnd(this.b), "%)") : "rgba(".concat(rnd(this.r), "%, ").concat(rnd(this.g), "%, ").concat(rnd(this.b), "%, ").concat(this.roundA, ")");
    }, TinyColor2.prototype.toName = function() {
      if (this.a === 0)
        return "transparent";
      if (this.a < 1)
        return !1;
      for (var hex2 = "#" + rgbToHex(this.r, this.g, this.b, !1), _i = 0, _a = Object.entries(names$1); _i < _a.length; _i++) {
        var _b = _a[_i], key = _b[0], value = _b[1];
        if (hex2 === value)
          return key;
      }
      return !1;
    }, TinyColor2.prototype.toString = function(format3) {
      var formatSet = !!format3;
      format3 = format3 ?? this.format;
      var formattedString = !1, hasAlpha = this.a < 1 && this.a >= 0, needsAlphaFormat = !formatSet && hasAlpha && (format3.startsWith("hex") || format3 === "name");
      return needsAlphaFormat ? format3 === "name" && this.a === 0 ? this.toName() : this.toRgbString() : (format3 === "rgb" && (formattedString = this.toRgbString()), format3 === "prgb" && (formattedString = this.toPercentageRgbString()), (format3 === "hex" || format3 === "hex6") && (formattedString = this.toHexString()), format3 === "hex3" && (formattedString = this.toHexString(!0)), format3 === "hex4" && (formattedString = this.toHex8String(!0)), format3 === "hex8" && (formattedString = this.toHex8String()), format3 === "name" && (formattedString = this.toName()), format3 === "hsl" && (formattedString = this.toHslString()), format3 === "hsv" && (formattedString = this.toHsvString()), formattedString || this.toHexString());
    }, TinyColor2.prototype.toNumber = function() {
      return (Math.round(this.r) << 16) + (Math.round(this.g) << 8) + Math.round(this.b);
    }, TinyColor2.prototype.clone = function() {
      return new TinyColor2(this.toString());
    }, TinyColor2.prototype.lighten = function(amount) {
      amount === void 0 && (amount = 10);
      var hsl = this.toHsl();
      return hsl.l += amount / 100, hsl.l = clamp01(hsl.l), new TinyColor2(hsl);
    }, TinyColor2.prototype.brighten = function(amount) {
      amount === void 0 && (amount = 10);
      var rgb = this.toRgb();
      return rgb.r = Math.max(0, Math.min(255, rgb.r - Math.round(255 * -(amount / 100)))), rgb.g = Math.max(0, Math.min(255, rgb.g - Math.round(255 * -(amount / 100)))), rgb.b = Math.max(0, Math.min(255, rgb.b - Math.round(255 * -(amount / 100)))), new TinyColor2(rgb);
    }, TinyColor2.prototype.darken = function(amount) {
      amount === void 0 && (amount = 10);
      var hsl = this.toHsl();
      return hsl.l -= amount / 100, hsl.l = clamp01(hsl.l), new TinyColor2(hsl);
    }, TinyColor2.prototype.tint = function(amount) {
      return amount === void 0 && (amount = 10), this.mix("white", amount);
    }, TinyColor2.prototype.shade = function(amount) {
      return amount === void 0 && (amount = 10), this.mix("black", amount);
    }, TinyColor2.prototype.desaturate = function(amount) {
      amount === void 0 && (amount = 10);
      var hsl = this.toHsl();
      return hsl.s -= amount / 100, hsl.s = clamp01(hsl.s), new TinyColor2(hsl);
    }, TinyColor2.prototype.saturate = function(amount) {
      amount === void 0 && (amount = 10);
      var hsl = this.toHsl();
      return hsl.s += amount / 100, hsl.s = clamp01(hsl.s), new TinyColor2(hsl);
    }, TinyColor2.prototype.greyscale = function() {
      return this.desaturate(100);
    }, TinyColor2.prototype.spin = function(amount) {
      var hsl = this.toHsl(), hue = (hsl.h + amount) % 360;
      return hsl.h = hue < 0 ? 360 + hue : hue, new TinyColor2(hsl);
    }, TinyColor2.prototype.mix = function(color, amount) {
      amount === void 0 && (amount = 50);
      var rgb1 = this.toRgb(), rgb2 = new TinyColor2(color).toRgb(), p = amount / 100, rgba = {
        r: (rgb2.r - rgb1.r) * p + rgb1.r,
        g: (rgb2.g - rgb1.g) * p + rgb1.g,
        b: (rgb2.b - rgb1.b) * p + rgb1.b,
        a: (rgb2.a - rgb1.a) * p + rgb1.a
      };
      return new TinyColor2(rgba);
    }, TinyColor2.prototype.analogous = function(results, slices) {
      results === void 0 && (results = 6), slices === void 0 && (slices = 30);
      var hsl = this.toHsl(), part = 360 / slices, ret = [this];
      for (hsl.h = (hsl.h - (part * results >> 1) + 720) % 360; --results; )
        hsl.h = (hsl.h + part) % 360, ret.push(new TinyColor2(hsl));
      return ret;
    }, TinyColor2.prototype.complement = function() {
      var hsl = this.toHsl();
      return hsl.h = (hsl.h + 180) % 360, new TinyColor2(hsl);
    }, TinyColor2.prototype.monochromatic = function(results) {
      results === void 0 && (results = 6);
      for (var hsv = this.toHsv(), h = hsv.h, s = hsv.s, v = hsv.v, res = [], modification = 1 / results; results--; )
        res.push(new TinyColor2({ h, s, v })), v = (v + modification) % 1;
      return res;
    }, TinyColor2.prototype.splitcomplement = function() {
      var hsl = this.toHsl(), h = hsl.h;
      return [
        this,
        new TinyColor2({ h: (h + 72) % 360, s: hsl.s, l: hsl.l }),
        new TinyColor2({ h: (h + 216) % 360, s: hsl.s, l: hsl.l })
      ];
    }, TinyColor2.prototype.onBackground = function(background) {
      var fg = this.toRgb(), bg = new TinyColor2(background).toRgb(), alpha = fg.a + bg.a * (1 - fg.a);
      return new TinyColor2({
        r: (fg.r * fg.a + bg.r * bg.a * (1 - fg.a)) / alpha,
        g: (fg.g * fg.a + bg.g * bg.a * (1 - fg.a)) / alpha,
        b: (fg.b * fg.a + bg.b * bg.a * (1 - fg.a)) / alpha,
        a: alpha
      });
    }, TinyColor2.prototype.triad = function() {
      return this.polyad(3);
    }, TinyColor2.prototype.tetrad = function() {
      return this.polyad(4);
    }, TinyColor2.prototype.polyad = function(n2) {
      for (var hsl = this.toHsl(), h = hsl.h, result = [this], increment = 360 / n2, i = 1; i < n2; i++)
        result.push(new TinyColor2({ h: (h + i * increment) % 360, s: hsl.s, l: hsl.l }));
      return result;
    }, TinyColor2.prototype.equals = function(color) {
      return this.toRgbString() === new TinyColor2(color).toRgbString();
    }, TinyColor2;
  }()
);
function genColorMapToken(seed, _ref) {
  let {
    generateColorPalettes: generateColorPalettes2,
    generateNeutralColorPalettes: generateNeutralColorPalettes2
  } = _ref;
  const {
    colorSuccess: colorSuccessBase,
    colorWarning: colorWarningBase,
    colorError: colorErrorBase,
    colorInfo: colorInfoBase,
    colorPrimary: colorPrimaryBase,
    colorBgBase,
    colorTextBase
  } = seed, primaryColors = generateColorPalettes2(colorPrimaryBase), successColors = generateColorPalettes2(colorSuccessBase), warningColors = generateColorPalettes2(colorWarningBase), errorColors = generateColorPalettes2(colorErrorBase), infoColors = generateColorPalettes2(colorInfoBase), neutralColors = generateNeutralColorPalettes2(colorBgBase, colorTextBase), colorLink = seed.colorLink || seed.colorInfo, linkColors = generateColorPalettes2(colorLink), colorErrorBgFilledHover = new TinyColor(errorColors[1]).mix(new TinyColor(errorColors[3]), 50).toHexString();
  return Object.assign(Object.assign({}, neutralColors), {
    colorPrimaryBg: primaryColors[1],
    colorPrimaryBgHover: primaryColors[2],
    colorPrimaryBorder: primaryColors[3],
    colorPrimaryBorderHover: primaryColors[4],
    colorPrimaryHover: primaryColors[5],
    colorPrimary: primaryColors[6],
    colorPrimaryActive: primaryColors[7],
    colorPrimaryTextHover: primaryColors[8],
    colorPrimaryText: primaryColors[9],
    colorPrimaryTextActive: primaryColors[10],
    colorSuccessBg: successColors[1],
    colorSuccessBgHover: successColors[2],
    colorSuccessBorder: successColors[3],
    colorSuccessBorderHover: successColors[4],
    colorSuccessHover: successColors[4],
    colorSuccess: successColors[6],
    colorSuccessActive: successColors[7],
    colorSuccessTextHover: successColors[8],
    colorSuccessText: successColors[9],
    colorSuccessTextActive: successColors[10],
    colorErrorBg: errorColors[1],
    colorErrorBgHover: errorColors[2],
    colorErrorBgFilledHover,
    colorErrorBgActive: errorColors[3],
    colorErrorBorder: errorColors[3],
    colorErrorBorderHover: errorColors[4],
    colorErrorHover: errorColors[5],
    colorError: errorColors[6],
    colorErrorActive: errorColors[7],
    colorErrorTextHover: errorColors[8],
    colorErrorText: errorColors[9],
    colorErrorTextActive: errorColors[10],
    colorWarningBg: warningColors[1],
    colorWarningBgHover: warningColors[2],
    colorWarningBorder: warningColors[3],
    colorWarningBorderHover: warningColors[4],
    colorWarningHover: warningColors[4],
    colorWarning: warningColors[6],
    colorWarningActive: warningColors[7],
    colorWarningTextHover: warningColors[8],
    colorWarningText: warningColors[9],
    colorWarningTextActive: warningColors[10],
    colorInfoBg: infoColors[1],
    colorInfoBgHover: infoColors[2],
    colorInfoBorder: infoColors[3],
    colorInfoBorderHover: infoColors[4],
    colorInfoHover: infoColors[4],
    colorInfo: infoColors[6],
    colorInfoActive: infoColors[7],
    colorInfoTextHover: infoColors[8],
    colorInfoText: infoColors[9],
    colorInfoTextActive: infoColors[10],
    colorLinkHover: linkColors[4],
    colorLink: linkColors[6],
    colorLinkActive: linkColors[7],
    colorBgMask: new TinyColor("#000").setAlpha(0.45).toRgbString(),
    colorWhite: "#fff"
  });
}
__name(genColorMapToken, "genColorMapToken");
const genRadius = /* @__PURE__ */ __name((radiusBase) => {
  let radiusLG = radiusBase, radiusSM = radiusBase, radiusXS = radiusBase, radiusOuter = radiusBase;
  return radiusBase < 6 && radiusBase >= 5 ? radiusLG = radiusBase + 1 : radiusBase < 16 && radiusBase >= 6 ? radiusLG = radiusBase + 2 : radiusBase >= 16 && (radiusLG = 16), radiusBase < 7 && radiusBase >= 5 ? radiusSM = 4 : radiusBase < 8 && radiusBase >= 7 ? radiusSM = 5 : radiusBase < 14 && radiusBase >= 8 ? radiusSM = 6 : radiusBase < 16 && radiusBase >= 14 ? radiusSM = 7 : radiusBase >= 16 && (radiusSM = 8), radiusBase < 6 && radiusBase >= 2 ? radiusXS = 1 : radiusBase >= 6 && (radiusXS = 2), radiusBase > 4 && radiusBase < 8 ? radiusOuter = 4 : radiusBase >= 8 && (radiusOuter = 6), {
    borderRadius: radiusBase,
    borderRadiusXS: radiusXS,
    borderRadiusSM: radiusSM,
    borderRadiusLG: radiusLG,
    borderRadiusOuter: radiusOuter
  };
}, "genRadius");
function genCommonMapToken(token2) {
  const {
    motionUnit,
    motionBase,
    borderRadius,
    lineWidth
  } = token2;
  return Object.assign({
    // motion
    motionDurationFast: `${(motionBase + motionUnit).toFixed(1)}s`,
    motionDurationMid: `${(motionBase + motionUnit * 2).toFixed(1)}s`,
    motionDurationSlow: `${(motionBase + motionUnit * 3).toFixed(1)}s`,
    // line
    lineWidthBold: lineWidth + 1
  }, genRadius(borderRadius));
}
__name(genCommonMapToken, "genCommonMapToken");
const genControlHeight = /* @__PURE__ */ __name((token2) => {
  const {
    controlHeight
  } = token2;
  return {
    controlHeightSM: controlHeight * 0.75,
    controlHeightXS: controlHeight * 0.5,
    controlHeightLG: controlHeight * 1.25
  };
}, "genControlHeight");
function getLineHeight(fontSize) {
  return (fontSize + 8) / fontSize;
}
__name(getLineHeight, "getLineHeight");
function getFontSizes(base) {
  const fontSizes = new Array(10).fill(null).map((_2, index2) => {
    const i = index2 - 1, baseSize = base * Math.pow(Math.E, i / 5), intSize = index2 > 1 ? Math.floor(baseSize) : Math.ceil(baseSize);
    return Math.floor(intSize / 2) * 2;
  });
  return fontSizes[1] = base, fontSizes.map((size) => ({
    size,
    lineHeight: getLineHeight(size)
  }));
}
__name(getFontSizes, "getFontSizes");
const genFontMapToken = /* @__PURE__ */ __name((fontSize) => {
  const fontSizePairs = getFontSizes(fontSize), fontSizes = fontSizePairs.map((pair) => pair.size), lineHeights = fontSizePairs.map((pair) => pair.lineHeight), fontSizeMD = fontSizes[1], fontSizeSM = fontSizes[0], fontSizeLG = fontSizes[2], lineHeight = lineHeights[1], lineHeightSM = lineHeights[0], lineHeightLG = lineHeights[2];
  return {
    fontSizeSM,
    fontSize: fontSizeMD,
    fontSizeLG,
    fontSizeXL: fontSizes[3],
    fontSizeHeading1: fontSizes[6],
    fontSizeHeading2: fontSizes[5],
    fontSizeHeading3: fontSizes[4],
    fontSizeHeading4: fontSizes[3],
    fontSizeHeading5: fontSizes[2],
    lineHeight,
    lineHeightLG,
    lineHeightSM,
    fontHeight: Math.round(lineHeight * fontSizeMD),
    fontHeightLG: Math.round(lineHeightLG * fontSizeLG),
    fontHeightSM: Math.round(lineHeightSM * fontSizeSM),
    lineHeightHeading1: lineHeights[6],
    lineHeightHeading2: lineHeights[5],
    lineHeightHeading3: lineHeights[4],
    lineHeightHeading4: lineHeights[3],
    lineHeightHeading5: lineHeights[2]
  };
}, "genFontMapToken");
function genSizeMapToken(token2) {
  const {
    sizeUnit,
    sizeStep
  } = token2;
  return {
    sizeXXL: sizeUnit * (sizeStep + 8),
    // 48
    sizeXL: sizeUnit * (sizeStep + 4),
    // 32
    sizeLG: sizeUnit * (sizeStep + 2),
    // 24
    sizeMD: sizeUnit * (sizeStep + 1),
    // 20
    sizeMS: sizeUnit * sizeStep,
    // 16
    size: sizeUnit * sizeStep,
    // 16
    sizeSM: sizeUnit * (sizeStep - 1),
    // 12
    sizeXS: sizeUnit * (sizeStep - 2),
    // 8
    sizeXXS: sizeUnit * (sizeStep - 3)
    // 4
  };
}
__name(genSizeMapToken, "genSizeMapToken");
const getAlphaColor$2 = /* @__PURE__ */ __name((baseColor, alpha) => new TinyColor(baseColor).setAlpha(alpha).toRgbString(), "getAlphaColor$2"), getSolidColor$1 = /* @__PURE__ */ __name((baseColor, brightness) => new TinyColor(baseColor).darken(brightness).toHexString(), "getSolidColor$1"), generateColorPalettes$1 = /* @__PURE__ */ __name((baseColor) => {
  const colors = generate$1(baseColor);
  return {
    1: colors[0],
    2: colors[1],
    3: colors[2],
    4: colors[3],
    5: colors[4],
    6: colors[5],
    7: colors[6],
    8: colors[4],
    9: colors[5],
    10: colors[6]
    // 8: colors[7],
    // 9: colors[8],
    // 10: colors[9],
  };
}, "generateColorPalettes$1"), generateNeutralColorPalettes$1 = /* @__PURE__ */ __name((bgBaseColor, textBaseColor) => {
  const colorBgBase = bgBaseColor || "#fff", colorTextBase = textBaseColor || "#000";
  return {
    colorBgBase,
    colorTextBase,
    colorText: getAlphaColor$2(colorTextBase, 0.88),
    colorTextSecondary: getAlphaColor$2(colorTextBase, 0.65),
    colorTextTertiary: getAlphaColor$2(colorTextBase, 0.45),
    colorTextQuaternary: getAlphaColor$2(colorTextBase, 0.25),
    colorFill: getAlphaColor$2(colorTextBase, 0.15),
    colorFillSecondary: getAlphaColor$2(colorTextBase, 0.06),
    colorFillTertiary: getAlphaColor$2(colorTextBase, 0.04),
    colorFillQuaternary: getAlphaColor$2(colorTextBase, 0.02),
    colorBgSolid: getAlphaColor$2(colorTextBase, 1),
    colorBgSolidHover: getAlphaColor$2(colorTextBase, 0.75),
    colorBgSolidActive: getAlphaColor$2(colorTextBase, 0.95),
    colorBgLayout: getSolidColor$1(colorBgBase, 4),
    colorBgContainer: getSolidColor$1(colorBgBase, 0),
    colorBgElevated: getSolidColor$1(colorBgBase, 0),
    colorBgSpotlight: getAlphaColor$2(colorTextBase, 0.85),
    colorBgBlur: "transparent",
    colorBorder: getSolidColor$1(colorBgBase, 15),
    colorBorderSecondary: getSolidColor$1(colorBgBase, 6)
  };
}, "generateNeutralColorPalettes$1");
function derivative$1(token2) {
  presetPrimaryColors.pink = presetPrimaryColors.magenta, presetPalettes.pink = presetPalettes.magenta;
  const colorPalettes = Object.keys(defaultPresetColors).map((colorKey) => {
    const colors = token2[colorKey] === presetPrimaryColors[colorKey] ? presetPalettes[colorKey] : generate$1(token2[colorKey]);
    return new Array(10).fill(1).reduce((prev2, _2, i) => (prev2[`${colorKey}-${i + 1}`] = colors[i], prev2[`${colorKey}${i + 1}`] = colors[i], prev2), {});
  }).reduce((prev2, cur) => (prev2 = Object.assign(Object.assign({}, prev2), cur), prev2), {});
  return Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, token2), colorPalettes), genColorMapToken(token2, {
    generateColorPalettes: generateColorPalettes$1,
    generateNeutralColorPalettes: generateNeutralColorPalettes$1
  })), genFontMapToken(token2.fontSize)), genSizeMapToken(token2)), genControlHeight(token2)), genCommonMapToken(token2));
}
__name(derivative$1, "derivative$1");
const defaultTheme = createTheme(derivative$1), defaultConfig = {
  token: seedToken,
  override: {
    override: seedToken
  },
  hashed: !0
}, DesignTokenContext = /* @__PURE__ */ React__default.createContext(defaultConfig), defaultPrefixCls = "ant", defaultIconPrefixCls = "anticon", Variants = ["outlined", "borderless", "filled"], defaultGetPrefixCls = /* @__PURE__ */ __name((suffixCls, customizePrefixCls) => customizePrefixCls || (suffixCls ? `${defaultPrefixCls}-${suffixCls}` : defaultPrefixCls), "defaultGetPrefixCls"), ConfigContext = /* @__PURE__ */ React.createContext({
  // We provide a default function for Context without provider
  getPrefixCls: defaultGetPrefixCls,
  iconPrefixCls: defaultIconPrefixCls
}), {
  Consumer: ConfigConsumer
} = ConfigContext, dynamicStyleMark = `-ant-${Date.now()}-${Math.random()}`;
function getStyle$1(globalPrefixCls2, theme2) {
  const variables = {}, formatColor = /* @__PURE__ */ __name((color, updater) => {
    let clone = color.clone();
    return clone = (updater == null ? void 0 : updater(clone)) || clone, clone.toRgbString();
  }, "formatColor"), fillColor = /* @__PURE__ */ __name((colorVal, type4) => {
    const baseColor = new TinyColor(colorVal), colorPalettes = generate$1(baseColor.toRgbString());
    variables[`${type4}-color`] = formatColor(baseColor), variables[`${type4}-color-disabled`] = colorPalettes[1], variables[`${type4}-color-hover`] = colorPalettes[4], variables[`${type4}-color-active`] = colorPalettes[6], variables[`${type4}-color-outline`] = baseColor.clone().setAlpha(0.2).toRgbString(), variables[`${type4}-color-deprecated-bg`] = colorPalettes[0], variables[`${type4}-color-deprecated-border`] = colorPalettes[2];
  }, "fillColor");
  if (theme2.primaryColor) {
    fillColor(theme2.primaryColor, "primary");
    const primaryColor = new TinyColor(theme2.primaryColor), primaryColors = generate$1(primaryColor.toRgbString());
    primaryColors.forEach((color, index2) => {
      variables[`primary-${index2 + 1}`] = color;
    }), variables["primary-color-deprecated-l-35"] = formatColor(primaryColor, (c) => c.lighten(35)), variables["primary-color-deprecated-l-20"] = formatColor(primaryColor, (c) => c.lighten(20)), variables["primary-color-deprecated-t-20"] = formatColor(primaryColor, (c) => c.tint(20)), variables["primary-color-deprecated-t-50"] = formatColor(primaryColor, (c) => c.tint(50)), variables["primary-color-deprecated-f-12"] = formatColor(primaryColor, (c) => c.setAlpha(c.getAlpha() * 0.12));
    const primaryActiveColor = new TinyColor(primaryColors[0]);
    variables["primary-color-active-deprecated-f-30"] = formatColor(primaryActiveColor, (c) => c.setAlpha(c.getAlpha() * 0.3)), variables["primary-color-active-deprecated-d-02"] = formatColor(primaryActiveColor, (c) => c.darken(2));
  }
  return theme2.successColor && fillColor(theme2.successColor, "success"), theme2.warningColor && fillColor(theme2.warningColor, "warning"), theme2.errorColor && fillColor(theme2.errorColor, "error"), theme2.infoColor && fillColor(theme2.infoColor, "info"), `
  :root {
    ${Object.keys(variables).map((key) => `--${globalPrefixCls2}-${key}: ${variables[key]};`).join(`
`)}
  }
  `.trim();
}
__name(getStyle$1, "getStyle$1");
function registerTheme$1(globalPrefixCls2, theme2) {
  const style2 = getStyle$1(globalPrefixCls2, theme2);
  canUseDom() ? updateCSS(style2, `${dynamicStyleMark}-dynamic-theme`) : process.env.NODE_ENV !== "production" && warning$2(!1, "ConfigProvider", "SSR do not support dynamic theme with css variables.");
}
__name(registerTheme$1, "registerTheme$1");
const DisabledContext = /* @__PURE__ */ React.createContext(!1), DisabledContextProvider = /* @__PURE__ */ __name((_ref) => {
  let {
    children,
    disabled
  } = _ref;
  const originDisabled = React.useContext(DisabledContext);
  return /* @__PURE__ */ React.createElement(DisabledContext.Provider, {
    value: disabled ?? originDisabled
  }, children);
}, "DisabledContextProvider"), SizeContext = /* @__PURE__ */ React.createContext(void 0), SizeContextProvider = /* @__PURE__ */ __name((_ref) => {
  let {
    children,
    size
  } = _ref;
  const originSize = React.useContext(SizeContext);
  return /* @__PURE__ */ React.createElement(SizeContext.Provider, {
    value: size || originSize
  }, children);
}, "SizeContextProvider");
function useConfig() {
  const componentDisabled = useContext$1(DisabledContext), componentSize = useContext$1(SizeContext);
  return {
    componentDisabled,
    componentSize
  };
}
__name(useConfig, "useConfig");
var AbstractCalculator = /* @__PURE__ */ _createClass$1(/* @__PURE__ */ __name(function AbstractCalculator2() {
  _classCallCheck$1(this, AbstractCalculator2);
}, "AbstractCalculator")), CALC_UNIT = "CALC_UNIT", regexp$1 = new RegExp(CALC_UNIT, "g");
function unit(value) {
  return typeof value == "number" ? "".concat(value).concat(CALC_UNIT) : value;
}
__name(unit, "unit");
var CSSCalculator = /* @__PURE__ */ function(_AbstractCalculator) {
  _inherits(CSSCalculator2, _AbstractCalculator);
  var _super = _createSuper(CSSCalculator2);
  function CSSCalculator2(num, unitlessCssVar) {
    var _this;
    _classCallCheck$1(this, CSSCalculator2), _this = _super.call(this), _defineProperty$2(_assertThisInitialized(_this), "result", ""), _defineProperty$2(_assertThisInitialized(_this), "unitlessCssVar", void 0), _defineProperty$2(_assertThisInitialized(_this), "lowPriority", void 0);
    var numType = _typeof$4(num);
    return _this.unitlessCssVar = unitlessCssVar, num instanceof CSSCalculator2 ? _this.result = "(".concat(num.result, ")") : numType === "number" ? _this.result = unit(num) : numType === "string" && (_this.result = num), _this;
  }
  return __name(CSSCalculator2, "CSSCalculator"), _createClass$1(CSSCalculator2, [{
    key: "add",
    value: /* @__PURE__ */ __name(function(num) {
      return num instanceof CSSCalculator2 ? this.result = "".concat(this.result, " + ").concat(num.getResult()) : (typeof num == "number" || typeof num == "string") && (this.result = "".concat(this.result, " + ").concat(unit(num))), this.lowPriority = !0, this;
    }, "add")
  }, {
    key: "sub",
    value: /* @__PURE__ */ __name(function(num) {
      return num instanceof CSSCalculator2 ? this.result = "".concat(this.result, " - ").concat(num.getResult()) : (typeof num == "number" || typeof num == "string") && (this.result = "".concat(this.result, " - ").concat(unit(num))), this.lowPriority = !0, this;
    }, "sub")
  }, {
    key: "mul",
    value: /* @__PURE__ */ __name(function(num) {
      return this.lowPriority && (this.result = "(".concat(this.result, ")")), num instanceof CSSCalculator2 ? this.result = "".concat(this.result, " * ").concat(num.getResult(!0)) : (typeof num == "number" || typeof num == "string") && (this.result = "".concat(this.result, " * ").concat(num)), this.lowPriority = !1, this;
    }, "mul")
  }, {
    key: "div",
    value: /* @__PURE__ */ __name(function(num) {
      return this.lowPriority && (this.result = "(".concat(this.result, ")")), num instanceof CSSCalculator2 ? this.result = "".concat(this.result, " / ").concat(num.getResult(!0)) : (typeof num == "number" || typeof num == "string") && (this.result = "".concat(this.result, " / ").concat(num)), this.lowPriority = !1, this;
    }, "div")
  }, {
    key: "getResult",
    value: /* @__PURE__ */ __name(function(force) {
      return this.lowPriority || force ? "(".concat(this.result, ")") : this.result;
    }, "getResult")
  }, {
    key: "equal",
    value: /* @__PURE__ */ __name(function(options) {
      var _this2 = this, _ref = options || {}, cssUnit = _ref.unit, mergedUnit = !0;
      return typeof cssUnit == "boolean" ? mergedUnit = cssUnit : Array.from(this.unitlessCssVar).some(function(cssVar) {
        return _this2.result.includes(cssVar);
      }) && (mergedUnit = !1), this.result = this.result.replace(regexp$1, mergedUnit ? "px" : ""), typeof this.lowPriority < "u" ? "calc(".concat(this.result, ")") : this.result;
    }, "equal")
  }]), CSSCalculator2;
}(AbstractCalculator), NumCalculator = /* @__PURE__ */ function(_AbstractCalculator) {
  _inherits(NumCalculator2, _AbstractCalculator);
  var _super = _createSuper(NumCalculator2);
  function NumCalculator2(num) {
    var _this;
    return _classCallCheck$1(this, NumCalculator2), _this = _super.call(this), _defineProperty$2(_assertThisInitialized(_this), "result", 0), num instanceof NumCalculator2 ? _this.result = num.result : typeof num == "number" && (_this.result = num), _this;
  }
  return __name(NumCalculator2, "NumCalculator"), _createClass$1(NumCalculator2, [{
    key: "add",
    value: /* @__PURE__ */ __name(function(num) {
      return num instanceof NumCalculator2 ? this.result += num.result : typeof num == "number" && (this.result += num), this;
    }, "add")
  }, {
    key: "sub",
    value: /* @__PURE__ */ __name(function(num) {
      return num instanceof NumCalculator2 ? this.result -= num.result : typeof num == "number" && (this.result -= num), this;
    }, "sub")
  }, {
    key: "mul",
    value: /* @__PURE__ */ __name(function(num) {
      return num instanceof NumCalculator2 ? this.result *= num.result : typeof num == "number" && (this.result *= num), this;
    }, "mul")
  }, {
    key: "div",
    value: /* @__PURE__ */ __name(function(num) {
      return num instanceof NumCalculator2 ? this.result /= num.result : typeof num == "number" && (this.result /= num), this;
    }, "div")
  }, {
    key: "equal",
    value: /* @__PURE__ */ __name(function() {
      return this.result;
    }, "equal")
  }]), NumCalculator2;
}(AbstractCalculator), genCalc = /* @__PURE__ */ __name(function(type4, unitlessCssVar) {
  var Calculator = type4 === "css" ? CSSCalculator : NumCalculator;
  return function(num) {
    return new Calculator(num, unitlessCssVar);
  };
}, "genCalc"), getCompVarPrefix = /* @__PURE__ */ __name(function(component, prefix) {
  return "".concat([prefix, component.replace(/([A-Z]+)([A-Z][a-z]+)/g, "$1-$2").replace(/([a-z])([A-Z])/g, "$1-$2")].filter(Boolean).join("-"));
}, "getCompVarPrefix");
function useEvent(callback) {
  var fnRef = React.useRef();
  fnRef.current = callback;
  var memoFn = React.useCallback(function() {
    for (var _fnRef$current, _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++)
      args[_key] = arguments[_key];
    return (_fnRef$current = fnRef.current) === null || _fnRef$current === void 0 ? void 0 : _fnRef$current.call.apply(_fnRef$current, [fnRef].concat(args));
  }, []);
  return memoFn;
}
__name(useEvent, "useEvent");
function useSafeState(defaultValue) {
  var destroyRef = React.useRef(!1), _React$useState = React.useState(defaultValue), _React$useState2 = _slicedToArray(_React$useState, 2), value = _React$useState2[0], setValue = _React$useState2[1];
  React.useEffect(function() {
    return destroyRef.current = !1, function() {
      destroyRef.current = !0;
    };
  }, []);
  function safeSetState(updater, ignoreDestroy) {
    ignoreDestroy && destroyRef.current || setValue(updater);
  }
  return __name(safeSetState, "safeSetState"), [value, safeSetState];
}
__name(useSafeState, "useSafeState");
function hasValue$1(value) {
  return value !== void 0;
}
__name(hasValue$1, "hasValue$1");
function useMergedState(defaultStateValue, option) {
  var _ref = option || {}, defaultValue = _ref.defaultValue, value = _ref.value, onChange = _ref.onChange, postState = _ref.postState, _useState = useSafeState(function() {
    return hasValue$1(value) ? value : hasValue$1(defaultValue) ? typeof defaultValue == "function" ? defaultValue() : defaultValue : typeof defaultStateValue == "function" ? defaultStateValue() : defaultStateValue;
  }), _useState2 = _slicedToArray(_useState, 2), innerValue = _useState2[0], setInnerValue = _useState2[1], mergedValue = value !== void 0 ? value : innerValue, postMergedValue = postState ? postState(mergedValue) : mergedValue, onChangeFn = useEvent(onChange), _useState3 = useSafeState([mergedValue]), _useState4 = _slicedToArray(_useState3, 2), prevValue = _useState4[0], setPrevValue = _useState4[1];
  useLayoutUpdateEffect(function() {
    var prev2 = prevValue[0];
    innerValue !== prev2 && onChangeFn(innerValue, prev2);
  }, [prevValue]), useLayoutUpdateEffect(function() {
    hasValue$1(value) || setInnerValue(value);
  }, [value]);
  var triggerChange = useEvent(function(updater, ignoreDestroy) {
    setInnerValue(updater, ignoreDestroy), setPrevValue([mergedValue], ignoreDestroy);
  });
  return [postMergedValue, triggerChange];
}
__name(useMergedState, "useMergedState");
function getComponentToken(component, token2, defaultToken, options) {
  var customToken = _objectSpread2$1({}, token2[component]);
  if (options != null && options.deprecatedTokens) {
    var deprecatedTokens = options.deprecatedTokens;
    deprecatedTokens.forEach(function(_ref) {
      var _ref2 = _slicedToArray(_ref, 2), oldTokenKey = _ref2[0], newTokenKey = _ref2[1];
      if (process.env.NODE_ENV !== "production" && warningOnce(!(customToken != null && customToken[oldTokenKey]), "Component Token `".concat(String(oldTokenKey), "` of ").concat(String(component), " is deprecated. Please use `").concat(String(newTokenKey), "` instead.")), customToken != null && customToken[oldTokenKey] || customToken != null && customToken[newTokenKey]) {
        var _customToken$newToken;
        (_customToken$newToken = customToken[newTokenKey]) !== null && _customToken$newToken !== void 0 || (customToken[newTokenKey] = customToken == null ? void 0 : customToken[oldTokenKey]);
      }
    });
  }
  var mergedToken = _objectSpread2$1(_objectSpread2$1({}, defaultToken), customToken);
  return Object.keys(mergedToken).forEach(function(key) {
    mergedToken[key] === token2[key] && delete mergedToken[key];
  }), mergedToken;
}
__name(getComponentToken, "getComponentToken");
var enableStatistic = process.env.NODE_ENV !== "production" || typeof CSSINJS_STATISTIC < "u", recording = !0;
function merge() {
  for (var _len = arguments.length, objs = new Array(_len), _key = 0; _key < _len; _key++)
    objs[_key] = arguments[_key];
  if (!enableStatistic)
    return Object.assign.apply(Object, [{}].concat(objs));
  recording = !1;
  var ret = {};
  return objs.forEach(function(obj) {
    if (_typeof$4(obj) === "object") {
      var keys2 = Object.keys(obj);
      keys2.forEach(function(key) {
        Object.defineProperty(ret, key, {
          configurable: !0,
          enumerable: !0,
          get: /* @__PURE__ */ __name(function() {
            return obj[key];
          }, "get")
        });
      });
    }
  }), recording = !0, ret;
}
__name(merge, "merge");
var statistic = {};
function noop$2() {
}
__name(noop$2, "noop$2");
var statisticToken = /* @__PURE__ */ __name(function(token2) {
  var tokenKeys2, proxy = token2, flush = noop$2;
  return enableStatistic && typeof Proxy < "u" && (tokenKeys2 = /* @__PURE__ */ new Set(), proxy = new Proxy(token2, {
    get: /* @__PURE__ */ __name(function(obj, prop) {
      if (recording) {
        var _tokenKeys;
        (_tokenKeys = tokenKeys2) === null || _tokenKeys === void 0 || _tokenKeys.add(prop);
      }
      return obj[prop];
    }, "get")
  }), flush = /* @__PURE__ */ __name(function(componentName, componentToken) {
    var _statistic$componentN;
    statistic[componentName] = {
      global: Array.from(tokenKeys2),
      component: _objectSpread2$1(_objectSpread2$1({}, (_statistic$componentN = statistic[componentName]) === null || _statistic$componentN === void 0 ? void 0 : _statistic$componentN.component), componentToken)
    };
  }, "flush")), {
    token: proxy,
    keys: tokenKeys2,
    flush
  };
}, "statisticToken");
function getDefaultComponentToken(component, token2, getDefaultToken) {
  if (typeof getDefaultToken == "function") {
    var _token$component;
    return getDefaultToken(merge(token2, (_token$component = token2[component]) !== null && _token$component !== void 0 ? _token$component : {}));
  }
  return getDefaultToken ?? {};
}
__name(getDefaultComponentToken, "getDefaultComponentToken");
function genMaxMin(type4) {
  return type4 === "js" ? {
    max: Math.max,
    min: Math.min
  } : {
    max: /* @__PURE__ */ __name(function() {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++)
        args[_key] = arguments[_key];
      return "max(".concat(args.map(function(value) {
        return unit$1(value);
      }).join(","), ")");
    }, "max"),
    min: /* @__PURE__ */ __name(function() {
      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++)
        args[_key2] = arguments[_key2];
      return "min(".concat(args.map(function(value) {
        return unit$1(value);
      }).join(","), ")");
    }, "min")
  };
}
__name(genMaxMin, "genMaxMin");
var BEAT_LIMIT = 1e3 * 60 * 10, ArrayKeyMap = /* @__PURE__ */ function() {
  function ArrayKeyMap2() {
    _classCallCheck$1(this, ArrayKeyMap2), _defineProperty$2(this, "map", /* @__PURE__ */ new Map()), _defineProperty$2(this, "objectIDMap", /* @__PURE__ */ new WeakMap()), _defineProperty$2(this, "nextID", 0), _defineProperty$2(this, "lastAccessBeat", /* @__PURE__ */ new Map()), _defineProperty$2(this, "accessBeat", 0);
  }
  return __name(ArrayKeyMap2, "ArrayKeyMap"), _createClass$1(ArrayKeyMap2, [{
    key: "set",
    value: /* @__PURE__ */ __name(function(keys2, value) {
      this.clear();
      var compositeKey = this.getCompositeKey(keys2);
      this.map.set(compositeKey, value), this.lastAccessBeat.set(compositeKey, Date.now());
    }, "set")
  }, {
    key: "get",
    value: /* @__PURE__ */ __name(function(keys2) {
      var compositeKey = this.getCompositeKey(keys2), cache = this.map.get(compositeKey);
      return this.lastAccessBeat.set(compositeKey, Date.now()), this.accessBeat += 1, cache;
    }, "get")
  }, {
    key: "getCompositeKey",
    value: /* @__PURE__ */ __name(function(keys2) {
      var _this = this, ids = keys2.map(function(key) {
        return key && _typeof$4(key) === "object" ? "obj_".concat(_this.getObjectID(key)) : "".concat(_typeof$4(key), "_").concat(key);
      });
      return ids.join("|");
    }, "getCompositeKey")
  }, {
    key: "getObjectID",
    value: /* @__PURE__ */ __name(function(obj) {
      if (this.objectIDMap.has(obj))
        return this.objectIDMap.get(obj);
      var id2 = this.nextID;
      return this.objectIDMap.set(obj, id2), this.nextID += 1, id2;
    }, "getObjectID")
  }, {
    key: "clear",
    value: /* @__PURE__ */ __name(function() {
      var _this2 = this;
      if (this.accessBeat > 1e4) {
        var now2 = Date.now();
        this.lastAccessBeat.forEach(function(beat, key) {
          now2 - beat > BEAT_LIMIT && (_this2.map.delete(key), _this2.lastAccessBeat.delete(key));
        }), this.accessBeat = 0;
      }
    }, "clear")
  }]), ArrayKeyMap2;
}(), uniqueMap = new ArrayKeyMap();
function useUniqueMemo(memoFn, deps) {
  return React__default.useMemo(function() {
    var cachedValue = uniqueMap.get(deps);
    if (cachedValue)
      return cachedValue;
    var newValue = memoFn();
    return uniqueMap.set(deps, newValue), newValue;
  }, deps);
}
__name(useUniqueMemo, "useUniqueMemo");
var useDefaultCSP = /* @__PURE__ */ __name(function() {
  return {};
}, "useDefaultCSP");
function genStyleUtils(config) {
  var _config$useCSP = config.useCSP, useCSP = _config$useCSP === void 0 ? useDefaultCSP : _config$useCSP, useToken2 = config.useToken, usePrefix = config.usePrefix, getResetStyles2 = config.getResetStyles, getCommonStyle = config.getCommonStyle, getCompUnitless = config.getCompUnitless;
  function genStyleHooks2(component, styleFn, getDefaultToken, options) {
    var componentName = Array.isArray(component) ? component[0] : component;
    function prefixToken(key) {
      return "".concat(String(componentName)).concat(key.slice(0, 1).toUpperCase()).concat(key.slice(1));
    }
    __name(prefixToken, "prefixToken");
    var originUnitless = (options == null ? void 0 : options.unitless) || {}, originCompUnitless = typeof getCompUnitless == "function" ? getCompUnitless(component) : {}, compUnitless = _objectSpread2$1(_objectSpread2$1({}, originCompUnitless), {}, _defineProperty$2({}, prefixToken("zIndexPopup"), !0));
    Object.keys(originUnitless).forEach(function(key) {
      compUnitless[prefixToken(key)] = originUnitless[key];
    });
    var mergedOptions = _objectSpread2$1(_objectSpread2$1({}, options), {}, {
      unitless: compUnitless,
      prefixToken
    }), useStyle2 = genComponentStyleHook2(component, styleFn, getDefaultToken, mergedOptions), useCSSVar = genCSSVarRegister(componentName, getDefaultToken, mergedOptions);
    return function(prefixCls) {
      var rootCls = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : prefixCls, _useStyle = useStyle2(prefixCls, rootCls), _useStyle2 = _slicedToArray(_useStyle, 2), hashId = _useStyle2[1], _useCSSVar = useCSSVar(rootCls), _useCSSVar2 = _slicedToArray(_useCSSVar, 2), wrapCSSVar = _useCSSVar2[0], cssVarCls = _useCSSVar2[1];
      return [wrapCSSVar, hashId, cssVarCls];
    };
  }
  __name(genStyleHooks2, "genStyleHooks");
  function genCSSVarRegister(component, getDefaultToken, options) {
    var compUnitless = options.unitless, _options$injectStyle = options.injectStyle, injectStyle = _options$injectStyle === void 0 ? !0 : _options$injectStyle, prefixToken = options.prefixToken, ignore2 = options.ignore, CSSVarRegister = /* @__PURE__ */ __name(function(_ref) {
      var rootCls = _ref.rootCls, _ref$cssVar = _ref.cssVar, cssVar = _ref$cssVar === void 0 ? {} : _ref$cssVar, _useToken = useToken2(), realToken = _useToken.realToken;
      return useCSSVarRegister({
        path: [component],
        prefix: cssVar.prefix,
        key: cssVar.key,
        unitless: compUnitless,
        ignore: ignore2,
        token: realToken,
        scope: rootCls
      }, function() {
        var defaultToken = getDefaultComponentToken(component, realToken, getDefaultToken), componentToken = getComponentToken(component, realToken, defaultToken, {
          deprecatedTokens: options == null ? void 0 : options.deprecatedTokens
        });
        return Object.keys(defaultToken).forEach(function(key) {
          componentToken[prefixToken(key)] = componentToken[key], delete componentToken[key];
        }), componentToken;
      }), null;
    }, "CSSVarRegister"), useCSSVar = /* @__PURE__ */ __name(function(rootCls) {
      var _useToken2 = useToken2(), cssVar = _useToken2.cssVar;
      return [function(node2) {
        return injectStyle && cssVar ? /* @__PURE__ */ React__default.createElement(React__default.Fragment, null, /* @__PURE__ */ React__default.createElement(CSSVarRegister, {
          rootCls,
          cssVar,
          component
        }), node2) : node2;
      }, cssVar == null ? void 0 : cssVar.key];
    }, "useCSSVar");
    return useCSSVar;
  }
  __name(genCSSVarRegister, "genCSSVarRegister");
  function genComponentStyleHook2(componentName, styleFn, getDefaultToken) {
    var options = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {}, cells = Array.isArray(componentName) ? componentName : [componentName, componentName], _cells = _slicedToArray(cells, 1), component = _cells[0], concatComponent = cells.join("-"), mergedLayer = config.layer || {
      name: "antd"
    };
    return function(prefixCls) {
      var rootCls = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : prefixCls, _useToken3 = useToken2(), theme2 = _useToken3.theme, realToken = _useToken3.realToken, hashId = _useToken3.hashId, token2 = _useToken3.token, cssVar = _useToken3.cssVar, _usePrefix = usePrefix(), rootPrefixCls = _usePrefix.rootPrefixCls, iconPrefixCls = _usePrefix.iconPrefixCls, csp = useCSP(), type4 = cssVar ? "css" : "js", calc = useUniqueMemo(function() {
        var unitlessCssVar = /* @__PURE__ */ new Set();
        return cssVar && Object.keys(options.unitless || {}).forEach(function(key) {
          unitlessCssVar.add(token2CSSVar(key, cssVar.prefix)), unitlessCssVar.add(token2CSSVar(key, getCompVarPrefix(component, cssVar.prefix)));
        }), genCalc(type4, unitlessCssVar);
      }, [type4, component, cssVar == null ? void 0 : cssVar.prefix]), _genMaxMin = genMaxMin(type4), max = _genMaxMin.max, min = _genMaxMin.min, sharedConfig = {
        theme: theme2,
        token: token2,
        hashId,
        nonce: /* @__PURE__ */ __name(function() {
          return csp.nonce;
        }, "nonce"),
        clientOnly: options.clientOnly,
        layer: mergedLayer,
        // antd is always at top of styles
        order: options.order || -999
      };
      typeof getResetStyles2 == "function" && useStyleRegister(_objectSpread2$1(_objectSpread2$1({}, sharedConfig), {}, {
        clientOnly: !1,
        path: ["Shared", rootPrefixCls]
      }), function() {
        return getResetStyles2(token2, {
          prefix: {
            rootPrefixCls,
            iconPrefixCls
          },
          csp
        });
      });
      var wrapSSR = useStyleRegister(_objectSpread2$1(_objectSpread2$1({}, sharedConfig), {}, {
        path: [concatComponent, prefixCls, iconPrefixCls]
      }), function() {
        if (options.injectStyle === !1)
          return [];
        var _statisticToken = statisticToken(token2), proxyToken = _statisticToken.token, flush = _statisticToken.flush, defaultComponentToken = getDefaultComponentToken(component, realToken, getDefaultToken), componentCls = ".".concat(prefixCls), componentToken = getComponentToken(component, realToken, defaultComponentToken, {
          deprecatedTokens: options.deprecatedTokens
        });
        cssVar && defaultComponentToken && _typeof$4(defaultComponentToken) === "object" && Object.keys(defaultComponentToken).forEach(function(key) {
          defaultComponentToken[key] = "var(".concat(token2CSSVar(key, getCompVarPrefix(component, cssVar.prefix)), ")");
        });
        var mergedToken = merge(proxyToken, {
          componentCls,
          prefixCls,
          iconCls: ".".concat(iconPrefixCls),
          antCls: ".".concat(rootPrefixCls),
          calc,
          // @ts-ignore
          max,
          // @ts-ignore
          min
        }, cssVar ? defaultComponentToken : componentToken), styleInterpolation = styleFn(mergedToken, {
          hashId,
          prefixCls,
          rootPrefixCls,
          iconPrefixCls
        });
        flush(component, componentToken);
        var commonStyle = typeof getCommonStyle == "function" ? getCommonStyle(mergedToken, prefixCls, rootCls, options.resetFont) : null;
        return [options.resetStyle === !1 ? null : commonStyle, styleInterpolation];
      });
      return [wrapSSR, hashId];
    };
  }
  __name(genComponentStyleHook2, "genComponentStyleHook");
  function genSubStyleComponent2(componentName, styleFn, getDefaultToken) {
    var options = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {}, useStyle2 = genComponentStyleHook2(componentName, styleFn, getDefaultToken, _objectSpread2$1({
      resetStyle: !1,
      // Sub Style should default after root one
      order: -998
    }, options)), StyledComponent = /* @__PURE__ */ __name(function(_ref2) {
      var prefixCls = _ref2.prefixCls, _ref2$rootCls = _ref2.rootCls, rootCls = _ref2$rootCls === void 0 ? prefixCls : _ref2$rootCls;
      return useStyle2(prefixCls, rootCls), null;
    }, "StyledComponent");
    return process.env.NODE_ENV !== "production" && (StyledComponent.displayName = "SubStyle_".concat(String(Array.isArray(componentName) ? componentName.join(".") : componentName))), StyledComponent;
  }
  return __name(genSubStyleComponent2, "genSubStyleComponent"), {
    genStyleHooks: genStyleHooks2,
    genSubStyleComponent: genSubStyleComponent2,
    genComponentStyleHook: genComponentStyleHook2
  };
}
__name(genStyleUtils, "genStyleUtils");
const PresetColors = ["blue", "purple", "cyan", "green", "magenta", "pink", "red", "orange", "yellow", "volcano", "geekblue", "lime", "gold"], version$1 = "5.22.7";
function isStableColor(color) {
  return color >= 0 && color <= 255;
}
__name(isStableColor, "isStableColor");
function getAlphaColor$1(frontColor, backgroundColor) {
  const {
    r: fR,
    g: fG,
    b: fB,
    a: originAlpha
  } = new TinyColor(frontColor).toRgb();
  if (originAlpha < 1)
    return frontColor;
  const {
    r: bR,
    g: bG,
    b: bB
  } = new TinyColor(backgroundColor).toRgb();
  for (let fA = 0.01; fA <= 1; fA += 0.01) {
    const r2 = Math.round((fR - bR * (1 - fA)) / fA), g = Math.round((fG - bG * (1 - fA)) / fA), b = Math.round((fB - bB * (1 - fA)) / fA);
    if (isStableColor(r2) && isStableColor(g) && isStableColor(b))
      return new TinyColor({
        r: r2,
        g,
        b,
        a: Math.round(fA * 100) / 100
      }).toRgbString();
  }
  return new TinyColor({
    r: fR,
    g: fG,
    b: fB,
    a: 1
  }).toRgbString();
}
__name(getAlphaColor$1, "getAlphaColor$1");
var __rest$W = function(s, e2) {
  var t2 = {};
  for (var p in s) Object.prototype.hasOwnProperty.call(s, p) && e2.indexOf(p) < 0 && (t2[p] = s[p]);
  if (s != null && typeof Object.getOwnPropertySymbols == "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++)
    e2.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]) && (t2[p[i]] = s[p[i]]);
  return t2;
};
function formatToken(derivativeToken) {
  const {
    override
  } = derivativeToken, restToken = __rest$W(derivativeToken, ["override"]), overrideTokens = Object.assign({}, override);
  Object.keys(seedToken).forEach((token2) => {
    delete overrideTokens[token2];
  });
  const mergedToken = Object.assign(Object.assign({}, restToken), overrideTokens), screenXS = 480, screenSM = 576, screenMD = 768, screenLG = 992, screenXL = 1200, screenXXL = 1600;
  if (mergedToken.motion === !1) {
    const fastDuration = "0s";
    mergedToken.motionDurationFast = fastDuration, mergedToken.motionDurationMid = fastDuration, mergedToken.motionDurationSlow = fastDuration;
  }
  return Object.assign(Object.assign(Object.assign({}, mergedToken), {
    // ============== Background ============== //
    colorFillContent: mergedToken.colorFillSecondary,
    colorFillContentHover: mergedToken.colorFill,
    colorFillAlter: mergedToken.colorFillQuaternary,
    colorBgContainerDisabled: mergedToken.colorFillTertiary,
    // ============== Split ============== //
    colorBorderBg: mergedToken.colorBgContainer,
    colorSplit: getAlphaColor$1(mergedToken.colorBorderSecondary, mergedToken.colorBgContainer),
    // ============== Text ============== //
    colorTextPlaceholder: mergedToken.colorTextQuaternary,
    colorTextDisabled: mergedToken.colorTextQuaternary,
    colorTextHeading: mergedToken.colorText,
    colorTextLabel: mergedToken.colorTextSecondary,
    colorTextDescription: mergedToken.colorTextTertiary,
    colorTextLightSolid: mergedToken.colorWhite,
    colorHighlight: mergedToken.colorError,
    colorBgTextHover: mergedToken.colorFillSecondary,
    colorBgTextActive: mergedToken.colorFill,
    colorIcon: mergedToken.colorTextTertiary,
    colorIconHover: mergedToken.colorText,
    colorErrorOutline: getAlphaColor$1(mergedToken.colorErrorBg, mergedToken.colorBgContainer),
    colorWarningOutline: getAlphaColor$1(mergedToken.colorWarningBg, mergedToken.colorBgContainer),
    // Font
    fontSizeIcon: mergedToken.fontSizeSM,
    // Line
    lineWidthFocus: mergedToken.lineWidth * 3,
    // Control
    lineWidth: mergedToken.lineWidth,
    controlOutlineWidth: mergedToken.lineWidth * 2,
    // Checkbox size and expand icon size
    controlInteractiveSize: mergedToken.controlHeight / 2,
    controlItemBgHover: mergedToken.colorFillTertiary,
    controlItemBgActive: mergedToken.colorPrimaryBg,
    controlItemBgActiveHover: mergedToken.colorPrimaryBgHover,
    controlItemBgActiveDisabled: mergedToken.colorFill,
    controlTmpOutline: mergedToken.colorFillQuaternary,
    controlOutline: getAlphaColor$1(mergedToken.colorPrimaryBg, mergedToken.colorBgContainer),
    lineType: mergedToken.lineType,
    borderRadius: mergedToken.borderRadius,
    borderRadiusXS: mergedToken.borderRadiusXS,
    borderRadiusSM: mergedToken.borderRadiusSM,
    borderRadiusLG: mergedToken.borderRadiusLG,
    fontWeightStrong: 600,
    opacityLoading: 0.65,
    linkDecoration: "none",
    linkHoverDecoration: "none",
    linkFocusDecoration: "none",
    controlPaddingHorizontal: 12,
    controlPaddingHorizontalSM: 8,
    paddingXXS: mergedToken.sizeXXS,
    paddingXS: mergedToken.sizeXS,
    paddingSM: mergedToken.sizeSM,
    padding: mergedToken.size,
    paddingMD: mergedToken.sizeMD,
    paddingLG: mergedToken.sizeLG,
    paddingXL: mergedToken.sizeXL,
    paddingContentHorizontalLG: mergedToken.sizeLG,
    paddingContentVerticalLG: mergedToken.sizeMS,
    paddingContentHorizontal: mergedToken.sizeMS,
    paddingContentVertical: mergedToken.sizeSM,
    paddingContentHorizontalSM: mergedToken.size,
    paddingContentVerticalSM: mergedToken.sizeXS,
    marginXXS: mergedToken.sizeXXS,
    marginXS: mergedToken.sizeXS,
    marginSM: mergedToken.sizeSM,
    margin: mergedToken.size,
    marginMD: mergedToken.sizeMD,
    marginLG: mergedToken.sizeLG,
    marginXL: mergedToken.sizeXL,
    marginXXL: mergedToken.sizeXXL,
    boxShadow: `
      0 6px 16px 0 rgba(0, 0, 0, 0.08),
      0 3px 6px -4px rgba(0, 0, 0, 0.12),
      0 9px 28px 8px rgba(0, 0, 0, 0.05)
    `,
    boxShadowSecondary: `
      0 6px 16px 0 rgba(0, 0, 0, 0.08),
      0 3px 6px -4px rgba(0, 0, 0, 0.12),
      0 9px 28px 8px rgba(0, 0, 0, 0.05)
    `,
    boxShadowTertiary: `
      0 1px 2px 0 rgba(0, 0, 0, 0.03),
      0 1px 6px -1px rgba(0, 0, 0, 0.02),
      0 2px 4px 0 rgba(0, 0, 0, 0.02)
    `,
    screenXS,
    screenXSMin: screenXS,
    screenXSMax: screenSM - 1,
    screenSM,
    screenSMMin: screenSM,
    screenSMMax: screenMD - 1,
    screenMD,
    screenMDMin: screenMD,
    screenMDMax: screenLG - 1,
    screenLG,
    screenLGMin: screenLG,
    screenLGMax: screenXL - 1,
    screenXL,
    screenXLMin: screenXL,
    screenXLMax: screenXXL - 1,
    screenXXL,
    screenXXLMin: screenXXL,
    boxShadowPopoverArrow: "2px 2px 5px rgba(0, 0, 0, 0.05)",
    boxShadowCard: `
      0 1px 2px -2px ${new TinyColor("rgba(0, 0, 0, 0.16)").toRgbString()},
      0 3px 6px 0 ${new TinyColor("rgba(0, 0, 0, 0.12)").toRgbString()},
      0 5px 12px 4px ${new TinyColor("rgba(0, 0, 0, 0.09)").toRgbString()}
    `,
    boxShadowDrawerRight: `
      -6px 0 16px 0 rgba(0, 0, 0, 0.08),
      -3px 0 6px -4px rgba(0, 0, 0, 0.12),
      -9px 0 28px 8px rgba(0, 0, 0, 0.05)
    `,
    boxShadowDrawerLeft: `
      6px 0 16px 0 rgba(0, 0, 0, 0.08),
      3px 0 6px -4px rgba(0, 0, 0, 0.12),
      9px 0 28px 8px rgba(0, 0, 0, 0.05)
    `,
    boxShadowDrawerUp: `
      0 6px 16px 0 rgba(0, 0, 0, 0.08),
      0 3px 6px -4px rgba(0, 0, 0, 0.12),
      0 9px 28px 8px rgba(0, 0, 0, 0.05)
    `,
    boxShadowDrawerDown: `
      0 -6px 16px 0 rgba(0, 0, 0, 0.08),
      0 -3px 6px -4px rgba(0, 0, 0, 0.12),
      0 -9px 28px 8px rgba(0, 0, 0, 0.05)
    `,
    boxShadowTabsOverflowLeft: "inset 10px 0 8px -8px rgba(0, 0, 0, 0.08)",
    boxShadowTabsOverflowRight: "inset -10px 0 8px -8px rgba(0, 0, 0, 0.08)",
    boxShadowTabsOverflowTop: "inset 0 10px 8px -8px rgba(0, 0, 0, 0.08)",
    boxShadowTabsOverflowBottom: "inset 0 -10px 8px -8px rgba(0, 0, 0, 0.08)"
  }), overrideTokens);
}
__name(formatToken, "formatToken");
var __rest$V = function(s, e2) {
  var t2 = {};
  for (var p in s) Object.prototype.hasOwnProperty.call(s, p) && e2.indexOf(p) < 0 && (t2[p] = s[p]);
  if (s != null && typeof Object.getOwnPropertySymbols == "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++)
    e2.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]) && (t2[p[i]] = s[p[i]]);
  return t2;
};
const unitless = {
  lineHeight: !0,
  lineHeightSM: !0,
  lineHeightLG: !0,
  lineHeightHeading1: !0,
  lineHeightHeading2: !0,
  lineHeightHeading3: !0,
  lineHeightHeading4: !0,
  lineHeightHeading5: !0,
  opacityLoading: !0,
  fontWeightStrong: !0,
  zIndexPopupBase: !0,
  zIndexBase: !0,
  opacityImage: !0
}, ignore = {
  size: !0,
  sizeSM: !0,
  sizeLG: !0,
  sizeMD: !0,
  sizeXS: !0,
  sizeXXS: !0,
  sizeMS: !0,
  sizeXL: !0,
  sizeXXL: !0,
  sizeUnit: !0,
  sizeStep: !0,
  motionBase: !0,
  motionUnit: !0
}, preserve = {
  screenXS: !0,
  screenXSMin: !0,
  screenXSMax: !0,
  screenSM: !0,
  screenSMMin: !0,
  screenSMMax: !0,
  screenMD: !0,
  screenMDMin: !0,
  screenMDMax: !0,
  screenLG: !0,
  screenLGMin: !0,
  screenLGMax: !0,
  screenXL: !0,
  screenXLMin: !0,
  screenXLMax: !0,
  screenXXL: !0,
  screenXXLMin: !0
}, getComputedToken2 = /* @__PURE__ */ __name((originToken, overrideToken, theme2) => {
  const derivativeToken = theme2.getDerivativeToken(originToken), {
    override
  } = overrideToken, components2 = __rest$V(overrideToken, ["override"]);
  let mergedDerivativeToken = Object.assign(Object.assign({}, derivativeToken), {
    override
  });
  return mergedDerivativeToken = formatToken(mergedDerivativeToken), components2 && Object.entries(components2).forEach((_ref) => {
    let [key, value] = _ref;
    const {
      theme: componentTheme
    } = value, componentTokens = __rest$V(value, ["theme"]);
    let mergedComponentToken = componentTokens;
    componentTheme && (mergedComponentToken = getComputedToken2(Object.assign(Object.assign({}, mergedDerivativeToken), componentTokens), {
      override: componentTokens
    }, componentTheme)), mergedDerivativeToken[key] = mergedComponentToken;
  }), mergedDerivativeToken;
}, "getComputedToken");
function useToken() {
  const {
    token: rootDesignToken,
    hashed,
    theme: theme2,
    override,
    cssVar
  } = React__default.useContext(DesignTokenContext), salt = `${version$1}-${hashed || ""}`, mergedTheme = theme2 || defaultTheme, [token2, hashId, realToken] = useCacheToken(mergedTheme, [seedToken, rootDesignToken], {
    salt,
    override,
    getComputedToken: getComputedToken2,
    // formatToken will not be consumed after 1.15.0 with getComputedToken.
    // But token will break if @ant-design/cssinjs is under 1.15.0 without it
    formatToken,
    cssVar: cssVar && {
      prefix: cssVar.prefix,
      key: cssVar.key,
      unitless,
      ignore,
      preserve
    }
  });
  return [mergedTheme, realToken, hashed ? hashId : "", token2, cssVar];
}
__name(useToken, "useToken");
const textEllipsis = {
  overflow: "hidden",
  whiteSpace: "nowrap",
  textOverflow: "ellipsis"
}, resetComponent = /* @__PURE__ */ __name(function(token2) {
  let needInheritFontFamily = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1;
  return {
    boxSizing: "border-box",
    margin: 0,
    padding: 0,
    color: token2.colorText,
    fontSize: token2.fontSize,
    // font-variant: @font-variant-base;
    lineHeight: token2.lineHeight,
    listStyle: "none",
    // font-feature-settings: @font-feature-settings-base;
    fontFamily: needInheritFontFamily ? "inherit" : token2.fontFamily
  };
}, "resetComponent"), resetIcon = /* @__PURE__ */ __name(() => ({
  display: "inline-flex",
  alignItems: "center",
  color: "inherit",
  fontStyle: "normal",
  lineHeight: 0,
  textAlign: "center",
  textTransform: "none",
  // for SVG icon, see https://blog.prototypr.io/align-svg-icons-to-text-and-say-goodbye-to-font-icons-d44b3d7b26b4
  verticalAlign: "-0.125em",
  textRendering: "optimizeLegibility",
  "-webkit-font-smoothing": "antialiased",
  "-moz-osx-font-smoothing": "grayscale",
  "> *": {
    lineHeight: 1
  },
  svg: {
    display: "inline-block"
  }
}), "resetIcon"), clearFix = /* @__PURE__ */ __name(() => ({
  // https://github.com/ant-design/ant-design/issues/21301#issuecomment-583955229
  "&::before": {
    display: "table",
    content: '""'
  },
  "&::after": {
    // https://github.com/ant-design/ant-design/issues/21864
    display: "table",
    clear: "both",
    content: '""'
  }
}), "clearFix"), genLinkStyle = /* @__PURE__ */ __name((token2) => ({
  a: {
    color: token2.colorLink,
    textDecoration: token2.linkDecoration,
    backgroundColor: "transparent",
    // remove the gray background on active links in IE 10.
    outline: "none",
    cursor: "pointer",
    transition: `color ${token2.motionDurationSlow}`,
    "-webkit-text-decoration-skip": "objects",
    // remove gaps in links underline in iOS 8+ and Safari 8+.
    "&:hover": {
      color: token2.colorLinkHover
    },
    "&:active": {
      color: token2.colorLinkActive
    },
    "&:active, &:hover": {
      textDecoration: token2.linkHoverDecoration,
      outline: 0
    },
    // https://github.com/ant-design/ant-design/issues/22503
    "&:focus": {
      textDecoration: token2.linkFocusDecoration,
      outline: 0
    },
    "&[disabled]": {
      color: token2.colorTextDisabled,
      cursor: "not-allowed"
    }
  }
}), "genLinkStyle"), genCommonStyle = /* @__PURE__ */ __name((token2, componentPrefixCls, rootCls, resetFont) => {
  const prefixSelector = `[class^="${componentPrefixCls}"], [class*=" ${componentPrefixCls}"]`, rootPrefixSelector = rootCls ? `.${rootCls}` : prefixSelector, resetStyle = {
    boxSizing: "border-box",
    "&::before, &::after": {
      boxSizing: "border-box"
    }
  };
  let resetFontStyle = {};
  return resetFont !== !1 && (resetFontStyle = {
    fontFamily: token2.fontFamily,
    fontSize: token2.fontSize
  }), {
    [rootPrefixSelector]: Object.assign(Object.assign(Object.assign({}, resetFontStyle), resetStyle), {
      [prefixSelector]: resetStyle
    })
  };
}, "genCommonStyle"), genFocusOutline = /* @__PURE__ */ __name((token2) => ({
  outline: `${unit$1(token2.lineWidthFocus)} solid ${token2.colorPrimaryBorder}`,
  outlineOffset: 1,
  transition: "outline-offset 0s, outline 0s"
}), "genFocusOutline"), genFocusStyle = /* @__PURE__ */ __name((token2) => ({
  "&:focus-visible": Object.assign({}, genFocusOutline(token2))
}), "genFocusStyle"), genIconStyle = /* @__PURE__ */ __name((iconPrefixCls) => ({
  [`.${iconPrefixCls}`]: Object.assign(Object.assign({}, resetIcon()), {
    [`.${iconPrefixCls} .${iconPrefixCls}-icon`]: {
      display: "block"
    }
  })
}), "genIconStyle"), operationUnit = /* @__PURE__ */ __name((token2) => Object.assign(Object.assign({
  // FIXME: This use link but is a operation unit. Seems should be a colorPrimary.
  // And Typography use this to generate link style which should not do this.
  color: token2.colorLink,
  textDecoration: token2.linkDecoration,
  outline: "none",
  cursor: "pointer",
  transition: `all ${token2.motionDurationSlow}`,
  border: 0,
  padding: 0,
  background: "none",
  userSelect: "none"
}, genFocusStyle(token2)), {
  "&:focus, &:hover": {
    color: token2.colorLinkHover
  },
  "&:active": {
    color: token2.colorLinkActive
  }
}), "operationUnit"), {
  genStyleHooks,
  genComponentStyleHook,
  genSubStyleComponent
} = genStyleUtils({
  usePrefix: /* @__PURE__ */ __name(() => {
    const {
      getPrefixCls,
      iconPrefixCls
    } = useContext$1(ConfigContext);
    return {
      rootPrefixCls: getPrefixCls(),
      iconPrefixCls
    };
  }, "usePrefix"),
  useToken: /* @__PURE__ */ __name(() => {
    const [theme2, realToken, hashId, token2, cssVar] = useToken();
    return {
      theme: theme2,
      realToken,
      hashId,
      token: token2,
      cssVar
    };
  }, "useToken"),
  useCSP: /* @__PURE__ */ __name(() => {
    const {
      csp
    } = useContext$1(ConfigContext);
    return csp ?? {};
  }, "useCSP"),
  getResetStyles: /* @__PURE__ */ __name((token2, config) => {
    var _a;
    return [{
      "&": genLinkStyle(token2)
    }, genIconStyle((_a = config == null ? void 0 : config.prefix.iconPrefixCls) !== null && _a !== void 0 ? _a : defaultIconPrefixCls)];
  }, "getResetStyles"),
  getCommonStyle: genCommonStyle,
  getCompUnitless: /* @__PURE__ */ __name(() => unitless, "getCompUnitless")
});
function genPresetColor(token2, genCss) {
  return PresetColors.reduce((prev2, colorKey) => {
    const lightColor = token2[`${colorKey}1`], lightBorderColor = token2[`${colorKey}3`], darkColor = token2[`${colorKey}6`], textColor = token2[`${colorKey}7`];
    return Object.assign(Object.assign({}, prev2), genCss(colorKey, {
      lightColor,
      lightBorderColor,
      darkColor,
      textColor
    }));
  }, {});
}
__name(genPresetColor, "genPresetColor");
const useResetIconStyle = /* @__PURE__ */ __name((iconPrefixCls, csp) => {
  const [theme2, token2] = useToken();
  return useStyleRegister({
    token: token2,
    hashId: "",
    path: ["ant-design-icons", iconPrefixCls],
    nonce: /* @__PURE__ */ __name(() => csp == null ? void 0 : csp.nonce, "nonce"),
    layer: {
      name: "antd"
    }
  }, () => [genIconStyle(iconPrefixCls)]);
}, "useResetIconStyle"), fullClone$1 = Object.assign({}, React), {
  useId: useId$3
} = fullClone$1, useEmptyId = /* @__PURE__ */ __name(() => "", "useEmptyId"), useThemeKey = typeof useId$3 > "u" ? useEmptyId : useId$3;
function useTheme$1(theme2, parentTheme, config) {
  var _a, _b;
  const warning3 = devUseWarning("ConfigProvider"), themeConfig = theme2 || {}, parentThemeConfig = themeConfig.inherit === !1 || !parentTheme ? Object.assign(Object.assign({}, defaultConfig), {
    hashed: (_a = parentTheme == null ? void 0 : parentTheme.hashed) !== null && _a !== void 0 ? _a : defaultConfig.hashed,
    cssVar: parentTheme == null ? void 0 : parentTheme.cssVar
  }) : parentTheme, themeKey = useThemeKey();
  if (process.env.NODE_ENV !== "production") {
    const cssVarEnabled = themeConfig.cssVar || parentThemeConfig.cssVar, validKey = !!(typeof themeConfig.cssVar == "object" && (!((_b = themeConfig.cssVar) === null || _b === void 0) && _b.key) || themeKey);
    process.env.NODE_ENV !== "production" && warning3(!cssVarEnabled || validKey, "breaking", "Missing key in `cssVar` config. Please upgrade to React 18 or set `cssVar.key` manually in each ConfigProvider inside `cssVar` enabled ConfigProvider.");
  }
  return useMemo(() => {
    var _a2, _b2;
    if (!theme2)
      return parentTheme;
    const mergedComponents = Object.assign({}, parentThemeConfig.components);
    Object.keys(theme2.components || {}).forEach((componentName) => {
      mergedComponents[componentName] = Object.assign(Object.assign({}, mergedComponents[componentName]), theme2.components[componentName]);
    });
    const cssVarKey = `css-var-${themeKey.replace(/:/g, "")}`, mergedCssVar = ((_a2 = themeConfig.cssVar) !== null && _a2 !== void 0 ? _a2 : parentThemeConfig.cssVar) && Object.assign(Object.assign(Object.assign({
      prefix: config == null ? void 0 : config.prefixCls
    }, typeof parentThemeConfig.cssVar == "object" ? parentThemeConfig.cssVar : {}), typeof themeConfig.cssVar == "object" ? themeConfig.cssVar : {}), {
      key: typeof themeConfig.cssVar == "object" && ((_b2 = themeConfig.cssVar) === null || _b2 === void 0 ? void 0 : _b2.key) || cssVarKey
    });
    return Object.assign(Object.assign(Object.assign({}, parentThemeConfig), themeConfig), {
      token: Object.assign(Object.assign({}, parentThemeConfig.token), themeConfig.token),
      components: mergedComponents,
      cssVar: mergedCssVar
    });
  }, [themeConfig, parentThemeConfig], (prev2, next2) => prev2.some((prevTheme, index2) => {
    const nextTheme = next2[index2];
    return !isEqual(prevTheme, nextTheme, !0);
  }));
}
__name(useTheme$1, "useTheme$1");
var _excluded$R = ["children"], Context$1 = /* @__PURE__ */ React.createContext({});
function MotionProvider(_ref) {
  var children = _ref.children, props = _objectWithoutProperties(_ref, _excluded$R);
  return /* @__PURE__ */ React.createElement(Context$1.Provider, {
    value: props
  }, children);
}
__name(MotionProvider, "MotionProvider");
var DomWrapper = /* @__PURE__ */ function(_React$Component) {
  _inherits(DomWrapper2, _React$Component);
  var _super = _createSuper(DomWrapper2);
  function DomWrapper2() {
    return _classCallCheck$1(this, DomWrapper2), _super.apply(this, arguments);
  }
  return __name(DomWrapper2, "DomWrapper"), _createClass$1(DomWrapper2, [{
    key: "render",
    value: /* @__PURE__ */ __name(function() {
      return this.props.children;
    }, "render")
  }]), DomWrapper2;
}(React.Component);
function useSyncState$3(defaultValue) {
  var _React$useReducer = React.useReducer(function(x) {
    return x + 1;
  }, 0), _React$useReducer2 = _slicedToArray(_React$useReducer, 2), forceUpdate = _React$useReducer2[1], currentValueRef = React.useRef(defaultValue), getValue2 = useEvent(function() {
    return currentValueRef.current;
  }), setValue = useEvent(function(updater) {
    currentValueRef.current = typeof updater == "function" ? updater(currentValueRef.current) : updater, forceUpdate();
  });
  return [getValue2, setValue];
}
__name(useSyncState$3, "useSyncState$3");
var STATUS_NONE = "none", STATUS_APPEAR = "appear", STATUS_ENTER = "enter", STATUS_LEAVE = "leave", STEP_NONE = "none", STEP_PREPARE = "prepare", STEP_START = "start", STEP_ACTIVE = "active", STEP_ACTIVATED = "end", STEP_PREPARED = "prepared";
function makePrefixMap(styleProp, eventName) {
  var prefixes = {};
  return prefixes[styleProp.toLowerCase()] = eventName.toLowerCase(), prefixes["Webkit".concat(styleProp)] = "webkit".concat(eventName), prefixes["Moz".concat(styleProp)] = "moz".concat(eventName), prefixes["ms".concat(styleProp)] = "MS".concat(eventName), prefixes["O".concat(styleProp)] = "o".concat(eventName.toLowerCase()), prefixes;
}
__name(makePrefixMap, "makePrefixMap");
function getVendorPrefixes(domSupport, win) {
  var prefixes = {
    animationend: makePrefixMap("Animation", "AnimationEnd"),
    transitionend: makePrefixMap("Transition", "TransitionEnd")
  };
  return domSupport && ("AnimationEvent" in win || delete prefixes.animationend.animation, "TransitionEvent" in win || delete prefixes.transitionend.transition), prefixes;
}
__name(getVendorPrefixes, "getVendorPrefixes");
var vendorPrefixes = getVendorPrefixes(canUseDom(), typeof window < "u" ? window : {}), style$1 = {};
if (canUseDom()) {
  var _document$createEleme = document.createElement("div");
  style$1 = _document$createEleme.style;
}
var prefixedEventNames = {};
function getVendorPrefixedEventName(eventName) {
  if (prefixedEventNames[eventName])
    return prefixedEventNames[eventName];
  var prefixMap = vendorPrefixes[eventName];
  if (prefixMap)
    for (var stylePropList = Object.keys(prefixMap), len = stylePropList.length, i = 0; i < len; i += 1) {
      var styleProp = stylePropList[i];
      if (Object.prototype.hasOwnProperty.call(prefixMap, styleProp) && styleProp in style$1)
        return prefixedEventNames[eventName] = prefixMap[styleProp], prefixedEventNames[eventName];
    }
  return "";
}
__name(getVendorPrefixedEventName, "getVendorPrefixedEventName");
var internalAnimationEndName = getVendorPrefixedEventName("animationend"), internalTransitionEndName = getVendorPrefixedEventName("transitionend"), supportTransition = !!(internalAnimationEndName && internalTransitionEndName), animationEndName = internalAnimationEndName || "animationend", transitionEndName = internalTransitionEndName || "transitionend";
function getTransitionName$1(transitionName, transitionType) {
  if (!transitionName) return null;
  if (_typeof$4(transitionName) === "object") {
    var type4 = transitionType.replace(/-\w/g, function(match2) {
      return match2[1].toUpperCase();
    });
    return transitionName[type4];
  }
  return "".concat(transitionName, "-").concat(transitionType);
}
__name(getTransitionName$1, "getTransitionName$1");
const useDomMotionEvents = /* @__PURE__ */ __name(function(onInternalMotionEnd) {
  var cacheElementRef = useRef();
  function removeMotionEvents(element) {
    element && (element.removeEventListener(transitionEndName, onInternalMotionEnd), element.removeEventListener(animationEndName, onInternalMotionEnd));
  }
  __name(removeMotionEvents, "removeMotionEvents");
  function patchMotionEvents(element) {
    cacheElementRef.current && cacheElementRef.current !== element && removeMotionEvents(cacheElementRef.current), element && element !== cacheElementRef.current && (element.addEventListener(transitionEndName, onInternalMotionEnd), element.addEventListener(animationEndName, onInternalMotionEnd), cacheElementRef.current = element);
  }
  return __name(patchMotionEvents, "patchMotionEvents"), React.useEffect(function() {
    return function() {
      removeMotionEvents(cacheElementRef.current);
    };
  }, []), [patchMotionEvents, removeMotionEvents];
}, "useDomMotionEvents");
var useIsomorphicLayoutEffect = canUseDom() ? useLayoutEffect$2 : useEffect;
const useNextFrame = /* @__PURE__ */ __name(function() {
  var nextFrameRef = React.useRef(null);
  function cancelNextFrame() {
    wrapperRaf.cancel(nextFrameRef.current);
  }
  __name(cancelNextFrame, "cancelNextFrame");
  function nextFrame(callback) {
    var delay = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 2;
    cancelNextFrame();
    var nextFrameId = wrapperRaf(function() {
      delay <= 1 ? callback({
        isCanceled: /* @__PURE__ */ __name(function() {
          return nextFrameId !== nextFrameRef.current;
        }, "isCanceled")
      }) : nextFrame(callback, delay - 1);
    });
    nextFrameRef.current = nextFrameId;
  }
  return __name(nextFrame, "nextFrame"), React.useEffect(function() {
    return function() {
      cancelNextFrame();
    };
  }, []), [nextFrame, cancelNextFrame];
}, "useNextFrame");
var FULL_STEP_QUEUE = [STEP_PREPARE, STEP_START, STEP_ACTIVE, STEP_ACTIVATED], SIMPLE_STEP_QUEUE = [STEP_PREPARE, STEP_PREPARED], SkipStep = !1, DoStep = !0;
function isActive(step) {
  return step === STEP_ACTIVE || step === STEP_ACTIVATED;
}
__name(isActive, "isActive");
const useStepQueue = /* @__PURE__ */ __name(function(status, prepareOnly, callback) {
  var _useState = useSafeState(STEP_NONE), _useState2 = _slicedToArray(_useState, 2), step = _useState2[0], setStep = _useState2[1], _useNextFrame = useNextFrame(), _useNextFrame2 = _slicedToArray(_useNextFrame, 2), nextFrame = _useNextFrame2[0], cancelNextFrame = _useNextFrame2[1];
  function startQueue() {
    setStep(STEP_PREPARE, !0);
  }
  __name(startQueue, "startQueue");
  var STEP_QUEUE = prepareOnly ? SIMPLE_STEP_QUEUE : FULL_STEP_QUEUE;
  return useIsomorphicLayoutEffect(function() {
    if (step !== STEP_NONE && step !== STEP_ACTIVATED) {
      var index2 = STEP_QUEUE.indexOf(step), nextStep = STEP_QUEUE[index2 + 1], result = callback(step);
      result === SkipStep ? setStep(nextStep, !0) : nextStep && nextFrame(function(info) {
        function doNext() {
          info.isCanceled() || setStep(nextStep, !0);
        }
        __name(doNext, "doNext"), result === !0 ? doNext() : Promise.resolve(result).then(doNext);
      });
    }
  }, [status, step]), React.useEffect(function() {
    return function() {
      cancelNextFrame();
    };
  }, []), [startQueue, step];
}, "useStepQueue");
function useStatus(supportMotion, visible, getElement, _ref) {
  var _ref$motionEnter = _ref.motionEnter, motionEnter = _ref$motionEnter === void 0 ? !0 : _ref$motionEnter, _ref$motionAppear = _ref.motionAppear, motionAppear = _ref$motionAppear === void 0 ? !0 : _ref$motionAppear, _ref$motionLeave = _ref.motionLeave, motionLeave = _ref$motionLeave === void 0 ? !0 : _ref$motionLeave, motionDeadline = _ref.motionDeadline, motionLeaveImmediately = _ref.motionLeaveImmediately, onAppearPrepare = _ref.onAppearPrepare, onEnterPrepare = _ref.onEnterPrepare, onLeavePrepare = _ref.onLeavePrepare, onAppearStart = _ref.onAppearStart, onEnterStart = _ref.onEnterStart, onLeaveStart = _ref.onLeaveStart, onAppearActive = _ref.onAppearActive, onEnterActive = _ref.onEnterActive, onLeaveActive = _ref.onLeaveActive, onAppearEnd = _ref.onAppearEnd, onEnterEnd = _ref.onEnterEnd, onLeaveEnd = _ref.onLeaveEnd, onVisibleChanged = _ref.onVisibleChanged, _useState = useSafeState(), _useState2 = _slicedToArray(_useState, 2), asyncVisible = _useState2[0], setAsyncVisible = _useState2[1], _useSyncState = useSyncState$3(STATUS_NONE), _useSyncState2 = _slicedToArray(_useSyncState, 2), getStatus2 = _useSyncState2[0], setStatus = _useSyncState2[1], _useState3 = useSafeState(null), _useState4 = _slicedToArray(_useState3, 2), style2 = _useState4[0], setStyle = _useState4[1], currentStatus = getStatus2(), mountedRef = useRef(!1), deadlineRef = useRef(null);
  function getDomElement() {
    return getElement();
  }
  __name(getDomElement, "getDomElement");
  var activeRef = useRef(!1);
  function updateMotionEndStatus() {
    setStatus(STATUS_NONE), setStyle(null, !0);
  }
  __name(updateMotionEndStatus, "updateMotionEndStatus");
  var onInternalMotionEnd = useEvent(function(event) {
    var status = getStatus2();
    if (status !== STATUS_NONE) {
      var element = getDomElement();
      if (!(event && !event.deadline && event.target !== element)) {
        var currentActive = activeRef.current, canEnd;
        status === STATUS_APPEAR && currentActive ? canEnd = onAppearEnd == null ? void 0 : onAppearEnd(element, event) : status === STATUS_ENTER && currentActive ? canEnd = onEnterEnd == null ? void 0 : onEnterEnd(element, event) : status === STATUS_LEAVE && currentActive && (canEnd = onLeaveEnd == null ? void 0 : onLeaveEnd(element, event)), currentActive && canEnd !== !1 && updateMotionEndStatus();
      }
    }
  }), _useDomMotionEvents = useDomMotionEvents(onInternalMotionEnd), _useDomMotionEvents2 = _slicedToArray(_useDomMotionEvents, 1), patchMotionEvents = _useDomMotionEvents2[0], getEventHandlers = /* @__PURE__ */ __name(function(targetStatus) {
    switch (targetStatus) {
      case STATUS_APPEAR:
        return _defineProperty$2(_defineProperty$2(_defineProperty$2({}, STEP_PREPARE, onAppearPrepare), STEP_START, onAppearStart), STEP_ACTIVE, onAppearActive);
      case STATUS_ENTER:
        return _defineProperty$2(_defineProperty$2(_defineProperty$2({}, STEP_PREPARE, onEnterPrepare), STEP_START, onEnterStart), STEP_ACTIVE, onEnterActive);
      case STATUS_LEAVE:
        return _defineProperty$2(_defineProperty$2(_defineProperty$2({}, STEP_PREPARE, onLeavePrepare), STEP_START, onLeaveStart), STEP_ACTIVE, onLeaveActive);
      default:
        return {};
    }
  }, "getEventHandlers"), eventHandlers = React.useMemo(function() {
    return getEventHandlers(currentStatus);
  }, [currentStatus]), _useStepQueue = useStepQueue(currentStatus, !supportMotion, function(newStep) {
    if (newStep === STEP_PREPARE) {
      var onPrepare = eventHandlers[STEP_PREPARE];
      return onPrepare ? onPrepare(getDomElement()) : SkipStep;
    }
    if (step in eventHandlers) {
      var _eventHandlers$step;
      setStyle(((_eventHandlers$step = eventHandlers[step]) === null || _eventHandlers$step === void 0 ? void 0 : _eventHandlers$step.call(eventHandlers, getDomElement(), null)) || null);
    }
    return step === STEP_ACTIVE && currentStatus !== STATUS_NONE && (patchMotionEvents(getDomElement()), motionDeadline > 0 && (clearTimeout(deadlineRef.current), deadlineRef.current = setTimeout(function() {
      onInternalMotionEnd({
        deadline: !0
      });
    }, motionDeadline))), step === STEP_PREPARED && updateMotionEndStatus(), DoStep;
  }), _useStepQueue2 = _slicedToArray(_useStepQueue, 2), startStep = _useStepQueue2[0], step = _useStepQueue2[1], active = isActive(step);
  activeRef.current = active;
  var visibleRef = useRef(null);
  useIsomorphicLayoutEffect(function() {
    if (!(mountedRef.current && visibleRef.current === visible)) {
      setAsyncVisible(visible);
      var isMounted = mountedRef.current;
      mountedRef.current = !0;
      var nextStatus;
      !isMounted && visible && motionAppear && (nextStatus = STATUS_APPEAR), isMounted && visible && motionEnter && (nextStatus = STATUS_ENTER), (isMounted && !visible && motionLeave || !isMounted && motionLeaveImmediately && !visible && motionLeave) && (nextStatus = STATUS_LEAVE);
      var nextEventHandlers = getEventHandlers(nextStatus);
      nextStatus && (supportMotion || nextEventHandlers[STEP_PREPARE]) ? (setStatus(nextStatus), startStep()) : setStatus(STATUS_NONE), visibleRef.current = visible;
    }
  }, [visible]), useEffect(function() {
    // Cancel appear
    (currentStatus === STATUS_APPEAR && !motionAppear || // Cancel enter
    currentStatus === STATUS_ENTER && !motionEnter || // Cancel leave
    currentStatus === STATUS_LEAVE && !motionLeave) && setStatus(STATUS_NONE);
  }, [motionAppear, motionEnter, motionLeave]), useEffect(function() {
    return function() {
      mountedRef.current = !1, clearTimeout(deadlineRef.current);
    };
  }, []);
  var firstMountChangeRef = React.useRef(!1);
  useEffect(function() {
    asyncVisible && (firstMountChangeRef.current = !0), asyncVisible !== void 0 && currentStatus === STATUS_NONE && ((firstMountChangeRef.current || asyncVisible) && (onVisibleChanged == null || onVisibleChanged(asyncVisible)), firstMountChangeRef.current = !0);
  }, [asyncVisible, currentStatus]);
  var mergedStyle = style2;
  return eventHandlers[STEP_PREPARE] && step === STEP_START && (mergedStyle = _objectSpread2$1({
    transition: "none"
  }, mergedStyle)), [currentStatus, step, mergedStyle, asyncVisible ?? visible];
}
__name(useStatus, "useStatus");
function genCSSMotion(config) {
  var transitionSupport = config;
  _typeof$4(config) === "object" && (transitionSupport = config.transitionSupport);
  function isSupportTransition(props, contextMotion) {
    return !!(props.motionName && transitionSupport && contextMotion !== !1);
  }
  __name(isSupportTransition, "isSupportTransition");
  var CSSMotion2 = /* @__PURE__ */ React.forwardRef(function(props, ref) {
    var _props$visible = props.visible, visible = _props$visible === void 0 ? !0 : _props$visible, _props$removeOnLeave = props.removeOnLeave, removeOnLeave = _props$removeOnLeave === void 0 ? !0 : _props$removeOnLeave, forceRender = props.forceRender, children = props.children, motionName = props.motionName, leavedClassName = props.leavedClassName, eventProps = props.eventProps, _React$useContext = React.useContext(Context$1), contextMotion = _React$useContext.motion, supportMotion = isSupportTransition(props, contextMotion), nodeRef = useRef(), wrapperNodeRef = useRef();
    function getDomElement() {
      try {
        return nodeRef.current instanceof HTMLElement ? nodeRef.current : findDOMNode(wrapperNodeRef.current);
      } catch {
        return null;
      }
    }
    __name(getDomElement, "getDomElement");
    var _useStatus = useStatus(supportMotion, visible, getDomElement, props), _useStatus2 = _slicedToArray(_useStatus, 4), status = _useStatus2[0], statusStep = _useStatus2[1], statusStyle = _useStatus2[2], mergedVisible = _useStatus2[3], renderedRef = React.useRef(mergedVisible);
    mergedVisible && (renderedRef.current = !0);
    var setNodeRef = React.useCallback(function(node2) {
      nodeRef.current = node2, fillRef(ref, node2);
    }, [ref]), motionChildren, mergedProps = _objectSpread2$1(_objectSpread2$1({}, eventProps), {}, {
      visible
    });
    if (!children)
      motionChildren = null;
    else if (status === STATUS_NONE)
      mergedVisible ? motionChildren = children(_objectSpread2$1({}, mergedProps), setNodeRef) : !removeOnLeave && renderedRef.current && leavedClassName ? motionChildren = children(_objectSpread2$1(_objectSpread2$1({}, mergedProps), {}, {
        className: leavedClassName
      }), setNodeRef) : forceRender || !removeOnLeave && !leavedClassName ? motionChildren = children(_objectSpread2$1(_objectSpread2$1({}, mergedProps), {}, {
        style: {
          display: "none"
        }
      }), setNodeRef) : motionChildren = null;
    else {
      var statusSuffix;
      statusStep === STEP_PREPARE ? statusSuffix = "prepare" : isActive(statusStep) ? statusSuffix = "active" : statusStep === STEP_START && (statusSuffix = "start");
      var motionCls = getTransitionName$1(motionName, "".concat(status, "-").concat(statusSuffix));
      motionChildren = children(_objectSpread2$1(_objectSpread2$1({}, mergedProps), {}, {
        className: cn(getTransitionName$1(motionName, status), _defineProperty$2(_defineProperty$2({}, motionCls, motionCls && statusSuffix), motionName, typeof motionName == "string")),
        style: statusStyle
      }), setNodeRef);
    }
    if (/* @__PURE__ */ React.isValidElement(motionChildren) && supportRef(motionChildren)) {
      var originNodeRef = getNodeRef(motionChildren);
      originNodeRef || (motionChildren = /* @__PURE__ */ React.cloneElement(motionChildren, {
        ref: setNodeRef
      }));
    }
    return /* @__PURE__ */ React.createElement(DomWrapper, {
      ref: wrapperNodeRef
    }, motionChildren);
  });
  return CSSMotion2.displayName = "CSSMotion", CSSMotion2;
}
__name(genCSSMotion, "genCSSMotion");
const CSSMotion = genCSSMotion(supportTransition);
var STATUS_ADD = "add", STATUS_KEEP = "keep", STATUS_REMOVE = "remove", STATUS_REMOVED = "removed";
function wrapKeyToObject(key) {
  var keyObj;
  return key && _typeof$4(key) === "object" && "key" in key ? keyObj = key : keyObj = {
    key
  }, _objectSpread2$1(_objectSpread2$1({}, keyObj), {}, {
    key: String(keyObj.key)
  });
}
__name(wrapKeyToObject, "wrapKeyToObject");
function parseKeys() {
  var keys2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
  return keys2.map(wrapKeyToObject);
}
__name(parseKeys, "parseKeys");
function diffKeys() {
  var prevKeys = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [], currentKeys = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [], list = [], currentIndex = 0, currentLen = currentKeys.length, prevKeyObjects = parseKeys(prevKeys), currentKeyObjects = parseKeys(currentKeys);
  prevKeyObjects.forEach(function(keyObj) {
    for (var hit = !1, i = currentIndex; i < currentLen; i += 1) {
      var currentKeyObj = currentKeyObjects[i];
      if (currentKeyObj.key === keyObj.key) {
        currentIndex < i && (list = list.concat(currentKeyObjects.slice(currentIndex, i).map(function(obj) {
          return _objectSpread2$1(_objectSpread2$1({}, obj), {}, {
            status: STATUS_ADD
          });
        })), currentIndex = i), list.push(_objectSpread2$1(_objectSpread2$1({}, currentKeyObj), {}, {
          status: STATUS_KEEP
        })), currentIndex += 1, hit = !0;
        break;
      }
    }
    hit || list.push(_objectSpread2$1(_objectSpread2$1({}, keyObj), {}, {
      status: STATUS_REMOVE
    }));
  }), currentIndex < currentLen && (list = list.concat(currentKeyObjects.slice(currentIndex).map(function(obj) {
    return _objectSpread2$1(_objectSpread2$1({}, obj), {}, {
      status: STATUS_ADD
    });
  })));
  var keys2 = {};
  list.forEach(function(_ref) {
    var key = _ref.key;
    keys2[key] = (keys2[key] || 0) + 1;
  });
  var duplicatedKeys = Object.keys(keys2).filter(function(key) {
    return keys2[key] > 1;
  });
  return duplicatedKeys.forEach(function(matchKey) {
    list = list.filter(function(_ref2) {
      var key = _ref2.key, status = _ref2.status;
      return key !== matchKey || status !== STATUS_REMOVE;
    }), list.forEach(function(node2) {
      node2.key === matchKey && (node2.status = STATUS_KEEP);
    });
  }), list;
}
__name(diffKeys, "diffKeys");
var _excluded$Q = ["component", "children", "onVisibleChanged", "onAllRemoved"], _excluded2$a = ["status"], MOTION_PROP_NAMES = ["eventProps", "visible", "children", "motionName", "motionAppear", "motionEnter", "motionLeave", "motionLeaveImmediately", "motionDeadline", "removeOnLeave", "leavedClassName", "onAppearPrepare", "onAppearStart", "onAppearActive", "onAppearEnd", "onEnterStart", "onEnterActive", "onEnterEnd", "onLeaveStart", "onLeaveActive", "onLeaveEnd"];
function genCSSMotionList(transitionSupport) {
  var CSSMotion$1 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : CSSMotion, CSSMotionList2 = /* @__PURE__ */ function(_React$Component) {
    _inherits(CSSMotionList3, _React$Component);
    var _super = _createSuper(CSSMotionList3);
    function CSSMotionList3() {
      var _this;
      _classCallCheck$1(this, CSSMotionList3);
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++)
        args[_key] = arguments[_key];
      return _this = _super.call.apply(_super, [this].concat(args)), _defineProperty$2(_assertThisInitialized(_this), "state", {
        keyEntities: []
      }), _defineProperty$2(_assertThisInitialized(_this), "removeKey", function(removeKey) {
        _this.setState(function(prevState) {
          var nextKeyEntities = prevState.keyEntities.map(function(entity) {
            return entity.key !== removeKey ? entity : _objectSpread2$1(_objectSpread2$1({}, entity), {}, {
              status: STATUS_REMOVED
            });
          });
          return {
            keyEntities: nextKeyEntities
          };
        }, function() {
          var keyEntities = _this.state.keyEntities, restKeysCount = keyEntities.filter(function(_ref) {
            var status = _ref.status;
            return status !== STATUS_REMOVED;
          }).length;
          restKeysCount === 0 && _this.props.onAllRemoved && _this.props.onAllRemoved();
        });
      }), _this;
    }
    return __name(CSSMotionList3, "CSSMotionList"), _createClass$1(CSSMotionList3, [{
      key: "render",
      value: /* @__PURE__ */ __name(function() {
        var _this2 = this, keyEntities = this.state.keyEntities, _this$props = this.props, component = _this$props.component, children = _this$props.children, _onVisibleChanged = _this$props.onVisibleChanged;
        _this$props.onAllRemoved;
        var restProps = _objectWithoutProperties(_this$props, _excluded$Q), Component2 = component || React.Fragment, motionProps = {};
        return MOTION_PROP_NAMES.forEach(function(prop) {
          motionProps[prop] = restProps[prop], delete restProps[prop];
        }), delete restProps.keys, /* @__PURE__ */ React.createElement(Component2, restProps, keyEntities.map(function(_ref2, index2) {
          var status = _ref2.status, eventProps = _objectWithoutProperties(_ref2, _excluded2$a), visible = status === STATUS_ADD || status === STATUS_KEEP;
          return /* @__PURE__ */ React.createElement(CSSMotion$1, _extends({}, motionProps, {
            key: eventProps.key,
            visible,
            eventProps,
            onVisibleChanged: /* @__PURE__ */ __name(function(changedVisible) {
              _onVisibleChanged == null || _onVisibleChanged(changedVisible, {
                key: eventProps.key
              }), changedVisible || _this2.removeKey(eventProps.key);
            }, "onVisibleChanged")
          }), function(props, ref) {
            return children(_objectSpread2$1(_objectSpread2$1({}, props), {}, {
              index: index2
            }), ref);
          });
        }));
      }, "render")
    }], [{
      key: "getDerivedStateFromProps",
      value: /* @__PURE__ */ __name(function(_ref3, _ref4) {
        var keys2 = _ref3.keys, keyEntities = _ref4.keyEntities, parsedKeyObjects = parseKeys(keys2), mixedKeyEntities = diffKeys(keyEntities, parsedKeyObjects);
        return {
          keyEntities: mixedKeyEntities.filter(function(entity) {
            var prevEntity = keyEntities.find(function(_ref5) {
              var key = _ref5.key;
              return entity.key === key;
            });
            return !(prevEntity && prevEntity.status === STATUS_REMOVED && entity.status === STATUS_REMOVE);
          })
        };
      }, "getDerivedStateFromProps")
    }]), CSSMotionList3;
  }(React.Component);
  return _defineProperty$2(CSSMotionList2, "defaultProps", {
    component: "div"
  }), CSSMotionList2;
}
__name(genCSSMotionList, "genCSSMotionList");
const CSSMotionList = genCSSMotionList(supportTransition);
function MotionWrapper(props) {
  const {
    children
  } = props, [, token2] = useToken(), {
    motion: motion2
  } = token2, needWrapMotionProviderRef = React.useRef(!1);
  return needWrapMotionProviderRef.current = needWrapMotionProviderRef.current || motion2 === !1, needWrapMotionProviderRef.current ? /* @__PURE__ */ React.createElement(MotionProvider, {
    motion: motion2
  }, children) : children;
}
__name(MotionWrapper, "MotionWrapper");
const PropWarning = /* @__PURE__ */ React.memo((_ref) => {
  let {
    dropdownMatchSelectWidth
  } = _ref;
  return devUseWarning("ConfigProvider").deprecated(dropdownMatchSelectWidth === void 0, "dropdownMatchSelectWidth", "popupMatchSelectWidth"), null;
});
process.env.NODE_ENV !== "production" && (PropWarning.displayName = "PropWarning");
const PropWarning$1 = process.env.NODE_ENV !== "production" ? PropWarning : () => null;
var __rest$U = function(s, e2) {
  var t2 = {};
  for (var p in s) Object.prototype.hasOwnProperty.call(s, p) && e2.indexOf(p) < 0 && (t2[p] = s[p]);
  if (s != null && typeof Object.getOwnPropertySymbols == "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++)
    e2.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]) && (t2[p[i]] = s[p[i]]);
  return t2;
};
let existThemeConfig = !1;
const warnContext = process.env.NODE_ENV !== "production" ? (componentName) => {
  process.env.NODE_ENV !== "production" && warning$2(!existThemeConfig, componentName, "Static function can not consume context like dynamic theme. Please use 'App' component instead.");
} : (
  /* istanbul ignore next */
  null
), PASSED_PROPS = ["getTargetContainer", "getPopupContainer", "renderEmpty", "input", "pagination", "form", "select", "button"];
let globalPrefixCls, globalIconPrefixCls, globalTheme, globalHolderRender;
function getGlobalPrefixCls() {
  return globalPrefixCls || defaultPrefixCls;
}
__name(getGlobalPrefixCls, "getGlobalPrefixCls");
function getGlobalIconPrefixCls() {
  return globalIconPrefixCls || defaultIconPrefixCls;
}
__name(getGlobalIconPrefixCls, "getGlobalIconPrefixCls");
function isLegacyTheme(theme2) {
  return Object.keys(theme2).some((key) => key.endsWith("Color"));
}
__name(isLegacyTheme, "isLegacyTheme");
const setGlobalConfig = /* @__PURE__ */ __name((props) => {
  const {
    prefixCls,
    iconPrefixCls,
    theme: theme2,
    holderRender
  } = props;
  prefixCls !== void 0 && (globalPrefixCls = prefixCls), iconPrefixCls !== void 0 && (globalIconPrefixCls = iconPrefixCls), "holderRender" in props && (globalHolderRender = holderRender), theme2 && (isLegacyTheme(theme2) ? (process.env.NODE_ENV !== "production" && warning$2(!1, "ConfigProvider", "`config` of css variable theme is not work in v5. Please use new `theme` config instead."), registerTheme$1(getGlobalPrefixCls(), theme2)) : globalTheme = theme2);
}, "setGlobalConfig"), globalConfig = /* @__PURE__ */ __name(() => ({
  getPrefixCls: /* @__PURE__ */ __name((suffixCls, customizePrefixCls) => customizePrefixCls || (suffixCls ? `${getGlobalPrefixCls()}-${suffixCls}` : getGlobalPrefixCls()), "getPrefixCls"),
  getIconPrefixCls: getGlobalIconPrefixCls,
  getRootPrefixCls: /* @__PURE__ */ __name(() => globalPrefixCls || getGlobalPrefixCls(), "getRootPrefixCls"),
  getTheme: /* @__PURE__ */ __name(() => globalTheme, "getTheme"),
  holderRender: globalHolderRender
}), "globalConfig"), ProviderChildren = /* @__PURE__ */ __name((props) => {
  const {
    children,
    csp: customCsp,
    autoInsertSpaceInButton,
    alert,
    anchor,
    form,
    locale: locale2,
    componentSize,
    direction,
    space,
    splitter,
    virtual,
    dropdownMatchSelectWidth,
    popupMatchSelectWidth,
    popupOverflow,
    legacyLocale,
    parentContext,
    iconPrefixCls: customIconPrefixCls,
    theme: theme2,
    componentDisabled,
    segmented,
    statistic: statistic2,
    spin,
    calendar,
    carousel,
    cascader,
    collapse,
    typography,
    checkbox,
    descriptions,
    divider,
    drawer,
    skeleton,
    steps,
    image,
    layout,
    list,
    mentions,
    modal,
    progress,
    result,
    slider,
    breadcrumb,
    menu,
    pagination,
    input,
    textArea,
    empty: empty2,
    badge,
    radio,
    rate,
    switch: SWITCH,
    transfer,
    avatar,
    message,
    tag,
    table,
    card,
    tabs,
    timeline,
    timePicker,
    upload: upload2,
    notification,
    tree,
    colorPicker,
    datePicker,
    rangePicker,
    flex,
    wave,
    dropdown,
    warning: warningConfig,
    tour,
    floatButtonGroup,
    variant,
    inputNumber,
    treeSelect
  } = props, getPrefixCls = React.useCallback((suffixCls, customizePrefixCls) => {
    const {
      prefixCls
    } = props;
    if (customizePrefixCls)
      return customizePrefixCls;
    const mergedPrefixCls = prefixCls || parentContext.getPrefixCls("");
    return suffixCls ? `${mergedPrefixCls}-${suffixCls}` : mergedPrefixCls;
  }, [parentContext.getPrefixCls, props.prefixCls]), iconPrefixCls = customIconPrefixCls || parentContext.iconPrefixCls || defaultIconPrefixCls, csp = customCsp || parentContext.csp;
  useResetIconStyle(iconPrefixCls, csp);
  const mergedTheme = useTheme$1(theme2, parentContext.theme, {
    prefixCls: getPrefixCls("")
  });
  process.env.NODE_ENV !== "production" && (existThemeConfig = existThemeConfig || !!mergedTheme);
  const baseConfig = {
    csp,
    autoInsertSpaceInButton,
    alert,
    anchor,
    locale: locale2 || legacyLocale,
    direction,
    space,
    splitter,
    virtual,
    popupMatchSelectWidth: popupMatchSelectWidth ?? dropdownMatchSelectWidth,
    popupOverflow,
    getPrefixCls,
    iconPrefixCls,
    theme: mergedTheme,
    segmented,
    statistic: statistic2,
    spin,
    calendar,
    carousel,
    cascader,
    collapse,
    typography,
    checkbox,
    descriptions,
    divider,
    drawer,
    skeleton,
    steps,
    image,
    input,
    textArea,
    layout,
    list,
    mentions,
    modal,
    progress,
    result,
    slider,
    breadcrumb,
    menu,
    pagination,
    empty: empty2,
    badge,
    radio,
    rate,
    switch: SWITCH,
    transfer,
    avatar,
    message,
    tag,
    table,
    card,
    tabs,
    timeline,
    timePicker,
    upload: upload2,
    notification,
    tree,
    colorPicker,
    datePicker,
    rangePicker,
    flex,
    wave,
    dropdown,
    warning: warningConfig,
    tour,
    floatButtonGroup,
    variant,
    inputNumber,
    treeSelect
  };
  process.env.NODE_ENV !== "production" && devUseWarning("ConfigProvider")(!("autoInsertSpaceInButton" in props), "deprecated", "`autoInsertSpaceInButton` is deprecated. Please use `{ button: { autoInsertSpace: boolean }}` instead.");
  const config = Object.assign({}, parentContext);
  Object.keys(baseConfig).forEach((key) => {
    baseConfig[key] !== void 0 && (config[key] = baseConfig[key]);
  }), PASSED_PROPS.forEach((propName) => {
    const propValue = props[propName];
    propValue && (config[propName] = propValue);
  }), typeof autoInsertSpaceInButton < "u" && (config.button = Object.assign({
    autoInsertSpace: autoInsertSpaceInButton
  }, config.button));
  const memoedConfig = useMemo(() => config, config, (prevConfig, currentConfig) => {
    const prevKeys = Object.keys(prevConfig), currentKeys = Object.keys(currentConfig);
    return prevKeys.length !== currentKeys.length || prevKeys.some((key) => prevConfig[key] !== currentConfig[key]);
  }), memoIconContextValue = React.useMemo(() => ({
    prefixCls: iconPrefixCls,
    csp
  }), [iconPrefixCls, csp]);
  let childNode = /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement(PropWarning$1, {
    dropdownMatchSelectWidth
  }), children);
  const validateMessages = React.useMemo(() => {
    var _a, _b, _c, _d;
    return merge$1(((_a = localeValues$1.Form) === null || _a === void 0 ? void 0 : _a.defaultValidateMessages) || {}, ((_c = (_b = memoedConfig.locale) === null || _b === void 0 ? void 0 : _b.Form) === null || _c === void 0 ? void 0 : _c.defaultValidateMessages) || {}, ((_d = memoedConfig.form) === null || _d === void 0 ? void 0 : _d.validateMessages) || {}, (form == null ? void 0 : form.validateMessages) || {});
  }, [memoedConfig, form == null ? void 0 : form.validateMessages]);
  Object.keys(validateMessages).length > 0 && (childNode = /* @__PURE__ */ React.createElement(ValidateMessagesContext.Provider, {
    value: validateMessages
  }, childNode)), locale2 && (childNode = /* @__PURE__ */ React.createElement(LocaleProvider, {
    locale: locale2,
    _ANT_MARK__: ANT_MARK
  }, childNode)), childNode = /* @__PURE__ */ React.createElement(IconContext.Provider, {
    value: memoIconContextValue
  }, childNode), componentSize && (childNode = /* @__PURE__ */ React.createElement(SizeContextProvider, {
    size: componentSize
  }, childNode)), childNode = /* @__PURE__ */ React.createElement(MotionWrapper, null, childNode);
  const memoTheme = React.useMemo(() => {
    const _a = mergedTheme || {}, {
      algorithm: algorithm2,
      token: token2,
      components: components2,
      cssVar
    } = _a, rest = __rest$U(_a, ["algorithm", "token", "components", "cssVar"]), themeObj = algorithm2 && (!Array.isArray(algorithm2) || algorithm2.length > 0) ? createTheme(algorithm2) : defaultTheme, parsedComponents = {};
    Object.entries(components2 || {}).forEach((_ref) => {
      let [componentName, componentToken] = _ref;
      const parsedToken = Object.assign({}, componentToken);
      "algorithm" in parsedToken && (parsedToken.algorithm === !0 ? parsedToken.theme = themeObj : (Array.isArray(parsedToken.algorithm) || typeof parsedToken.algorithm == "function") && (parsedToken.theme = createTheme(parsedToken.algorithm)), delete parsedToken.algorithm), parsedComponents[componentName] = parsedToken;
    });
    const mergedToken = Object.assign(Object.assign({}, seedToken), token2);
    return Object.assign(Object.assign({}, rest), {
      theme: themeObj,
      token: mergedToken,
      components: parsedComponents,
      override: Object.assign({
        override: mergedToken
      }, parsedComponents),
      cssVar
    });
  }, [mergedTheme]);
  return theme2 && (childNode = /* @__PURE__ */ React.createElement(DesignTokenContext.Provider, {
    value: memoTheme
  }, childNode)), memoedConfig.warning && (childNode = /* @__PURE__ */ React.createElement(WarningContext.Provider, {
    value: memoedConfig.warning
  }, childNode)), componentDisabled !== void 0 && (childNode = /* @__PURE__ */ React.createElement(DisabledContextProvider, {
    disabled: componentDisabled
  }, childNode)), /* @__PURE__ */ React.createElement(ConfigContext.Provider, {
    value: memoedConfig
  }, childNode);
}, "ProviderChildren"), ConfigProvider = /* @__PURE__ */ __name((props) => {
  const context = React.useContext(ConfigContext), antLocale = React.useContext(LocaleContext);
  return /* @__PURE__ */ React.createElement(ProviderChildren, Object.assign({
    parentContext: context,
    legacyLocale: antLocale
  }, props));
}, "ConfigProvider");
ConfigProvider.ConfigContext = ConfigContext;
ConfigProvider.SizeContext = SizeContext;
ConfigProvider.config = setGlobalConfig;
ConfigProvider.useConfig = useConfig;
Object.defineProperty(ConfigProvider, "SizeContext", {
  get: /* @__PURE__ */ __name(() => (process.env.NODE_ENV !== "production" && warning$2(!1, "ConfigProvider", "ConfigProvider.SizeContext is deprecated. Please use `ConfigProvider.useConfig().componentSize` instead."), SizeContext), "get")
});
process.env.NODE_ENV !== "production" && (ConfigProvider.displayName = "ConfigProvider");
var CheckCircleFilled$1 = { icon: { tag: "svg", attrs: { viewBox: "64 64 896 896", focusable: "false" }, children: [{ tag: "path", attrs: { d: "M512 64C264.6 64 64 264.6 64 512s200.6 448 448 448 448-200.6 448-448S759.4 64 512 64zm193.5 301.7l-210.6 292a31.8 31.8 0 01-51.7 0L318.5 484.9c-3.8-5.3 0-12.7 6.5-12.7h46.9c10.2 0 19.9 4.9 25.9 13.3l71.2 98.8 157.2-218c6-8.3 15.6-13.3 25.9-13.3H699c6.5 0 10.3 7.4 6.5 12.7z" } }] }, name: "check-circle", theme: "filled" };
function getRoot(ele) {
  var _ele$getRootNode;
  return ele == null || (_ele$getRootNode = ele.getRootNode) === null || _ele$getRootNode === void 0 ? void 0 : _ele$getRootNode.call(ele);
}
__name(getRoot, "getRoot");
function inShadow(ele) {
  return getRoot(ele) instanceof ShadowRoot;
}
__name(inShadow, "inShadow");
function getShadowRoot(ele) {
  return inShadow(ele) ? getRoot(ele) : null;
}
__name(getShadowRoot, "getShadowRoot");
function camelCase(input) {
  return input.replace(/-(.)/g, function(match2, g) {
    return g.toUpperCase();
  });
}
__name(camelCase, "camelCase");
function warning$1(valid, message) {
  warningOnce(valid, "[@ant-design/icons] ".concat(message));
}
__name(warning$1, "warning$1");
function isIconDefinition(target) {
  return _typeof$4(target) === "object" && typeof target.name == "string" && typeof target.theme == "string" && (_typeof$4(target.icon) === "object" || typeof target.icon == "function");
}
__name(isIconDefinition, "isIconDefinition");
function normalizeAttrs() {
  var attrs = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
  return Object.keys(attrs).reduce(function(acc, key) {
    var val = attrs[key];
    switch (key) {
      case "class":
        acc.className = val, delete acc.class;
        break;
      default:
        delete acc[key], acc[camelCase(key)] = val;
    }
    return acc;
  }, {});
}
__name(normalizeAttrs, "normalizeAttrs");
function generate(node2, key, rootProps) {
  return rootProps ? /* @__PURE__ */ React__default.createElement(node2.tag, _objectSpread2$1(_objectSpread2$1({
    key
  }, normalizeAttrs(node2.attrs)), rootProps), (node2.children || []).map(function(child, index2) {
    return generate(child, "".concat(key, "-").concat(node2.tag, "-").concat(index2));
  })) : /* @__PURE__ */ React__default.createElement(node2.tag, _objectSpread2$1({
    key
  }, normalizeAttrs(node2.attrs)), (node2.children || []).map(function(child, index2) {
    return generate(child, "".concat(key, "-").concat(node2.tag, "-").concat(index2));
  }));
}
__name(generate, "generate");
function getSecondaryColor(primaryColor) {
  return generate$1(primaryColor)[0];
}
__name(getSecondaryColor, "getSecondaryColor");
function normalizeTwoToneColors(twoToneColor) {
  return twoToneColor ? Array.isArray(twoToneColor) ? twoToneColor : [twoToneColor] : [];
}
__name(normalizeTwoToneColors, "normalizeTwoToneColors");
var iconStyles = `
.anticon {
  display: inline-flex;
  align-items: center;
  color: inherit;
  font-style: normal;
  line-height: 0;
  text-align: center;
  text-transform: none;
  vertical-align: -0.125em;
  text-rendering: optimizeLegibility;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
}

.anticon > * {
  line-height: 1;
}

.anticon svg {
  display: inline-block;
}

.anticon::before {
  display: none;
}

.anticon .anticon-icon {
  display: block;
}

.anticon[tabindex] {
  cursor: pointer;
}

.anticon-spin::before,
.anticon-spin {
  display: inline-block;
  -webkit-animation: loadingCircle 1s infinite linear;
  animation: loadingCircle 1s infinite linear;
}

@-webkit-keyframes loadingCircle {
  100% {
    -webkit-transform: rotate(360deg);
    transform: rotate(360deg);
  }
}

@keyframes loadingCircle {
  100% {
    -webkit-transform: rotate(360deg);
    transform: rotate(360deg);
  }
}
`, useInsertStyles = /* @__PURE__ */ __name(function(eleRef) {
  var _useContext = useContext$1(IconContext), csp = _useContext.csp, prefixCls = _useContext.prefixCls, layer = _useContext.layer, mergedStyleStr = iconStyles;
  prefixCls && (mergedStyleStr = mergedStyleStr.replace(/anticon/g, prefixCls)), layer && (mergedStyleStr = "@layer ".concat(layer, ` {
`).concat(mergedStyleStr, `
}`)), useEffect(function() {
    var ele = eleRef.current, shadowRoot = getShadowRoot(ele);
    updateCSS(mergedStyleStr, "@ant-design-icons", {
      prepend: !layer,
      csp,
      attachTo: shadowRoot
    });
  }, []);
}, "useInsertStyles"), _excluded$P = ["icon", "className", "onClick", "style", "primaryColor", "secondaryColor"], twoToneColorPalette = {
  primaryColor: "#333",
  secondaryColor: "#E6E6E6",
  calculated: !1
};
function setTwoToneColors(_ref) {
  var primaryColor = _ref.primaryColor, secondaryColor = _ref.secondaryColor;
  twoToneColorPalette.primaryColor = primaryColor, twoToneColorPalette.secondaryColor = secondaryColor || getSecondaryColor(primaryColor), twoToneColorPalette.calculated = !!secondaryColor;
}
__name(setTwoToneColors, "setTwoToneColors");
function getTwoToneColors() {
  return _objectSpread2$1({}, twoToneColorPalette);
}
__name(getTwoToneColors, "getTwoToneColors");
var IconBase = /* @__PURE__ */ __name(function(props) {
  var icon = props.icon, className = props.className, onClick = props.onClick, style2 = props.style, primaryColor = props.primaryColor, secondaryColor = props.secondaryColor, restProps = _objectWithoutProperties(props, _excluded$P), svgRef = React.useRef(), colors = twoToneColorPalette;
  if (primaryColor && (colors = {
    primaryColor,
    secondaryColor: secondaryColor || getSecondaryColor(primaryColor)
  }), useInsertStyles(svgRef), warning$1(isIconDefinition(icon), "icon should be icon definiton, but got ".concat(icon)), !isIconDefinition(icon))
    return null;
  var target = icon;
  return target && typeof target.icon == "function" && (target = _objectSpread2$1(_objectSpread2$1({}, target), {}, {
    icon: target.icon(colors.primaryColor, colors.secondaryColor)
  })), generate(target.icon, "svg-".concat(target.name), _objectSpread2$1(_objectSpread2$1({
    className,
    onClick,
    style: style2,
    "data-icon": target.name,
    width: "1em",
    height: "1em",
    fill: "currentColor",
    "aria-hidden": "true"
  }, restProps), {}, {
    ref: svgRef
  }));
}, "IconBase");
IconBase.displayName = "IconReact";
IconBase.getTwoToneColors = getTwoToneColors;
IconBase.setTwoToneColors = setTwoToneColors;
function setTwoToneColor(twoToneColor) {
  var _normalizeTwoToneColo = normalizeTwoToneColors(twoToneColor), _normalizeTwoToneColo2 = _slicedToArray(_normalizeTwoToneColo, 2), primaryColor = _normalizeTwoToneColo2[0], secondaryColor = _normalizeTwoToneColo2[1];
  return IconBase.setTwoToneColors({
    primaryColor,
    secondaryColor
  });
}
__name(setTwoToneColor, "setTwoToneColor");
function getTwoToneColor() {
  var colors = IconBase.getTwoToneColors();
  return colors.calculated ? [colors.primaryColor, colors.secondaryColor] : colors.primaryColor;
}
__name(getTwoToneColor, "getTwoToneColor");
var _excluded$O = ["className", "icon", "spin", "rotate", "tabIndex", "onClick", "twoToneColor"];
setTwoToneColor(blue.primary);
var Icon$3 = /* @__PURE__ */ React.forwardRef(function(props, ref) {
  var className = props.className, icon = props.icon, spin = props.spin, rotate = props.rotate, tabIndex = props.tabIndex, onClick = props.onClick, twoToneColor = props.twoToneColor, restProps = _objectWithoutProperties(props, _excluded$O), _React$useContext = React.useContext(IconContext), _React$useContext$pre = _React$useContext.prefixCls, prefixCls = _React$useContext$pre === void 0 ? "anticon" : _React$useContext$pre, rootClassName = _React$useContext.rootClassName, classString = cn(rootClassName, prefixCls, _defineProperty$2(_defineProperty$2({}, "".concat(prefixCls, "-").concat(icon.name), !!icon.name), "".concat(prefixCls, "-spin"), !!spin || icon.name === "loading"), className), iconTabIndex = tabIndex;
  iconTabIndex === void 0 && onClick && (iconTabIndex = -1);
  var svgStyle = rotate ? {
    msTransform: "rotate(".concat(rotate, "deg)"),
    transform: "rotate(".concat(rotate, "deg)")
  } : void 0, _normalizeTwoToneColo = normalizeTwoToneColors(twoToneColor), _normalizeTwoToneColo2 = _slicedToArray(_normalizeTwoToneColo, 2), primaryColor = _normalizeTwoToneColo2[0], secondaryColor = _normalizeTwoToneColo2[1];
  return /* @__PURE__ */ React.createElement("span", _extends({
    role: "img",
    "aria-label": icon.name
  }, restProps, {
    ref,
    tabIndex: iconTabIndex,
    onClick,
    className: classString
  }), /* @__PURE__ */ React.createElement(IconBase, {
    icon,
    primaryColor,
    secondaryColor,
    style: svgStyle
  }));
});
Icon$3.displayName = "AntdIcon";
Icon$3.getTwoToneColor = getTwoToneColor;
Icon$3.setTwoToneColor = setTwoToneColor;
var CheckCircleFilled = /* @__PURE__ */ __name(function(props, ref) {
  return /* @__PURE__ */ React.createElement(Icon$3, _extends({}, props, {
    ref,
    icon: CheckCircleFilled$1
  }));
}, "CheckCircleFilled"), RefIcon$D = /* @__PURE__ */ React.forwardRef(CheckCircleFilled);
process.env.NODE_ENV !== "production" && (RefIcon$D.displayName = "CheckCircleFilled");
var CloseCircleFilled$1 = { icon: { tag: "svg", attrs: { "fill-rule": "evenodd", viewBox: "64 64 896 896", focusable: "false" }, children: [{ tag: "path", attrs: { d: "M512 64c247.4 0 448 200.6 448 448S759.4 960 512 960 64 759.4 64 512 264.6 64 512 64zm127.98 274.82h-.04l-.08.06L512 466.75 384.14 338.88c-.04-.05-.06-.06-.08-.06a.12.12 0 00-.07 0c-.03 0-.05.01-.09.05l-45.02 45.02a.2.2 0 00-.05.09.12.12 0 000 .07v.02a.27.27 0 00.06.06L466.75 512 338.88 639.86c-.05.04-.06.06-.06.08a.12.12 0 000 .07c0 .03.01.05.05.09l45.02 45.02a.2.2 0 00.09.05.12.12 0 00.07 0c.02 0 .04-.01.08-.05L512 557.25l127.86 127.87c.04.04.06.05.08.05a.12.12 0 00.07 0c.03 0 .05-.01.09-.05l45.02-45.02a.2.2 0 00.05-.09.12.12 0 000-.07v-.02a.27.27 0 00-.05-.06L557.25 512l127.87-127.86c.04-.04.05-.06.05-.08a.12.12 0 000-.07c0-.03-.01-.05-.05-.09l-45.02-45.02a.2.2 0 00-.09-.05.12.12 0 00-.07 0z" } }] }, name: "close-circle", theme: "filled" }, CloseCircleFilled = /* @__PURE__ */ __name(function(props, ref) {
  return /* @__PURE__ */ React.createElement(Icon$3, _extends({}, props, {
    ref,
    icon: CloseCircleFilled$1
  }));
}, "CloseCircleFilled"), RefIcon$C = /* @__PURE__ */ React.forwardRef(CloseCircleFilled);
process.env.NODE_ENV !== "production" && (RefIcon$C.displayName = "CloseCircleFilled");
var CloseOutlined$1 = { icon: { tag: "svg", attrs: { "fill-rule": "evenodd", viewBox: "64 64 896 896", focusable: "false" }, children: [{ tag: "path", attrs: { d: "M799.86 166.31c.02 0 .04.02.08.06l57.69 57.7c.04.03.05.05.06.08a.12.12 0 010 .06c0 .03-.02.05-.06.09L569.93 512l287.7 287.7c.04.04.05.06.06.09a.12.12 0 010 .07c0 .02-.02.04-.06.08l-57.7 57.69c-.03.04-.05.05-.07.06a.12.12 0 01-.07 0c-.03 0-.05-.02-.09-.06L512 569.93l-287.7 287.7c-.04.04-.06.05-.09.06a.12.12 0 01-.07 0c-.02 0-.04-.02-.08-.06l-57.69-57.7c-.04-.03-.05-.05-.06-.07a.12.12 0 010-.07c0-.03.02-.05.06-.09L454.07 512l-287.7-287.7c-.04-.04-.05-.06-.06-.09a.12.12 0 010-.07c0-.02.02-.04.06-.08l57.7-57.69c.03-.04.05-.05.07-.06a.12.12 0 01.07 0c.03 0 .05.02.09.06L512 454.07l287.7-287.7c.04-.04.06-.05.09-.06a.12.12 0 01.07 0z" } }] }, name: "close", theme: "outlined" }, CloseOutlined = /* @__PURE__ */ __name(function(props, ref) {
  return /* @__PURE__ */ React.createElement(Icon$3, _extends({}, props, {
    ref,
    icon: CloseOutlined$1
  }));
}, "CloseOutlined"), RefIcon$B = /* @__PURE__ */ React.forwardRef(CloseOutlined);
process.env.NODE_ENV !== "production" && (RefIcon$B.displayName = "CloseOutlined");
var ExclamationCircleFilled$1 = { icon: { tag: "svg", attrs: { viewBox: "64 64 896 896", focusable: "false" }, children: [{ tag: "path", attrs: { d: "M512 64C264.6 64 64 264.6 64 512s200.6 448 448 448 448-200.6 448-448S759.4 64 512 64zm-32 232c0-4.4 3.6-8 8-8h48c4.4 0 8 3.6 8 8v272c0 4.4-3.6 8-8 8h-48c-4.4 0-8-3.6-8-8V296zm32 440a48.01 48.01 0 010-96 48.01 48.01 0 010 96z" } }] }, name: "exclamation-circle", theme: "filled" }, ExclamationCircleFilled = /* @__PURE__ */ __name(function(props, ref) {
  return /* @__PURE__ */ React.createElement(Icon$3, _extends({}, props, {
    ref,
    icon: ExclamationCircleFilled$1
  }));
}, "ExclamationCircleFilled"), RefIcon$A = /* @__PURE__ */ React.forwardRef(ExclamationCircleFilled);
process.env.NODE_ENV !== "production" && (RefIcon$A.displayName = "ExclamationCircleFilled");
var attributes = `accept acceptCharset accessKey action allowFullScreen allowTransparency
    alt async autoComplete autoFocus autoPlay capture cellPadding cellSpacing challenge
    charSet checked classID className colSpan cols content contentEditable contextMenu
    controls coords crossOrigin data dateTime default defer dir disabled download draggable
    encType form formAction formEncType formMethod formNoValidate formTarget frameBorder
    headers height hidden high href hrefLang htmlFor httpEquiv icon id inputMode integrity
    is keyParams keyType kind label lang list loop low manifest marginHeight marginWidth max maxLength media
    mediaGroup method min minLength multiple muted name noValidate nonce open
    optimum pattern placeholder poster preload radioGroup readOnly rel required
    reversed role rowSpan rows sandbox scope scoped scrolling seamless selected
    shape size sizes span spellCheck src srcDoc srcLang srcSet start step style
    summary tabIndex target title type useMap value width wmode wrap`, eventsName = `onCopy onCut onPaste onCompositionEnd onCompositionStart onCompositionUpdate onKeyDown
    onKeyPress onKeyUp onFocus onBlur onChange onInput onSubmit onClick onContextMenu onDoubleClick
    onDrag onDragEnd onDragEnter onDragExit onDragLeave onDragOver onDragStart onDrop onMouseDown
    onMouseEnter onMouseLeave onMouseMove onMouseOut onMouseOver onMouseUp onSelect onTouchCancel
    onTouchEnd onTouchMove onTouchStart onScroll onWheel onAbort onCanPlay onCanPlayThrough
    onDurationChange onEmptied onEncrypted onEnded onError onLoadedData onLoadedMetadata
    onLoadStart onPause onPlay onPlaying onProgress onRateChange onSeeked onSeeking onStalled onSuspend onTimeUpdate onVolumeChange onWaiting onLoad onError`, propList = "".concat(attributes, " ").concat(eventsName).split(/[\s\n]+/), ariaPrefix = "aria-", dataPrefix = "data-";
function match(key, prefix) {
  return key.indexOf(prefix) === 0;
}
__name(match, "match");
function pickAttrs(props) {
  var ariaOnly = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1, mergedConfig;
  ariaOnly === !1 ? mergedConfig = {
    aria: !0,
    data: !0,
    attr: !0
  } : ariaOnly === !0 ? mergedConfig = {
    aria: !0
  } : mergedConfig = _objectSpread2$1({}, ariaOnly);
  var attrs = {};
  return Object.keys(props).forEach(function(key) {
    // Aria
    (mergedConfig.aria && (key === "role" || match(key, ariaPrefix)) || // Data
    mergedConfig.data && match(key, dataPrefix) || // Attr
    mergedConfig.attr && propList.includes(key)) && (attrs[key] = props[key]);
  }), attrs;
}
__name(pickAttrs, "pickAttrs");
function isFragment(child) {
  return child && /* @__PURE__ */ React__default.isValidElement(child) && child.type === React__default.Fragment;
}
__name(isFragment, "isFragment");
const replaceElement = /* @__PURE__ */ __name((element, replacement, props) => /* @__PURE__ */ React__default.isValidElement(element) ? /* @__PURE__ */ React__default.cloneElement(element, typeof props == "function" ? props(element.props || {}) : props) : replacement, "replaceElement");
function cloneElement(element, props) {
  return replaceElement(element, element, props);
}
__name(cloneElement, "cloneElement");
const t = /* @__PURE__ */ __name((t2) => typeof t2 == "object" && t2 != null && t2.nodeType === 1, "t"), e$1 = /* @__PURE__ */ __name((t2, e2) => (!e2 || t2 !== "hidden") && t2 !== "visible" && t2 !== "clip", "e$1"), n = /* @__PURE__ */ __name((t2, n2) => {
  if (t2.clientHeight < t2.scrollHeight || t2.clientWidth < t2.scrollWidth) {
    const o2 = getComputedStyle(t2, null);
    return e$1(o2.overflowY, n2) || e$1(o2.overflowX, n2) || ((t3) => {
      const e2 = ((t4) => {
        if (!t4.ownerDocument || !t4.ownerDocument.defaultView) return null;
        try {
          return t4.ownerDocument.defaultView.frameElement;
        } catch {
          return null;
        }
      })(t3);
      return !!e2 && (e2.clientHeight < t3.scrollHeight || e2.clientWidth < t3.scrollWidth);
    })(t2);
  }
  return !1;
}, "n"), o$1 = /* @__PURE__ */ __name((t2, e2, n2, o2, l2, r2, i, s) => r2 < t2 && i > e2 || r2 > t2 && i < e2 ? 0 : r2 <= t2 && s <= n2 || i >= e2 && s >= n2 ? r2 - t2 - o2 : i > e2 && s < n2 || r2 < t2 && s > n2 ? i - e2 + l2 : 0, "o$1"), l = /* @__PURE__ */ __name((t2) => {
  const e2 = t2.parentElement;
  return e2 ?? (t2.getRootNode().host || null);
}, "l"), r = /* @__PURE__ */ __name((e2, r2) => {
  var i, s, d, h;
  if (typeof document > "u") return [];
  const { scrollMode: c, block: f, inline: u, boundary: a, skipOverflowHiddenElements: g } = r2, p = typeof a == "function" ? a : (t2) => t2 !== a;
  if (!t(e2)) throw new TypeError("Invalid target");
  const m2 = document.scrollingElement || document.documentElement, w = [];
  let W = e2;
  for (; t(W) && p(W); ) {
    if (W = l(W), W === m2) {
      w.push(W);
      break;
    }
    W != null && W === document.body && n(W) && !n(document.documentElement) || W != null && n(W, g) && w.push(W);
  }
  const b = (s = (i = window.visualViewport) == null ? void 0 : i.width) != null ? s : innerWidth, H = (h = (d = window.visualViewport) == null ? void 0 : d.height) != null ? h : innerHeight, { scrollX: y, scrollY: M } = window, { height: v, width: E, top: x, right: C, bottom: I, left: R } = e2.getBoundingClientRect(), { top: T, right: B, bottom: F, left: V } = ((t2) => {
    const e3 = window.getComputedStyle(t2);
    return { top: parseFloat(e3.scrollMarginTop) || 0, right: parseFloat(e3.scrollMarginRight) || 0, bottom: parseFloat(e3.scrollMarginBottom) || 0, left: parseFloat(e3.scrollMarginLeft) || 0 };
  })(e2);
  let k = f === "start" || f === "nearest" ? x - T : f === "end" ? I + F : x + v / 2 - T + F, D = u === "center" ? R + E / 2 - V + B : u === "end" ? C + B : R - V;
  const L = [];
  for (let t2 = 0; t2 < w.length; t2++) {
    const e3 = w[t2], { height: l2, width: r3, top: i2, right: s2, bottom: d2, left: h2 } = e3.getBoundingClientRect();
    if (c === "if-needed" && x >= 0 && R >= 0 && I <= H && C <= b && (e3 === m2 && !n(e3) || x >= i2 && I <= d2 && R >= h2 && C <= s2)) return L;
    const a2 = getComputedStyle(e3), g2 = parseInt(a2.borderLeftWidth, 10), p2 = parseInt(a2.borderTopWidth, 10), W2 = parseInt(a2.borderRightWidth, 10), T2 = parseInt(a2.borderBottomWidth, 10);
    let B2 = 0, F2 = 0;
    const V2 = "offsetWidth" in e3 ? e3.offsetWidth - e3.clientWidth - g2 - W2 : 0, S = "offsetHeight" in e3 ? e3.offsetHeight - e3.clientHeight - p2 - T2 : 0, X = "offsetWidth" in e3 ? e3.offsetWidth === 0 ? 0 : r3 / e3.offsetWidth : 0, Y = "offsetHeight" in e3 ? e3.offsetHeight === 0 ? 0 : l2 / e3.offsetHeight : 0;
    if (m2 === e3) B2 = f === "start" ? k : f === "end" ? k - H : f === "nearest" ? o$1(M, M + H, H, p2, T2, M + k, M + k + v, v) : k - H / 2, F2 = u === "start" ? D : u === "center" ? D - b / 2 : u === "end" ? D - b : o$1(y, y + b, b, g2, W2, y + D, y + D + E, E), B2 = Math.max(0, B2 + M), F2 = Math.max(0, F2 + y);
    else {
      B2 = f === "start" ? k - i2 - p2 : f === "end" ? k - d2 + T2 + S : f === "nearest" ? o$1(i2, d2, l2, p2, T2 + S, k, k + v, v) : k - (i2 + l2 / 2) + S / 2, F2 = u === "start" ? D - h2 - g2 : u === "center" ? D - (h2 + r3 / 2) + V2 / 2 : u === "end" ? D - s2 + W2 + V2 : o$1(h2, s2, r3, g2, W2 + V2, D, D + E, E);
      const { scrollLeft: t3, scrollTop: n2 } = e3;
      B2 = Y === 0 ? 0 : Math.max(0, Math.min(n2 + B2 / Y, e3.scrollHeight - l2 / Y + S)), F2 = X === 0 ? 0 : Math.max(0, Math.min(t3 + F2 / X, e3.scrollWidth - r3 / X + V2)), k += n2 - B2, D += t3 - F2;
    }
    L.push({ el: e3, top: B2, left: F2 });
  }
  return L;
}, "r"), o = /* @__PURE__ */ __name((t2) => t2 === !1 ? { block: "end", inline: "nearest" } : ((t3) => t3 === Object(t3) && Object.keys(t3).length !== 0)(t2) ? t2 : { block: "start", inline: "nearest" }, "o");
function e(e2, r$1) {
  if (!e2.isConnected || !((t2) => {
    let o2 = t2;
    for (; o2 && o2.parentNode; ) {
      if (o2.parentNode === document) return !0;
      o2 = o2.parentNode instanceof ShadowRoot ? o2.parentNode.host : o2.parentNode;
    }
    return !1;
  })(e2)) return;
  const n2 = ((t2) => {
    const o2 = window.getComputedStyle(t2);
    return { top: parseFloat(o2.scrollMarginTop) || 0, right: parseFloat(o2.scrollMarginRight) || 0, bottom: parseFloat(o2.scrollMarginBottom) || 0, left: parseFloat(o2.scrollMarginLeft) || 0 };
  })(e2);
  if (((t2) => typeof t2 == "object" && typeof t2.behavior == "function")(r$1)) return r$1.behavior(r(e2, r$1));
  const l2 = typeof r$1 == "boolean" || r$1 == null ? void 0 : r$1.behavior;
  for (const { el: a, top: i, left: s } of r(e2, o(r$1))) {
    const t2 = i - n2.top + n2.bottom, o2 = s - n2.left + n2.right;
    a.scroll({ top: t2, left: o2, behavior: l2 });
  }
}
__name(e, "e");
function isWindow(obj) {
  return obj != null && obj === obj.window;
}
__name(isWindow, "isWindow");
const getScroll = /* @__PURE__ */ __name((target) => {
  var _a, _b;
  if (typeof window > "u")
    return 0;
  let result = 0;
  return isWindow(target) ? result = target.pageYOffset : target instanceof Document ? result = target.documentElement.scrollTop : (target instanceof HTMLElement || target) && (result = target.scrollTop), target && !isWindow(target) && typeof result != "number" && (result = (_b = ((_a = target.ownerDocument) !== null && _a !== void 0 ? _a : target).documentElement) === null || _b === void 0 ? void 0 : _b.scrollTop), result;
}, "getScroll");
function easeInOutCubic(t2, b, c, d) {
  const cc = c - b;
  return t2 /= d / 2, t2 < 1 ? cc / 2 * t2 * t2 * t2 + b : cc / 2 * ((t2 -= 2) * t2 * t2 + 2) + b;
}
__name(easeInOutCubic, "easeInOutCubic");
function scrollTo(y) {
  let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  const {
    getContainer: getContainer2 = /* @__PURE__ */ __name(() => window, "getContainer"),
    callback,
    duration = 450
  } = options, container2 = getContainer2(), scrollTop = getScroll(container2), startTime = Date.now(), frameFunc = /* @__PURE__ */ __name(() => {
    const time = Date.now() - startTime, nextScrollTop = easeInOutCubic(time > duration ? duration : time, scrollTop, y, duration);
    isWindow(container2) ? container2.scrollTo(window.pageXOffset, nextScrollTop) : container2 instanceof Document || container2.constructor.name === "HTMLDocument" ? container2.documentElement.scrollTop = nextScrollTop : container2.scrollTop = nextScrollTop, time < duration ? wrapperRaf(frameFunc) : typeof callback == "function" && callback();
  }, "frameFunc");
  wrapperRaf(frameFunc);
}
__name(scrollTo, "scrollTo");
const useCSSVarCls = /* @__PURE__ */ __name((prefixCls) => {
  const [, , , , cssVar] = useToken();
  return cssVar ? `${prefixCls}-css-var` : "";
}, "useCSSVarCls");
var KeyCode = {
  /**
   * BACKSPACE
   */
  BACKSPACE: 8,
  /**
   * TAB
   */
  TAB: 9,
  // NUMLOCK on FF/Safari Mac
  /**
   * ENTER
   */
  ENTER: 13,
  /**
   * SHIFT
   */
  SHIFT: 16,
  /**
   * CTRL
   */
  CTRL: 17,
  /**
   * ALT
   */
  ALT: 18,
  /**
   * CAPS_LOCK
   */
  CAPS_LOCK: 20,
  /**
   * ESC
   */
  ESC: 27,
  /**
   * SPACE
   */
  SPACE: 32,
  // also NUM_SOUTH_EAST
  /**
   * END
   */
  END: 35,
  // also NUM_SOUTH_WEST
  /**
   * HOME
   */
  HOME: 36,
  // also NUM_NORTH_WEST
  /**
   * LEFT
   */
  LEFT: 37,
  // also NUM_WEST
  /**
   * UP
   */
  UP: 38,
  // also NUM_NORTH
  /**
   * RIGHT
   */
  RIGHT: 39,
  // also NUM_EAST
  /**
   * DOWN
   */
  DOWN: 40,
  /**
   * N
   */
  N: 78,
  /**
   * P
   */
  P: 80,
  /**
   * META
   */
  META: 91,
  // WIN_KEY_LEFT
  /**
   * WIN_KEY_RIGHT
   */
  WIN_KEY_RIGHT: 92,
  /**
   * CONTEXT_MENU
   */
  CONTEXT_MENU: 93,
  /**
   * F1
   */
  F1: 112,
  /**
   * F2
   */
  F2: 113,
  /**
   * F3
   */
  F3: 114,
  /**
   * F4
   */
  F4: 115,
  /**
   * F5
   */
  F5: 116,
  /**
   * F6
   */
  F6: 117,
  /**
   * F7
   */
  F7: 118,
  /**
   * F8
   */
  F8: 119,
  /**
   * F9
   */
  F9: 120,
  /**
   * F10
   */
  F10: 121,
  /**
   * F11
   */
  F11: 122,
  /**
   * F12
   */
  F12: 123,
  /**
   * SEMICOLON
   */
  SEMICOLON: 186,
  // needs localization
  /**
   * EQUALS
   */
  EQUALS: 187,
  // needs localization
  /**
   * WIN_KEY
   */
  WIN_KEY: 224
}, LoadingOutlined$1 = { icon: { tag: "svg", attrs: { viewBox: "0 0 1024 1024", focusable: "false" }, children: [{ tag: "path", attrs: { d: "M988 548c-19.9 0-36-16.1-36-36 0-59.4-11.6-117-34.6-171.3a440.45 440.45 0 00-94.3-139.9 437.71 437.71 0 00-139.9-94.3C629 83.6 571.4 72 512 72c-19.9 0-36-16.1-36-36s16.1-36 36-36c69.1 0 136.2 13.5 199.3 40.3C772.3 66 827 103 874 150c47 47 83.9 101.8 109.7 162.7 26.7 63.1 40.2 130.2 40.2 199.3.1 19.9-16 36-35.9 36z" } }] }, name: "loading", theme: "outlined" }, LoadingOutlined = /* @__PURE__ */ __name(function(props, ref) {
  return /* @__PURE__ */ React.createElement(Icon$3, _extends({}, props, {
    ref,
    icon: LoadingOutlined$1
  }));
}, "LoadingOutlined"), RefIcon$z = /* @__PURE__ */ React.forwardRef(LoadingOutlined);
process.env.NODE_ENV !== "production" && (RefIcon$z.displayName = "LoadingOutlined");
const zIndexContext = /* @__PURE__ */ React__default.createContext(void 0);
process.env.NODE_ENV !== "production" && (zIndexContext.displayName = "zIndexContext");
const CONTAINER_OFFSET = 100, CONTAINER_OFFSET_MAX_COUNT = 10, CONTAINER_MAX_OFFSET = CONTAINER_OFFSET * CONTAINER_OFFSET_MAX_COUNT, CONTAINER_MAX_OFFSET_WITH_CHILDREN = CONTAINER_MAX_OFFSET + CONTAINER_OFFSET, containerBaseZIndexOffset = {
  Modal: CONTAINER_OFFSET,
  Drawer: CONTAINER_OFFSET,
  Popover: CONTAINER_OFFSET,
  Popconfirm: CONTAINER_OFFSET,
  Tooltip: CONTAINER_OFFSET,
  Tour: CONTAINER_OFFSET,
  FloatButton: CONTAINER_OFFSET
}, consumerBaseZIndexOffset = {
  SelectLike: 50,
  Dropdown: 50,
  DatePicker: 50,
  Menu: 50,
  ImagePreview: 1
};
function isContainerType(type4) {
  return type4 in containerBaseZIndexOffset;
}
__name(isContainerType, "isContainerType");
const useZIndex = /* @__PURE__ */ __name((componentType, customZIndex) => {
  const [, token2] = useToken(), parentZIndex = React__default.useContext(zIndexContext), isContainer = isContainerType(componentType);
  let result;
  if (customZIndex !== void 0)
    result = [customZIndex, customZIndex];
  else {
    let zIndex = parentZIndex ?? 0;
    isContainer ? zIndex += // Use preset token zIndex by default but not stack when has parent container
    (parentZIndex ? 0 : token2.zIndexPopupBase) + // Container offset
    containerBaseZIndexOffset[componentType] : zIndex += consumerBaseZIndexOffset[componentType], result = [parentZIndex === void 0 ? customZIndex : zIndex, zIndex];
  }
  if (process.env.NODE_ENV !== "production") {
    const warning3 = devUseWarning(componentType), maxZIndex = token2.zIndexPopupBase + CONTAINER_MAX_OFFSET_WITH_CHILDREN, currentZIndex = result[0] || 0;
    process.env.NODE_ENV !== "production" && warning3(customZIndex !== void 0 || currentZIndex <= maxZIndex, "usage", "`zIndex` is over design token `zIndexPopupBase` too much. It may cause unexpected override.");
  }
  return result;
}, "useZIndex");
function _regeneratorRuntime() {
  _regeneratorRuntime = /* @__PURE__ */ __name(function() {
    return e2;
  }, "_regeneratorRuntime");
  var t2, e2 = {}, r2 = Object.prototype, n2 = r2.hasOwnProperty, o2 = Object.defineProperty || function(t3, e3, r3) {
    t3[e3] = r3.value;
  }, i = typeof Symbol == "function" ? Symbol : {}, a = i.iterator || "@@iterator", c = i.asyncIterator || "@@asyncIterator", u = i.toStringTag || "@@toStringTag";
  function define(t3, e3, r3) {
    return Object.defineProperty(t3, e3, {
      value: r3,
      enumerable: !0,
      configurable: !0,
      writable: !0
    }), t3[e3];
  }
  __name(define, "define");
  try {
    define({}, "");
  } catch {
    define = /* @__PURE__ */ __name(function(t4, e3, r3) {
      return t4[e3] = r3;
    }, "define");
  }
  function wrap(t3, e3, r3, n3) {
    var i2 = e3 && e3.prototype instanceof Generator ? e3 : Generator, a2 = Object.create(i2.prototype), c2 = new Context2(n3 || []);
    return o2(a2, "_invoke", {
      value: makeInvokeMethod(t3, r3, c2)
    }), a2;
  }
  __name(wrap, "wrap");
  function tryCatch(t3, e3, r3) {
    try {
      return {
        type: "normal",
        arg: t3.call(e3, r3)
      };
    } catch (t4) {
      return {
        type: "throw",
        arg: t4
      };
    }
  }
  __name(tryCatch, "tryCatch"), e2.wrap = wrap;
  var h = "suspendedStart", l2 = "suspendedYield", f = "executing", s = "completed", y = {};
  function Generator() {
  }
  __name(Generator, "Generator");
  function GeneratorFunction() {
  }
  __name(GeneratorFunction, "GeneratorFunction");
  function GeneratorFunctionPrototype() {
  }
  __name(GeneratorFunctionPrototype, "GeneratorFunctionPrototype");
  var p = {};
  define(p, a, function() {
    return this;
  });
  var d = Object.getPrototypeOf, v = d && d(d(values([])));
  v && v !== r2 && n2.call(v, a) && (p = v);
  var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p);
  function defineIteratorMethods(t3) {
    ["next", "throw", "return"].forEach(function(e3) {
      define(t3, e3, function(t4) {
        return this._invoke(e3, t4);
      });
    });
  }
  __name(defineIteratorMethods, "defineIteratorMethods");
  function AsyncIterator(t3, e3) {
    function invoke(r4, o3, i2, a2) {
      var c2 = tryCatch(t3[r4], t3, o3);
      if (c2.type !== "throw") {
        var u2 = c2.arg, h2 = u2.value;
        return h2 && _typeof$4(h2) == "object" && n2.call(h2, "__await") ? e3.resolve(h2.__await).then(function(t4) {
          invoke("next", t4, i2, a2);
        }, function(t4) {
          invoke("throw", t4, i2, a2);
        }) : e3.resolve(h2).then(function(t4) {
          u2.value = t4, i2(u2);
        }, function(t4) {
          return invoke("throw", t4, i2, a2);
        });
      }
      a2(c2.arg);
    }
    __name(invoke, "invoke");
    var r3;
    o2(this, "_invoke", {
      value: /* @__PURE__ */ __name(function(t4, n3) {
        function callInvokeWithMethodAndArg() {
          return new e3(function(e4, r4) {
            invoke(t4, n3, e4, r4);
          });
        }
        return __name(callInvokeWithMethodAndArg, "callInvokeWithMethodAndArg"), r3 = r3 ? r3.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
      }, "value")
    });
  }
  __name(AsyncIterator, "AsyncIterator");
  function makeInvokeMethod(e3, r3, n3) {
    var o3 = h;
    return function(i2, a2) {
      if (o3 === f) throw Error("Generator is already running");
      if (o3 === s) {
        if (i2 === "throw") throw a2;
        return {
          value: t2,
          done: !0
        };
      }
      for (n3.method = i2, n3.arg = a2; ; ) {
        var c2 = n3.delegate;
        if (c2) {
          var u2 = maybeInvokeDelegate(c2, n3);
          if (u2) {
            if (u2 === y) continue;
            return u2;
          }
        }
        if (n3.method === "next") n3.sent = n3._sent = n3.arg;
        else if (n3.method === "throw") {
          if (o3 === h) throw o3 = s, n3.arg;
          n3.dispatchException(n3.arg);
        } else n3.method === "return" && n3.abrupt("return", n3.arg);
        o3 = f;
        var p2 = tryCatch(e3, r3, n3);
        if (p2.type === "normal") {
          if (o3 = n3.done ? s : l2, p2.arg === y) continue;
          return {
            value: p2.arg,
            done: n3.done
          };
        }
        p2.type === "throw" && (o3 = s, n3.method = "throw", n3.arg = p2.arg);
      }
    };
  }
  __name(makeInvokeMethod, "makeInvokeMethod");
  function maybeInvokeDelegate(e3, r3) {
    var n3 = r3.method, o3 = e3.iterator[n3];
    if (o3 === t2) return r3.delegate = null, n3 === "throw" && e3.iterator.return && (r3.method = "return", r3.arg = t2, maybeInvokeDelegate(e3, r3), r3.method === "throw") || n3 !== "return" && (r3.method = "throw", r3.arg = new TypeError("The iterator does not provide a '" + n3 + "' method")), y;
    var i2 = tryCatch(o3, e3.iterator, r3.arg);
    if (i2.type === "throw") return r3.method = "throw", r3.arg = i2.arg, r3.delegate = null, y;
    var a2 = i2.arg;
    return a2 ? a2.done ? (r3[e3.resultName] = a2.value, r3.next = e3.nextLoc, r3.method !== "return" && (r3.method = "next", r3.arg = t2), r3.delegate = null, y) : a2 : (r3.method = "throw", r3.arg = new TypeError("iterator result is not an object"), r3.delegate = null, y);
  }
  __name(maybeInvokeDelegate, "maybeInvokeDelegate");
  function pushTryEntry(t3) {
    var e3 = {
      tryLoc: t3[0]
    };
    1 in t3 && (e3.catchLoc = t3[1]), 2 in t3 && (e3.finallyLoc = t3[2], e3.afterLoc = t3[3]), this.tryEntries.push(e3);
  }
  __name(pushTryEntry, "pushTryEntry");
  function resetTryEntry(t3) {
    var e3 = t3.completion || {};
    e3.type = "normal", delete e3.arg, t3.completion = e3;
  }
  __name(resetTryEntry, "resetTryEntry");
  function Context2(t3) {
    this.tryEntries = [{
      tryLoc: "root"
    }], t3.forEach(pushTryEntry, this), this.reset(!0);
  }
  __name(Context2, "Context");
  function values(e3) {
    if (e3 || e3 === "") {
      var r3 = e3[a];
      if (r3) return r3.call(e3);
      if (typeof e3.next == "function") return e3;
      if (!isNaN(e3.length)) {
        var o3 = -1, i2 = /* @__PURE__ */ __name(function next2() {
          for (; ++o3 < e3.length; ) if (n2.call(e3, o3)) return next2.value = e3[o3], next2.done = !1, next2;
          return next2.value = t2, next2.done = !0, next2;
        }, "next");
        return i2.next = i2;
      }
    }
    throw new TypeError(_typeof$4(e3) + " is not iterable");
  }
  return __name(values, "values"), GeneratorFunction.prototype = GeneratorFunctionPrototype, o2(g, "constructor", {
    value: GeneratorFunctionPrototype,
    configurable: !0
  }), o2(GeneratorFunctionPrototype, "constructor", {
    value: GeneratorFunction,
    configurable: !0
  }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, "GeneratorFunction"), e2.isGeneratorFunction = function(t3) {
    var e3 = typeof t3 == "function" && t3.constructor;
    return !!e3 && (e3 === GeneratorFunction || (e3.displayName || e3.name) === "GeneratorFunction");
  }, e2.mark = function(t3) {
    return Object.setPrototypeOf ? Object.setPrototypeOf(t3, GeneratorFunctionPrototype) : (t3.__proto__ = GeneratorFunctionPrototype, define(t3, u, "GeneratorFunction")), t3.prototype = Object.create(g), t3;
  }, e2.awrap = function(t3) {
    return {
      __await: t3
    };
  }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function() {
    return this;
  }), e2.AsyncIterator = AsyncIterator, e2.async = function(t3, r3, n3, o3, i2) {
    i2 === void 0 && (i2 = Promise);
    var a2 = new AsyncIterator(wrap(t3, r3, n3, o3), i2);
    return e2.isGeneratorFunction(r3) ? a2 : a2.next().then(function(t4) {
      return t4.done ? t4.value : a2.next();
    });
  }, defineIteratorMethods(g), define(g, u, "Generator"), define(g, a, function() {
    return this;
  }), define(g, "toString", function() {
    return "[object Generator]";
  }), e2.keys = function(t3) {
    var e3 = Object(t3), r3 = [];
    for (var n3 in e3) r3.push(n3);
    return r3.reverse(), /* @__PURE__ */ __name(function next2() {
      for (; r3.length; ) {
        var t4 = r3.pop();
        if (t4 in e3) return next2.value = t4, next2.done = !1, next2;
      }
      return next2.done = !0, next2;
    }, "next");
  }, e2.values = values, Context2.prototype = {
    constructor: Context2,
    reset: /* @__PURE__ */ __name(function(e3) {
      if (this.prev = 0, this.next = 0, this.sent = this._sent = t2, this.done = !1, this.delegate = null, this.method = "next", this.arg = t2, this.tryEntries.forEach(resetTryEntry), !e3) for (var r3 in this) r3.charAt(0) === "t" && n2.call(this, r3) && !isNaN(+r3.slice(1)) && (this[r3] = t2);
    }, "reset"),
    stop: /* @__PURE__ */ __name(function() {
      this.done = !0;
      var t3 = this.tryEntries[0].completion;
      if (t3.type === "throw") throw t3.arg;
      return this.rval;
    }, "stop"),
    dispatchException: /* @__PURE__ */ __name(function(e3) {
      if (this.done) throw e3;
      var r3 = this;
      function handle(n3, o4) {
        return a2.type = "throw", a2.arg = e3, r3.next = n3, o4 && (r3.method = "next", r3.arg = t2), !!o4;
      }
      __name(handle, "handle");
      for (var o3 = this.tryEntries.length - 1; o3 >= 0; --o3) {
        var i2 = this.tryEntries[o3], a2 = i2.completion;
        if (i2.tryLoc === "root") return handle("end");
        if (i2.tryLoc <= this.prev) {
          var c2 = n2.call(i2, "catchLoc"), u2 = n2.call(i2, "finallyLoc");
          if (c2 && u2) {
            if (this.prev < i2.catchLoc) return handle(i2.catchLoc, !0);
            if (this.prev < i2.finallyLoc) return handle(i2.finallyLoc);
          } else if (c2) {
            if (this.prev < i2.catchLoc) return handle(i2.catchLoc, !0);
          } else {
            if (!u2) throw Error("try statement without catch or finally");
            if (this.prev < i2.finallyLoc) return handle(i2.finallyLoc);
          }
        }
      }
    }, "dispatchException"),
    abrupt: /* @__PURE__ */ __name(function(t3, e3) {
      for (var r3 = this.tryEntries.length - 1; r3 >= 0; --r3) {
        var o3 = this.tryEntries[r3];
        if (o3.tryLoc <= this.prev && n2.call(o3, "finallyLoc") && this.prev < o3.finallyLoc) {
          var i2 = o3;
          break;
        }
      }
      i2 && (t3 === "break" || t3 === "continue") && i2.tryLoc <= e3 && e3 <= i2.finallyLoc && (i2 = null);
      var a2 = i2 ? i2.completion : {};
      return a2.type = t3, a2.arg = e3, i2 ? (this.method = "next", this.next = i2.finallyLoc, y) : this.complete(a2);
    }, "abrupt"),
    complete: /* @__PURE__ */ __name(function(t3, e3) {
      if (t3.type === "throw") throw t3.arg;
      return t3.type === "break" || t3.type === "continue" ? this.next = t3.arg : t3.type === "return" ? (this.rval = this.arg = t3.arg, this.method = "return", this.next = "end") : t3.type === "normal" && e3 && (this.next = e3), y;
    }, "complete"),
    finish: /* @__PURE__ */ __name(function(t3) {
      for (var e3 = this.tryEntries.length - 1; e3 >= 0; --e3) {
        var r3 = this.tryEntries[e3];
        if (r3.finallyLoc === t3) return this.complete(r3.completion, r3.afterLoc), resetTryEntry(r3), y;
      }
    }, "finish"),
    catch: /* @__PURE__ */ __name(function(t3) {
      for (var e3 = this.tryEntries.length - 1; e3 >= 0; --e3) {
        var r3 = this.tryEntries[e3];
        if (r3.tryLoc === t3) {
          var n3 = r3.completion;
          if (n3.type === "throw") {
            var o3 = n3.arg;
            resetTryEntry(r3);
          }
          return o3;
        }
      }
      throw Error("illegal catch attempt");
    }, "_catch"),
    delegateYield: /* @__PURE__ */ __name(function(e3, r3, n3) {
      return this.delegate = {
        iterator: values(e3),
        resultName: r3,
        nextLoc: n3
      }, this.method === "next" && (this.arg = t2), y;
    }, "delegateYield")
  }, e2;
}
__name(_regeneratorRuntime, "_regeneratorRuntime");
function asyncGeneratorStep(n2, t2, e2, r2, o2, a, c) {
  try {
    var i = n2[a](c), u = i.value;
  } catch (n3) {
    return void e2(n3);
  }
  i.done ? t2(u) : Promise.resolve(u).then(r2, o2);
}
__name(asyncGeneratorStep, "asyncGeneratorStep");
function _asyncToGenerator(n2) {
  return function() {
    var t2 = this, e2 = arguments;
    return new Promise(function(r2, o2) {
      var a = n2.apply(t2, e2);
      function _next(n3) {
        asyncGeneratorStep(a, r2, o2, _next, _throw, "next", n3);
      }
      __name(_next, "_next");
      function _throw(n3) {
        asyncGeneratorStep(a, r2, o2, _next, _throw, "throw", n3);
      }
      __name(_throw, "_throw"), _next(void 0);
    });
  };
}
__name(_asyncToGenerator, "_asyncToGenerator");
var fullClone = _objectSpread2$1({}, ReactDOM), version = fullClone.version, reactRender = fullClone.render, unmountComponentAtNode = fullClone.unmountComponentAtNode, createRoot$1;
try {
  var mainVersion = Number((version || "").split(".")[0]);
  mainVersion >= 18 && (createRoot$1 = fullClone.createRoot);
} catch {
}
function toggleWarning(skip) {
  var __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = fullClone.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
  __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED && _typeof$4(__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED) === "object" && (__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.usingClientEntryPoint = skip);
}
__name(toggleWarning, "toggleWarning");
var MARK = "__rc_react_root__";
function modernRender(node2, container2) {
  toggleWarning(!0);
  var root = container2[MARK] || createRoot$1(container2);
  toggleWarning(!1), root.render(node2), container2[MARK] = root;
}
__name(modernRender, "modernRender");
function legacyRender(node2, container2) {
  reactRender == null || reactRender(node2, container2);
}
__name(legacyRender, "legacyRender");
function render(node2, container2) {
  if (createRoot$1) {
    modernRender(node2, container2);
    return;
  }
  legacyRender(node2, container2);
}
__name(render, "render");
function modernUnmount(_x) {
  return _modernUnmount.apply(this, arguments);
}
__name(modernUnmount, "modernUnmount");
function _modernUnmount() {
  return _modernUnmount = _asyncToGenerator(/* @__PURE__ */ _regeneratorRuntime().mark(/* @__PURE__ */ __name(function _callee(container2) {
    return _regeneratorRuntime().wrap(/* @__PURE__ */ __name(function(_context) {
      for (; ; ) switch (_context.prev = _context.next) {
        case 0:
          return _context.abrupt("return", Promise.resolve().then(function() {
            var _container$MARK;
            (_container$MARK = container2[MARK]) === null || _container$MARK === void 0 || _container$MARK.unmount(), delete container2[MARK];
          }));
        case 1:
        case "end":
          return _context.stop();
      }
    }, "_callee$"), _callee);
  }, "_callee"))), _modernUnmount.apply(this, arguments);
}
__name(_modernUnmount, "_modernUnmount");
function legacyUnmount(container2) {
  unmountComponentAtNode(container2);
}
__name(legacyUnmount, "legacyUnmount");
function unmount(_x2) {
  return _unmount.apply(this, arguments);
}
__name(unmount, "unmount");
function _unmount() {
  return _unmount = _asyncToGenerator(/* @__PURE__ */ _regeneratorRuntime().mark(/* @__PURE__ */ __name(function _callee2(container2) {
    return _regeneratorRuntime().wrap(/* @__PURE__ */ __name(function(_context2) {
      for (; ; ) switch (_context2.prev = _context2.next) {
        case 0:
          if (createRoot$1 === void 0) {
            _context2.next = 2;
            break;
          }
          return _context2.abrupt("return", modernUnmount(container2));
        case 2:
          legacyUnmount(container2);
        case 3:
        case "end":
          return _context2.stop();
      }
    }, "_callee2$"), _callee2);
  }, "_callee2"))), _unmount.apply(this, arguments);
}
__name(_unmount, "_unmount");
const defaultReactRender = /* @__PURE__ */ __name((node2, container2) => {
  if (process.env.NODE_ENV !== "production") {
    const majorVersion = parseInt(React.version.split(".")[0], 10);
    process.env.NODE_ENV !== "production" && warning$2(majorVersion < 19 || !!ReactDOM.createRoot, "compatible", "antd v5 support React is 16 ~ 18. see https://u.ant.design/v5-for-19 for compatible.");
  }
  return render(node2, container2), () => unmount(container2);
}, "defaultReactRender");
let unstableRender = defaultReactRender;
function getReactRender() {
  return unstableRender;
}
__name(getReactRender, "getReactRender");
const getCollapsedHeight = /* @__PURE__ */ __name(() => ({
  height: 0,
  opacity: 0
}), "getCollapsedHeight"), getRealHeight = /* @__PURE__ */ __name((node2) => {
  const {
    scrollHeight
  } = node2;
  return {
    height: scrollHeight,
    opacity: 1
  };
}, "getRealHeight"), getCurrentHeight = /* @__PURE__ */ __name((node2) => ({
  height: node2 ? node2.offsetHeight : 0
}), "getCurrentHeight"), skipOpacityTransition = /* @__PURE__ */ __name((_2, event) => (event == null ? void 0 : event.deadline) === !0 || event.propertyName === "height", "skipOpacityTransition"), initCollapseMotion = /* @__PURE__ */ __name(function() {
  return {
    motionName: `${arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : defaultPrefixCls}-motion-collapse`,
    onAppearStart: getCollapsedHeight,
    onEnterStart: getCollapsedHeight,
    onAppearActive: getRealHeight,
    onEnterActive: getRealHeight,
    onLeaveStart: getCurrentHeight,
    onLeaveActive: getCollapsedHeight,
    onAppearEnd: skipOpacityTransition,
    onEnterEnd: skipOpacityTransition,
    onLeaveEnd: skipOpacityTransition,
    motionDeadline: 500
  };
}, "initCollapseMotion"), getTransitionName = /* @__PURE__ */ __name((rootPrefixCls, motion2, transitionName) => transitionName !== void 0 ? transitionName : `${rootPrefixCls}-${motion2}`, "getTransitionName"), isVisible = /* @__PURE__ */ __name(function(element) {
  if (!element)
    return !1;
  if (element instanceof Element) {
    if (element.offsetParent)
      return !0;
    if (element.getBBox) {
      var _getBBox = element.getBBox(), width = _getBBox.width, height = _getBBox.height;
      if (width || height)
        return !0;
    }
    if (element.getBoundingClientRect) {
      var _element$getBoundingC = element.getBoundingClientRect(), _width = _element$getBoundingC.width, _height = _element$getBoundingC.height;
      if (_width || _height)
        return !0;
    }
  }
  return !1;
}, "isVisible"), genWaveStyle = /* @__PURE__ */ __name((token2) => {
  const {
    componentCls,
    colorPrimary
  } = token2;
  return {
    [componentCls]: {
      position: "absolute",
      background: "transparent",
      pointerEvents: "none",
      boxSizing: "border-box",
      color: `var(--wave-color, ${colorPrimary})`,
      boxShadow: "0 0 0 0 currentcolor",
      opacity: 0.2,
      // =================== Motion ===================
      "&.wave-motion-appear": {
        transition: [`box-shadow 0.4s ${token2.motionEaseOutCirc}`, `opacity 2s ${token2.motionEaseOutCirc}`].join(","),
        "&-active": {
          boxShadow: "0 0 0 6px currentcolor",
          opacity: 0
        },
        "&.wave-quick": {
          transition: [`box-shadow ${token2.motionDurationSlow} ${token2.motionEaseInOut}`, `opacity ${token2.motionDurationSlow} ${token2.motionEaseInOut}`].join(",")
        }
      }
    }
  };
}, "genWaveStyle"), useStyle$u = genComponentStyleHook("Wave", (token2) => [genWaveStyle(token2)]), TARGET_CLS = `${defaultPrefixCls}-wave-target`;
function isValidWaveColor(color) {
  return color && color !== "#fff" && color !== "#ffffff" && color !== "rgb(255, 255, 255)" && color !== "rgba(255, 255, 255, 1)" && !/rgba\((?:\d*, ){3}0\)/.test(color) && // any transparent rgba color
  color !== "transparent";
}
__name(isValidWaveColor, "isValidWaveColor");
function getTargetWaveColor(node2) {
  const {
    borderTopColor,
    borderColor,
    backgroundColor
  } = getComputedStyle(node2);
  return isValidWaveColor(borderTopColor) ? borderTopColor : isValidWaveColor(borderColor) ? borderColor : isValidWaveColor(backgroundColor) ? backgroundColor : null;
}
__name(getTargetWaveColor, "getTargetWaveColor");
function validateNum(value) {
  return Number.isNaN(value) ? 0 : value;
}
__name(validateNum, "validateNum");
const WaveEffect = /* @__PURE__ */ __name((props) => {
  const {
    className,
    target,
    component,
    registerUnmount
  } = props, divRef = React.useRef(null), unmountRef = React.useRef(null);
  React.useEffect(() => {
    unmountRef.current = registerUnmount();
  }, []);
  const [color, setWaveColor] = React.useState(null), [borderRadius, setBorderRadius] = React.useState([]), [left, setLeft] = React.useState(0), [top, setTop] = React.useState(0), [width, setWidth] = React.useState(0), [height, setHeight] = React.useState(0), [enabled, setEnabled] = React.useState(!1), waveStyle = {
    left,
    top,
    width,
    height,
    borderRadius: borderRadius.map((radius2) => `${radius2}px`).join(" ")
  };
  color && (waveStyle["--wave-color"] = color);
  function syncPos() {
    const nodeStyle = getComputedStyle(target);
    setWaveColor(getTargetWaveColor(target));
    const isStatic = nodeStyle.position === "static", {
      borderLeftWidth,
      borderTopWidth
    } = nodeStyle;
    setLeft(isStatic ? target.offsetLeft : validateNum(-parseFloat(borderLeftWidth))), setTop(isStatic ? target.offsetTop : validateNum(-parseFloat(borderTopWidth))), setWidth(target.offsetWidth), setHeight(target.offsetHeight);
    const {
      borderTopLeftRadius,
      borderTopRightRadius,
      borderBottomLeftRadius,
      borderBottomRightRadius
    } = nodeStyle;
    setBorderRadius([borderTopLeftRadius, borderTopRightRadius, borderBottomRightRadius, borderBottomLeftRadius].map((radius2) => validateNum(parseFloat(radius2))));
  }
  if (__name(syncPos, "syncPos"), React.useEffect(() => {
    if (target) {
      const id2 = wrapperRaf(() => {
        syncPos(), setEnabled(!0);
      });
      let resizeObserver2;
      return typeof ResizeObserver < "u" && (resizeObserver2 = new ResizeObserver(syncPos), resizeObserver2.observe(target)), () => {
        wrapperRaf.cancel(id2), resizeObserver2 == null || resizeObserver2.disconnect();
      };
    }
  }, []), !enabled)
    return null;
  const isSmallComponent = (component === "Checkbox" || component === "Radio") && (target == null ? void 0 : target.classList.contains(TARGET_CLS));
  return /* @__PURE__ */ React.createElement(CSSMotion, {
    visible: !0,
    motionAppear: !0,
    motionName: "wave-motion",
    motionDeadline: 5e3,
    onAppearEnd: /* @__PURE__ */ __name((_2, event) => {
      var _a, _b;
      if (event.deadline || event.propertyName === "opacity") {
        const holder = (_a = divRef.current) === null || _a === void 0 ? void 0 : _a.parentElement;
        (_b = unmountRef.current) === null || _b === void 0 || _b.call(unmountRef).then(() => {
          holder == null || holder.remove();
        });
      }
      return !1;
    }, "onAppearEnd")
  }, (_ref, ref) => {
    let {
      className: motionClassName
    } = _ref;
    return /* @__PURE__ */ React.createElement("div", {
      ref: composeRef(divRef, ref),
      className: cn(className, motionClassName, {
        "wave-quick": isSmallComponent
      }),
      style: waveStyle
    });
  });
}, "WaveEffect"), showWaveEffect = /* @__PURE__ */ __name((target, info) => {
  var _a;
  const {
    component
  } = info;
  if (component === "Checkbox" && !(!((_a = target.querySelector("input")) === null || _a === void 0) && _a.checked))
    return;
  const holder = document.createElement("div");
  holder.style.position = "absolute", holder.style.left = "0px", holder.style.top = "0px", target == null || target.insertBefore(holder, target == null ? void 0 : target.firstChild);
  const reactRender2 = getReactRender();
  let unmountCallback = null;
  function registerUnmount() {
    return unmountCallback;
  }
  __name(registerUnmount, "registerUnmount"), unmountCallback = reactRender2(/* @__PURE__ */ React.createElement(WaveEffect, Object.assign({}, info, {
    target,
    registerUnmount
  })), holder);
}, "showWaveEffect"), useWave = /* @__PURE__ */ __name((nodeRef, className, component) => {
  const {
    wave
  } = React.useContext(ConfigContext), [, token2, hashId] = useToken(), showWave = useEvent((event) => {
    const node2 = nodeRef.current;
    if (wave != null && wave.disabled || !node2)
      return;
    const targetNode = node2.querySelector(`.${TARGET_CLS}`) || node2, {
      showEffect
    } = wave || {};
    (showEffect || showWaveEffect)(targetNode, {
      className,
      token: token2,
      component,
      event,
      hashId
    });
  }), rafId = React.useRef(null);
  return /* @__PURE__ */ __name((event) => {
    wrapperRaf.cancel(rafId.current), rafId.current = wrapperRaf(() => {
      showWave(event);
    });
  }, "showDebounceWave");
}, "useWave"), Wave = /* @__PURE__ */ __name((props) => {
  const {
    children,
    disabled,
    component
  } = props, {
    getPrefixCls
  } = useContext$1(ConfigContext), containerRef = useRef(null), prefixCls = getPrefixCls("wave"), [, hashId] = useStyle$u(prefixCls), showWave = useWave(containerRef, cn(prefixCls, hashId), component);
  if (React__default.useEffect(() => {
    const node2 = containerRef.current;
    if (!node2 || node2.nodeType !== 1 || disabled)
      return;
    const onClick = /* @__PURE__ */ __name((e2) => {
      !isVisible(e2.target) || // No need wave
      !node2.getAttribute || node2.getAttribute("disabled") || node2.disabled || node2.className.includes("disabled") || node2.className.includes("-leave") || showWave(e2);
    }, "onClick");
    return node2.addEventListener("click", onClick, !0), () => {
      node2.removeEventListener("click", onClick, !0);
    };
  }, [disabled]), !/* @__PURE__ */ React__default.isValidElement(children))
    return children ?? null;
  const ref = supportRef(children) ? composeRef(getNodeRef(children), containerRef) : containerRef;
  return cloneElement(children, {
    ref
  });
}, "Wave");
process.env.NODE_ENV !== "production" && (Wave.displayName = "Wave");
const useSize = /* @__PURE__ */ __name((customSize) => {
  const size = React__default.useContext(SizeContext);
  return React__default.useMemo(() => customSize ? typeof customSize == "string" ? customSize ?? size : customSize instanceof Function ? customSize(size) : size : size, [customSize, size]);
}, "useSize"), genSpaceCompactStyle = /* @__PURE__ */ __name((token2) => {
  const {
    componentCls
  } = token2;
  return {
    [componentCls]: {
      "&-block": {
        display: "flex",
        width: "100%"
      },
      "&-vertical": {
        flexDirection: "column"
      }
    }
  };
}, "genSpaceCompactStyle"), genSpaceStyle = /* @__PURE__ */ __name((token2) => {
  const {
    componentCls,
    antCls
  } = token2;
  return {
    [componentCls]: {
      display: "inline-flex",
      "&-rtl": {
        direction: "rtl"
      },
      "&-vertical": {
        flexDirection: "column"
      },
      "&-align": {
        flexDirection: "column",
        "&-center": {
          alignItems: "center"
        },
        "&-start": {
          alignItems: "flex-start"
        },
        "&-end": {
          alignItems: "flex-end"
        },
        "&-baseline": {
          alignItems: "baseline"
        }
      },
      [`${componentCls}-item:empty`]: {
        display: "none"
      },
      // https://github.com/ant-design/ant-design/issues/47875
      [`${componentCls}-item > ${antCls}-badge-not-a-wrapper:only-child`]: {
        display: "block"
      }
    }
  };
}, "genSpaceStyle"), genSpaceGapStyle = /* @__PURE__ */ __name((token2) => {
  const {
    componentCls
  } = token2;
  return {
    [componentCls]: {
      "&-gap-row-small": {
        rowGap: token2.spaceGapSmallSize
      },
      "&-gap-row-middle": {
        rowGap: token2.spaceGapMiddleSize
      },
      "&-gap-row-large": {
        rowGap: token2.spaceGapLargeSize
      },
      "&-gap-col-small": {
        columnGap: token2.spaceGapSmallSize
      },
      "&-gap-col-middle": {
        columnGap: token2.spaceGapMiddleSize
      },
      "&-gap-col-large": {
        columnGap: token2.spaceGapLargeSize
      }
    }
  };
}, "genSpaceGapStyle"), useStyle$t = genStyleHooks("Space", (token2) => {
  const spaceToken = merge(token2, {
    spaceGapSmallSize: token2.paddingXS,
    spaceGapMiddleSize: token2.padding,
    spaceGapLargeSize: token2.paddingLG
  });
  return [genSpaceStyle(spaceToken), genSpaceGapStyle(spaceToken), genSpaceCompactStyle(spaceToken)];
}, () => ({}), {
  // Space component don't apply extra font style
  // https://github.com/ant-design/ant-design/issues/40315
  resetStyle: !1
});
var __rest$T = function(s, e2) {
  var t2 = {};
  for (var p in s) Object.prototype.hasOwnProperty.call(s, p) && e2.indexOf(p) < 0 && (t2[p] = s[p]);
  if (s != null && typeof Object.getOwnPropertySymbols == "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++)
    e2.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]) && (t2[p[i]] = s[p[i]]);
  return t2;
};
const SpaceCompactItemContext = /* @__PURE__ */ React.createContext(null), useCompactItemContext = /* @__PURE__ */ __name((prefixCls, direction) => {
  const compactItemContext = React.useContext(SpaceCompactItemContext), compactItemClassnames = React.useMemo(() => {
    if (!compactItemContext)
      return "";
    const {
      compactDirection,
      isFirstItem,
      isLastItem
    } = compactItemContext, separator = compactDirection === "vertical" ? "-vertical-" : "-";
    return cn(`${prefixCls}-compact${separator}item`, {
      [`${prefixCls}-compact${separator}first-item`]: isFirstItem,
      [`${prefixCls}-compact${separator}last-item`]: isLastItem,
      [`${prefixCls}-compact${separator}item-rtl`]: direction === "rtl"
    });
  }, [prefixCls, direction, compactItemContext]);
  return {
    compactSize: compactItemContext == null ? void 0 : compactItemContext.compactSize,
    compactDirection: compactItemContext == null ? void 0 : compactItemContext.compactDirection,
    compactItemClassnames
  };
}, "useCompactItemContext"), NoCompactStyle = /* @__PURE__ */ __name((_ref) => {
  let {
    children
  } = _ref;
  return /* @__PURE__ */ React.createElement(SpaceCompactItemContext.Provider, {
    value: null
  }, children);
}, "NoCompactStyle"), CompactItem = /* @__PURE__ */ __name((_a) => {
  var {
    children
  } = _a, otherProps = __rest$T(_a, ["children"]);
  return /* @__PURE__ */ React.createElement(SpaceCompactItemContext.Provider, {
    value: otherProps
  }, children);
}, "CompactItem"), Compact$1 = /* @__PURE__ */ __name((props) => {
  const {
    getPrefixCls,
    direction: directionConfig
  } = React.useContext(ConfigContext), {
    size,
    direction,
    block,
    prefixCls: customizePrefixCls,
    className,
    rootClassName,
    children
  } = props, restProps = __rest$T(props, ["size", "direction", "block", "prefixCls", "className", "rootClassName", "children"]), mergedSize = useSize((ctx) => size ?? ctx), prefixCls = getPrefixCls("space-compact", customizePrefixCls), [wrapCSSVar, hashId] = useStyle$t(prefixCls), clx = cn(prefixCls, hashId, {
    [`${prefixCls}-rtl`]: directionConfig === "rtl",
    [`${prefixCls}-block`]: block,
    [`${prefixCls}-vertical`]: direction === "vertical"
  }, className, rootClassName), compactItemContext = React.useContext(SpaceCompactItemContext), childNodes = toArray$7(children), nodes = React.useMemo(() => childNodes.map((child, i) => {
    const key = (child == null ? void 0 : child.key) || `${prefixCls}-item-${i}`;
    return /* @__PURE__ */ React.createElement(CompactItem, {
      key,
      compactSize: mergedSize,
      compactDirection: direction,
      isFirstItem: i === 0 && (!compactItemContext || (compactItemContext == null ? void 0 : compactItemContext.isFirstItem)),
      isLastItem: i === childNodes.length - 1 && (!compactItemContext || (compactItemContext == null ? void 0 : compactItemContext.isLastItem))
    }, child);
  }), [size, childNodes, compactItemContext]);
  return childNodes.length === 0 ? null : wrapCSSVar(/* @__PURE__ */ React.createElement("div", Object.assign({
    className: clx
  }, restProps), nodes));
}, "Compact$1");
var __rest$S = function(s, e2) {
  var t2 = {};
  for (var p in s) Object.prototype.hasOwnProperty.call(s, p) && e2.indexOf(p) < 0 && (t2[p] = s[p]);
  if (s != null && typeof Object.getOwnPropertySymbols == "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++)
    e2.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]) && (t2[p[i]] = s[p[i]]);
  return t2;
};
const GroupSizeContext = /* @__PURE__ */ React.createContext(void 0), ButtonGroup = /* @__PURE__ */ __name((props) => {
  const {
    getPrefixCls,
    direction
  } = React.useContext(ConfigContext), {
    prefixCls: customizePrefixCls,
    size,
    className
  } = props, others = __rest$S(props, ["prefixCls", "size", "className"]), prefixCls = getPrefixCls("btn-group", customizePrefixCls), [, , hashId] = useToken();
  let sizeCls = "";
  switch (size) {
    case "large":
      sizeCls = "lg";
      break;
    case "small":
      sizeCls = "sm";
      break;
  }
  if (process.env.NODE_ENV !== "production") {
    const warning3 = devUseWarning("Button.Group");
    process.env.NODE_ENV !== "production" && warning3(!size || ["large", "small", "middle"].includes(size), "usage", "Invalid prop `size`.");
  }
  const classes = cn(prefixCls, {
    [`${prefixCls}-${sizeCls}`]: sizeCls,
    [`${prefixCls}-rtl`]: direction === "rtl"
  }, className, hashId);
  return /* @__PURE__ */ React.createElement(GroupSizeContext.Provider, {
    value: size
  }, /* @__PURE__ */ React.createElement("div", Object.assign({}, others, {
    className: classes
  })));
}, "ButtonGroup"), rxTwoCNChar = /^[\u4E00-\u9FA5]{2}$/, isTwoCNChar = rxTwoCNChar.test.bind(rxTwoCNChar);
function convertLegacyProps(type4) {
  return type4 === "danger" ? {
    danger: !0
  } : {
    type: type4
  };
}
__name(convertLegacyProps, "convertLegacyProps");
function isString$1(str) {
  return typeof str == "string";
}
__name(isString$1, "isString$1");
function isUnBorderedButtonVariant(type4) {
  return type4 === "text" || type4 === "link";
}
__name(isUnBorderedButtonVariant, "isUnBorderedButtonVariant");
function splitCNCharsBySpace(child, needInserted) {
  if (child == null)
    return;
  const SPACE = needInserted ? " " : "";
  return typeof child != "string" && typeof child != "number" && isString$1(child.type) && isTwoCNChar(child.props.children) ? cloneElement(child, {
    children: child.props.children.split("").join(SPACE)
  }) : isString$1(child) ? isTwoCNChar(child) ? /* @__PURE__ */ React__default.createElement("span", null, child.split("").join(SPACE)) : /* @__PURE__ */ React__default.createElement("span", null, child) : isFragment(child) ? /* @__PURE__ */ React__default.createElement("span", null, child) : child;
}
__name(splitCNCharsBySpace, "splitCNCharsBySpace");
function spaceChildren(children, needInserted) {
  let isPrevChildPure = !1;
  const childList = [];
  return React__default.Children.forEach(children, (child) => {
    const type4 = typeof child, isCurrentChildPure = type4 === "string" || type4 === "number";
    if (isPrevChildPure && isCurrentChildPure) {
      const lastIndex = childList.length - 1, lastChild = childList[lastIndex];
      childList[lastIndex] = `${lastChild}${child}`;
    } else
      childList.push(child);
    isPrevChildPure = isCurrentChildPure;
  }), React__default.Children.map(childList, (child) => splitCNCharsBySpace(child, needInserted));
}
__name(spaceChildren, "spaceChildren");
const IconWrapper = /* @__PURE__ */ forwardRef((props, ref) => {
  const {
    className,
    style: style2,
    children,
    prefixCls
  } = props, iconWrapperCls = cn(`${prefixCls}-icon`, className);
  return /* @__PURE__ */ React__default.createElement("span", {
    ref,
    className: iconWrapperCls,
    style: style2
  }, children);
}), InnerLoadingIcon = /* @__PURE__ */ forwardRef((props, ref) => {
  const {
    prefixCls,
    className,
    style: style2,
    iconClassName
  } = props, mergedIconCls = cn(`${prefixCls}-loading-icon`, className);
  return /* @__PURE__ */ React__default.createElement(IconWrapper, {
    prefixCls,
    className: mergedIconCls,
    style: style2,
    ref
  }, /* @__PURE__ */ React__default.createElement(RefIcon$z, {
    className: iconClassName
  }));
}), getCollapsedWidth = /* @__PURE__ */ __name(() => ({
  width: 0,
  opacity: 0,
  transform: "scale(0)"
}), "getCollapsedWidth"), getRealWidth = /* @__PURE__ */ __name((node2) => ({
  width: node2.scrollWidth,
  opacity: 1,
  transform: "scale(1)"
}), "getRealWidth"), LoadingIcon = /* @__PURE__ */ __name((props) => {
  const {
    prefixCls,
    loading,
    existIcon,
    className,
    style: style2,
    mount
  } = props, visible = !!loading;
  return existIcon ? /* @__PURE__ */ React__default.createElement(InnerLoadingIcon, {
    prefixCls,
    className,
    style: style2
  }) : /* @__PURE__ */ React__default.createElement(CSSMotion, {
    visible,
    // Used for minus flex gap style only
    motionName: `${prefixCls}-loading-icon-motion`,
    motionAppear: !mount,
    motionEnter: !mount,
    motionLeave: !mount,
    removeOnLeave: !0,
    onAppearStart: getCollapsedWidth,
    onAppearActive: getRealWidth,
    onEnterStart: getCollapsedWidth,
    onEnterActive: getRealWidth,
    onLeaveStart: getRealWidth,
    onLeaveActive: getCollapsedWidth
  }, (_ref, ref) => {
    let {
      className: motionCls,
      style: motionStyle
    } = _ref;
    const mergedStyle = Object.assign(Object.assign({}, style2), motionStyle);
    return /* @__PURE__ */ React__default.createElement(InnerLoadingIcon, {
      prefixCls,
      className: cn(className, motionCls),
      style: mergedStyle,
      ref
    });
  });
}, "LoadingIcon"), genButtonBorderStyle = /* @__PURE__ */ __name((buttonTypeCls, borderColor) => ({
  // Border
  [`> span, > ${buttonTypeCls}`]: {
    "&:not(:last-child)": {
      [`&, & > ${buttonTypeCls}`]: {
        "&:not(:disabled)": {
          borderInlineEndColor: borderColor
        }
      }
    },
    "&:not(:first-child)": {
      [`&, & > ${buttonTypeCls}`]: {
        "&:not(:disabled)": {
          borderInlineStartColor: borderColor
        }
      }
    }
  }
}), "genButtonBorderStyle"), genGroupStyle$1 = /* @__PURE__ */ __name((token2) => {
  const {
    componentCls,
    fontSize,
    lineWidth,
    groupBorderColor,
    colorErrorHover
  } = token2;
  return {
    [`${componentCls}-group`]: [
      {
        position: "relative",
        display: "inline-flex",
        // Border
        [`> span, > ${componentCls}`]: {
          "&:not(:last-child)": {
            [`&, & > ${componentCls}`]: {
              borderStartEndRadius: 0,
              borderEndEndRadius: 0
            }
          },
          "&:not(:first-child)": {
            marginInlineStart: token2.calc(lineWidth).mul(-1).equal(),
            [`&, & > ${componentCls}`]: {
              borderStartStartRadius: 0,
              borderEndStartRadius: 0
            }
          }
        },
        [componentCls]: {
          position: "relative",
          zIndex: 1,
          "&:hover, &:focus, &:active": {
            zIndex: 2
          },
          "&[disabled]": {
            zIndex: 0
          }
        },
        [`${componentCls}-icon-only`]: {
          fontSize
        }
      },
      // Border Color
      genButtonBorderStyle(`${componentCls}-primary`, groupBorderColor),
      genButtonBorderStyle(`${componentCls}-danger`, colorErrorHover)
    ]
  };
}, "genGroupStyle$1");
var _excluded$N = ["b"], _excluded2$9 = ["v"], getRoundNumber = /* @__PURE__ */ __name(function(value) {
  return Math.round(Number(value || 0));
}, "getRoundNumber"), convertHsb2Hsv = /* @__PURE__ */ __name(function(color) {
  if (color instanceof FastColor)
    return color;
  if (color && _typeof$4(color) === "object" && "h" in color && "b" in color) {
    var _ref = color, b = _ref.b, resets = _objectWithoutProperties(_ref, _excluded$N);
    return _objectSpread2$1(_objectSpread2$1({}, resets), {}, {
      v: b
    });
  }
  return typeof color == "string" && /hsb/.test(color) ? color.replace(/hsb/, "hsv") : color;
}, "convertHsb2Hsv"), Color = /* @__PURE__ */ function(_FastColor2) {
  _inherits(Color2, _FastColor2);
  var _super = _createSuper(Color2);
  function Color2(color) {
    return _classCallCheck$1(this, Color2), _super.call(this, convertHsb2Hsv(color));
  }
  return __name(Color2, "Color"), _createClass$1(Color2, [{
    key: "toHsbString",
    value: /* @__PURE__ */ __name(function() {
      var hsb = this.toHsb(), saturation = getRoundNumber(hsb.s * 100), lightness = getRoundNumber(hsb.b * 100), hue = getRoundNumber(hsb.h), alpha = hsb.a, hsbString = "hsb(".concat(hue, ", ").concat(saturation, "%, ").concat(lightness, "%)"), hsbaString = "hsba(".concat(hue, ", ").concat(saturation, "%, ").concat(lightness, "%, ").concat(alpha.toFixed(alpha === 0 ? 0 : 2), ")");
      return alpha === 1 ? hsbString : hsbaString;
    }, "toHsbString")
  }, {
    key: "toHsb",
    value: /* @__PURE__ */ __name(function() {
      var _this$toHsv = this.toHsv(), v = _this$toHsv.v, resets = _objectWithoutProperties(_this$toHsv, _excluded2$9);
      return _objectSpread2$1(_objectSpread2$1({}, resets), {}, {
        b: v,
        a: this.a
      });
    }, "toHsb")
  }]), Color2;
}(FastColor), ColorPickerPrefixCls = "rc-color-picker", generateColor = /* @__PURE__ */ __name(function(color) {
  return color instanceof Color ? color : new Color(color);
}, "generateColor"), defaultColor = generateColor("#1677ff"), calculateColor = /* @__PURE__ */ __name(function(props) {
  var offset2 = props.offset, targetRef = props.targetRef, containerRef = props.containerRef, color = props.color, type4 = props.type, _containerRef$current = containerRef.current.getBoundingClientRect(), width = _containerRef$current.width, height = _containerRef$current.height, _targetRef$current$ge = targetRef.current.getBoundingClientRect(), targetWidth = _targetRef$current$ge.width, targetHeight = _targetRef$current$ge.height, centerOffsetX = targetWidth / 2, centerOffsetY = targetHeight / 2, saturation = (offset2.x + centerOffsetX) / width, bright = 1 - (offset2.y + centerOffsetY) / height, hsb = color.toHsb(), alphaOffset = saturation, hueOffset = (offset2.x + centerOffsetX) / width * 360;
  if (type4)
    switch (type4) {
      case "hue":
        return generateColor(_objectSpread2$1(_objectSpread2$1({}, hsb), {}, {
          h: hueOffset <= 0 ? 0 : hueOffset
        }));
      case "alpha":
        return generateColor(_objectSpread2$1(_objectSpread2$1({}, hsb), {}, {
          a: alphaOffset <= 0 ? 0 : alphaOffset
        }));
    }
  return generateColor({
    h: hsb.h,
    s: saturation <= 0 ? 0 : saturation,
    b: bright >= 1 ? 1 : bright,
    a: hsb.a
  });
}, "calculateColor"), calcOffset = /* @__PURE__ */ __name(function(color, type4) {
  var hsb = color.toHsb();
  switch (type4) {
    case "hue":
      return {
        x: hsb.h / 360 * 100,
        y: 50
      };
    case "alpha":
      return {
        x: color.a * 100,
        y: 50
      };
    default:
      return {
        x: hsb.s * 100,
        y: (1 - hsb.b) * 100
      };
  }
}, "calcOffset"), ColorBlock = /* @__PURE__ */ __name(function(_ref) {
  var color = _ref.color, prefixCls = _ref.prefixCls, className = _ref.className, style2 = _ref.style, onClick = _ref.onClick, colorBlockCls = "".concat(prefixCls, "-color-block");
  return /* @__PURE__ */ React__default.createElement("div", {
    className: cn(colorBlockCls, className),
    style: style2,
    onClick
  }, /* @__PURE__ */ React__default.createElement("div", {
    className: "".concat(colorBlockCls, "-inner"),
    style: {
      background: color
    }
  }));
}, "ColorBlock");
function getPosition$1(e2) {
  var obj = "touches" in e2 ? e2.touches[0] : e2, scrollXOffset = document.documentElement.scrollLeft || document.body.scrollLeft || window.pageXOffset, scrollYOffset = document.documentElement.scrollTop || document.body.scrollTop || window.pageYOffset;
  return {
    pageX: obj.pageX - scrollXOffset,
    pageY: obj.pageY - scrollYOffset
  };
}
__name(getPosition$1, "getPosition$1");
function useColorDrag(props) {
  var targetRef = props.targetRef, containerRef = props.containerRef, direction = props.direction, onDragChange = props.onDragChange, onDragChangeComplete = props.onDragChangeComplete, calculate = props.calculate, color = props.color, disabledDrag = props.disabledDrag, _useState = useState({
    x: 0,
    y: 0
  }), _useState2 = _slicedToArray(_useState, 2), offsetValue = _useState2[0], setOffsetValue = _useState2[1], mouseMoveRef = useRef(null), mouseUpRef = useRef(null);
  useEffect(function() {
    setOffsetValue(calculate());
  }, [color]), useEffect(function() {
    return function() {
      document.removeEventListener("mousemove", mouseMoveRef.current), document.removeEventListener("mouseup", mouseUpRef.current), document.removeEventListener("touchmove", mouseMoveRef.current), document.removeEventListener("touchend", mouseUpRef.current), mouseMoveRef.current = null, mouseUpRef.current = null;
    };
  }, []);
  var updateOffset = /* @__PURE__ */ __name(function(e2) {
    var _getPosition = getPosition$1(e2), pageX = _getPosition.pageX, pageY = _getPosition.pageY, _containerRef$current = containerRef.current.getBoundingClientRect(), rectX = _containerRef$current.x, rectY = _containerRef$current.y, width = _containerRef$current.width, height = _containerRef$current.height, _targetRef$current$ge = targetRef.current.getBoundingClientRect(), targetWidth = _targetRef$current$ge.width, targetHeight = _targetRef$current$ge.height, centerOffsetX = targetWidth / 2, centerOffsetY = targetHeight / 2, offsetX = Math.max(0, Math.min(pageX - rectX, width)) - centerOffsetX, offsetY = Math.max(0, Math.min(pageY - rectY, height)) - centerOffsetY, calcOffset3 = {
      x: offsetX,
      y: direction === "x" ? offsetValue.y : offsetY
    };
    if (targetWidth === 0 && targetHeight === 0 || targetWidth !== targetHeight)
      return !1;
    onDragChange == null || onDragChange(calcOffset3);
  }, "updateOffset"), onDragMove = /* @__PURE__ */ __name(function(e2) {
    e2.preventDefault(), updateOffset(e2);
  }, "onDragMove"), onDragStop = /* @__PURE__ */ __name(function(e2) {
    e2.preventDefault(), document.removeEventListener("mousemove", mouseMoveRef.current), document.removeEventListener("mouseup", mouseUpRef.current), document.removeEventListener("touchmove", mouseMoveRef.current), document.removeEventListener("touchend", mouseUpRef.current), mouseMoveRef.current = null, mouseUpRef.current = null, onDragChangeComplete == null || onDragChangeComplete();
  }, "onDragStop"), onDragStart = /* @__PURE__ */ __name(function(e2) {
    document.removeEventListener("mousemove", mouseMoveRef.current), document.removeEventListener("mouseup", mouseUpRef.current), !disabledDrag && (updateOffset(e2), document.addEventListener("mousemove", onDragMove), document.addEventListener("mouseup", onDragStop), document.addEventListener("touchmove", onDragMove), document.addEventListener("touchend", onDragStop), mouseMoveRef.current = onDragMove, mouseUpRef.current = onDragStop);
  }, "onDragStart");
  return [offsetValue, onDragStart];
}
__name(useColorDrag, "useColorDrag");
var Handler = /* @__PURE__ */ __name(function(_ref) {
  var _ref$size = _ref.size, size = _ref$size === void 0 ? "default" : _ref$size, color = _ref.color, prefixCls = _ref.prefixCls;
  return /* @__PURE__ */ React__default.createElement("div", {
    className: cn("".concat(prefixCls, "-handler"), _defineProperty$2({}, "".concat(prefixCls, "-handler-sm"), size === "small")),
    style: {
      backgroundColor: color
    }
  });
}, "Handler"), Palette = /* @__PURE__ */ __name(function(_ref) {
  var children = _ref.children, style2 = _ref.style, prefixCls = _ref.prefixCls;
  return /* @__PURE__ */ React__default.createElement("div", {
    className: "".concat(prefixCls, "-palette"),
    style: _objectSpread2$1({
      position: "relative"
    }, style2)
  }, children);
}, "Palette"), Transform = /* @__PURE__ */ forwardRef(function(props, ref) {
  var children = props.children, x = props.x, y = props.y;
  return /* @__PURE__ */ React__default.createElement("div", {
    ref,
    style: {
      position: "absolute",
      left: "".concat(x, "%"),
      top: "".concat(y, "%"),
      zIndex: 1,
      transform: "translate(-50%, -50%)"
    }
  }, children);
}), Picker$1 = /* @__PURE__ */ __name(function(_ref) {
  var color = _ref.color, onChange = _ref.onChange, prefixCls = _ref.prefixCls, onChangeComplete = _ref.onChangeComplete, disabled = _ref.disabled, pickerRef = useRef(), transformRef = useRef(), colorRef = useRef(color), onDragChange = useEvent(function(offsetValue) {
    var calcColor = calculateColor({
      offset: offsetValue,
      targetRef: transformRef,
      containerRef: pickerRef,
      color
    });
    colorRef.current = calcColor, onChange(calcColor);
  }), _useColorDrag = useColorDrag({
    color,
    containerRef: pickerRef,
    targetRef: transformRef,
    calculate: /* @__PURE__ */ __name(function() {
      return calcOffset(color);
    }, "calculate"),
    onDragChange,
    onDragChangeComplete: /* @__PURE__ */ __name(function() {
      return onChangeComplete == null ? void 0 : onChangeComplete(colorRef.current);
    }, "onDragChangeComplete"),
    disabledDrag: disabled
  }), _useColorDrag2 = _slicedToArray(_useColorDrag, 2), offset2 = _useColorDrag2[0], dragStartHandle = _useColorDrag2[1];
  return /* @__PURE__ */ React__default.createElement("div", {
    ref: pickerRef,
    className: "".concat(prefixCls, "-select"),
    onMouseDown: dragStartHandle,
    onTouchStart: dragStartHandle
  }, /* @__PURE__ */ React__default.createElement(Palette, {
    prefixCls
  }, /* @__PURE__ */ React__default.createElement(Transform, {
    x: offset2.x,
    y: offset2.y,
    ref: transformRef
  }, /* @__PURE__ */ React__default.createElement(Handler, {
    color: color.toRgbString(),
    prefixCls
  })), /* @__PURE__ */ React__default.createElement("div", {
    className: "".concat(prefixCls, "-saturation"),
    style: {
      backgroundColor: "hsl(".concat(color.toHsb().h, ",100%, 50%)"),
      backgroundImage: "linear-gradient(0deg, #000, transparent),linear-gradient(90deg, #fff, hsla(0, 0%, 100%, 0))"
    }
  })));
}, "Picker"), useColorState = /* @__PURE__ */ __name(function(defaultValue, value) {
  var _useMergedState = useMergedState(defaultValue, {
    value
  }), _useMergedState2 = _slicedToArray(_useMergedState, 2), mergedValue = _useMergedState2[0], setValue = _useMergedState2[1], color = useMemo$1(function() {
    return generateColor(mergedValue);
  }, [mergedValue]);
  return [color, setValue];
}, "useColorState"), Gradient = /* @__PURE__ */ __name(function(_ref) {
  var colors = _ref.colors, children = _ref.children, _ref$direction = _ref.direction, direction = _ref$direction === void 0 ? "to right" : _ref$direction, type4 = _ref.type, prefixCls = _ref.prefixCls, gradientColors = useMemo$1(function() {
    return colors.map(function(color, idx) {
      var result = generateColor(color);
      return type4 === "alpha" && idx === colors.length - 1 && (result = new Color(result.setA(1))), result.toRgbString();
    }).join(",");
  }, [colors, type4]);
  return /* @__PURE__ */ React__default.createElement("div", {
    className: "".concat(prefixCls, "-gradient"),
    style: {
      position: "absolute",
      inset: 0,
      background: "linear-gradient(".concat(direction, ", ").concat(gradientColors, ")")
    }
  }, children);
}, "Gradient"), Slider = /* @__PURE__ */ __name(function(props) {
  var prefixCls = props.prefixCls, colors = props.colors, disabled = props.disabled, onChange = props.onChange, onChangeComplete = props.onChangeComplete, color = props.color, type4 = props.type, sliderRef = useRef(), transformRef = useRef(), colorRef = useRef(color), getValue2 = /* @__PURE__ */ __name(function(c) {
    return type4 === "hue" ? c.getHue() : c.a * 100;
  }, "getValue"), onDragChange = useEvent(function(offsetValue) {
    var calcColor = calculateColor({
      offset: offsetValue,
      targetRef: transformRef,
      containerRef: sliderRef,
      color,
      type: type4
    });
    colorRef.current = calcColor, onChange(getValue2(calcColor));
  }), _useColorDrag = useColorDrag({
    color,
    targetRef: transformRef,
    containerRef: sliderRef,
    calculate: /* @__PURE__ */ __name(function() {
      return calcOffset(color, type4);
    }, "calculate"),
    onDragChange,
    onDragChangeComplete: /* @__PURE__ */ __name(function() {
      onChangeComplete(getValue2(colorRef.current));
    }, "onDragChangeComplete"),
    direction: "x",
    disabledDrag: disabled
  }), _useColorDrag2 = _slicedToArray(_useColorDrag, 2), offset2 = _useColorDrag2[0], dragStartHandle = _useColorDrag2[1], handleColor = React__default.useMemo(function() {
    if (type4 === "hue") {
      var hsb = color.toHsb();
      hsb.s = 1, hsb.b = 1, hsb.a = 1;
      var lightColor = new Color(hsb);
      return lightColor;
    }
    return color;
  }, [color, type4]), gradientList = React__default.useMemo(function() {
    return colors.map(function(info) {
      return "".concat(info.color, " ").concat(info.percent, "%");
    });
  }, [colors]);
  return /* @__PURE__ */ React__default.createElement("div", {
    ref: sliderRef,
    className: cn("".concat(prefixCls, "-slider"), "".concat(prefixCls, "-slider-").concat(type4)),
    onMouseDown: dragStartHandle,
    onTouchStart: dragStartHandle
  }, /* @__PURE__ */ React__default.createElement(Palette, {
    prefixCls
  }, /* @__PURE__ */ React__default.createElement(Transform, {
    x: offset2.x,
    y: offset2.y,
    ref: transformRef
  }, /* @__PURE__ */ React__default.createElement(Handler, {
    size: "small",
    color: handleColor.toHexString(),
    prefixCls
  })), /* @__PURE__ */ React__default.createElement(Gradient, {
    colors: gradientList,
    type: type4,
    prefixCls
  })));
}, "Slider");
function useComponent(components2) {
  return React.useMemo(function() {
    var _ref = components2 || {}, slider = _ref.slider;
    return [slider || Slider];
  }, [components2]);
}
__name(useComponent, "useComponent");
var HUE_COLORS = [{
  color: "rgb(255, 0, 0)",
  percent: 0
}, {
  color: "rgb(255, 255, 0)",
  percent: 17
}, {
  color: "rgb(0, 255, 0)",
  percent: 33
}, {
  color: "rgb(0, 255, 255)",
  percent: 50
}, {
  color: "rgb(0, 0, 255)",
  percent: 67
}, {
  color: "rgb(255, 0, 255)",
  percent: 83
}, {
  color: "rgb(255, 0, 0)",
  percent: 100
}], ColorPicker = /* @__PURE__ */ forwardRef(function(props, ref) {
  var value = props.value, defaultValue = props.defaultValue, _props$prefixCls = props.prefixCls, prefixCls = _props$prefixCls === void 0 ? ColorPickerPrefixCls : _props$prefixCls, onChange = props.onChange, onChangeComplete = props.onChangeComplete, className = props.className, style2 = props.style, panelRender = props.panelRender, _props$disabledAlpha = props.disabledAlpha, disabledAlpha = _props$disabledAlpha === void 0 ? !1 : _props$disabledAlpha, _props$disabled = props.disabled, disabled = _props$disabled === void 0 ? !1 : _props$disabled, components2 = props.components, _useComponent = useComponent(components2), _useComponent2 = _slicedToArray(_useComponent, 1), Slider3 = _useComponent2[0], _useColorState = useColorState(defaultValue || defaultColor, value), _useColorState2 = _slicedToArray(_useColorState, 2), colorValue = _useColorState2[0], setColorValue = _useColorState2[1], alphaColor = useMemo$1(function() {
    return colorValue.setA(1).toRgbString();
  }, [colorValue]), handleChange = /* @__PURE__ */ __name(function(data, type4) {
    value || setColorValue(data), onChange == null || onChange(data, type4);
  }, "handleChange"), getHueColor = /* @__PURE__ */ __name(function(hue) {
    return new Color(colorValue.setHue(hue));
  }, "getHueColor"), getAlphaColor2 = /* @__PURE__ */ __name(function(alpha) {
    return new Color(colorValue.setA(alpha / 100));
  }, "getAlphaColor"), onHueChange = /* @__PURE__ */ __name(function(hue) {
    handleChange(getHueColor(hue), {
      type: "hue",
      value: hue
    });
  }, "onHueChange"), onAlphaChange = /* @__PURE__ */ __name(function(alpha) {
    handleChange(getAlphaColor2(alpha), {
      type: "alpha",
      value: alpha
    });
  }, "onAlphaChange"), onHueChangeComplete = /* @__PURE__ */ __name(function(hue) {
    onChangeComplete && onChangeComplete(getHueColor(hue));
  }, "onHueChangeComplete"), onAlphaChangeComplete = /* @__PURE__ */ __name(function(alpha) {
    onChangeComplete && onChangeComplete(getAlphaColor2(alpha));
  }, "onAlphaChangeComplete"), mergeCls = cn("".concat(prefixCls, "-panel"), className, _defineProperty$2({}, "".concat(prefixCls, "-panel-disabled"), disabled)), sharedSliderProps = {
    prefixCls,
    disabled,
    color: colorValue
  }, defaultPanel = /* @__PURE__ */ React__default.createElement(React__default.Fragment, null, /* @__PURE__ */ React__default.createElement(Picker$1, _extends({
    onChange: handleChange
  }, sharedSliderProps, {
    onChangeComplete
  })), /* @__PURE__ */ React__default.createElement("div", {
    className: "".concat(prefixCls, "-slider-container")
  }, /* @__PURE__ */ React__default.createElement("div", {
    className: cn("".concat(prefixCls, "-slider-group"), _defineProperty$2({}, "".concat(prefixCls, "-slider-group-disabled-alpha"), disabledAlpha))
  }, /* @__PURE__ */ React__default.createElement(Slider3, _extends({}, sharedSliderProps, {
    type: "hue",
    colors: HUE_COLORS,
    min: 0,
    max: 359,
    value: colorValue.getHue(),
    onChange: onHueChange,
    onChangeComplete: onHueChangeComplete
  })), !disabledAlpha && /* @__PURE__ */ React__default.createElement(Slider3, _extends({}, sharedSliderProps, {
    type: "alpha",
    colors: [{
      percent: 0,
      color: "rgba(255, 0, 4, 0)"
    }, {
      percent: 100,
      color: alphaColor
    }],
    min: 0,
    max: 100,
    value: colorValue.a * 100,
    onChange: onAlphaChange,
    onChangeComplete: onAlphaChangeComplete
  }))), /* @__PURE__ */ React__default.createElement(ColorBlock, {
    color: colorValue.toRgbString(),
    prefixCls
  })));
  return /* @__PURE__ */ React__default.createElement("div", {
    className: mergeCls,
    style: style2,
    ref
  }, typeof panelRender == "function" ? panelRender(defaultPanel) : defaultPanel);
});
process.env.NODE_ENV !== "production" && (ColorPicker.displayName = "ColorPicker");
const toHexFormat = /* @__PURE__ */ __name((value, alpha) => (value == null ? void 0 : value.replace(/[^\w/]/g, "").slice(0, alpha ? 8 : 6)) || "", "toHexFormat"), getHex = /* @__PURE__ */ __name((value, alpha) => value ? toHexFormat(value, alpha) : "", "getHex");
let AggregationColor = /* @__PURE__ */ function() {
  function AggregationColor2(color) {
    _classCallCheck$1(this, AggregationColor2);
    var _a;
    if (this.cleared = !1, color instanceof AggregationColor2) {
      this.metaColor = color.metaColor.clone(), this.colors = (_a = color.colors) === null || _a === void 0 ? void 0 : _a.map((info) => ({
        color: new AggregationColor2(info.color),
        percent: info.percent
      })), this.cleared = color.cleared;
      return;
    }
    const isArray = Array.isArray(color);
    isArray && color.length ? (this.colors = color.map((_ref) => {
      let {
        color: c,
        percent
      } = _ref;
      return {
        color: new AggregationColor2(c),
        percent
      };
    }), this.metaColor = new Color(this.colors[0].color.metaColor)) : this.metaColor = new Color(isArray ? "" : color), (!color || isArray && !this.colors) && (this.metaColor = this.metaColor.setA(0), this.cleared = !0);
  }
  return __name(AggregationColor2, "AggregationColor"), _createClass$1(AggregationColor2, [{
    key: "toHsb",
    value: /* @__PURE__ */ __name(function() {
      return this.metaColor.toHsb();
    }, "toHsb")
  }, {
    key: "toHsbString",
    value: /* @__PURE__ */ __name(function() {
      return this.metaColor.toHsbString();
    }, "toHsbString")
  }, {
    key: "toHex",
    value: /* @__PURE__ */ __name(function() {
      return getHex(this.toHexString(), this.metaColor.a < 1);
    }, "toHex")
  }, {
    key: "toHexString",
    value: /* @__PURE__ */ __name(function() {
      return this.metaColor.toHexString();
    }, "toHexString")
  }, {
    key: "toRgb",
    value: /* @__PURE__ */ __name(function() {
      return this.metaColor.toRgb();
    }, "toRgb")
  }, {
    key: "toRgbString",
    value: /* @__PURE__ */ __name(function() {
      return this.metaColor.toRgbString();
    }, "toRgbString")
  }, {
    key: "isGradient",
    value: /* @__PURE__ */ __name(function() {
      return !!this.colors && !this.cleared;
    }, "isGradient")
  }, {
    key: "getColors",
    value: /* @__PURE__ */ __name(function() {
      return this.colors || [{
        color: this,
        percent: 0
      }];
    }, "getColors")
  }, {
    key: "toCssString",
    value: /* @__PURE__ */ __name(function() {
      const {
        colors
      } = this;
      return colors ? `linear-gradient(90deg, ${colors.map((c) => `${c.color.toRgbString()} ${c.percent}%`).join(", ")})` : this.metaColor.toRgbString();
    }, "toCssString")
  }, {
    key: "equals",
    value: /* @__PURE__ */ __name(function(color) {
      return !color || this.isGradient() !== color.isGradient() ? !1 : this.isGradient() ? this.colors.length === color.colors.length && this.colors.every((c, i) => {
        const target = color.colors[i];
        return c.percent === target.percent && c.color.equals(target.color);
      }) : this.toHexString() === color.toHexString();
    }, "equals")
  }]);
}();
var RightOutlined$1 = { icon: { tag: "svg", attrs: { viewBox: "64 64 896 896", focusable: "false" }, children: [{ tag: "path", attrs: { d: "M765.7 486.8L314.9 134.7A7.97 7.97 0 00302 141v77.3c0 4.9 2.3 9.6 6.1 12.6l360 281.1-360 281.1c-3.9 3-6.1 7.7-6.1 12.6V883c0 6.7 7.7 10.4 12.9 6.3l450.8-352.1a31.96 31.96 0 000-50.4z" } }] }, name: "right", theme: "outlined" }, RightOutlined = /* @__PURE__ */ __name(function(props, ref) {
  return /* @__PURE__ */ React.createElement(Icon$3, _extends({}, props, {
    ref,
    icon: RightOutlined$1
  }));
}, "RightOutlined"), RefIcon$y = /* @__PURE__ */ React.forwardRef(RightOutlined);
process.env.NODE_ENV !== "production" && (RefIcon$y.displayName = "RightOutlined");
const genCollapseMotion = /* @__PURE__ */ __name((token2) => ({
  [token2.componentCls]: {
    // For common/openAnimation
    [`${token2.antCls}-motion-collapse-legacy`]: {
      overflow: "hidden",
      "&-active": {
        transition: `height ${token2.motionDurationMid} ${token2.motionEaseInOut},
        opacity ${token2.motionDurationMid} ${token2.motionEaseInOut} !important`
      }
    },
    [`${token2.antCls}-motion-collapse`]: {
      overflow: "hidden",
      transition: `height ${token2.motionDurationMid} ${token2.motionEaseInOut},
        opacity ${token2.motionDurationMid} ${token2.motionEaseInOut} !important`
    }
  }
}), "genCollapseMotion"), initMotionCommon = /* @__PURE__ */ __name((duration) => ({
  animationDuration: duration,
  animationFillMode: "both"
}), "initMotionCommon"), initMotionCommonLeave = /* @__PURE__ */ __name((duration) => ({
  animationDuration: duration,
  animationFillMode: "both"
}), "initMotionCommonLeave"), initMotion = /* @__PURE__ */ __name(function(motionCls, inKeyframes, outKeyframes, duration) {
  const sameLevelPrefix = (arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : !1) ? "&" : "";
  return {
    [`
      ${sameLevelPrefix}${motionCls}-enter,
      ${sameLevelPrefix}${motionCls}-appear
    `]: Object.assign(Object.assign({}, initMotionCommon(duration)), {
      animationPlayState: "paused"
    }),
    [`${sameLevelPrefix}${motionCls}-leave`]: Object.assign(Object.assign({}, initMotionCommonLeave(duration)), {
      animationPlayState: "paused"
    }),
    [`
      ${sameLevelPrefix}${motionCls}-enter${motionCls}-enter-active,
      ${sameLevelPrefix}${motionCls}-appear${motionCls}-appear-active
    `]: {
      animationName: inKeyframes,
      animationPlayState: "running"
    },
    [`${sameLevelPrefix}${motionCls}-leave${motionCls}-leave-active`]: {
      animationName: outKeyframes,
      animationPlayState: "running",
      pointerEvents: "none"
    }
  };
}, "initMotion"), fadeIn = new Keyframe("antFadeIn", {
  "0%": {
    opacity: 0
  },
  "100%": {
    opacity: 1
  }
}), fadeOut = new Keyframe("antFadeOut", {
  "0%": {
    opacity: 1
  },
  "100%": {
    opacity: 0
  }
}), initFadeMotion = /* @__PURE__ */ __name(function(token2) {
  let sameLevel = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1;
  const {
    antCls
  } = token2, motionCls = `${antCls}-fade`, sameLevelPrefix = sameLevel ? "&" : "";
  return [initMotion(motionCls, fadeIn, fadeOut, token2.motionDurationMid, sameLevel), {
    [`
        ${sameLevelPrefix}${motionCls}-enter,
        ${sameLevelPrefix}${motionCls}-appear
      `]: {
      opacity: 0,
      animationTimingFunction: "linear"
    },
    [`${sameLevelPrefix}${motionCls}-leave`]: {
      animationTimingFunction: "linear"
    }
  }];
}, "initFadeMotion"), moveDownIn = new Keyframe("antMoveDownIn", {
  "0%": {
    transform: "translate3d(0, 100%, 0)",
    transformOrigin: "0 0",
    opacity: 0
  },
  "100%": {
    transform: "translate3d(0, 0, 0)",
    transformOrigin: "0 0",
    opacity: 1
  }
}), moveDownOut = new Keyframe("antMoveDownOut", {
  "0%": {
    transform: "translate3d(0, 0, 0)",
    transformOrigin: "0 0",
    opacity: 1
  },
  "100%": {
    transform: "translate3d(0, 100%, 0)",
    transformOrigin: "0 0",
    opacity: 0
  }
}), moveLeftIn = new Keyframe("antMoveLeftIn", {
  "0%": {
    transform: "translate3d(-100%, 0, 0)",
    transformOrigin: "0 0",
    opacity: 0
  },
  "100%": {
    transform: "translate3d(0, 0, 0)",
    transformOrigin: "0 0",
    opacity: 1
  }
}), moveLeftOut = new Keyframe("antMoveLeftOut", {
  "0%": {
    transform: "translate3d(0, 0, 0)",
    transformOrigin: "0 0",
    opacity: 1
  },
  "100%": {
    transform: "translate3d(-100%, 0, 0)",
    transformOrigin: "0 0",
    opacity: 0
  }
}), moveRightIn = new Keyframe("antMoveRightIn", {
  "0%": {
    transform: "translate3d(100%, 0, 0)",
    transformOrigin: "0 0",
    opacity: 0
  },
  "100%": {
    transform: "translate3d(0, 0, 0)",
    transformOrigin: "0 0",
    opacity: 1
  }
}), moveRightOut = new Keyframe("antMoveRightOut", {
  "0%": {
    transform: "translate3d(0, 0, 0)",
    transformOrigin: "0 0",
    opacity: 1
  },
  "100%": {
    transform: "translate3d(100%, 0, 0)",
    transformOrigin: "0 0",
    opacity: 0
  }
}), moveUpIn = new Keyframe("antMoveUpIn", {
  "0%": {
    transform: "translate3d(0, -100%, 0)",
    transformOrigin: "0 0",
    opacity: 0
  },
  "100%": {
    transform: "translate3d(0, 0, 0)",
    transformOrigin: "0 0",
    opacity: 1
  }
}), moveUpOut = new Keyframe("antMoveUpOut", {
  "0%": {
    transform: "translate3d(0, 0, 0)",
    transformOrigin: "0 0",
    opacity: 1
  },
  "100%": {
    transform: "translate3d(0, -100%, 0)",
    transformOrigin: "0 0",
    opacity: 0
  }
}), moveMotion = {
  "move-up": {
    inKeyframes: moveUpIn,
    outKeyframes: moveUpOut
  },
  "move-down": {
    inKeyframes: moveDownIn,
    outKeyframes: moveDownOut
  },
  "move-left": {
    inKeyframes: moveLeftIn,
    outKeyframes: moveLeftOut
  },
  "move-right": {
    inKeyframes: moveRightIn,
    outKeyframes: moveRightOut
  }
}, initMoveMotion = /* @__PURE__ */ __name((token2, motionName) => {
  const {
    antCls
  } = token2, motionCls = `${antCls}-${motionName}`, {
    inKeyframes,
    outKeyframes
  } = moveMotion[motionName];
  return [initMotion(motionCls, inKeyframes, outKeyframes, token2.motionDurationMid), {
    [`
        ${motionCls}-enter,
        ${motionCls}-appear
      `]: {
      opacity: 0,
      animationTimingFunction: token2.motionEaseOutCirc
    },
    [`${motionCls}-leave`]: {
      animationTimingFunction: token2.motionEaseInOutCirc
    }
  }];
}, "initMoveMotion"), slideUpIn = new Keyframe("antSlideUpIn", {
  "0%": {
    transform: "scaleY(0.8)",
    transformOrigin: "0% 0%",
    opacity: 0
  },
  "100%": {
    transform: "scaleY(1)",
    transformOrigin: "0% 0%",
    opacity: 1
  }
}), slideUpOut = new Keyframe("antSlideUpOut", {
  "0%": {
    transform: "scaleY(1)",
    transformOrigin: "0% 0%",
    opacity: 1
  },
  "100%": {
    transform: "scaleY(0.8)",
    transformOrigin: "0% 0%",
    opacity: 0
  }
}), slideDownIn = new Keyframe("antSlideDownIn", {
  "0%": {
    transform: "scaleY(0.8)",
    transformOrigin: "100% 100%",
    opacity: 0
  },
  "100%": {
    transform: "scaleY(1)",
    transformOrigin: "100% 100%",
    opacity: 1
  }
}), slideDownOut = new Keyframe("antSlideDownOut", {
  "0%": {
    transform: "scaleY(1)",
    transformOrigin: "100% 100%",
    opacity: 1
  },
  "100%": {
    transform: "scaleY(0.8)",
    transformOrigin: "100% 100%",
    opacity: 0
  }
}), slideLeftIn = new Keyframe("antSlideLeftIn", {
  "0%": {
    transform: "scaleX(0.8)",
    transformOrigin: "0% 0%",
    opacity: 0
  },
  "100%": {
    transform: "scaleX(1)",
    transformOrigin: "0% 0%",
    opacity: 1
  }
}), slideLeftOut = new Keyframe("antSlideLeftOut", {
  "0%": {
    transform: "scaleX(1)",
    transformOrigin: "0% 0%",
    opacity: 1
  },
  "100%": {
    transform: "scaleX(0.8)",
    transformOrigin: "0% 0%",
    opacity: 0
  }
}), slideRightIn = new Keyframe("antSlideRightIn", {
  "0%": {
    transform: "scaleX(0.8)",
    transformOrigin: "100% 0%",
    opacity: 0
  },
  "100%": {
    transform: "scaleX(1)",
    transformOrigin: "100% 0%",
    opacity: 1
  }
}), slideRightOut = new Keyframe("antSlideRightOut", {
  "0%": {
    transform: "scaleX(1)",
    transformOrigin: "100% 0%",
    opacity: 1
  },
  "100%": {
    transform: "scaleX(0.8)",
    transformOrigin: "100% 0%",
    opacity: 0
  }
}), slideMotion = {
  "slide-up": {
    inKeyframes: slideUpIn,
    outKeyframes: slideUpOut
  },
  "slide-down": {
    inKeyframes: slideDownIn,
    outKeyframes: slideDownOut
  },
  "slide-left": {
    inKeyframes: slideLeftIn,
    outKeyframes: slideLeftOut
  },
  "slide-right": {
    inKeyframes: slideRightIn,
    outKeyframes: slideRightOut
  }
}, initSlideMotion = /* @__PURE__ */ __name((token2, motionName) => {
  const {
    antCls
  } = token2, motionCls = `${antCls}-${motionName}`, {
    inKeyframes,
    outKeyframes
  } = slideMotion[motionName];
  return [initMotion(motionCls, inKeyframes, outKeyframes, token2.motionDurationMid), {
    [`
      ${motionCls}-enter,
      ${motionCls}-appear
    `]: {
      transform: "scale(0)",
      transformOrigin: "0% 0%",
      opacity: 0,
      animationTimingFunction: token2.motionEaseOutQuint,
      "&-prepare": {
        transform: "scale(1)"
      }
    },
    [`${motionCls}-leave`]: {
      animationTimingFunction: token2.motionEaseInQuint
    }
  }];
}, "initSlideMotion"), zoomIn = new Keyframe("antZoomIn", {
  "0%": {
    transform: "scale(0.2)",
    opacity: 0
  },
  "100%": {
    transform: "scale(1)",
    opacity: 1
  }
}), zoomOut = new Keyframe("antZoomOut", {
  "0%": {
    transform: "scale(1)"
  },
  "100%": {
    transform: "scale(0.2)",
    opacity: 0
  }
}), zoomBigIn = new Keyframe("antZoomBigIn", {
  "0%": {
    transform: "scale(0.8)",
    opacity: 0
  },
  "100%": {
    transform: "scale(1)",
    opacity: 1
  }
}), zoomBigOut = new Keyframe("antZoomBigOut", {
  "0%": {
    transform: "scale(1)"
  },
  "100%": {
    transform: "scale(0.8)",
    opacity: 0
  }
}), zoomUpIn = new Keyframe("antZoomUpIn", {
  "0%": {
    transform: "scale(0.8)",
    transformOrigin: "50% 0%",
    opacity: 0
  },
  "100%": {
    transform: "scale(1)",
    transformOrigin: "50% 0%"
  }
}), zoomUpOut = new Keyframe("antZoomUpOut", {
  "0%": {
    transform: "scale(1)",
    transformOrigin: "50% 0%"
  },
  "100%": {
    transform: "scale(0.8)",
    transformOrigin: "50% 0%",
    opacity: 0
  }
}), zoomLeftIn = new Keyframe("antZoomLeftIn", {
  "0%": {
    transform: "scale(0.8)",
    transformOrigin: "0% 50%",
    opacity: 0
  },
  "100%": {
    transform: "scale(1)",
    transformOrigin: "0% 50%"
  }
}), zoomLeftOut = new Keyframe("antZoomLeftOut", {
  "0%": {
    transform: "scale(1)",
    transformOrigin: "0% 50%"
  },
  "100%": {
    transform: "scale(0.8)",
    transformOrigin: "0% 50%",
    opacity: 0
  }
}), zoomRightIn = new Keyframe("antZoomRightIn", {
  "0%": {
    transform: "scale(0.8)",
    transformOrigin: "100% 50%",
    opacity: 0
  },
  "100%": {
    transform: "scale(1)",
    transformOrigin: "100% 50%"
  }
}), zoomRightOut = new Keyframe("antZoomRightOut", {
  "0%": {
    transform: "scale(1)",
    transformOrigin: "100% 50%"
  },
  "100%": {
    transform: "scale(0.8)",
    transformOrigin: "100% 50%",
    opacity: 0
  }
}), zoomDownIn = new Keyframe("antZoomDownIn", {
  "0%": {
    transform: "scale(0.8)",
    transformOrigin: "50% 100%",
    opacity: 0
  },
  "100%": {
    transform: "scale(1)",
    transformOrigin: "50% 100%"
  }
}), zoomDownOut = new Keyframe("antZoomDownOut", {
  "0%": {
    transform: "scale(1)",
    transformOrigin: "50% 100%"
  },
  "100%": {
    transform: "scale(0.8)",
    transformOrigin: "50% 100%",
    opacity: 0
  }
}), zoomMotion = {
  zoom: {
    inKeyframes: zoomIn,
    outKeyframes: zoomOut
  },
  "zoom-big": {
    inKeyframes: zoomBigIn,
    outKeyframes: zoomBigOut
  },
  "zoom-big-fast": {
    inKeyframes: zoomBigIn,
    outKeyframes: zoomBigOut
  },
  "zoom-left": {
    inKeyframes: zoomLeftIn,
    outKeyframes: zoomLeftOut
  },
  "zoom-right": {
    inKeyframes: zoomRightIn,
    outKeyframes: zoomRightOut
  },
  "zoom-up": {
    inKeyframes: zoomUpIn,
    outKeyframes: zoomUpOut
  },
  "zoom-down": {
    inKeyframes: zoomDownIn,
    outKeyframes: zoomDownOut
  }
}, initZoomMotion = /* @__PURE__ */ __name((token2, motionName) => {
  const {
    antCls
  } = token2, motionCls = `${antCls}-${motionName}`, {
    inKeyframes,
    outKeyframes
  } = zoomMotion[motionName];
  return [initMotion(motionCls, inKeyframes, outKeyframes, motionName === "zoom-big-fast" ? token2.motionDurationFast : token2.motionDurationMid), {
    [`
        ${motionCls}-enter,
        ${motionCls}-appear
      `]: {
      transform: "scale(0)",
      opacity: 0,
      animationTimingFunction: token2.motionEaseOutCirc,
      "&-prepare": {
        transform: "none"
      }
    },
    [`${motionCls}-leave`]: {
      animationTimingFunction: token2.motionEaseInOutCirc
    }
  }];
}, "initZoomMotion"), isBright = /* @__PURE__ */ __name((value, bgColorToken) => {
  const {
    r: r2,
    g,
    b,
    a
  } = value.toRgb(), hsv = new Color(value.toRgbString()).onBackground(bgColorToken).toHsv();
  return a <= 0.5 ? hsv.v > 0.5 : r2 * 0.299 + g * 0.587 + b * 0.114 > 192;
}, "isBright"), prepareToken$3 = /* @__PURE__ */ __name((token2) => {
  const {
    paddingInline,
    onlyIconSize
  } = token2;
  return merge(token2, {
    buttonPaddingHorizontal: paddingInline,
    buttonPaddingVertical: 0,
    buttonIconOnlyFontSize: onlyIconSize
  });
}, "prepareToken$3"), prepareComponentToken$n = /* @__PURE__ */ __name((token2) => {
  var _a, _b, _c, _d, _e, _f;
  const contentFontSize = (_a = token2.contentFontSize) !== null && _a !== void 0 ? _a : token2.fontSize, contentFontSizeSM = (_b = token2.contentFontSizeSM) !== null && _b !== void 0 ? _b : token2.fontSize, contentFontSizeLG = (_c = token2.contentFontSizeLG) !== null && _c !== void 0 ? _c : token2.fontSizeLG, contentLineHeight = (_d = token2.contentLineHeight) !== null && _d !== void 0 ? _d : getLineHeight(contentFontSize), contentLineHeightSM = (_e = token2.contentLineHeightSM) !== null && _e !== void 0 ? _e : getLineHeight(contentFontSizeSM), contentLineHeightLG = (_f = token2.contentLineHeightLG) !== null && _f !== void 0 ? _f : getLineHeight(contentFontSizeLG), solidTextColor = isBright(new AggregationColor(token2.colorBgSolid), "#fff") ? "#000" : "#fff";
  return {
    fontWeight: 400,
    defaultShadow: `0 ${token2.controlOutlineWidth}px 0 ${token2.controlTmpOutline}`,
    primaryShadow: `0 ${token2.controlOutlineWidth}px 0 ${token2.controlOutline}`,
    dangerShadow: `0 ${token2.controlOutlineWidth}px 0 ${token2.colorErrorOutline}`,
    primaryColor: token2.colorTextLightSolid,
    dangerColor: token2.colorTextLightSolid,
    borderColorDisabled: token2.colorBorder,
    defaultGhostColor: token2.colorBgContainer,
    ghostBg: "transparent",
    defaultGhostBorderColor: token2.colorBgContainer,
    paddingInline: token2.paddingContentHorizontal - token2.lineWidth,
    paddingInlineLG: token2.paddingContentHorizontal - token2.lineWidth,
    paddingInlineSM: 8 - token2.lineWidth,
    onlyIconSize: token2.fontSizeLG,
    onlyIconSizeSM: token2.fontSizeLG - 2,
    onlyIconSizeLG: token2.fontSizeLG + 2,
    groupBorderColor: token2.colorPrimaryHover,
    linkHoverBg: "transparent",
    textTextColor: token2.colorText,
    textTextHoverColor: token2.colorText,
    textTextActiveColor: token2.colorText,
    textHoverBg: token2.colorFillTertiary,
    defaultColor: token2.colorText,
    defaultBg: token2.colorBgContainer,
    defaultBorderColor: token2.colorBorder,
    defaultBorderColorDisabled: token2.colorBorder,
    defaultHoverBg: token2.colorBgContainer,
    defaultHoverColor: token2.colorPrimaryHover,
    defaultHoverBorderColor: token2.colorPrimaryHover,
    defaultActiveBg: token2.colorBgContainer,
    defaultActiveColor: token2.colorPrimaryActive,
    defaultActiveBorderColor: token2.colorPrimaryActive,
    solidTextColor,
    contentFontSize,
    contentFontSizeSM,
    contentFontSizeLG,
    contentLineHeight,
    contentLineHeightSM,
    contentLineHeightLG,
    paddingBlock: Math.max((token2.controlHeight - contentFontSize * contentLineHeight) / 2 - token2.lineWidth, 0),
    paddingBlockSM: Math.max((token2.controlHeightSM - contentFontSizeSM * contentLineHeightSM) / 2 - token2.lineWidth, 0),
    paddingBlockLG: Math.max((token2.controlHeightLG - contentFontSizeLG * contentLineHeightLG) / 2 - token2.lineWidth, 0)
  };
}, "prepareComponentToken$n"), genSharedButtonStyle = /* @__PURE__ */ __name((token2) => {
  const {
    componentCls,
    iconCls,
    fontWeight,
    opacityLoading,
    motionDurationSlow,
    motionEaseInOut,
    marginXS,
    calc
  } = token2;
  return {
    [componentCls]: {
      outline: "none",
      position: "relative",
      display: "inline-flex",
      gap: token2.marginXS,
      alignItems: "center",
      justifyContent: "center",
      fontWeight,
      whiteSpace: "nowrap",
      textAlign: "center",
      backgroundImage: "none",
      background: "transparent",
      border: `${unit$1(token2.lineWidth)} ${token2.lineType} transparent`,
      cursor: "pointer",
      transition: `all ${token2.motionDurationMid} ${token2.motionEaseInOut}`,
      userSelect: "none",
      touchAction: "manipulation",
      color: token2.colorText,
      "&:disabled > *": {
        pointerEvents: "none"
      },
      // https://github.com/ant-design/ant-design/issues/51380
      [`${componentCls}-icon > svg`]: resetIcon(),
      "> a": {
        color: "currentColor"
      },
      "&:not(:disabled)": genFocusStyle(token2),
      [`&${componentCls}-two-chinese-chars::first-letter`]: {
        letterSpacing: "0.34em"
      },
      [`&${componentCls}-two-chinese-chars > *:not(${iconCls})`]: {
        marginInlineEnd: "-0.34em",
        letterSpacing: "0.34em"
      },
      [`&${componentCls}-icon-only`]: {
        paddingInline: 0,
        // make `btn-icon-only` not too narrow
        [`&${componentCls}-compact-item`]: {
          flex: "none"
        },
        [`&${componentCls}-round`]: {
          width: "auto"
        }
      },
      // Loading
      [`&${componentCls}-loading`]: {
        opacity: opacityLoading,
        cursor: "default"
      },
      [`${componentCls}-loading-icon`]: {
        transition: ["width", "opacity", "margin"].map((transition) => `${transition} ${motionDurationSlow} ${motionEaseInOut}`).join(",")
      },
      // iconPosition
      [`&:not(${componentCls}-icon-end)`]: {
        [`${componentCls}-loading-icon-motion`]: {
          "&-appear-start, &-enter-start": {
            marginInlineEnd: calc(marginXS).mul(-1).equal()
          },
          "&-appear-active, &-enter-active": {
            marginInlineEnd: 0
          },
          "&-leave-start": {
            marginInlineEnd: 0
          },
          "&-leave-active": {
            marginInlineEnd: calc(marginXS).mul(-1).equal()
          }
        }
      },
      "&-icon-end": {
        flexDirection: "row-reverse",
        [`${componentCls}-loading-icon-motion`]: {
          "&-appear-start, &-enter-start": {
            marginInlineStart: calc(marginXS).mul(-1).equal()
          },
          "&-appear-active, &-enter-active": {
            marginInlineStart: 0
          },
          "&-leave-start": {
            marginInlineStart: 0
          },
          "&-leave-active": {
            marginInlineStart: calc(marginXS).mul(-1).equal()
          }
        }
      }
    }
  };
}, "genSharedButtonStyle"), genHoverActiveButtonStyle = /* @__PURE__ */ __name((btnCls, hoverStyle, activeStyle) => ({
  [`&:not(:disabled):not(${btnCls}-disabled)`]: {
    "&:hover": hoverStyle,
    "&:active": activeStyle
  }
}), "genHoverActiveButtonStyle"), genCircleButtonStyle = /* @__PURE__ */ __name((token2) => ({
  minWidth: token2.controlHeight,
  paddingInlineStart: 0,
  paddingInlineEnd: 0,
  borderRadius: "50%"
}), "genCircleButtonStyle"), genRoundButtonStyle = /* @__PURE__ */ __name((token2) => ({
  borderRadius: token2.controlHeight,
  paddingInlineStart: token2.calc(token2.controlHeight).div(2).equal(),
  paddingInlineEnd: token2.calc(token2.controlHeight).div(2).equal()
}), "genRoundButtonStyle"), genDisabledStyle$1 = /* @__PURE__ */ __name((token2) => ({
  cursor: "not-allowed",
  borderColor: token2.borderColorDisabled,
  color: token2.colorTextDisabled,
  background: token2.colorBgContainerDisabled,
  boxShadow: "none"
}), "genDisabledStyle$1"), genGhostButtonStyle = /* @__PURE__ */ __name((btnCls, background, textColor, borderColor, textColorDisabled, borderColorDisabled, hoverStyle, activeStyle) => ({
  [`&${btnCls}-background-ghost`]: Object.assign(Object.assign({
    color: textColor || void 0,
    background,
    borderColor: borderColor || void 0,
    boxShadow: "none"
  }, genHoverActiveButtonStyle(btnCls, Object.assign({
    background
  }, hoverStyle), Object.assign({
    background
  }, activeStyle))), {
    "&:disabled": {
      cursor: "not-allowed",
      color: textColorDisabled || void 0,
      borderColor: borderColorDisabled || void 0
    }
  })
}), "genGhostButtonStyle"), genSolidDisabledButtonStyle = /* @__PURE__ */ __name((token2) => ({
  [`&:disabled, &${token2.componentCls}-disabled`]: Object.assign({}, genDisabledStyle$1(token2))
}), "genSolidDisabledButtonStyle"), genPureDisabledButtonStyle = /* @__PURE__ */ __name((token2) => ({
  [`&:disabled, &${token2.componentCls}-disabled`]: {
    cursor: "not-allowed",
    color: token2.colorTextDisabled
  }
}), "genPureDisabledButtonStyle"), genVariantButtonStyle = /* @__PURE__ */ __name((token2, hoverStyle, activeStyle, variant) => {
  const genDisabledButtonStyle = variant && ["link", "text"].includes(variant) ? genPureDisabledButtonStyle : genSolidDisabledButtonStyle;
  return Object.assign(Object.assign({}, genDisabledButtonStyle(token2)), genHoverActiveButtonStyle(token2.componentCls, hoverStyle, activeStyle));
}, "genVariantButtonStyle"), genSolidButtonStyle = /* @__PURE__ */ __name((token2, textColor, background, hoverStyle, activeStyle) => ({
  [`&${token2.componentCls}-variant-solid`]: Object.assign({
    color: textColor,
    background
  }, genVariantButtonStyle(token2, hoverStyle, activeStyle))
}), "genSolidButtonStyle"), genOutlinedDashedButtonStyle = /* @__PURE__ */ __name((token2, borderColor, background, hoverStyle, activeStyle) => ({
  [`&${token2.componentCls}-variant-outlined, &${token2.componentCls}-variant-dashed`]: Object.assign({
    borderColor,
    background
  }, genVariantButtonStyle(token2, hoverStyle, activeStyle))
}), "genOutlinedDashedButtonStyle"), genDashedButtonStyle = /* @__PURE__ */ __name((token2) => ({
  [`&${token2.componentCls}-variant-dashed`]: {
    borderStyle: "dashed"
  }
}), "genDashedButtonStyle"), genFilledButtonStyle = /* @__PURE__ */ __name((token2, background, hoverStyle, activeStyle) => ({
  [`&${token2.componentCls}-variant-filled`]: Object.assign({
    boxShadow: "none",
    background
  }, genVariantButtonStyle(token2, hoverStyle, activeStyle))
}), "genFilledButtonStyle"), genTextLinkButtonStyle = /* @__PURE__ */ __name((token2, textColor, variant, hoverStyle, activeStyle) => ({
  [`&${token2.componentCls}-variant-${variant}`]: Object.assign({
    color: textColor,
    boxShadow: "none"
  }, genVariantButtonStyle(token2, hoverStyle, activeStyle, variant))
}), "genTextLinkButtonStyle"), genDefaultButtonStyle = /* @__PURE__ */ __name((token2) => Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({
  color: token2.defaultColor,
  boxShadow: token2.defaultShadow
}, genSolidButtonStyle(token2, token2.solidTextColor, token2.colorBgSolid, {
  color: token2.solidTextColor,
  background: token2.colorBgSolidHover
}, {
  color: token2.solidTextColor,
  background: token2.colorBgSolidActive
})), genDashedButtonStyle(token2)), genFilledButtonStyle(token2, token2.colorFillTertiary, {
  background: token2.colorFillSecondary
}, {
  background: token2.colorFill
})), genTextLinkButtonStyle(token2, token2.textTextColor, "link", {
  color: token2.colorLinkHover,
  background: token2.linkHoverBg
}, {
  color: token2.colorLinkActive
})), genGhostButtonStyle(token2.componentCls, token2.ghostBg, token2.defaultGhostColor, token2.defaultGhostBorderColor, token2.colorTextDisabled, token2.colorBorder)), "genDefaultButtonStyle"), genPrimaryButtonStyle = /* @__PURE__ */ __name((token2) => Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({
  color: token2.colorPrimary,
  boxShadow: token2.primaryShadow
}, genOutlinedDashedButtonStyle(token2, token2.colorPrimary, token2.colorBgContainer, {
  color: token2.colorPrimaryTextHover,
  borderColor: token2.colorPrimaryHover,
  background: token2.colorBgContainer
}, {
  color: token2.colorPrimaryTextActive,
  borderColor: token2.colorPrimaryActive,
  background: token2.colorBgContainer
})), genDashedButtonStyle(token2)), genFilledButtonStyle(token2, token2.colorPrimaryBg, {
  background: token2.colorPrimaryBgHover
}, {
  background: token2.colorPrimaryBorder
})), genTextLinkButtonStyle(token2, token2.colorLink, "text", {
  color: token2.colorPrimaryTextHover,
  background: token2.colorPrimaryBg
}, {
  color: token2.colorPrimaryTextActive,
  background: token2.colorPrimaryBorder
})), genGhostButtonStyle(token2.componentCls, token2.ghostBg, token2.colorPrimary, token2.colorPrimary, token2.colorTextDisabled, token2.colorBorder, {
  color: token2.colorPrimaryHover,
  borderColor: token2.colorPrimaryHover
}, {
  color: token2.colorPrimaryActive,
  borderColor: token2.colorPrimaryActive
})), "genPrimaryButtonStyle"), genDangerousStyle = /* @__PURE__ */ __name((token2) => Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({
  color: token2.colorError,
  boxShadow: token2.dangerShadow
}, genSolidButtonStyle(token2, token2.dangerColor, token2.colorError, {
  background: token2.colorErrorHover
}, {
  background: token2.colorErrorActive
})), genOutlinedDashedButtonStyle(token2, token2.colorError, token2.colorBgContainer, {
  color: token2.colorErrorHover,
  borderColor: token2.colorErrorBorderHover
}, {
  color: token2.colorErrorActive,
  borderColor: token2.colorErrorActive
})), genDashedButtonStyle(token2)), genFilledButtonStyle(token2, token2.colorErrorBg, {
  background: token2.colorErrorBgFilledHover
}, {
  background: token2.colorErrorBgActive
})), genTextLinkButtonStyle(token2, token2.colorError, "text", {
  color: token2.colorErrorHover,
  background: token2.colorErrorBg
}, {
  color: token2.colorErrorHover,
  background: token2.colorErrorBgActive
})), genTextLinkButtonStyle(token2, token2.colorError, "link", {
  color: token2.colorErrorHover
}, {
  color: token2.colorErrorActive
})), genGhostButtonStyle(token2.componentCls, token2.ghostBg, token2.colorError, token2.colorError, token2.colorTextDisabled, token2.colorBorder, {
  color: token2.colorErrorHover,
  borderColor: token2.colorErrorHover
}, {
  color: token2.colorErrorActive,
  borderColor: token2.colorErrorActive
})), "genDangerousStyle"), genColorButtonStyle = /* @__PURE__ */ __name((token2) => {
  const {
    componentCls
  } = token2;
  return {
    [`${componentCls}-color-default`]: genDefaultButtonStyle(token2),
    [`${componentCls}-color-primary`]: genPrimaryButtonStyle(token2),
    [`${componentCls}-color-dangerous`]: genDangerousStyle(token2)
  };
}, "genColorButtonStyle"), genCompatibleButtonStyle = /* @__PURE__ */ __name((token2) => Object.assign(Object.assign(Object.assign(Object.assign({}, genOutlinedDashedButtonStyle(token2, token2.defaultBorderColor, token2.defaultBg, {
  color: token2.defaultHoverColor,
  borderColor: token2.defaultHoverBorderColor,
  background: token2.defaultHoverBg
}, {
  color: token2.defaultActiveColor,
  borderColor: token2.defaultActiveBorderColor,
  background: token2.defaultActiveBg
})), genTextLinkButtonStyle(token2, token2.textTextColor, "text", {
  color: token2.textTextHoverColor,
  background: token2.textHoverBg
}, {
  color: token2.textTextActiveColor,
  background: token2.colorBgTextActive
})), genSolidButtonStyle(token2, token2.primaryColor, token2.colorPrimary, {
  background: token2.colorPrimaryHover,
  color: token2.primaryColor
}, {
  background: token2.colorPrimaryActive,
  color: token2.primaryColor
})), genTextLinkButtonStyle(token2, token2.colorLink, "link", {
  color: token2.colorLinkHover,
  background: token2.linkHoverBg
}, {
  color: token2.colorLinkActive
})), "genCompatibleButtonStyle"), genButtonStyle = /* @__PURE__ */ __name(function(token2) {
  let prefixCls = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
  const {
    componentCls,
    controlHeight,
    fontSize,
    borderRadius,
    buttonPaddingHorizontal,
    iconCls,
    buttonPaddingVertical,
    buttonIconOnlyFontSize
  } = token2;
  return [
    {
      [prefixCls]: {
        fontSize,
        height: controlHeight,
        padding: `${unit$1(buttonPaddingVertical)} ${unit$1(buttonPaddingHorizontal)}`,
        borderRadius,
        [`&${componentCls}-icon-only`]: {
          width: controlHeight,
          [iconCls]: {
            fontSize: buttonIconOnlyFontSize,
            verticalAlign: "calc(-0.125em - 1px)"
          }
        }
      }
    },
    // Shape - patch prefixCls again to override solid border radius style
    {
      [`${componentCls}${componentCls}-circle${prefixCls}`]: genCircleButtonStyle(token2)
    },
    {
      [`${componentCls}${componentCls}-round${prefixCls}`]: genRoundButtonStyle(token2)
    }
  ];
}, "genButtonStyle"), genSizeBaseButtonStyle = /* @__PURE__ */ __name((token2) => {
  const baseToken = merge(token2, {
    fontSize: token2.contentFontSize
  });
  return genButtonStyle(baseToken, token2.componentCls);
}, "genSizeBaseButtonStyle"), genSizeSmallButtonStyle = /* @__PURE__ */ __name((token2) => {
  const smallToken = merge(token2, {
    controlHeight: token2.controlHeightSM,
    fontSize: token2.contentFontSizeSM,
    padding: token2.paddingXS,
    buttonPaddingHorizontal: token2.paddingInlineSM,
    buttonPaddingVertical: 0,
    borderRadius: token2.borderRadiusSM,
    buttonIconOnlyFontSize: token2.onlyIconSizeSM
  });
  return genButtonStyle(smallToken, `${token2.componentCls}-sm`);
}, "genSizeSmallButtonStyle"), genSizeLargeButtonStyle = /* @__PURE__ */ __name((token2) => {
  const largeToken = merge(token2, {
    controlHeight: token2.controlHeightLG,
    fontSize: token2.contentFontSizeLG,
    buttonPaddingHorizontal: token2.paddingInlineLG,
    buttonPaddingVertical: 0,
    borderRadius: token2.borderRadiusLG,
    buttonIconOnlyFontSize: token2.onlyIconSizeLG
  });
  return genButtonStyle(largeToken, `${token2.componentCls}-lg`);
}, "genSizeLargeButtonStyle"), genBlockButtonStyle = /* @__PURE__ */ __name((token2) => {
  const {
    componentCls
  } = token2;
  return {
    [componentCls]: {
      [`&${componentCls}-block`]: {
        width: "100%"
      }
    }
  };
}, "genBlockButtonStyle"), useStyle$s = genStyleHooks("Button", (token2) => {
  const buttonToken = prepareToken$3(token2);
  return [
    // Shared
    genSharedButtonStyle(buttonToken),
    // Size
    genSizeBaseButtonStyle(buttonToken),
    genSizeSmallButtonStyle(buttonToken),
    genSizeLargeButtonStyle(buttonToken),
    // Block
    genBlockButtonStyle(buttonToken),
    // Color
    genColorButtonStyle(buttonToken),
    // https://github.com/ant-design/ant-design/issues/50969
    genCompatibleButtonStyle(buttonToken),
    // Button Group
    genGroupStyle$1(buttonToken)
  ];
}, prepareComponentToken$n, {
  unitless: {
    fontWeight: !0,
    contentLineHeight: !0,
    contentLineHeightSM: !0,
    contentLineHeightLG: !0
  }
});
function compactItemBorder(token2, parentCls, options) {
  const {
    focusElCls,
    focus,
    borderElCls
  } = options, childCombinator = borderElCls ? "> *" : "", hoverEffects = ["hover", focus ? "focus" : null, "active"].filter(Boolean).map((n2) => `&:${n2} ${childCombinator}`).join(",");
  return {
    [`&-item:not(${parentCls}-last-item)`]: {
      marginInlineEnd: token2.calc(token2.lineWidth).mul(-1).equal()
    },
    "&-item": Object.assign(Object.assign({
      [hoverEffects]: {
        zIndex: 2
      }
    }, focusElCls ? {
      [`&${focusElCls}`]: {
        zIndex: 2
      }
    } : {}), {
      [`&[disabled] ${childCombinator}`]: {
        zIndex: 0
      }
    })
  };
}
__name(compactItemBorder, "compactItemBorder");
function compactItemBorderRadius(prefixCls, parentCls, options) {
  const {
    borderElCls
  } = options, childCombinator = borderElCls ? `> ${borderElCls}` : "";
  return {
    [`&-item:not(${parentCls}-first-item):not(${parentCls}-last-item) ${childCombinator}`]: {
      borderRadius: 0
    },
    [`&-item:not(${parentCls}-last-item)${parentCls}-first-item`]: {
      [`& ${childCombinator}, &${prefixCls}-sm ${childCombinator}, &${prefixCls}-lg ${childCombinator}`]: {
        borderStartEndRadius: 0,
        borderEndEndRadius: 0
      }
    },
    [`&-item:not(${parentCls}-first-item)${parentCls}-last-item`]: {
      [`& ${childCombinator}, &${prefixCls}-sm ${childCombinator}, &${prefixCls}-lg ${childCombinator}`]: {
        borderStartStartRadius: 0,
        borderEndStartRadius: 0
      }
    }
  };
}
__name(compactItemBorderRadius, "compactItemBorderRadius");
function genCompactItemStyle(token2) {
  let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
    focus: !0
  };
  const {
    componentCls
  } = token2, compactCls = `${componentCls}-compact`;
  return {
    [compactCls]: Object.assign(Object.assign({}, compactItemBorder(token2, compactCls, options)), compactItemBorderRadius(componentCls, compactCls, options))
  };
}
__name(genCompactItemStyle, "genCompactItemStyle");
function compactItemVerticalBorder(token2, parentCls) {
  return {
    // border collapse
    [`&-item:not(${parentCls}-last-item)`]: {
      marginBottom: token2.calc(token2.lineWidth).mul(-1).equal()
    },
    "&-item": {
      "&:hover,&:focus,&:active": {
        zIndex: 2
      },
      "&[disabled]": {
        zIndex: 0
      }
    }
  };
}
__name(compactItemVerticalBorder, "compactItemVerticalBorder");
function compactItemBorderVerticalRadius(prefixCls, parentCls) {
  return {
    [`&-item:not(${parentCls}-first-item):not(${parentCls}-last-item)`]: {
      borderRadius: 0
    },
    [`&-item${parentCls}-first-item:not(${parentCls}-last-item)`]: {
      [`&, &${prefixCls}-sm, &${prefixCls}-lg`]: {
        borderEndEndRadius: 0,
        borderEndStartRadius: 0
      }
    },
    [`&-item${parentCls}-last-item:not(${parentCls}-first-item)`]: {
      [`&, &${prefixCls}-sm, &${prefixCls}-lg`]: {
        borderStartStartRadius: 0,
        borderStartEndRadius: 0
      }
    }
  };
}
__name(compactItemBorderVerticalRadius, "compactItemBorderVerticalRadius");
function genCompactItemVerticalStyle(token2) {
  const compactCls = `${token2.componentCls}-compact-vertical`;
  return {
    [compactCls]: Object.assign(Object.assign({}, compactItemVerticalBorder(token2, compactCls)), compactItemBorderVerticalRadius(token2.componentCls, compactCls))
  };
}
__name(genCompactItemVerticalStyle, "genCompactItemVerticalStyle");
const genButtonCompactStyle = /* @__PURE__ */ __name((token2) => {
  const {
    componentCls,
    colorPrimaryHover,
    lineWidth,
    calc
  } = token2, insetOffset = calc(lineWidth).mul(-1).equal(), getCompactBorderStyle = /* @__PURE__ */ __name((vertical) => ({
    [`${componentCls}-compact${vertical ? "-vertical" : ""}-item${componentCls}-primary:not([disabled])`]: {
      "& + &::before": {
        position: "absolute",
        top: vertical ? insetOffset : 0,
        insetInlineStart: vertical ? 0 : insetOffset,
        backgroundColor: colorPrimaryHover,
        content: '""',
        width: vertical ? "100%" : lineWidth,
        height: vertical ? lineWidth : "100%"
      }
    }
  }), "getCompactBorderStyle");
  return Object.assign(Object.assign({}, getCompactBorderStyle()), getCompactBorderStyle(!0));
}, "genButtonCompactStyle"), Compact = genSubStyleComponent(["Button", "compact"], (token2) => {
  const buttonToken = prepareToken$3(token2);
  return [
    // Space Compact
    genCompactItemStyle(buttonToken),
    genCompactItemVerticalStyle(buttonToken),
    genButtonCompactStyle(buttonToken)
  ];
}, prepareComponentToken$n);
var __rest$R = function(s, e2) {
  var t2 = {};
  for (var p in s) Object.prototype.hasOwnProperty.call(s, p) && e2.indexOf(p) < 0 && (t2[p] = s[p]);
  if (s != null && typeof Object.getOwnPropertySymbols == "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++)
    e2.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]) && (t2[p[i]] = s[p[i]]);
  return t2;
};
function getLoadingConfig(loading) {
  if (typeof loading == "object" && loading) {
    let delay = loading == null ? void 0 : loading.delay;
    return delay = !Number.isNaN(delay) && typeof delay == "number" ? delay : 0, {
      loading: delay <= 0,
      delay
    };
  }
  return {
    loading: !!loading,
    delay: 0
  };
}
__name(getLoadingConfig, "getLoadingConfig");
const ButtonTypeMap = {
  default: ["default", "outlined"],
  primary: ["primary", "solid"],
  dashed: ["default", "dashed"],
  link: ["primary", "link"],
  text: ["default", "text"]
}, InternalCompoundedButton = /* @__PURE__ */ React__default.forwardRef((props, ref) => {
  var _a, _b, _c, _d;
  const {
    loading = !1,
    prefixCls: customizePrefixCls,
    color,
    variant,
    type: type4,
    danger = !1,
    shape = "default",
    size: customizeSize,
    styles: styles2,
    disabled: customDisabled,
    className,
    rootClassName,
    children,
    icon,
    iconPosition = "start",
    ghost = !1,
    block = !1,
    // React does not recognize the `htmlType` prop on a DOM element. Here we pick it out of `rest`.
    htmlType = "button",
    classNames: customClassNames,
    style: customStyle = {},
    autoInsertSpace,
    autoFocus
  } = props, rest = __rest$R(props, ["loading", "prefixCls", "color", "variant", "type", "danger", "shape", "size", "styles", "disabled", "className", "rootClassName", "children", "icon", "iconPosition", "ghost", "block", "htmlType", "classNames", "style", "autoInsertSpace", "autoFocus"]), mergedType = type4 || "default", [mergedColor, mergedVariant] = useMemo$1(() => {
    if (color && variant)
      return [color, variant];
    const colorVariantPair = ButtonTypeMap[mergedType] || [];
    return danger ? ["danger", colorVariantPair[1]] : colorVariantPair;
  }, [type4, color, variant, danger]), mergedColorText = mergedColor === "danger" ? "dangerous" : mergedColor, {
    getPrefixCls,
    direction,
    button: button2
  } = useContext$1(ConfigContext), mergedInsertSpace = (_a = autoInsertSpace ?? (button2 == null ? void 0 : button2.autoInsertSpace)) !== null && _a !== void 0 ? _a : !0, prefixCls = getPrefixCls("btn", customizePrefixCls), [wrapCSSVar, hashId, cssVarCls] = useStyle$s(prefixCls), disabled = useContext$1(DisabledContext), mergedDisabled = customDisabled ?? disabled, groupSize = useContext$1(GroupSizeContext), loadingOrDelay = useMemo$1(() => getLoadingConfig(loading), [loading]), [innerLoading, setLoading] = useState(loadingOrDelay.loading), [hasTwoCNChar, setHasTwoCNChar] = useState(!1), buttonRef = useRef(null), mergedRef = useComposeRef(ref, buttonRef), needInserted = Children.count(children) === 1 && !icon && !isUnBorderedButtonVariant(mergedVariant), isMountRef = useRef(!0);
  React__default.useEffect(() => (isMountRef.current = !1, () => {
    isMountRef.current = !0;
  }), []), useEffect(() => {
    let delayTimer = null;
    loadingOrDelay.delay > 0 ? delayTimer = setTimeout(() => {
      delayTimer = null, setLoading(!0);
    }, loadingOrDelay.delay) : setLoading(loadingOrDelay.loading);
    function cleanupTimer() {
      delayTimer && (clearTimeout(delayTimer), delayTimer = null);
    }
    return __name(cleanupTimer, "cleanupTimer"), cleanupTimer;
  }, [loadingOrDelay]), useEffect(() => {
    if (!buttonRef.current || !mergedInsertSpace)
      return;
    const buttonText = buttonRef.current.textContent || "";
    needInserted && isTwoCNChar(buttonText) ? hasTwoCNChar || setHasTwoCNChar(!0) : hasTwoCNChar && setHasTwoCNChar(!1);
  }), useEffect(() => {
    autoFocus && buttonRef.current && buttonRef.current.focus();
  }, []);
  const handleClick = React__default.useCallback((e2) => {
    var _a2;
    if (innerLoading || mergedDisabled) {
      e2.preventDefault();
      return;
    }
    (_a2 = props.onClick) === null || _a2 === void 0 || _a2.call(props, e2);
  }, [props.onClick, innerLoading, mergedDisabled]);
  if (process.env.NODE_ENV !== "production") {
    const warning3 = devUseWarning("Button");
    process.env.NODE_ENV !== "production" && warning3(!(typeof icon == "string" && icon.length > 2), "breaking", `\`icon\` is using ReactNode instead of string naming in v4. Please check \`${icon}\` at https://ant.design/components/icon`), process.env.NODE_ENV !== "production" && warning3(!(ghost && isUnBorderedButtonVariant(mergedVariant)), "usage", "`link` or `text` button can't be a `ghost` button.");
  }
  const {
    compactSize,
    compactItemClassnames
  } = useCompactItemContext(prefixCls, direction), sizeClassNameMap = {
    large: "lg",
    small: "sm",
    middle: void 0
  }, sizeFullName = useSize((ctxSize) => {
    var _a2, _b2;
    return (_b2 = (_a2 = customizeSize ?? compactSize) !== null && _a2 !== void 0 ? _a2 : groupSize) !== null && _b2 !== void 0 ? _b2 : ctxSize;
  }), sizeCls = sizeFullName && (_b = sizeClassNameMap[sizeFullName]) !== null && _b !== void 0 ? _b : "", iconType = innerLoading ? "loading" : icon, linkButtonRestProps = omit(rest, ["navigate"]), classes = cn(prefixCls, hashId, cssVarCls, {
    [`${prefixCls}-${shape}`]: shape !== "default" && shape,
    // line(253 - 254): Compatible with versions earlier than 5.21.0
    [`${prefixCls}-${mergedType}`]: mergedType,
    [`${prefixCls}-dangerous`]: danger,
    [`${prefixCls}-color-${mergedColorText}`]: mergedColorText,
    [`${prefixCls}-variant-${mergedVariant}`]: mergedVariant,
    [`${prefixCls}-${sizeCls}`]: sizeCls,
    [`${prefixCls}-icon-only`]: !children && children !== 0 && !!iconType,
    [`${prefixCls}-background-ghost`]: ghost && !isUnBorderedButtonVariant(mergedVariant),
    [`${prefixCls}-loading`]: innerLoading,
    [`${prefixCls}-two-chinese-chars`]: hasTwoCNChar && mergedInsertSpace && !innerLoading,
    [`${prefixCls}-block`]: block,
    [`${prefixCls}-rtl`]: direction === "rtl",
    [`${prefixCls}-icon-end`]: iconPosition === "end"
  }, compactItemClassnames, className, rootClassName, button2 == null ? void 0 : button2.className), fullStyle = Object.assign(Object.assign({}, button2 == null ? void 0 : button2.style), customStyle), iconClasses = cn(customClassNames == null ? void 0 : customClassNames.icon, (_c = button2 == null ? void 0 : button2.classNames) === null || _c === void 0 ? void 0 : _c.icon), iconStyle = Object.assign(Object.assign({}, (styles2 == null ? void 0 : styles2.icon) || {}), ((_d = button2 == null ? void 0 : button2.styles) === null || _d === void 0 ? void 0 : _d.icon) || {}), iconNode = icon && !innerLoading ? /* @__PURE__ */ React__default.createElement(IconWrapper, {
    prefixCls,
    className: iconClasses,
    style: iconStyle
  }, icon) : /* @__PURE__ */ React__default.createElement(LoadingIcon, {
    existIcon: !!icon,
    prefixCls,
    loading: innerLoading,
    mount: isMountRef.current
  }), kids = children || children === 0 ? spaceChildren(children, needInserted && mergedInsertSpace) : null;
  if (linkButtonRestProps.href !== void 0)
    return wrapCSSVar(/* @__PURE__ */ React__default.createElement("a", Object.assign({}, linkButtonRestProps, {
      className: cn(classes, {
        [`${prefixCls}-disabled`]: mergedDisabled
      }),
      href: mergedDisabled ? void 0 : linkButtonRestProps.href,
      style: fullStyle,
      onClick: handleClick,
      ref: mergedRef,
      tabIndex: mergedDisabled ? -1 : 0
    }), iconNode, kids));
  let buttonNode = /* @__PURE__ */ React__default.createElement("button", Object.assign({}, rest, {
    type: htmlType,
    className: classes,
    style: fullStyle,
    onClick: handleClick,
    disabled: mergedDisabled,
    ref: mergedRef
  }), iconNode, kids, compactItemClassnames && /* @__PURE__ */ React__default.createElement(Compact, {
    prefixCls
  }));
  return isUnBorderedButtonVariant(mergedVariant) || (buttonNode = /* @__PURE__ */ React__default.createElement(Wave, {
    component: "Button",
    disabled: innerLoading
  }, buttonNode)), wrapCSSVar(buttonNode);
}), Button$2 = InternalCompoundedButton;
Button$2.Group = ButtonGroup;
Button$2.__ANT_BUTTON = !0;
process.env.NODE_ENV !== "production" && (Button$2.displayName = "Button");
var OrderContext = /* @__PURE__ */ React.createContext(null), EMPTY_LIST$5 = [];
function useDom(render4, debug) {
  var _React$useState = React.useState(function() {
    if (!canUseDom())
      return null;
    var defaultEle = document.createElement("div");
    return process.env.NODE_ENV !== "production" && debug && defaultEle.setAttribute("data-debug", debug), defaultEle;
  }), _React$useState2 = _slicedToArray(_React$useState, 1), ele = _React$useState2[0], appendedRef = React.useRef(!1), queueCreate = React.useContext(OrderContext), _React$useState3 = React.useState(EMPTY_LIST$5), _React$useState4 = _slicedToArray(_React$useState3, 2), queue = _React$useState4[0], setQueue = _React$useState4[1], mergedQueueCreate = queueCreate || (appendedRef.current ? void 0 : function(appendFn) {
    setQueue(function(origin) {
      var newQueue = [appendFn].concat(_toConsumableArray(origin));
      return newQueue;
    });
  });
  function append2() {
    ele.parentElement || document.body.appendChild(ele), appendedRef.current = !0;
  }
  __name(append2, "append");
  function cleanup2() {
    var _ele$parentElement;
    (_ele$parentElement = ele.parentElement) === null || _ele$parentElement === void 0 || _ele$parentElement.removeChild(ele), appendedRef.current = !1;
  }
  return __name(cleanup2, "cleanup"), useLayoutEffect$1(function() {
    return render4 ? queueCreate ? queueCreate(append2) : append2() : cleanup2(), cleanup2;
  }, [render4]), useLayoutEffect$1(function() {
    queue.length && (queue.forEach(function(appendFn) {
      return appendFn();
    }), setQueue(EMPTY_LIST$5));
  }, [queue]), [ele, mergedQueueCreate];
}
__name(useDom, "useDom");
var cached;
function measureScrollbarSize(ele) {
  var randomId = "rc-scrollbar-measure-".concat(Math.random().toString(36).substring(7)), measureEle = document.createElement("div");
  measureEle.id = randomId;
  var measureStyle = measureEle.style;
  measureStyle.position = "absolute", measureStyle.left = "0", measureStyle.top = "0", measureStyle.width = "100px", measureStyle.height = "100px", measureStyle.overflow = "scroll";
  var fallbackWidth, fallbackHeight;
  if (ele) {
    var targetStyle = getComputedStyle(ele);
    measureStyle.scrollbarColor = targetStyle.scrollbarColor, measureStyle.scrollbarWidth = targetStyle.scrollbarWidth;
    var webkitScrollbarStyle = getComputedStyle(ele, "::-webkit-scrollbar"), width = parseInt(webkitScrollbarStyle.width, 10), height = parseInt(webkitScrollbarStyle.height, 10);
    try {
      var widthStyle = width ? "width: ".concat(webkitScrollbarStyle.width, ";") : "", heightStyle = height ? "height: ".concat(webkitScrollbarStyle.height, ";") : "";
      updateCSS(`
#`.concat(randomId, `::-webkit-scrollbar {
`).concat(widthStyle, `
`).concat(heightStyle, `
}`), randomId);
    } catch (e2) {
      console.error(e2), fallbackWidth = width, fallbackHeight = height;
    }
  }
  document.body.appendChild(measureEle);
  var scrollWidth = ele && fallbackWidth && !isNaN(fallbackWidth) ? fallbackWidth : measureEle.offsetWidth - measureEle.clientWidth, scrollHeight = ele && fallbackHeight && !isNaN(fallbackHeight) ? fallbackHeight : measureEle.offsetHeight - measureEle.clientHeight;
  return document.body.removeChild(measureEle), removeCSS(randomId), {
    width: scrollWidth,
    height: scrollHeight
  };
}
__name(measureScrollbarSize, "measureScrollbarSize");
function getScrollBarSize(fresh) {
  return typeof document > "u" ? 0 : (cached === void 0 && (cached = measureScrollbarSize()), cached.width);
}
__name(getScrollBarSize, "getScrollBarSize");
function getTargetScrollBarSize(target) {
  return typeof document > "u" || !target || !(target instanceof Element) ? {
    width: 0,
    height: 0
  } : measureScrollbarSize(target);
}
__name(getTargetScrollBarSize, "getTargetScrollBarSize");
function isBodyOverflowing() {
  return document.body.scrollHeight > (window.innerHeight || document.documentElement.clientHeight) && window.innerWidth > document.body.offsetWidth;
}
__name(isBodyOverflowing, "isBodyOverflowing");
var UNIQUE_ID = "rc-util-locker-".concat(Date.now()), uuid$4 = 0;
function useScrollLocker(lock) {
  var mergedLock = !!lock, _React$useState = React.useState(function() {
    return uuid$4 += 1, "".concat(UNIQUE_ID, "_").concat(uuid$4);
  }), _React$useState2 = _slicedToArray(_React$useState, 1), id2 = _React$useState2[0];
  useLayoutEffect$1(function() {
    if (mergedLock) {
      var scrollbarSize = getTargetScrollBarSize(document.body).width, isOverflow = isBodyOverflowing();
      updateCSS(`
html body {
  overflow-y: hidden;
  `.concat(isOverflow ? "width: calc(100% - ".concat(scrollbarSize, "px);") : "", `
}`), id2);
    } else
      removeCSS(id2);
    return function() {
      removeCSS(id2);
    };
  }, [mergedLock, id2]);
}
__name(useScrollLocker, "useScrollLocker");
var inline = !1;
function inlineMock(nextInline) {
  return inline;
}
__name(inlineMock, "inlineMock");
var getPortalContainer = /* @__PURE__ */ __name(function(getContainer2) {
  return getContainer2 === !1 ? !1 : !canUseDom() || !getContainer2 ? null : typeof getContainer2 == "string" ? document.querySelector(getContainer2) : typeof getContainer2 == "function" ? getContainer2() : getContainer2;
}, "getPortalContainer"), Portal = /* @__PURE__ */ React.forwardRef(function(props, ref) {
  var open = props.open, autoLock = props.autoLock, getContainer2 = props.getContainer, debug = props.debug, _props$autoDestroy = props.autoDestroy, autoDestroy = _props$autoDestroy === void 0 ? !0 : _props$autoDestroy, children = props.children, _React$useState = React.useState(open), _React$useState2 = _slicedToArray(_React$useState, 2), shouldRender = _React$useState2[0], setShouldRender = _React$useState2[1], mergedRender = shouldRender || open;
  process.env.NODE_ENV !== "production" && warningOnce(canUseDom() || !open, "Portal only work in client side. Please call 'useEffect' to show Portal instead default render in SSR."), React.useEffect(function() {
    (autoDestroy || open) && setShouldRender(open);
  }, [open, autoDestroy]);
  var _React$useState3 = React.useState(function() {
    return getPortalContainer(getContainer2);
  }), _React$useState4 = _slicedToArray(_React$useState3, 2), innerContainer = _React$useState4[0], setInnerContainer = _React$useState4[1];
  React.useEffect(function() {
    var customizeContainer = getPortalContainer(getContainer2);
    setInnerContainer(customizeContainer ?? null);
  });
  var _useDom = useDom(mergedRender && !innerContainer, debug), _useDom2 = _slicedToArray(_useDom, 2), defaultContainer2 = _useDom2[0], queueCreate = _useDom2[1], mergedContainer = innerContainer ?? defaultContainer2;
  useScrollLocker(autoLock && open && canUseDom() && (mergedContainer === defaultContainer2 || mergedContainer === document.body));
  var childRef = null;
  if (children && supportRef(children) && ref) {
    var _ref = children;
    childRef = _ref.ref;
  }
  var mergedRef = useComposeRef(childRef, ref);
  if (!mergedRender || !canUseDom() || innerContainer === void 0)
    return null;
  var renderInline = mergedContainer === !1 || inlineMock(), reffedChildren = children;
  return ref && (reffedChildren = /* @__PURE__ */ React.cloneElement(children, {
    ref: mergedRef
  })), /* @__PURE__ */ React.createElement(OrderContext.Provider, {
    value: queueCreate
  }, renderInline ? reffedChildren : /* @__PURE__ */ createPortal(reffedChildren, mergedContainer));
});
process.env.NODE_ENV !== "production" && (Portal.displayName = "Portal");
function getUseId() {
  var fullClone2 = _objectSpread2$1({}, React);
  return fullClone2.useId;
}
__name(getUseId, "getUseId");
var uuid$3 = 0, useOriginId = getUseId();
const useId$2 = useOriginId ? (
  // Use React `useId`
  /* @__PURE__ */ __name(function(id2) {
    var reactId = useOriginId();
    return id2 || (process.env.NODE_ENV === "test" ? "test-id" : reactId);
  }, "useId")
) : (
  // Use compatible of `useId`
  /* @__PURE__ */ __name(function(id2) {
    var _React$useState = React.useState("ssr-id"), _React$useState2 = _slicedToArray(_React$useState, 2), innerId = _React$useState2[0], setInnerId = _React$useState2[1];
    return React.useEffect(function() {
      var nextId = uuid$3;
      uuid$3 += 1, setInnerId("rc_unique_".concat(nextId));
    }, []), id2 || (process.env.NODE_ENV === "test" ? "test-id" : innerId);
  }, "useCompatId")
);
var HOOK_MARK = "RC_FORM_INTERNAL_HOOKS", warningFunc = /* @__PURE__ */ __name(function() {
  warningOnce(!1, "Can not find FormContext. Please make sure you wrap Field under Form.");
}, "warningFunc"), Context = /* @__PURE__ */ React.createContext({
  getFieldValue: warningFunc,
  getFieldsValue: warningFunc,
  getFieldError: warningFunc,
  getFieldWarning: warningFunc,
  getFieldsError: warningFunc,
  isFieldsTouched: warningFunc,
  isFieldTouched: warningFunc,
  isFieldValidating: warningFunc,
  isFieldsValidating: warningFunc,
  resetFields: warningFunc,
  setFields: warningFunc,
  setFieldValue: warningFunc,
  setFieldsValue: warningFunc,
  validateFields: warningFunc,
  submit: warningFunc,
  getInternalHooks: /* @__PURE__ */ __name(function() {
    return warningFunc(), {
      dispatch: warningFunc,
      initEntityValue: warningFunc,
      registerField: warningFunc,
      useSubscribe: warningFunc,
      setInitialValues: warningFunc,
      destroyForm: warningFunc,
      setCallbacks: warningFunc,
      registerWatch: warningFunc,
      getFields: warningFunc,
      setValidateMessages: warningFunc,
      setPreserve: warningFunc,
      getInitialValue: warningFunc
    };
  }, "getInternalHooks")
}), ListContext = /* @__PURE__ */ React.createContext(null);
function toArray$6(value) {
  return value == null ? [] : Array.isArray(value) ? value : [value];
}
__name(toArray$6, "toArray$6");
function isFormInstance(form) {
  return form && !!form._init;
}
__name(isFormInstance, "isFormInstance");
function newMessages() {
  return {
    default: "Validation error on field %s",
    required: "%s is required",
    enum: "%s must be one of %s",
    whitespace: "%s cannot be empty",
    date: {
      format: "%s date %s is invalid for format %s",
      parse: "%s date could not be parsed, %s is invalid ",
      invalid: "%s date %s is invalid"
    },
    types: {
      string: "%s is not a %s",
      method: "%s is not a %s (function)",
      array: "%s is not an %s",
      object: "%s is not an %s",
      number: "%s is not a %s",
      date: "%s is not a %s",
      boolean: "%s is not a %s",
      integer: "%s is not an %s",
      float: "%s is not a %s",
      regexp: "%s is not a valid %s",
      email: "%s is not a valid %s",
      url: "%s is not a valid %s",
      hex: "%s is not a valid %s"
    },
    string: {
      len: "%s must be exactly %s characters",
      min: "%s must be at least %s characters",
      max: "%s cannot be longer than %s characters",
      range: "%s must be between %s and %s characters"
    },
    number: {
      len: "%s must equal %s",
      min: "%s cannot be less than %s",
      max: "%s cannot be greater than %s",
      range: "%s must be between %s and %s"
    },
    array: {
      len: "%s must be exactly %s in length",
      min: "%s cannot be less than %s in length",
      max: "%s cannot be greater than %s in length",
      range: "%s must be between %s and %s in length"
    },
    pattern: {
      mismatch: "%s value %s does not match pattern %s"
    },
    clone: /* @__PURE__ */ __name(function() {
      var cloned = JSON.parse(JSON.stringify(this));
      return cloned.clone = this.clone, cloned;
    }, "clone")
  };
}
__name(newMessages, "newMessages");
var messages = newMessages();
function _isNativeFunction(t2) {
  try {
    return Function.toString.call(t2).indexOf("[native code]") !== -1;
  } catch {
    return typeof t2 == "function";
  }
}
__name(_isNativeFunction, "_isNativeFunction");
function _construct(t2, e2, r2) {
  if (_isNativeReflectConstruct()) return Reflect.construct.apply(null, arguments);
  var o2 = [null];
  o2.push.apply(o2, e2);
  var p = new (t2.bind.apply(t2, o2))();
  return r2 && _setPrototypeOf(p, r2.prototype), p;
}
__name(_construct, "_construct");
function _wrapNativeSuper(t2) {
  var r2 = typeof Map == "function" ? /* @__PURE__ */ new Map() : void 0;
  return _wrapNativeSuper = /* @__PURE__ */ __name(function(t3) {
    if (t3 === null || !_isNativeFunction(t3)) return t3;
    if (typeof t3 != "function") throw new TypeError("Super expression must either be null or a function");
    if (r2 !== void 0) {
      if (r2.has(t3)) return r2.get(t3);
      r2.set(t3, Wrapper);
    }
    function Wrapper() {
      return _construct(t3, arguments, _getPrototypeOf(this).constructor);
    }
    return __name(Wrapper, "Wrapper"), Wrapper.prototype = Object.create(t3.prototype, {
      constructor: {
        value: Wrapper,
        enumerable: !1,
        writable: !0,
        configurable: !0
      }
    }), _setPrototypeOf(Wrapper, t3);
  }, "_wrapNativeSuper"), _wrapNativeSuper(t2);
}
__name(_wrapNativeSuper, "_wrapNativeSuper");
var formatRegExp = /%[sdj%]/g, warning = /* @__PURE__ */ __name(function() {
}, "warning");
typeof process < "u" && process.env && process.env.NODE_ENV !== "production" && typeof window < "u" && typeof document < "u" && (warning = /* @__PURE__ */ __name(function(type4, errors) {
  typeof console < "u" && console.warn && typeof ASYNC_VALIDATOR_NO_WARNING > "u" && errors.every(function(e2) {
    return typeof e2 == "string";
  }) && console.warn(type4, errors);
}, "warning"));
function convertFieldsError(errors) {
  if (!errors || !errors.length) return null;
  var fields = {};
  return errors.forEach(function(error) {
    var field = error.field;
    fields[field] = fields[field] || [], fields[field].push(error);
  }), fields;
}
__name(convertFieldsError, "convertFieldsError");
function format$1(template) {
  for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++)
    args[_key - 1] = arguments[_key];
  var i = 0, len = args.length;
  if (typeof template == "function")
    return template.apply(null, args);
  if (typeof template == "string") {
    var str = template.replace(formatRegExp, function(x) {
      if (x === "%%")
        return "%";
      if (i >= len)
        return x;
      switch (x) {
        case "%s":
          return String(args[i++]);
        case "%d":
          return Number(args[i++]);
        case "%j":
          try {
            return JSON.stringify(args[i++]);
          } catch {
            return "[Circular]";
          }
          break;
        default:
          return x;
      }
    });
    return str;
  }
  return template;
}
__name(format$1, "format$1");
function isNativeStringType(type4) {
  return type4 === "string" || type4 === "url" || type4 === "hex" || type4 === "email" || type4 === "date" || type4 === "pattern";
}
__name(isNativeStringType, "isNativeStringType");
function isEmptyValue(value, type4) {
  return !!(value == null || type4 === "array" && Array.isArray(value) && !value.length || isNativeStringType(type4) && typeof value == "string" && !value);
}
__name(isEmptyValue, "isEmptyValue");
function asyncParallelArray(arr, func, callback) {
  var results = [], total = 0, arrLength = arr.length;
  function count(errors) {
    results.push.apply(results, _toConsumableArray(errors || [])), total++, total === arrLength && callback(results);
  }
  __name(count, "count"), arr.forEach(function(a) {
    func(a, count);
  });
}
__name(asyncParallelArray, "asyncParallelArray");
function asyncSerialArray(arr, func, callback) {
  var index2 = 0, arrLength = arr.length;
  function next2(errors) {
    if (errors && errors.length) {
      callback(errors);
      return;
    }
    var original = index2;
    index2 = index2 + 1, original < arrLength ? func(arr[original], next2) : callback([]);
  }
  __name(next2, "next"), next2([]);
}
__name(asyncSerialArray, "asyncSerialArray");
function flattenObjArr(objArr) {
  var ret = [];
  return Object.keys(objArr).forEach(function(k) {
    ret.push.apply(ret, _toConsumableArray(objArr[k] || []));
  }), ret;
}
__name(flattenObjArr, "flattenObjArr");
var AsyncValidationError = /* @__PURE__ */ function(_Error) {
  _inherits(AsyncValidationError2, _Error);
  var _super = _createSuper(AsyncValidationError2);
  function AsyncValidationError2(errors, fields) {
    var _this;
    return _classCallCheck$1(this, AsyncValidationError2), _this = _super.call(this, "Async Validation Error"), _defineProperty$2(_assertThisInitialized(_this), "errors", void 0), _defineProperty$2(_assertThisInitialized(_this), "fields", void 0), _this.errors = errors, _this.fields = fields, _this;
  }
  return __name(AsyncValidationError2, "AsyncValidationError"), _createClass$1(AsyncValidationError2);
}(/* @__PURE__ */ _wrapNativeSuper(Error));
function asyncMap(objArr, option, func, callback, source) {
  if (option.first) {
    var _pending = new Promise(function(resolve, reject) {
      var next2 = /* @__PURE__ */ __name(function(errors) {
        return callback(errors), errors.length ? reject(new AsyncValidationError(errors, convertFieldsError(errors))) : resolve(source);
      }, "next"), flattenArr = flattenObjArr(objArr);
      asyncSerialArray(flattenArr, func, next2);
    });
    return _pending.catch(function(e2) {
      return e2;
    }), _pending;
  }
  var firstFields = option.firstFields === !0 ? Object.keys(objArr) : option.firstFields || [], objArrKeys = Object.keys(objArr), objArrLength = objArrKeys.length, total = 0, results = [], pending = new Promise(function(resolve, reject) {
    var next2 = /* @__PURE__ */ __name(function(errors) {
      if (results.push.apply(results, errors), total++, total === objArrLength)
        return callback(results), results.length ? reject(new AsyncValidationError(results, convertFieldsError(results))) : resolve(source);
    }, "next");
    objArrKeys.length || (callback(results), resolve(source)), objArrKeys.forEach(function(key) {
      var arr = objArr[key];
      firstFields.indexOf(key) !== -1 ? asyncSerialArray(arr, func, next2) : asyncParallelArray(arr, func, next2);
    });
  });
  return pending.catch(function(e2) {
    return e2;
  }), pending;
}
__name(asyncMap, "asyncMap");
function isErrorObj(obj) {
  return !!(obj && obj.message !== void 0);
}
__name(isErrorObj, "isErrorObj");
function getValue(value, path2) {
  for (var v = value, i = 0; i < path2.length; i++) {
    if (v == null)
      return v;
    v = v[path2[i]];
  }
  return v;
}
__name(getValue, "getValue");
function complementError(rule, source) {
  return function(oe) {
    var fieldValue;
    return rule.fullFields ? fieldValue = getValue(source, rule.fullFields) : fieldValue = source[oe.field || rule.fullField], isErrorObj(oe) ? (oe.field = oe.field || rule.fullField, oe.fieldValue = fieldValue, oe) : {
      message: typeof oe == "function" ? oe() : oe,
      fieldValue,
      field: oe.field || rule.fullField
    };
  };
}
__name(complementError, "complementError");
function deepMerge(target, source) {
  if (source) {
    for (var s in source)
      if (source.hasOwnProperty(s)) {
        var value = source[s];
        _typeof$4(value) === "object" && _typeof$4(target[s]) === "object" ? target[s] = _objectSpread2$1(_objectSpread2$1({}, target[s]), value) : target[s] = value;
      }
  }
  return target;
}
__name(deepMerge, "deepMerge");
var ENUM$1 = "enum", enumerable$1 = /* @__PURE__ */ __name(function(rule, value, source, errors, options) {
  rule[ENUM$1] = Array.isArray(rule[ENUM$1]) ? rule[ENUM$1] : [], rule[ENUM$1].indexOf(value) === -1 && errors.push(format$1(options.messages[ENUM$1], rule.fullField, rule[ENUM$1].join(", ")));
}, "enumerable"), pattern$2 = /* @__PURE__ */ __name(function(rule, value, source, errors, options) {
  if (rule.pattern) {
    if (rule.pattern instanceof RegExp)
      rule.pattern.lastIndex = 0, rule.pattern.test(value) || errors.push(format$1(options.messages.pattern.mismatch, rule.fullField, value, rule.pattern));
    else if (typeof rule.pattern == "string") {
      var _pattern = new RegExp(rule.pattern);
      _pattern.test(value) || errors.push(format$1(options.messages.pattern.mismatch, rule.fullField, value, rule.pattern));
    }
  }
}, "pattern"), range = /* @__PURE__ */ __name(function(rule, value, source, errors, options) {
  var len = typeof rule.len == "number", min = typeof rule.min == "number", max = typeof rule.max == "number", spRegexp = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g, val = value, key = null, num = typeof value == "number", str = typeof value == "string", arr = Array.isArray(value);
  if (num ? key = "number" : str ? key = "string" : arr && (key = "array"), !key)
    return !1;
  arr && (val = value.length), str && (val = value.replace(spRegexp, "_").length), len ? val !== rule.len && errors.push(format$1(options.messages[key].len, rule.fullField, rule.len)) : min && !max && val < rule.min ? errors.push(format$1(options.messages[key].min, rule.fullField, rule.min)) : max && !min && val > rule.max ? errors.push(format$1(options.messages[key].max, rule.fullField, rule.max)) : min && max && (val < rule.min || val > rule.max) && errors.push(format$1(options.messages[key].range, rule.fullField, rule.min, rule.max));
}, "range"), required$1 = /* @__PURE__ */ __name(function(rule, value, source, errors, options, type4) {
  rule.required && (!source.hasOwnProperty(rule.field) || isEmptyValue(value, type4 || rule.type)) && errors.push(format$1(options.messages.required, rule.fullField));
}, "required"), urlReg;
const getUrlRegex = /* @__PURE__ */ __name(function() {
  if (urlReg)
    return urlReg;
  var word = "[a-fA-F\\d:]", b = /* @__PURE__ */ __name(function(options) {
    return options && options.includeBoundaries ? "(?:(?<=\\s|^)(?=".concat(word, ")|(?<=").concat(word, ")(?=\\s|$))") : "";
  }, "b"), v4 = "(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)){3}", v6seg = "[a-fA-F\\d]{1,4}", v6List = [
    "(?:".concat(v6seg, ":){7}(?:").concat(v6seg, "|:)"),
    // 1:2:3:4:5:6:7::  1:2:3:4:5:6:7:8
    "(?:".concat(v6seg, ":){6}(?:").concat(v4, "|:").concat(v6seg, "|:)"),
    // 1:2:3:4:5:6::    1:2:3:4:5:6::8   1:2:3:4:5:6::8  1:2:3:4:5:6::
    "(?:".concat(v6seg, ":){5}(?::").concat(v4, "|(?::").concat(v6seg, "){1,2}|:)"),
    // 1:2:3:4:5::      1:2:3:4:5::7:8   1:2:3:4:5::8    1:2:3:4:5::
    "(?:".concat(v6seg, ":){4}(?:(?::").concat(v6seg, "){0,1}:").concat(v4, "|(?::").concat(v6seg, "){1,3}|:)"),
    // 1:2:3:4::        1:2:3:4::6:7:8   1:2:3:4::8      1:2:3:4::
    "(?:".concat(v6seg, ":){3}(?:(?::").concat(v6seg, "){0,2}:").concat(v4, "|(?::").concat(v6seg, "){1,4}|:)"),
    // 1:2:3::          1:2:3::5:6:7:8   1:2:3::8        1:2:3::
    "(?:".concat(v6seg, ":){2}(?:(?::").concat(v6seg, "){0,3}:").concat(v4, "|(?::").concat(v6seg, "){1,5}|:)"),
    // 1:2::            1:2::4:5:6:7:8   1:2::8          1:2::
    "(?:".concat(v6seg, ":){1}(?:(?::").concat(v6seg, "){0,4}:").concat(v4, "|(?::").concat(v6seg, "){1,6}|:)"),
    // 1::              1::3:4:5:6:7:8   1::8            1::
    "(?::(?:(?::".concat(v6seg, "){0,5}:").concat(v4, "|(?::").concat(v6seg, "){1,7}|:))")
    // ::2:3:4:5:6:7:8  ::2:3:4:5:6:7:8  ::8             ::
  ], v6Eth0 = "(?:%[0-9a-zA-Z]{1,})?", v6 = "(?:".concat(v6List.join("|"), ")").concat(v6Eth0), v46Exact = new RegExp("(?:^".concat(v4, "$)|(?:^").concat(v6, "$)")), v4exact = new RegExp("^".concat(v4, "$")), v6exact = new RegExp("^".concat(v6, "$")), ip = /* @__PURE__ */ __name(function(options) {
    return options && options.exact ? v46Exact : new RegExp("(?:".concat(b(options)).concat(v4).concat(b(options), ")|(?:").concat(b(options)).concat(v6).concat(b(options), ")"), "g");
  }, "ip");
  ip.v4 = function(options) {
    return options && options.exact ? v4exact : new RegExp("".concat(b(options)).concat(v4).concat(b(options)), "g");
  }, ip.v6 = function(options) {
    return options && options.exact ? v6exact : new RegExp("".concat(b(options)).concat(v6).concat(b(options)), "g");
  };
  var protocol = "(?:(?:[a-z]+:)?//)", auth = "(?:\\S+(?::\\S*)?@)?", ipv4 = ip.v4().source, ipv6 = ip.v6().source, host = "(?:(?:[a-z\\u00a1-\\uffff0-9][-_]*)*[a-z\\u00a1-\\uffff0-9]+)", domain = "(?:\\.(?:[a-z\\u00a1-\\uffff0-9]-*)*[a-z\\u00a1-\\uffff0-9]+)*", tld = "(?:\\.(?:[a-z\\u00a1-\\uffff]{2,}))", port = "(?::\\d{2,5})?", path2 = '(?:[/?#][^\\s"]*)?', regex = "(?:".concat(protocol, "|www\\.)").concat(auth, "(?:localhost|").concat(ipv4, "|").concat(ipv6, "|").concat(host).concat(domain).concat(tld, ")").concat(port).concat(path2);
  return urlReg = new RegExp("(?:^".concat(regex, "$)"), "i"), urlReg;
}, "getUrlRegex");
var pattern$1 = {
  // http://emailregex.com/
  email: /^(([^<>()\[\]\\.,;:\s@"]+(\.[^<>()\[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}])|(([a-zA-Z\-0-9\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]+\.)+[a-zA-Z\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]{2,}))$/,
  // url: new RegExp(
  //   '^(?!mailto:)(?:(?:http|https|ftp)://|//)(?:\\S+(?::\\S*)?@)?(?:(?:(?:[1-9]\\d?|1\\d\\d|2[01]\\d|22[0-3])(?:\\.(?:1?\\d{1,2}|2[0-4]\\d|25[0-5])){2}(?:\\.(?:[0-9]\\d?|1\\d\\d|2[0-4]\\d|25[0-4]))|(?:(?:[a-z\\u00a1-\\uffff0-9]+-*)*[a-z\\u00a1-\\uffff0-9]+)(?:\\.(?:[a-z\\u00a1-\\uffff0-9]+-*)*[a-z\\u00a1-\\uffff0-9]+)*(?:\\.(?:[a-z\\u00a1-\\uffff]{2,})))|localhost)(?::\\d{2,5})?(?:(/|\\?|#)[^\\s]*)?$',
  //   'i',
  // ),
  hex: /^#?([a-f0-9]{6}|[a-f0-9]{3})$/i
}, types = {
  integer: /* @__PURE__ */ __name(function(value) {
    return types.number(value) && parseInt(value, 10) === value;
  }, "integer"),
  float: /* @__PURE__ */ __name(function(value) {
    return types.number(value) && !types.integer(value);
  }, "float"),
  array: /* @__PURE__ */ __name(function(value) {
    return Array.isArray(value);
  }, "array"),
  regexp: /* @__PURE__ */ __name(function(value) {
    if (value instanceof RegExp)
      return !0;
    try {
      return !!new RegExp(value);
    } catch {
      return !1;
    }
  }, "regexp"),
  date: /* @__PURE__ */ __name(function(value) {
    return typeof value.getTime == "function" && typeof value.getMonth == "function" && typeof value.getYear == "function" && !isNaN(value.getTime());
  }, "date"),
  number: /* @__PURE__ */ __name(function(value) {
    return isNaN(value) ? !1 : typeof value == "number";
  }, "number"),
  object: /* @__PURE__ */ __name(function(value) {
    return _typeof$4(value) === "object" && !types.array(value);
  }, "object"),
  method: /* @__PURE__ */ __name(function(value) {
    return typeof value == "function";
  }, "method"),
  email: /* @__PURE__ */ __name(function(value) {
    return typeof value == "string" && value.length <= 320 && !!value.match(pattern$1.email);
  }, "email"),
  url: /* @__PURE__ */ __name(function(value) {
    return typeof value == "string" && value.length <= 2048 && !!value.match(getUrlRegex());
  }, "url"),
  hex: /* @__PURE__ */ __name(function(value) {
    return typeof value == "string" && !!value.match(pattern$1.hex);
  }, "hex")
}, type$1 = /* @__PURE__ */ __name(function(rule, value, source, errors, options) {
  if (rule.required && value === void 0) {
    required$1(rule, value, source, errors, options);
    return;
  }
  var custom = ["integer", "float", "array", "regexp", "object", "method", "email", "number", "date", "url", "hex"], ruleType = rule.type;
  custom.indexOf(ruleType) > -1 ? types[ruleType](value) || errors.push(format$1(options.messages.types[ruleType], rule.fullField, rule.type)) : ruleType && _typeof$4(value) !== rule.type && errors.push(format$1(options.messages.types[ruleType], rule.fullField, rule.type));
}, "type"), whitespace = /* @__PURE__ */ __name(function(rule, value, source, errors, options) {
  (/^\s+$/.test(value) || value === "") && errors.push(format$1(options.messages.whitespace, rule.fullField));
}, "whitespace");
const rules = {
  required: required$1,
  whitespace,
  type: type$1,
  range,
  enum: enumerable$1,
  pattern: pattern$2
};
var any = /* @__PURE__ */ __name(function(rule, value, callback, source, options) {
  var errors = [], validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
  if (validate) {
    if (isEmptyValue(value) && !rule.required)
      return callback();
    rules.required(rule, value, source, errors, options);
  }
  callback(errors);
}, "any"), array2 = /* @__PURE__ */ __name(function(rule, value, callback, source, options) {
  var errors = [], validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
  if (validate) {
    if (value == null && !rule.required)
      return callback();
    rules.required(rule, value, source, errors, options, "array"), value != null && (rules.type(rule, value, source, errors, options), rules.range(rule, value, source, errors, options));
  }
  callback(errors);
}, "array"), boolean = /* @__PURE__ */ __name(function(rule, value, callback, source, options) {
  var errors = [], validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
  if (validate) {
    if (isEmptyValue(value) && !rule.required)
      return callback();
    rules.required(rule, value, source, errors, options), value !== void 0 && rules.type(rule, value, source, errors, options);
  }
  callback(errors);
}, "boolean"), date2 = /* @__PURE__ */ __name(function(rule, value, callback, source, options) {
  var errors = [], validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
  if (validate) {
    if (isEmptyValue(value, "date") && !rule.required)
      return callback();
    if (rules.required(rule, value, source, errors, options), !isEmptyValue(value, "date")) {
      var dateObject;
      value instanceof Date ? dateObject = value : dateObject = new Date(value), rules.type(rule, dateObject, source, errors, options), dateObject && rules.range(rule, dateObject.getTime(), source, errors, options);
    }
  }
  callback(errors);
}, "date"), ENUM = "enum", enumerable2 = /* @__PURE__ */ __name(function(rule, value, callback, source, options) {
  var errors = [], validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
  if (validate) {
    if (isEmptyValue(value) && !rule.required)
      return callback();
    rules.required(rule, value, source, errors, options), value !== void 0 && rules[ENUM](rule, value, source, errors, options);
  }
  callback(errors);
}, "enumerable"), floatFn = /* @__PURE__ */ __name(function(rule, value, callback, source, options) {
  var errors = [], validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
  if (validate) {
    if (isEmptyValue(value) && !rule.required)
      return callback();
    rules.required(rule, value, source, errors, options), value !== void 0 && (rules.type(rule, value, source, errors, options), rules.range(rule, value, source, errors, options));
  }
  callback(errors);
}, "floatFn"), integer2 = /* @__PURE__ */ __name(function(rule, value, callback, source, options) {
  var errors = [], validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
  if (validate) {
    if (isEmptyValue(value) && !rule.required)
      return callback();
    rules.required(rule, value, source, errors, options), value !== void 0 && (rules.type(rule, value, source, errors, options), rules.range(rule, value, source, errors, options));
  }
  callback(errors);
}, "integer"), method2 = /* @__PURE__ */ __name(function(rule, value, callback, source, options) {
  var errors = [], validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
  if (validate) {
    if (isEmptyValue(value) && !rule.required)
      return callback();
    rules.required(rule, value, source, errors, options), value !== void 0 && rules.type(rule, value, source, errors, options);
  }
  callback(errors);
}, "method"), number2 = /* @__PURE__ */ __name(function(rule, value, callback, source, options) {
  var errors = [], validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
  if (validate) {
    if (value === "" && (value = void 0), isEmptyValue(value) && !rule.required)
      return callback();
    rules.required(rule, value, source, errors, options), value !== void 0 && (rules.type(rule, value, source, errors, options), rules.range(rule, value, source, errors, options));
  }
  callback(errors);
}, "number"), object2 = /* @__PURE__ */ __name(function(rule, value, callback, source, options) {
  var errors = [], validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
  if (validate) {
    if (isEmptyValue(value) && !rule.required)
      return callback();
    rules.required(rule, value, source, errors, options), value !== void 0 && rules.type(rule, value, source, errors, options);
  }
  callback(errors);
}, "object"), pattern2 = /* @__PURE__ */ __name(function(rule, value, callback, source, options) {
  var errors = [], validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
  if (validate) {
    if (isEmptyValue(value, "string") && !rule.required)
      return callback();
    rules.required(rule, value, source, errors, options), isEmptyValue(value, "string") || rules.pattern(rule, value, source, errors, options);
  }
  callback(errors);
}, "pattern"), regexp2 = /* @__PURE__ */ __name(function(rule, value, callback, source, options) {
  var errors = [], validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
  if (validate) {
    if (isEmptyValue(value) && !rule.required)
      return callback();
    rules.required(rule, value, source, errors, options), isEmptyValue(value) || rules.type(rule, value, source, errors, options);
  }
  callback(errors);
}, "regexp"), required2 = /* @__PURE__ */ __name(function(rule, value, callback, source, options) {
  var errors = [], type4 = Array.isArray(value) ? "array" : _typeof$4(value);
  rules.required(rule, value, source, errors, options, type4), callback(errors);
}, "required"), string = /* @__PURE__ */ __name(function(rule, value, callback, source, options) {
  var errors = [], validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
  if (validate) {
    if (isEmptyValue(value, "string") && !rule.required)
      return callback();
    rules.required(rule, value, source, errors, options, "string"), isEmptyValue(value, "string") || (rules.type(rule, value, source, errors, options), rules.range(rule, value, source, errors, options), rules.pattern(rule, value, source, errors, options), rule.whitespace === !0 && rules.whitespace(rule, value, source, errors, options));
  }
  callback(errors);
}, "string"), type2 = /* @__PURE__ */ __name(function(rule, value, callback, source, options) {
  var ruleType = rule.type, errors = [], validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
  if (validate) {
    if (isEmptyValue(value, ruleType) && !rule.required)
      return callback();
    rules.required(rule, value, source, errors, options, ruleType), isEmptyValue(value, ruleType) || rules.type(rule, value, source, errors, options);
  }
  callback(errors);
}, "type");
const validators = {
  string,
  method: method2,
  number: number2,
  boolean,
  regexp: regexp2,
  integer: integer2,
  float: floatFn,
  array: array2,
  object: object2,
  enum: enumerable2,
  pattern: pattern2,
  date: date2,
  url: type2,
  hex: type2,
  email: type2,
  required: required2,
  any
};
var Schema = /* @__PURE__ */ function() {
  function Schema2(descriptor) {
    _classCallCheck$1(this, Schema2), _defineProperty$2(this, "rules", null), _defineProperty$2(this, "_messages", messages), this.define(descriptor);
  }
  return __name(Schema2, "Schema"), _createClass$1(Schema2, [{
    key: "define",
    value: /* @__PURE__ */ __name(function(rules2) {
      var _this = this;
      if (!rules2)
        throw new Error("Cannot configure a schema with no rules");
      if (_typeof$4(rules2) !== "object" || Array.isArray(rules2))
        throw new Error("Rules must be an object");
      this.rules = {}, Object.keys(rules2).forEach(function(name) {
        var item = rules2[name];
        _this.rules[name] = Array.isArray(item) ? item : [item];
      });
    }, "define")
  }, {
    key: "messages",
    value: /* @__PURE__ */ __name(function(_messages) {
      return _messages && (this._messages = deepMerge(newMessages(), _messages)), this._messages;
    }, "messages")
  }, {
    key: "validate",
    value: /* @__PURE__ */ __name(function(source_) {
      var _this2 = this, o2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, oc = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : function() {
      }, source = source_, options = o2, callback = oc;
      if (typeof options == "function" && (callback = options, options = {}), !this.rules || Object.keys(this.rules).length === 0)
        return callback && callback(null, source), Promise.resolve(source);
      function complete(results) {
        var errors = [], fields = {};
        function add(e2) {
          if (Array.isArray(e2)) {
            var _errors;
            errors = (_errors = errors).concat.apply(_errors, _toConsumableArray(e2));
          } else
            errors.push(e2);
        }
        __name(add, "add");
        for (var i = 0; i < results.length; i++)
          add(results[i]);
        errors.length ? (fields = convertFieldsError(errors), callback(errors, fields)) : callback(null, source);
      }
      if (__name(complete, "complete"), options.messages) {
        var messages$1 = this.messages();
        messages$1 === messages && (messages$1 = newMessages()), deepMerge(messages$1, options.messages), options.messages = messages$1;
      } else
        options.messages = this.messages();
      var series = {}, keys2 = options.keys || Object.keys(this.rules);
      keys2.forEach(function(z) {
        var arr = _this2.rules[z], value = source[z];
        arr.forEach(function(r2) {
          var rule = r2;
          typeof rule.transform == "function" && (source === source_ && (source = _objectSpread2$1({}, source)), value = source[z] = rule.transform(value), value != null && (rule.type = rule.type || (Array.isArray(value) ? "array" : _typeof$4(value)))), typeof rule == "function" ? rule = {
            validator: rule
          } : rule = _objectSpread2$1({}, rule), rule.validator = _this2.getValidationMethod(rule), rule.validator && (rule.field = z, rule.fullField = rule.fullField || z, rule.type = _this2.getType(rule), series[z] = series[z] || [], series[z].push({
            rule,
            value,
            source,
            field: z
          }));
        });
      });
      var errorFields = {};
      return asyncMap(series, options, function(data, doIt) {
        var rule = data.rule, deep = (rule.type === "object" || rule.type === "array") && (_typeof$4(rule.fields) === "object" || _typeof$4(rule.defaultField) === "object");
        deep = deep && (rule.required || !rule.required && data.value), rule.field = data.field;
        function addFullField(key, schema) {
          return _objectSpread2$1(_objectSpread2$1({}, schema), {}, {
            fullField: "".concat(rule.fullField, ".").concat(key),
            fullFields: rule.fullFields ? [].concat(_toConsumableArray(rule.fullFields), [key]) : [key]
          });
        }
        __name(addFullField, "addFullField");
        function cb() {
          var e2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [], errorList = Array.isArray(e2) ? e2 : [e2];
          !options.suppressWarning && errorList.length && Schema2.warning("async-validator:", errorList), errorList.length && rule.message !== void 0 && (errorList = [].concat(rule.message));
          var filledErrors = errorList.map(complementError(rule, source));
          if (options.first && filledErrors.length)
            return errorFields[rule.field] = 1, doIt(filledErrors);
          if (!deep)
            doIt(filledErrors);
          else {
            if (rule.required && !data.value)
              return rule.message !== void 0 ? filledErrors = [].concat(rule.message).map(complementError(rule, source)) : options.error && (filledErrors = [options.error(rule, format$1(options.messages.required, rule.field))]), doIt(filledErrors);
            var fieldsSchema = {};
            rule.defaultField && Object.keys(data.value).map(function(key) {
              fieldsSchema[key] = rule.defaultField;
            }), fieldsSchema = _objectSpread2$1(_objectSpread2$1({}, fieldsSchema), data.rule.fields);
            var paredFieldsSchema = {};
            Object.keys(fieldsSchema).forEach(function(field) {
              var fieldSchema = fieldsSchema[field], fieldSchemaList = Array.isArray(fieldSchema) ? fieldSchema : [fieldSchema];
              paredFieldsSchema[field] = fieldSchemaList.map(addFullField.bind(null, field));
            });
            var schema = new Schema2(paredFieldsSchema);
            schema.messages(options.messages), data.rule.options && (data.rule.options.messages = options.messages, data.rule.options.error = options.error), schema.validate(data.value, data.rule.options || options, function(errs) {
              var finalErrors = [];
              filledErrors && filledErrors.length && finalErrors.push.apply(finalErrors, _toConsumableArray(filledErrors)), errs && errs.length && finalErrors.push.apply(finalErrors, _toConsumableArray(errs)), doIt(finalErrors.length ? finalErrors : null);
            });
          }
        }
        __name(cb, "cb");
        var res;
        if (rule.asyncValidator)
          res = rule.asyncValidator(rule, data.value, cb, data.source, options);
        else if (rule.validator) {
          try {
            res = rule.validator(rule, data.value, cb, data.source, options);
          } catch (error) {
            var _console$error, _console;
            (_console$error = (_console = console).error) === null || _console$error === void 0 || _console$error.call(_console, error), options.suppressValidatorError || setTimeout(function() {
              throw error;
            }, 0), cb(error.message);
          }
          res === !0 ? cb() : res === !1 ? cb(typeof rule.message == "function" ? rule.message(rule.fullField || rule.field) : rule.message || "".concat(rule.fullField || rule.field, " fails")) : res instanceof Array ? cb(res) : res instanceof Error && cb(res.message);
        }
        res && res.then && res.then(function() {
          return cb();
        }, function(e2) {
          return cb(e2);
        });
      }, function(results) {
        complete(results);
      }, source);
    }, "validate")
  }, {
    key: "getType",
    value: /* @__PURE__ */ __name(function(rule) {
      if (rule.type === void 0 && rule.pattern instanceof RegExp && (rule.type = "pattern"), typeof rule.validator != "function" && rule.type && !validators.hasOwnProperty(rule.type))
        throw new Error(format$1("Unknown rule type %s", rule.type));
      return rule.type || "string";
    }, "getType")
  }, {
    key: "getValidationMethod",
    value: /* @__PURE__ */ __name(function(rule) {
      if (typeof rule.validator == "function")
        return rule.validator;
      var keys2 = Object.keys(rule), messageIndex = keys2.indexOf("message");
      return messageIndex !== -1 && keys2.splice(messageIndex, 1), keys2.length === 1 && keys2[0] === "required" ? validators.required : validators[this.getType(rule)] || void 0;
    }, "getValidationMethod")
  }]), Schema2;
}();
_defineProperty$2(Schema, "register", /* @__PURE__ */ __name(function(type4, validator) {
  if (typeof validator != "function")
    throw new Error("Cannot register a validator by type, validator is not a function");
  validators[type4] = validator;
}, "register"));
_defineProperty$2(Schema, "warning", warning);
_defineProperty$2(Schema, "messages", messages);
_defineProperty$2(Schema, "validators", validators);
var typeTemplate$1 = "'${name}' is not a valid ${type}", defaultValidateMessages = {
  default: "Validation error on field '${name}'",
  required: "'${name}' is required",
  enum: "'${name}' must be one of [${enum}]",
  whitespace: "'${name}' cannot be empty",
  date: {
    format: "'${name}' is invalid for format date",
    parse: "'${name}' could not be parsed as date",
    invalid: "'${name}' is invalid date"
  },
  types: {
    string: typeTemplate$1,
    method: typeTemplate$1,
    array: typeTemplate$1,
    object: typeTemplate$1,
    number: typeTemplate$1,
    date: typeTemplate$1,
    boolean: typeTemplate$1,
    integer: typeTemplate$1,
    float: typeTemplate$1,
    regexp: typeTemplate$1,
    email: typeTemplate$1,
    url: typeTemplate$1,
    hex: typeTemplate$1
  },
  string: {
    len: "'${name}' must be exactly ${len} characters",
    min: "'${name}' must be at least ${min} characters",
    max: "'${name}' cannot be longer than ${max} characters",
    range: "'${name}' must be between ${min} and ${max} characters"
  },
  number: {
    len: "'${name}' must equal ${len}",
    min: "'${name}' cannot be less than ${min}",
    max: "'${name}' cannot be greater than ${max}",
    range: "'${name}' must be between ${min} and ${max}"
  },
  array: {
    len: "'${name}' must be exactly ${len} in length",
    min: "'${name}' cannot be less than ${min} in length",
    max: "'${name}' cannot be greater than ${max} in length",
    range: "'${name}' must be between ${min} and ${max} in length"
  },
  pattern: {
    mismatch: "'${name}' does not match pattern ${pattern}"
  }
}, AsyncValidator = Schema;
function replaceMessage(template, kv) {
  return template.replace(/\\?\$\{\w+\}/g, function(str) {
    if (str.startsWith("\\"))
      return str.slice(1);
    var key = str.slice(2, -1);
    return kv[key];
  });
}
__name(replaceMessage, "replaceMessage");
var CODE_LOGIC_ERROR = "CODE_LOGIC_ERROR";
function validateRule(_x, _x2, _x3, _x4, _x5) {
  return _validateRule.apply(this, arguments);
}
__name(validateRule, "validateRule");
function _validateRule() {
  return _validateRule = _asyncToGenerator(/* @__PURE__ */ _regeneratorRuntime().mark(/* @__PURE__ */ __name(function _callee2(name, value, rule, options, messageVariables) {
    var cloneRule, originValidator, subRuleField, validator, messages2, result, subResults, kv, fillVariableResult;
    return _regeneratorRuntime().wrap(/* @__PURE__ */ __name(function(_context2) {
      for (; ; ) switch (_context2.prev = _context2.next) {
        case 0:
          return cloneRule = _objectSpread2$1({}, rule), delete cloneRule.ruleIndex, AsyncValidator.warning = function() {
          }, cloneRule.validator && (originValidator = cloneRule.validator, cloneRule.validator = function() {
            try {
              return originValidator.apply(void 0, arguments);
            } catch (error) {
              return console.error(error), Promise.reject(CODE_LOGIC_ERROR);
            }
          }), subRuleField = null, cloneRule && cloneRule.type === "array" && cloneRule.defaultField && (subRuleField = cloneRule.defaultField, delete cloneRule.defaultField), validator = new AsyncValidator(_defineProperty$2({}, name, [cloneRule])), messages2 = merge$1(defaultValidateMessages, options.validateMessages), validator.messages(messages2), result = [], _context2.prev = 10, _context2.next = 13, Promise.resolve(validator.validate(_defineProperty$2({}, name, value), _objectSpread2$1({}, options)));
        case 13:
          _context2.next = 18;
          break;
        case 15:
          _context2.prev = 15, _context2.t0 = _context2.catch(10), _context2.t0.errors && (result = _context2.t0.errors.map(function(_ref4, index2) {
            var message = _ref4.message, mergedMessage = message === CODE_LOGIC_ERROR ? messages2.default : message;
            return /* @__PURE__ */ React.isValidElement(mergedMessage) ? (
              // Wrap ReactNode with `key`
              /* @__PURE__ */ React.cloneElement(mergedMessage, {
                key: "error_".concat(index2)
              })
            ) : mergedMessage;
          }));
        case 18:
          if (!(!result.length && subRuleField)) {
            _context2.next = 23;
            break;
          }
          return _context2.next = 21, Promise.all(value.map(function(subValue, i) {
            return validateRule("".concat(name, ".").concat(i), subValue, subRuleField, options, messageVariables);
          }));
        case 21:
          return subResults = _context2.sent, _context2.abrupt("return", subResults.reduce(function(prev2, errors) {
            return [].concat(_toConsumableArray(prev2), _toConsumableArray(errors));
          }, []));
        case 23:
          return kv = _objectSpread2$1(_objectSpread2$1({}, rule), {}, {
            name,
            enum: (rule.enum || []).join(", ")
          }, messageVariables), fillVariableResult = result.map(function(error) {
            return typeof error == "string" ? replaceMessage(error, kv) : error;
          }), _context2.abrupt("return", fillVariableResult);
        case 26:
        case "end":
          return _context2.stop();
      }
    }, "_callee2$"), _callee2, null, [[10, 15]]);
  }, "_callee2"))), _validateRule.apply(this, arguments);
}
__name(_validateRule, "_validateRule");
function validateRules(namePath, value, rules2, options, validateFirst, messageVariables) {
  var name = namePath.join("."), filledRules = rules2.map(function(currentRule, ruleIndex) {
    var originValidatorFunc = currentRule.validator, cloneRule = _objectSpread2$1(_objectSpread2$1({}, currentRule), {}, {
      ruleIndex
    });
    return originValidatorFunc && (cloneRule.validator = function(rule, val, callback) {
      var hasPromise = !1, wrappedCallback = /* @__PURE__ */ __name(function() {
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++)
          args[_key] = arguments[_key];
        Promise.resolve().then(function() {
          warningOnce(!hasPromise, "Your validator function has already return a promise. `callback` will be ignored."), hasPromise || callback.apply(void 0, args);
        });
      }, "wrappedCallback"), promise = originValidatorFunc(rule, val, wrappedCallback);
      hasPromise = promise && typeof promise.then == "function" && typeof promise.catch == "function", warningOnce(hasPromise, "`callback` is deprecated. Please return a promise instead."), hasPromise && promise.then(function() {
        callback();
      }).catch(function(err) {
        callback(err || " ");
      });
    }), cloneRule;
  }).sort(function(_ref, _ref2) {
    var w1 = _ref.warningOnly, i1 = _ref.ruleIndex, w2 = _ref2.warningOnly, i2 = _ref2.ruleIndex;
    return !!w1 == !!w2 ? i1 - i2 : w1 ? 1 : -1;
  }), summaryPromise;
  if (validateFirst === !0)
    summaryPromise = new Promise(/* @__PURE__ */ function() {
      var _ref3 = _asyncToGenerator(/* @__PURE__ */ _regeneratorRuntime().mark(/* @__PURE__ */ __name(function _callee(resolve, reject) {
        var i, rule, errors;
        return _regeneratorRuntime().wrap(/* @__PURE__ */ __name(function(_context) {
          for (; ; ) switch (_context.prev = _context.next) {
            case 0:
              i = 0;
            case 1:
              if (!(i < filledRules.length)) {
                _context.next = 12;
                break;
              }
              return rule = filledRules[i], _context.next = 5, validateRule(name, value, rule, options, messageVariables);
            case 5:
              if (errors = _context.sent, !errors.length) {
                _context.next = 9;
                break;
              }
              return reject([{
                errors,
                rule
              }]), _context.abrupt("return");
            case 9:
              i += 1, _context.next = 1;
              break;
            case 12:
              resolve([]);
            case 13:
            case "end":
              return _context.stop();
          }
        }, "_callee$"), _callee);
      }, "_callee")));
      return function(_x6, _x7) {
        return _ref3.apply(this, arguments);
      };
    }());
  else {
    var rulePromises = filledRules.map(function(rule) {
      return validateRule(name, value, rule, options, messageVariables).then(function(errors) {
        return {
          errors,
          rule
        };
      });
    });
    summaryPromise = (validateFirst ? finishOnFirstFailed(rulePromises) : finishOnAllFailed(rulePromises)).then(function(errors) {
      return Promise.reject(errors);
    });
  }
  return summaryPromise.catch(function(e2) {
    return e2;
  }), summaryPromise;
}
__name(validateRules, "validateRules");
function finishOnAllFailed(_x8) {
  return _finishOnAllFailed.apply(this, arguments);
}
__name(finishOnAllFailed, "finishOnAllFailed");
function _finishOnAllFailed() {
  return _finishOnAllFailed = _asyncToGenerator(/* @__PURE__ */ _regeneratorRuntime().mark(/* @__PURE__ */ __name(function _callee3(rulePromises) {
    return _regeneratorRuntime().wrap(/* @__PURE__ */ __name(function(_context3) {
      for (; ; ) switch (_context3.prev = _context3.next) {
        case 0:
          return _context3.abrupt("return", Promise.all(rulePromises).then(function(errorsList) {
            var _ref5, errors = (_ref5 = []).concat.apply(_ref5, _toConsumableArray(errorsList));
            return errors;
          }));
        case 1:
        case "end":
          return _context3.stop();
      }
    }, "_callee3$"), _callee3);
  }, "_callee3"))), _finishOnAllFailed.apply(this, arguments);
}
__name(_finishOnAllFailed, "_finishOnAllFailed");
function finishOnFirstFailed(_x9) {
  return _finishOnFirstFailed.apply(this, arguments);
}
__name(finishOnFirstFailed, "finishOnFirstFailed");
function _finishOnFirstFailed() {
  return _finishOnFirstFailed = _asyncToGenerator(/* @__PURE__ */ _regeneratorRuntime().mark(/* @__PURE__ */ __name(function _callee4(rulePromises) {
    var count;
    return _regeneratorRuntime().wrap(/* @__PURE__ */ __name(function(_context4) {
      for (; ; ) switch (_context4.prev = _context4.next) {
        case 0:
          return count = 0, _context4.abrupt("return", new Promise(function(resolve) {
            rulePromises.forEach(function(promise) {
              promise.then(function(ruleError) {
                ruleError.errors.length && resolve([ruleError]), count += 1, count === rulePromises.length && resolve([]);
              });
            });
          }));
        case 2:
        case "end":
          return _context4.stop();
      }
    }, "_callee4$"), _callee4);
  }, "_callee4"))), _finishOnFirstFailed.apply(this, arguments);
}
__name(_finishOnFirstFailed, "_finishOnFirstFailed");
function getNamePath(path2) {
  return toArray$6(path2);
}
__name(getNamePath, "getNamePath");
function cloneByNamePathList(store, namePathList) {
  var newStore = {};
  return namePathList.forEach(function(namePath) {
    var value = get(store, namePath);
    newStore = set(newStore, namePath, value);
  }), newStore;
}
__name(cloneByNamePathList, "cloneByNamePathList");
function containsNamePath(namePathList, namePath) {
  var partialMatch = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !1;
  return namePathList && namePathList.some(function(path2) {
    return matchNamePath(namePath, path2, partialMatch);
  });
}
__name(containsNamePath, "containsNamePath");
function matchNamePath(namePath, subNamePath) {
  var partialMatch = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !1;
  return !namePath || !subNamePath || !partialMatch && namePath.length !== subNamePath.length ? !1 : subNamePath.every(function(nameUnit, i) {
    return namePath[i] === nameUnit;
  });
}
__name(matchNamePath, "matchNamePath");
function isSimilar(source, target) {
  if (source === target)
    return !0;
  if (!source && target || source && !target || !source || !target || _typeof$4(source) !== "object" || _typeof$4(target) !== "object")
    return !1;
  var sourceKeys = Object.keys(source), targetKeys = Object.keys(target), keys2 = new Set([].concat(sourceKeys, targetKeys));
  return _toConsumableArray(keys2).every(function(key) {
    var sourceValue = source[key], targetValue = target[key];
    return typeof sourceValue == "function" && typeof targetValue == "function" ? !0 : sourceValue === targetValue;
  });
}
__name(isSimilar, "isSimilar");
function defaultGetValueFromEvent(valuePropName) {
  var event = arguments.length <= 1 ? void 0 : arguments[1];
  return event && event.target && _typeof$4(event.target) === "object" && valuePropName in event.target ? event.target[valuePropName] : event;
}
__name(defaultGetValueFromEvent, "defaultGetValueFromEvent");
function move(array4, moveIndex, toIndex) {
  var length2 = array4.length;
  if (moveIndex < 0 || moveIndex >= length2 || toIndex < 0 || toIndex >= length2)
    return array4;
  var item = array4[moveIndex], diff = moveIndex - toIndex;
  return diff > 0 ? [].concat(_toConsumableArray(array4.slice(0, toIndex)), [item], _toConsumableArray(array4.slice(toIndex, moveIndex)), _toConsumableArray(array4.slice(moveIndex + 1, length2))) : diff < 0 ? [].concat(_toConsumableArray(array4.slice(0, moveIndex)), _toConsumableArray(array4.slice(moveIndex + 1, toIndex + 1)), [item], _toConsumableArray(array4.slice(toIndex + 1, length2))) : array4;
}
__name(move, "move");
var _excluded$M = ["name"], EMPTY_ERRORS = [];
function requireUpdate(shouldUpdate, prev2, next2, prevValue, nextValue, info) {
  return typeof shouldUpdate == "function" ? shouldUpdate(prev2, next2, "source" in info ? {
    source: info.source
  } : {}) : prevValue !== nextValue;
}
__name(requireUpdate, "requireUpdate");
var Field = /* @__PURE__ */ function(_React$Component) {
  _inherits(Field2, _React$Component);
  var _super = _createSuper(Field2);
  function Field2(props) {
    var _this;
    if (_classCallCheck$1(this, Field2), _this = _super.call(this, props), _defineProperty$2(_assertThisInitialized(_this), "state", {
      resetCount: 0
    }), _defineProperty$2(_assertThisInitialized(_this), "cancelRegisterFunc", null), _defineProperty$2(_assertThisInitialized(_this), "mounted", !1), _defineProperty$2(_assertThisInitialized(_this), "touched", !1), _defineProperty$2(_assertThisInitialized(_this), "dirty", !1), _defineProperty$2(_assertThisInitialized(_this), "validatePromise", void 0), _defineProperty$2(_assertThisInitialized(_this), "prevValidating", void 0), _defineProperty$2(_assertThisInitialized(_this), "errors", EMPTY_ERRORS), _defineProperty$2(_assertThisInitialized(_this), "warnings", EMPTY_ERRORS), _defineProperty$2(_assertThisInitialized(_this), "cancelRegister", function() {
      var _this$props = _this.props, preserve2 = _this$props.preserve, isListField = _this$props.isListField, name = _this$props.name;
      _this.cancelRegisterFunc && _this.cancelRegisterFunc(isListField, preserve2, getNamePath(name)), _this.cancelRegisterFunc = null;
    }), _defineProperty$2(_assertThisInitialized(_this), "getNamePath", function() {
      var _this$props2 = _this.props, name = _this$props2.name, fieldContext = _this$props2.fieldContext, _fieldContext$prefixN = fieldContext.prefixName, prefixName = _fieldContext$prefixN === void 0 ? [] : _fieldContext$prefixN;
      return name !== void 0 ? [].concat(_toConsumableArray(prefixName), _toConsumableArray(name)) : [];
    }), _defineProperty$2(_assertThisInitialized(_this), "getRules", function() {
      var _this$props3 = _this.props, _this$props3$rules = _this$props3.rules, rules2 = _this$props3$rules === void 0 ? [] : _this$props3$rules, fieldContext = _this$props3.fieldContext;
      return rules2.map(function(rule) {
        return typeof rule == "function" ? rule(fieldContext) : rule;
      });
    }), _defineProperty$2(_assertThisInitialized(_this), "refresh", function() {
      _this.mounted && _this.setState(function(_ref) {
        var resetCount = _ref.resetCount;
        return {
          resetCount: resetCount + 1
        };
      });
    }), _defineProperty$2(_assertThisInitialized(_this), "metaCache", null), _defineProperty$2(_assertThisInitialized(_this), "triggerMetaEvent", function(destroy) {
      var onMetaChange = _this.props.onMetaChange;
      if (onMetaChange) {
        var _meta = _objectSpread2$1(_objectSpread2$1({}, _this.getMeta()), {}, {
          destroy
        });
        isEqual(_this.metaCache, _meta) || onMetaChange(_meta), _this.metaCache = _meta;
      } else
        _this.metaCache = null;
    }), _defineProperty$2(_assertThisInitialized(_this), "onStoreChange", function(prevStore, namePathList, info) {
      var _this$props4 = _this.props, shouldUpdate = _this$props4.shouldUpdate, _this$props4$dependen = _this$props4.dependencies, dependencies = _this$props4$dependen === void 0 ? [] : _this$props4$dependen, onReset = _this$props4.onReset, store = info.store, namePath = _this.getNamePath(), prevValue = _this.getValue(prevStore), curValue = _this.getValue(store), namePathMatch = namePathList && containsNamePath(namePathList, namePath);
      switch (info.type === "valueUpdate" && info.source === "external" && !isEqual(prevValue, curValue) && (_this.touched = !0, _this.dirty = !0, _this.validatePromise = null, _this.errors = EMPTY_ERRORS, _this.warnings = EMPTY_ERRORS, _this.triggerMetaEvent()), info.type) {
        case "reset":
          if (!namePathList || namePathMatch) {
            _this.touched = !1, _this.dirty = !1, _this.validatePromise = void 0, _this.errors = EMPTY_ERRORS, _this.warnings = EMPTY_ERRORS, _this.triggerMetaEvent(), onReset == null || onReset(), _this.refresh();
            return;
          }
          break;
        case "remove": {
          if (shouldUpdate && requireUpdate(shouldUpdate, prevStore, store, prevValue, curValue, info)) {
            _this.reRender();
            return;
          }
          break;
        }
        case "setField": {
          var data = info.data;
          if (namePathMatch) {
            "touched" in data && (_this.touched = data.touched), "validating" in data && !("originRCField" in data) && (_this.validatePromise = data.validating ? Promise.resolve([]) : null), "errors" in data && (_this.errors = data.errors || EMPTY_ERRORS), "warnings" in data && (_this.warnings = data.warnings || EMPTY_ERRORS), _this.dirty = !0, _this.triggerMetaEvent(), _this.reRender();
            return;
          } else if ("value" in data && containsNamePath(namePathList, namePath, !0)) {
            _this.reRender();
            return;
          }
          if (shouldUpdate && !namePath.length && requireUpdate(shouldUpdate, prevStore, store, prevValue, curValue, info)) {
            _this.reRender();
            return;
          }
          break;
        }
        case "dependenciesUpdate": {
          var dependencyList = dependencies.map(getNamePath);
          if (dependencyList.some(function(dependency) {
            return containsNamePath(info.relatedFields, dependency);
          })) {
            _this.reRender();
            return;
          }
          break;
        }
        default:
          if (namePathMatch || (!dependencies.length || namePath.length || shouldUpdate) && requireUpdate(shouldUpdate, prevStore, store, prevValue, curValue, info)) {
            _this.reRender();
            return;
          }
          break;
      }
      shouldUpdate === !0 && _this.reRender();
    }), _defineProperty$2(_assertThisInitialized(_this), "validateRules", function(options) {
      var namePath = _this.getNamePath(), currentValue = _this.getValue(), _ref2 = options || {}, triggerName = _ref2.triggerName, _ref2$validateOnly = _ref2.validateOnly, validateOnly = _ref2$validateOnly === void 0 ? !1 : _ref2$validateOnly, rootPromise = Promise.resolve().then(/* @__PURE__ */ _asyncToGenerator(/* @__PURE__ */ _regeneratorRuntime().mark(/* @__PURE__ */ __name(function _callee() {
        var _this$props5, _this$props5$validate, validateFirst, messageVariables, validateDebounce, filteredRules, promise;
        return _regeneratorRuntime().wrap(/* @__PURE__ */ __name(function(_context) {
          for (; ; ) switch (_context.prev = _context.next) {
            case 0:
              if (_this.mounted) {
                _context.next = 2;
                break;
              }
              return _context.abrupt("return", []);
            case 2:
              if (_this$props5 = _this.props, _this$props5$validate = _this$props5.validateFirst, validateFirst = _this$props5$validate === void 0 ? !1 : _this$props5$validate, messageVariables = _this$props5.messageVariables, validateDebounce = _this$props5.validateDebounce, filteredRules = _this.getRules(), triggerName && (filteredRules = filteredRules.filter(function(rule) {
                return rule;
              }).filter(function(rule) {
                var validateTrigger = rule.validateTrigger;
                if (!validateTrigger)
                  return !0;
                var triggerList = toArray$6(validateTrigger);
                return triggerList.includes(triggerName);
              })), !(validateDebounce && triggerName)) {
                _context.next = 10;
                break;
              }
              return _context.next = 8, new Promise(function(resolve) {
                setTimeout(resolve, validateDebounce);
              });
            case 8:
              if (_this.validatePromise === rootPromise) {
                _context.next = 10;
                break;
              }
              return _context.abrupt("return", []);
            case 10:
              return promise = validateRules(namePath, currentValue, filteredRules, options, validateFirst, messageVariables), promise.catch(function(e2) {
                return e2;
              }).then(function() {
                var ruleErrors = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : EMPTY_ERRORS;
                if (_this.validatePromise === rootPromise) {
                  var _ruleErrors$forEach;
                  _this.validatePromise = null;
                  var nextErrors = [], nextWarnings = [];
                  (_ruleErrors$forEach = ruleErrors.forEach) === null || _ruleErrors$forEach === void 0 || _ruleErrors$forEach.call(ruleErrors, function(_ref4) {
                    var warningOnly = _ref4.rule.warningOnly, _ref4$errors = _ref4.errors, errors = _ref4$errors === void 0 ? EMPTY_ERRORS : _ref4$errors;
                    warningOnly ? nextWarnings.push.apply(nextWarnings, _toConsumableArray(errors)) : nextErrors.push.apply(nextErrors, _toConsumableArray(errors));
                  }), _this.errors = nextErrors, _this.warnings = nextWarnings, _this.triggerMetaEvent(), _this.reRender();
                }
              }), _context.abrupt("return", promise);
            case 13:
            case "end":
              return _context.stop();
          }
        }, "_callee$"), _callee);
      }, "_callee"))));
      return validateOnly || (_this.validatePromise = rootPromise, _this.dirty = !0, _this.errors = EMPTY_ERRORS, _this.warnings = EMPTY_ERRORS, _this.triggerMetaEvent(), _this.reRender()), rootPromise;
    }), _defineProperty$2(_assertThisInitialized(_this), "isFieldValidating", function() {
      return !!_this.validatePromise;
    }), _defineProperty$2(_assertThisInitialized(_this), "isFieldTouched", function() {
      return _this.touched;
    }), _defineProperty$2(_assertThisInitialized(_this), "isFieldDirty", function() {
      if (_this.dirty || _this.props.initialValue !== void 0)
        return !0;
      var fieldContext = _this.props.fieldContext, _fieldContext$getInte = fieldContext.getInternalHooks(HOOK_MARK), getInitialValue = _fieldContext$getInte.getInitialValue;
      return getInitialValue(_this.getNamePath()) !== void 0;
    }), _defineProperty$2(_assertThisInitialized(_this), "getErrors", function() {
      return _this.errors;
    }), _defineProperty$2(_assertThisInitialized(_this), "getWarnings", function() {
      return _this.warnings;
    }), _defineProperty$2(_assertThisInitialized(_this), "isListField", function() {
      return _this.props.isListField;
    }), _defineProperty$2(_assertThisInitialized(_this), "isList", function() {
      return _this.props.isList;
    }), _defineProperty$2(_assertThisInitialized(_this), "isPreserve", function() {
      return _this.props.preserve;
    }), _defineProperty$2(_assertThisInitialized(_this), "getMeta", function() {
      _this.prevValidating = _this.isFieldValidating();
      var meta = {
        touched: _this.isFieldTouched(),
        validating: _this.prevValidating,
        errors: _this.errors,
        warnings: _this.warnings,
        name: _this.getNamePath(),
        validated: _this.validatePromise === null
      };
      return meta;
    }), _defineProperty$2(_assertThisInitialized(_this), "getOnlyChild", function(children) {
      if (typeof children == "function") {
        var _meta2 = _this.getMeta();
        return _objectSpread2$1(_objectSpread2$1({}, _this.getOnlyChild(children(_this.getControlled(), _meta2, _this.props.fieldContext))), {}, {
          isFunction: !0
        });
      }
      var childList = toArray$7(children);
      return childList.length !== 1 || !/* @__PURE__ */ React.isValidElement(childList[0]) ? {
        child: childList,
        isFunction: !1
      } : {
        child: childList[0],
        isFunction: !1
      };
    }), _defineProperty$2(_assertThisInitialized(_this), "getValue", function(store) {
      var getFieldsValue = _this.props.fieldContext.getFieldsValue, namePath = _this.getNamePath();
      return get(store || getFieldsValue(!0), namePath);
    }), _defineProperty$2(_assertThisInitialized(_this), "getControlled", function() {
      var childProps = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, _this$props6 = _this.props, name = _this$props6.name, trigger = _this$props6.trigger, validateTrigger = _this$props6.validateTrigger, getValueFromEvent = _this$props6.getValueFromEvent, normalize2 = _this$props6.normalize, valuePropName = _this$props6.valuePropName, getValueProps = _this$props6.getValueProps, fieldContext = _this$props6.fieldContext, mergedValidateTrigger = validateTrigger !== void 0 ? validateTrigger : fieldContext.validateTrigger, namePath = _this.getNamePath(), getInternalHooks3 = fieldContext.getInternalHooks, getFieldsValue = fieldContext.getFieldsValue, _getInternalHooks = getInternalHooks3(HOOK_MARK), dispatch = _getInternalHooks.dispatch, value = _this.getValue(), mergedGetValueProps = getValueProps || function(val) {
        return _defineProperty$2({}, valuePropName, val);
      }, originTriggerFunc = childProps[trigger], valueProps = name !== void 0 ? mergedGetValueProps(value) : {};
      process.env.NODE_ENV !== "production" && valueProps && Object.keys(valueProps).forEach(function(key) {
        warningOnce(typeof valueProps[key] != "function", "It's not recommended to generate dynamic function prop by `getValueProps`. Please pass it to child component directly (prop: ".concat(key, ")"));
      });
      var control = _objectSpread2$1(_objectSpread2$1({}, childProps), valueProps);
      control[trigger] = function() {
        _this.touched = !0, _this.dirty = !0, _this.triggerMetaEvent();
        for (var newValue, _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++)
          args[_key] = arguments[_key];
        getValueFromEvent ? newValue = getValueFromEvent.apply(void 0, args) : newValue = defaultGetValueFromEvent.apply(void 0, [valuePropName].concat(args)), normalize2 && (newValue = normalize2(newValue, value, getFieldsValue(!0))), newValue !== value && dispatch({
          type: "updateValue",
          namePath,
          value: newValue
        }), originTriggerFunc && originTriggerFunc.apply(void 0, args);
      };
      var validateTriggerList = toArray$6(mergedValidateTrigger || []);
      return validateTriggerList.forEach(function(triggerName) {
        var originTrigger = control[triggerName];
        control[triggerName] = function() {
          originTrigger && originTrigger.apply(void 0, arguments);
          var rules2 = _this.props.rules;
          rules2 && rules2.length && dispatch({
            type: "validateField",
            namePath,
            triggerName
          });
        };
      }), control;
    }), props.fieldContext) {
      var getInternalHooks2 = props.fieldContext.getInternalHooks, _getInternalHooks2 = getInternalHooks2(HOOK_MARK), initEntityValue = _getInternalHooks2.initEntityValue;
      initEntityValue(_assertThisInitialized(_this));
    }
    return _this;
  }
  return __name(Field2, "Field"), _createClass$1(Field2, [{
    key: "componentDidMount",
    value: /* @__PURE__ */ __name(function() {
      var _this$props7 = this.props, shouldUpdate = _this$props7.shouldUpdate, fieldContext = _this$props7.fieldContext;
      if (this.mounted = !0, fieldContext) {
        var getInternalHooks2 = fieldContext.getInternalHooks, _getInternalHooks3 = getInternalHooks2(HOOK_MARK), registerField = _getInternalHooks3.registerField;
        this.cancelRegisterFunc = registerField(this);
      }
      shouldUpdate === !0 && this.reRender();
    }, "componentDidMount")
  }, {
    key: "componentWillUnmount",
    value: /* @__PURE__ */ __name(function() {
      this.cancelRegister(), this.triggerMetaEvent(!0), this.mounted = !1;
    }, "componentWillUnmount")
  }, {
    key: "reRender",
    value: /* @__PURE__ */ __name(function() {
      this.mounted && this.forceUpdate();
    }, "reRender")
  }, {
    key: "render",
    value: /* @__PURE__ */ __name(function() {
      var resetCount = this.state.resetCount, children = this.props.children, _this$getOnlyChild = this.getOnlyChild(children), child = _this$getOnlyChild.child, isFunction = _this$getOnlyChild.isFunction, returnChildNode;
      return isFunction ? returnChildNode = child : /* @__PURE__ */ React.isValidElement(child) ? returnChildNode = /* @__PURE__ */ React.cloneElement(child, this.getControlled(child.props)) : (warningOnce(!child, "`children` of Field is not validate ReactElement."), returnChildNode = child), /* @__PURE__ */ React.createElement(React.Fragment, {
        key: resetCount
      }, returnChildNode);
    }, "render")
  }]), Field2;
}(React.Component);
_defineProperty$2(Field, "contextType", Context);
_defineProperty$2(Field, "defaultProps", {
  trigger: "onChange",
  valuePropName: "value"
});
function WrapperField(_ref6) {
  var _restProps$isListFiel, name = _ref6.name, restProps = _objectWithoutProperties(_ref6, _excluded$M), fieldContext = React.useContext(Context), listContext = React.useContext(ListContext), namePath = name !== void 0 ? getNamePath(name) : void 0, isMergedListField = (_restProps$isListFiel = restProps.isListField) !== null && _restProps$isListFiel !== void 0 ? _restProps$isListFiel : !!listContext, key = "keep";
  return isMergedListField || (key = "_".concat((namePath || []).join("_"))), process.env.NODE_ENV !== "production" && restProps.preserve === !1 && isMergedListField && namePath.length <= 1 && warningOnce(!1, "`preserve` should not apply on Form.List fields."), /* @__PURE__ */ React.createElement(Field, _extends({
    key,
    name: namePath,
    isListField: isMergedListField
  }, restProps, {
    fieldContext
  }));
}
__name(WrapperField, "WrapperField");
function List$1(_ref) {
  var name = _ref.name, initialValue = _ref.initialValue, children = _ref.children, rules2 = _ref.rules, validateTrigger = _ref.validateTrigger, isListField = _ref.isListField, context = React.useContext(Context), wrapperListContext = React.useContext(ListContext), keyRef = React.useRef({
    keys: [],
    id: 0
  }), keyManager = keyRef.current, prefixName = React.useMemo(function() {
    var parentPrefixName = getNamePath(context.prefixName) || [];
    return [].concat(_toConsumableArray(parentPrefixName), _toConsumableArray(getNamePath(name)));
  }, [context.prefixName, name]), fieldContext = React.useMemo(function() {
    return _objectSpread2$1(_objectSpread2$1({}, context), {}, {
      prefixName
    });
  }, [context, prefixName]), listContext = React.useMemo(function() {
    return {
      getKey: /* @__PURE__ */ __name(function(namePath) {
        var len = prefixName.length, pathName = namePath[len];
        return [keyManager.keys[pathName], namePath.slice(len + 1)];
      }, "getKey")
    };
  }, [prefixName]);
  if (typeof children != "function")
    return warningOnce(!1, "Form.List only accepts function as children."), null;
  var shouldUpdate = /* @__PURE__ */ __name(function(prevValue, nextValue, _ref2) {
    var source = _ref2.source;
    return source === "internal" ? !1 : prevValue !== nextValue;
  }, "shouldUpdate");
  return /* @__PURE__ */ React.createElement(ListContext.Provider, {
    value: listContext
  }, /* @__PURE__ */ React.createElement(Context.Provider, {
    value: fieldContext
  }, /* @__PURE__ */ React.createElement(WrapperField, {
    name: [],
    shouldUpdate,
    rules: rules2,
    validateTrigger,
    initialValue,
    isList: !0,
    isListField: isListField ?? !!wrapperListContext
  }, function(_ref3, meta) {
    var _ref3$value = _ref3.value, value = _ref3$value === void 0 ? [] : _ref3$value, onChange = _ref3.onChange, getFieldValue = context.getFieldValue, getNewValue = /* @__PURE__ */ __name(function() {
      var values = getFieldValue(prefixName || []);
      return values || [];
    }, "getNewValue"), operations = {
      add: /* @__PURE__ */ __name(function(defaultValue, index2) {
        var newValue = getNewValue();
        index2 >= 0 && index2 <= newValue.length ? (keyManager.keys = [].concat(_toConsumableArray(keyManager.keys.slice(0, index2)), [keyManager.id], _toConsumableArray(keyManager.keys.slice(index2))), onChange([].concat(_toConsumableArray(newValue.slice(0, index2)), [defaultValue], _toConsumableArray(newValue.slice(index2))))) : (process.env.NODE_ENV !== "production" && (index2 < 0 || index2 > newValue.length) && warningOnce(!1, "The second parameter of the add function should be a valid positive number."), keyManager.keys = [].concat(_toConsumableArray(keyManager.keys), [keyManager.id]), onChange([].concat(_toConsumableArray(newValue), [defaultValue]))), keyManager.id += 1;
      }, "add"),
      remove: /* @__PURE__ */ __name(function(index2) {
        var newValue = getNewValue(), indexSet = new Set(Array.isArray(index2) ? index2 : [index2]);
        indexSet.size <= 0 || (keyManager.keys = keyManager.keys.filter(function(_2, keysIndex) {
          return !indexSet.has(keysIndex);
        }), onChange(newValue.filter(function(_2, valueIndex) {
          return !indexSet.has(valueIndex);
        })));
      }, "remove"),
      move: /* @__PURE__ */ __name(function(from2, to) {
        if (from2 !== to) {
          var newValue = getNewValue();
          from2 < 0 || from2 >= newValue.length || to < 0 || to >= newValue.length || (keyManager.keys = move(keyManager.keys, from2, to), onChange(move(newValue, from2, to)));
        }
      }, "move$1")
    }, listValue = value || [];
    return Array.isArray(listValue) || (listValue = [], process.env.NODE_ENV !== "production" && warningOnce(!1, "Current value of '".concat(prefixName.join(" > "), "' is not an array type."))), children(listValue.map(function(__, index2) {
      var key = keyManager.keys[index2];
      return key === void 0 && (keyManager.keys[index2] = keyManager.id, key = keyManager.keys[index2], keyManager.id += 1), {
        name: index2,
        key,
        isListField: !0
      };
    }), operations, meta);
  })));
}
__name(List$1, "List$1");
function allPromiseFinish(promiseList) {
  var hasError = !1, count = promiseList.length, results = [];
  return promiseList.length ? new Promise(function(resolve, reject) {
    promiseList.forEach(function(promise, index2) {
      promise.catch(function(e2) {
        return hasError = !0, e2;
      }).then(function(result) {
        count -= 1, results[index2] = result, !(count > 0) && (hasError && reject(results), resolve(results));
      });
    });
  }) : Promise.resolve([]);
}
__name(allPromiseFinish, "allPromiseFinish");
var SPLIT = "__@field_split__";
function normalize(namePath) {
  return namePath.map(function(cell) {
    return "".concat(_typeof$4(cell), ":").concat(cell);
  }).join(SPLIT);
}
__name(normalize, "normalize");
var NameMap = /* @__PURE__ */ function() {
  function NameMap2() {
    _classCallCheck$1(this, NameMap2), _defineProperty$2(this, "kvs", /* @__PURE__ */ new Map());
  }
  return __name(NameMap2, "NameMap"), _createClass$1(NameMap2, [{
    key: "set",
    value: /* @__PURE__ */ __name(function(key, value) {
      this.kvs.set(normalize(key), value);
    }, "set")
  }, {
    key: "get",
    value: /* @__PURE__ */ __name(function(key) {
      return this.kvs.get(normalize(key));
    }, "get")
  }, {
    key: "update",
    value: /* @__PURE__ */ __name(function(key, updater) {
      var origin = this.get(key), next2 = updater(origin);
      next2 ? this.set(key, next2) : this.delete(key);
    }, "update")
  }, {
    key: "delete",
    value: /* @__PURE__ */ __name(function(key) {
      this.kvs.delete(normalize(key));
    }, "_delete")
    // Since we only use this in test, let simply realize this
  }, {
    key: "map",
    value: /* @__PURE__ */ __name(function(callback) {
      return _toConsumableArray(this.kvs.entries()).map(function(_ref) {
        var _ref2 = _slicedToArray(_ref, 2), key = _ref2[0], value = _ref2[1], cells = key.split(SPLIT);
        return callback({
          key: cells.map(function(cell) {
            var _cell$match = cell.match(/^([^:]*):(.*)$/), _cell$match2 = _slicedToArray(_cell$match, 3), type4 = _cell$match2[1], unit2 = _cell$match2[2];
            return type4 === "number" ? Number(unit2) : unit2;
          }),
          value
        });
      });
    }, "map")
  }, {
    key: "toJSON",
    value: /* @__PURE__ */ __name(function() {
      var json = {};
      return this.map(function(_ref3) {
        var key = _ref3.key, value = _ref3.value;
        return json[key.join(".")] = value, null;
      }), json;
    }, "toJSON")
  }]), NameMap2;
}(), _excluded$L = ["name"], FormStore = /* @__PURE__ */ _createClass$1(/* @__PURE__ */ __name(function FormStore2(forceRootUpdate) {
  var _this = this;
  _classCallCheck$1(this, FormStore2), _defineProperty$2(this, "formHooked", !1), _defineProperty$2(this, "forceRootUpdate", void 0), _defineProperty$2(this, "subscribable", !0), _defineProperty$2(this, "store", {}), _defineProperty$2(this, "fieldEntities", []), _defineProperty$2(this, "initialValues", {}), _defineProperty$2(this, "callbacks", {}), _defineProperty$2(this, "validateMessages", null), _defineProperty$2(this, "preserve", null), _defineProperty$2(this, "lastValidatePromise", null), _defineProperty$2(this, "getForm", function() {
    return {
      getFieldValue: _this.getFieldValue,
      getFieldsValue: _this.getFieldsValue,
      getFieldError: _this.getFieldError,
      getFieldWarning: _this.getFieldWarning,
      getFieldsError: _this.getFieldsError,
      isFieldsTouched: _this.isFieldsTouched,
      isFieldTouched: _this.isFieldTouched,
      isFieldValidating: _this.isFieldValidating,
      isFieldsValidating: _this.isFieldsValidating,
      resetFields: _this.resetFields,
      setFields: _this.setFields,
      setFieldValue: _this.setFieldValue,
      setFieldsValue: _this.setFieldsValue,
      validateFields: _this.validateFields,
      submit: _this.submit,
      _init: !0,
      getInternalHooks: _this.getInternalHooks
    };
  }), _defineProperty$2(this, "getInternalHooks", function(key) {
    return key === HOOK_MARK ? (_this.formHooked = !0, {
      dispatch: _this.dispatch,
      initEntityValue: _this.initEntityValue,
      registerField: _this.registerField,
      useSubscribe: _this.useSubscribe,
      setInitialValues: _this.setInitialValues,
      destroyForm: _this.destroyForm,
      setCallbacks: _this.setCallbacks,
      setValidateMessages: _this.setValidateMessages,
      getFields: _this.getFields,
      setPreserve: _this.setPreserve,
      getInitialValue: _this.getInitialValue,
      registerWatch: _this.registerWatch
    }) : (warningOnce(!1, "`getInternalHooks` is internal usage. Should not call directly."), null);
  }), _defineProperty$2(this, "useSubscribe", function(subscribable) {
    _this.subscribable = subscribable;
  }), _defineProperty$2(this, "prevWithoutPreserves", null), _defineProperty$2(this, "setInitialValues", function(initialValues, init) {
    if (_this.initialValues = initialValues || {}, init) {
      var _this$prevWithoutPres, nextStore = merge$1(initialValues, _this.store);
      (_this$prevWithoutPres = _this.prevWithoutPreserves) === null || _this$prevWithoutPres === void 0 || _this$prevWithoutPres.map(function(_ref) {
        var namePath = _ref.key;
        nextStore = set(nextStore, namePath, get(initialValues, namePath));
      }), _this.prevWithoutPreserves = null, _this.updateStore(nextStore);
    }
  }), _defineProperty$2(this, "destroyForm", function(clearOnDestroy) {
    if (clearOnDestroy)
      _this.updateStore({});
    else {
      var prevWithoutPreserves = new NameMap();
      _this.getFieldEntities(!0).forEach(function(entity) {
        _this.isMergedPreserve(entity.isPreserve()) || prevWithoutPreserves.set(entity.getNamePath(), !0);
      }), _this.prevWithoutPreserves = prevWithoutPreserves;
    }
  }), _defineProperty$2(this, "getInitialValue", function(namePath) {
    var initValue = get(_this.initialValues, namePath);
    return namePath.length ? merge$1(initValue) : initValue;
  }), _defineProperty$2(this, "setCallbacks", function(callbacks) {
    _this.callbacks = callbacks;
  }), _defineProperty$2(this, "setValidateMessages", function(validateMessages) {
    _this.validateMessages = validateMessages;
  }), _defineProperty$2(this, "setPreserve", function(preserve2) {
    _this.preserve = preserve2;
  }), _defineProperty$2(this, "watchList", []), _defineProperty$2(this, "registerWatch", function(callback) {
    return _this.watchList.push(callback), function() {
      _this.watchList = _this.watchList.filter(function(fn) {
        return fn !== callback;
      });
    };
  }), _defineProperty$2(this, "notifyWatch", function() {
    var namePath = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
    if (_this.watchList.length) {
      var values = _this.getFieldsValue(), allValues = _this.getFieldsValue(!0);
      _this.watchList.forEach(function(callback) {
        callback(values, allValues, namePath);
      });
    }
  }), _defineProperty$2(this, "timeoutId", null), _defineProperty$2(this, "warningUnhooked", function() {
    process.env.NODE_ENV !== "production" && !_this.timeoutId && typeof window < "u" && (_this.timeoutId = setTimeout(function() {
      _this.timeoutId = null, _this.formHooked || warningOnce(!1, "Instance created by `useForm` is not connected to any Form element. Forget to pass `form` prop?");
    }));
  }), _defineProperty$2(this, "updateStore", function(nextStore) {
    _this.store = nextStore;
  }), _defineProperty$2(this, "getFieldEntities", function() {
    var pure = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : !1;
    return pure ? _this.fieldEntities.filter(function(field) {
      return field.getNamePath().length;
    }) : _this.fieldEntities;
  }), _defineProperty$2(this, "getFieldsMap", function() {
    var pure = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : !1, cache = new NameMap();
    return _this.getFieldEntities(pure).forEach(function(field) {
      var namePath = field.getNamePath();
      cache.set(namePath, field);
    }), cache;
  }), _defineProperty$2(this, "getFieldEntitiesForNamePathList", function(nameList) {
    if (!nameList)
      return _this.getFieldEntities(!0);
    var cache = _this.getFieldsMap(!0);
    return nameList.map(function(name) {
      var namePath = getNamePath(name);
      return cache.get(namePath) || {
        INVALIDATE_NAME_PATH: getNamePath(name)
      };
    });
  }), _defineProperty$2(this, "getFieldsValue", function(nameList, filterFunc) {
    _this.warningUnhooked();
    var mergedNameList, mergedFilterFunc, mergedStrict;
    if (nameList === !0 || Array.isArray(nameList) ? (mergedNameList = nameList, mergedFilterFunc = filterFunc) : nameList && _typeof$4(nameList) === "object" && (mergedStrict = nameList.strict, mergedFilterFunc = nameList.filter), mergedNameList === !0 && !mergedFilterFunc)
      return _this.store;
    var fieldEntities = _this.getFieldEntitiesForNamePathList(Array.isArray(mergedNameList) ? mergedNameList : null), filteredNameList = [];
    return fieldEntities.forEach(function(entity) {
      var _isListField, _ref3, namePath = "INVALIDATE_NAME_PATH" in entity ? entity.INVALIDATE_NAME_PATH : entity.getNamePath();
      if (mergedStrict) {
        var _isList, _ref2;
        if ((_isList = (_ref2 = entity).isList) !== null && _isList !== void 0 && _isList.call(_ref2))
          return;
      } else if (!mergedNameList && (_isListField = (_ref3 = entity).isListField) !== null && _isListField !== void 0 && _isListField.call(_ref3))
        return;
      if (!mergedFilterFunc)
        filteredNameList.push(namePath);
      else {
        var meta = "getMeta" in entity ? entity.getMeta() : null;
        mergedFilterFunc(meta) && filteredNameList.push(namePath);
      }
    }), cloneByNamePathList(_this.store, filteredNameList.map(getNamePath));
  }), _defineProperty$2(this, "getFieldValue", function(name) {
    _this.warningUnhooked();
    var namePath = getNamePath(name);
    return get(_this.store, namePath);
  }), _defineProperty$2(this, "getFieldsError", function(nameList) {
    _this.warningUnhooked();
    var fieldEntities = _this.getFieldEntitiesForNamePathList(nameList);
    return fieldEntities.map(function(entity, index2) {
      return entity && !("INVALIDATE_NAME_PATH" in entity) ? {
        name: entity.getNamePath(),
        errors: entity.getErrors(),
        warnings: entity.getWarnings()
      } : {
        name: getNamePath(nameList[index2]),
        errors: [],
        warnings: []
      };
    });
  }), _defineProperty$2(this, "getFieldError", function(name) {
    _this.warningUnhooked();
    var namePath = getNamePath(name), fieldError = _this.getFieldsError([namePath])[0];
    return fieldError.errors;
  }), _defineProperty$2(this, "getFieldWarning", function(name) {
    _this.warningUnhooked();
    var namePath = getNamePath(name), fieldError = _this.getFieldsError([namePath])[0];
    return fieldError.warnings;
  }), _defineProperty$2(this, "isFieldsTouched", function() {
    _this.warningUnhooked();
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++)
      args[_key] = arguments[_key];
    var arg0 = args[0], arg1 = args[1], namePathList, isAllFieldsTouched = !1;
    args.length === 0 ? namePathList = null : args.length === 1 ? Array.isArray(arg0) ? (namePathList = arg0.map(getNamePath), isAllFieldsTouched = !1) : (namePathList = null, isAllFieldsTouched = arg0) : (namePathList = arg0.map(getNamePath), isAllFieldsTouched = arg1);
    var fieldEntities = _this.getFieldEntities(!0), isFieldTouched = /* @__PURE__ */ __name(function(field) {
      return field.isFieldTouched();
    }, "isFieldTouched");
    if (!namePathList)
      return isAllFieldsTouched ? fieldEntities.every(function(entity) {
        return isFieldTouched(entity) || entity.isList();
      }) : fieldEntities.some(isFieldTouched);
    var map = new NameMap();
    namePathList.forEach(function(shortNamePath) {
      map.set(shortNamePath, []);
    }), fieldEntities.forEach(function(field) {
      var fieldNamePath = field.getNamePath();
      namePathList.forEach(function(shortNamePath) {
        shortNamePath.every(function(nameUnit, i) {
          return fieldNamePath[i] === nameUnit;
        }) && map.update(shortNamePath, function(list) {
          return [].concat(_toConsumableArray(list), [field]);
        });
      });
    });
    var isNamePathListTouched = /* @__PURE__ */ __name(function(entities) {
      return entities.some(isFieldTouched);
    }, "isNamePathListTouched"), namePathListEntities = map.map(function(_ref4) {
      var value = _ref4.value;
      return value;
    });
    return isAllFieldsTouched ? namePathListEntities.every(isNamePathListTouched) : namePathListEntities.some(isNamePathListTouched);
  }), _defineProperty$2(this, "isFieldTouched", function(name) {
    return _this.warningUnhooked(), _this.isFieldsTouched([name]);
  }), _defineProperty$2(this, "isFieldsValidating", function(nameList) {
    _this.warningUnhooked();
    var fieldEntities = _this.getFieldEntities();
    if (!nameList)
      return fieldEntities.some(function(testField) {
        return testField.isFieldValidating();
      });
    var namePathList = nameList.map(getNamePath);
    return fieldEntities.some(function(testField) {
      var fieldNamePath = testField.getNamePath();
      return containsNamePath(namePathList, fieldNamePath) && testField.isFieldValidating();
    });
  }), _defineProperty$2(this, "isFieldValidating", function(name) {
    return _this.warningUnhooked(), _this.isFieldsValidating([name]);
  }), _defineProperty$2(this, "resetWithFieldInitialValue", function() {
    var info = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, cache = new NameMap(), fieldEntities = _this.getFieldEntities(!0);
    fieldEntities.forEach(function(field) {
      var initialValue = field.props.initialValue, namePath = field.getNamePath();
      if (initialValue !== void 0) {
        var records = cache.get(namePath) || /* @__PURE__ */ new Set();
        records.add({
          entity: field,
          value: initialValue
        }), cache.set(namePath, records);
      }
    });
    var resetWithFields = /* @__PURE__ */ __name(function(entities) {
      entities.forEach(function(field) {
        var initialValue = field.props.initialValue;
        if (initialValue !== void 0) {
          var namePath = field.getNamePath(), formInitialValue = _this.getInitialValue(namePath);
          if (formInitialValue !== void 0)
            warningOnce(!1, "Form already set 'initialValues' with path '".concat(namePath.join("."), "'. Field can not overwrite it."));
          else {
            var records = cache.get(namePath);
            if (records && records.size > 1)
              warningOnce(!1, "Multiple Field with path '".concat(namePath.join("."), "' set 'initialValue'. Can not decide which one to pick."));
            else if (records) {
              var originValue = _this.getFieldValue(namePath), isListField = field.isListField();
              !isListField && (!info.skipExist || originValue === void 0) && _this.updateStore(set(_this.store, namePath, _toConsumableArray(records)[0].value));
            }
          }
        }
      });
    }, "resetWithFields"), requiredFieldEntities;
    info.entities ? requiredFieldEntities = info.entities : info.namePathList ? (requiredFieldEntities = [], info.namePathList.forEach(function(namePath) {
      var records = cache.get(namePath);
      if (records) {
        var _requiredFieldEntitie;
        (_requiredFieldEntitie = requiredFieldEntities).push.apply(_requiredFieldEntitie, _toConsumableArray(_toConsumableArray(records).map(function(r2) {
          return r2.entity;
        })));
      }
    })) : requiredFieldEntities = fieldEntities, resetWithFields(requiredFieldEntities);
  }), _defineProperty$2(this, "resetFields", function(nameList) {
    _this.warningUnhooked();
    var prevStore = _this.store;
    if (!nameList) {
      _this.updateStore(merge$1(_this.initialValues)), _this.resetWithFieldInitialValue(), _this.notifyObservers(prevStore, null, {
        type: "reset"
      }), _this.notifyWatch();
      return;
    }
    var namePathList = nameList.map(getNamePath);
    namePathList.forEach(function(namePath) {
      var initialValue = _this.getInitialValue(namePath);
      _this.updateStore(set(_this.store, namePath, initialValue));
    }), _this.resetWithFieldInitialValue({
      namePathList
    }), _this.notifyObservers(prevStore, namePathList, {
      type: "reset"
    }), _this.notifyWatch(namePathList);
  }), _defineProperty$2(this, "setFields", function(fields) {
    _this.warningUnhooked();
    var prevStore = _this.store, namePathList = [];
    fields.forEach(function(fieldData) {
      var name = fieldData.name, data = _objectWithoutProperties(fieldData, _excluded$L), namePath = getNamePath(name);
      namePathList.push(namePath), "value" in data && _this.updateStore(set(_this.store, namePath, data.value)), _this.notifyObservers(prevStore, [namePath], {
        type: "setField",
        data: fieldData
      });
    }), _this.notifyWatch(namePathList);
  }), _defineProperty$2(this, "getFields", function() {
    var entities = _this.getFieldEntities(!0), fields = entities.map(function(field) {
      var namePath = field.getNamePath(), meta = field.getMeta(), fieldData = _objectSpread2$1(_objectSpread2$1({}, meta), {}, {
        name: namePath,
        value: _this.getFieldValue(namePath)
      });
      return Object.defineProperty(fieldData, "originRCField", {
        value: !0
      }), fieldData;
    });
    return fields;
  }), _defineProperty$2(this, "initEntityValue", function(entity) {
    var initialValue = entity.props.initialValue;
    if (initialValue !== void 0) {
      var namePath = entity.getNamePath(), prevValue = get(_this.store, namePath);
      prevValue === void 0 && _this.updateStore(set(_this.store, namePath, initialValue));
    }
  }), _defineProperty$2(this, "isMergedPreserve", function(fieldPreserve) {
    var mergedPreserve = fieldPreserve !== void 0 ? fieldPreserve : _this.preserve;
    return mergedPreserve ?? !0;
  }), _defineProperty$2(this, "registerField", function(entity) {
    _this.fieldEntities.push(entity);
    var namePath = entity.getNamePath();
    if (_this.notifyWatch([namePath]), entity.props.initialValue !== void 0) {
      var prevStore = _this.store;
      _this.resetWithFieldInitialValue({
        entities: [entity],
        skipExist: !0
      }), _this.notifyObservers(prevStore, [entity.getNamePath()], {
        type: "valueUpdate",
        source: "internal"
      });
    }
    return function(isListField, preserve2) {
      var subNamePath = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : [];
      if (_this.fieldEntities = _this.fieldEntities.filter(function(item) {
        return item !== entity;
      }), !_this.isMergedPreserve(preserve2) && (!isListField || subNamePath.length > 1)) {
        var defaultValue = isListField ? void 0 : _this.getInitialValue(namePath);
        if (namePath.length && _this.getFieldValue(namePath) !== defaultValue && _this.fieldEntities.every(function(field) {
          return (
            // Only reset when no namePath exist
            !matchNamePath(field.getNamePath(), namePath)
          );
        })) {
          var _prevStore = _this.store;
          _this.updateStore(set(_prevStore, namePath, defaultValue, !0)), _this.notifyObservers(_prevStore, [namePath], {
            type: "remove"
          }), _this.triggerDependenciesUpdate(_prevStore, namePath);
        }
      }
      _this.notifyWatch([namePath]);
    };
  }), _defineProperty$2(this, "dispatch", function(action) {
    switch (action.type) {
      case "updateValue": {
        var namePath = action.namePath, value = action.value;
        _this.updateValue(namePath, value);
        break;
      }
      case "validateField": {
        var _namePath = action.namePath, triggerName = action.triggerName;
        _this.validateFields([_namePath], {
          triggerName
        });
        break;
      }
    }
  }), _defineProperty$2(this, "notifyObservers", function(prevStore, namePathList, info) {
    if (_this.subscribable) {
      var mergedInfo = _objectSpread2$1(_objectSpread2$1({}, info), {}, {
        store: _this.getFieldsValue(!0)
      });
      _this.getFieldEntities().forEach(function(_ref5) {
        var onStoreChange = _ref5.onStoreChange;
        onStoreChange(prevStore, namePathList, mergedInfo);
      });
    } else
      _this.forceRootUpdate();
  }), _defineProperty$2(this, "triggerDependenciesUpdate", function(prevStore, namePath) {
    var childrenFields = _this.getDependencyChildrenFields(namePath);
    return childrenFields.length && _this.validateFields(childrenFields), _this.notifyObservers(prevStore, childrenFields, {
      type: "dependenciesUpdate",
      relatedFields: [namePath].concat(_toConsumableArray(childrenFields))
    }), childrenFields;
  }), _defineProperty$2(this, "updateValue", function(name, value) {
    var namePath = getNamePath(name), prevStore = _this.store;
    _this.updateStore(set(_this.store, namePath, value)), _this.notifyObservers(prevStore, [namePath], {
      type: "valueUpdate",
      source: "internal"
    }), _this.notifyWatch([namePath]);
    var childrenFields = _this.triggerDependenciesUpdate(prevStore, namePath), onValuesChange = _this.callbacks.onValuesChange;
    if (onValuesChange) {
      var changedValues = cloneByNamePathList(_this.store, [namePath]);
      onValuesChange(changedValues, _this.getFieldsValue());
    }
    _this.triggerOnFieldsChange([namePath].concat(_toConsumableArray(childrenFields)));
  }), _defineProperty$2(this, "setFieldsValue", function(store) {
    _this.warningUnhooked();
    var prevStore = _this.store;
    if (store) {
      var nextStore = merge$1(_this.store, store);
      _this.updateStore(nextStore);
    }
    _this.notifyObservers(prevStore, null, {
      type: "valueUpdate",
      source: "external"
    }), _this.notifyWatch();
  }), _defineProperty$2(this, "setFieldValue", function(name, value) {
    _this.setFields([{
      name,
      value,
      errors: [],
      warnings: []
    }]);
  }), _defineProperty$2(this, "getDependencyChildrenFields", function(rootNamePath) {
    var children = /* @__PURE__ */ new Set(), childrenFields = [], dependencies2fields = new NameMap();
    _this.getFieldEntities().forEach(function(field) {
      var dependencies = field.props.dependencies;
      (dependencies || []).forEach(function(dependency) {
        var dependencyNamePath = getNamePath(dependency);
        dependencies2fields.update(dependencyNamePath, function() {
          var fields = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : /* @__PURE__ */ new Set();
          return fields.add(field), fields;
        });
      });
    });
    var fillChildren = /* @__PURE__ */ __name(function fillChildren2(namePath) {
      var fields = dependencies2fields.get(namePath) || /* @__PURE__ */ new Set();
      fields.forEach(function(field) {
        if (!children.has(field)) {
          children.add(field);
          var fieldNamePath = field.getNamePath();
          field.isFieldDirty() && fieldNamePath.length && (childrenFields.push(fieldNamePath), fillChildren2(fieldNamePath));
        }
      });
    }, "fillChildren");
    return fillChildren(rootNamePath), childrenFields;
  }), _defineProperty$2(this, "triggerOnFieldsChange", function(namePathList, filedErrors) {
    var onFieldsChange = _this.callbacks.onFieldsChange;
    if (onFieldsChange) {
      var fields = _this.getFields();
      if (filedErrors) {
        var cache = new NameMap();
        filedErrors.forEach(function(_ref6) {
          var name = _ref6.name, errors = _ref6.errors;
          cache.set(name, errors);
        }), fields.forEach(function(field) {
          field.errors = cache.get(field.name) || field.errors;
        });
      }
      var changedFields = fields.filter(function(_ref7) {
        var fieldName = _ref7.name;
        return containsNamePath(namePathList, fieldName);
      });
      changedFields.length && onFieldsChange(changedFields, fields);
    }
  }), _defineProperty$2(this, "validateFields", function(arg1, arg2) {
    _this.warningUnhooked();
    var nameList, options;
    Array.isArray(arg1) || typeof arg1 == "string" || typeof arg2 == "string" ? (nameList = arg1, options = arg2) : options = arg1;
    var provideNameList = !!nameList, namePathList = provideNameList ? nameList.map(getNamePath) : [], promiseList = [], TMP_SPLIT = String(Date.now()), validateNamePathList = /* @__PURE__ */ new Set(), _ref8 = options || {}, recursive = _ref8.recursive, dirty = _ref8.dirty;
    _this.getFieldEntities(!0).forEach(function(field) {
      if (provideNameList || namePathList.push(field.getNamePath()), !(!field.props.rules || !field.props.rules.length) && !(dirty && !field.isFieldDirty())) {
        var fieldNamePath = field.getNamePath();
        if (validateNamePathList.add(fieldNamePath.join(TMP_SPLIT)), !provideNameList || containsNamePath(namePathList, fieldNamePath, recursive)) {
          var promise = field.validateRules(_objectSpread2$1({
            validateMessages: _objectSpread2$1(_objectSpread2$1({}, defaultValidateMessages), _this.validateMessages)
          }, options));
          promiseList.push(promise.then(function() {
            return {
              name: fieldNamePath,
              errors: [],
              warnings: []
            };
          }).catch(function(ruleErrors) {
            var _ruleErrors$forEach, mergedErrors = [], mergedWarnings = [];
            return (_ruleErrors$forEach = ruleErrors.forEach) === null || _ruleErrors$forEach === void 0 || _ruleErrors$forEach.call(ruleErrors, function(_ref9) {
              var warningOnly = _ref9.rule.warningOnly, errors = _ref9.errors;
              warningOnly ? mergedWarnings.push.apply(mergedWarnings, _toConsumableArray(errors)) : mergedErrors.push.apply(mergedErrors, _toConsumableArray(errors));
            }), mergedErrors.length ? Promise.reject({
              name: fieldNamePath,
              errors: mergedErrors,
              warnings: mergedWarnings
            }) : {
              name: fieldNamePath,
              errors: mergedErrors,
              warnings: mergedWarnings
            };
          }));
        }
      }
    });
    var summaryPromise = allPromiseFinish(promiseList);
    _this.lastValidatePromise = summaryPromise, summaryPromise.catch(function(results) {
      return results;
    }).then(function(results) {
      var resultNamePathList = results.map(function(_ref10) {
        var name = _ref10.name;
        return name;
      });
      _this.notifyObservers(_this.store, resultNamePathList, {
        type: "validateFinish"
      }), _this.triggerOnFieldsChange(resultNamePathList, results);
    });
    var returnPromise = summaryPromise.then(function() {
      return _this.lastValidatePromise === summaryPromise ? Promise.resolve(_this.getFieldsValue(namePathList)) : Promise.reject([]);
    }).catch(function(results) {
      var errorList = results.filter(function(result) {
        return result && result.errors.length;
      });
      return Promise.reject({
        values: _this.getFieldsValue(namePathList),
        errorFields: errorList,
        outOfDate: _this.lastValidatePromise !== summaryPromise
      });
    });
    returnPromise.catch(function(e2) {
      return e2;
    });
    var triggerNamePathList = namePathList.filter(function(namePath) {
      return validateNamePathList.has(namePath.join(TMP_SPLIT));
    });
    return _this.triggerOnFieldsChange(triggerNamePathList), returnPromise;
  }), _defineProperty$2(this, "submit", function() {
    _this.warningUnhooked(), _this.validateFields().then(function(values) {
      var onFinish = _this.callbacks.onFinish;
      if (onFinish)
        try {
          onFinish(values);
        } catch (err) {
          console.error(err);
        }
    }).catch(function(e2) {
      var onFinishFailed = _this.callbacks.onFinishFailed;
      onFinishFailed && onFinishFailed(e2);
    });
  }), this.forceRootUpdate = forceRootUpdate;
}, "FormStore"));
function useForm$1(form) {
  var formRef = React.useRef(), _React$useState = React.useState({}), _React$useState2 = _slicedToArray(_React$useState, 2), forceUpdate = _React$useState2[1];
  if (!formRef.current)
    if (form)
      formRef.current = form;
    else {
      var forceReRender = /* @__PURE__ */ __name(function() {
        forceUpdate({});
      }, "forceReRender"), formStore = new FormStore(forceReRender);
      formRef.current = formStore.getForm();
    }
  return [formRef.current];
}
__name(useForm$1, "useForm$1");
var FormContext$1 = /* @__PURE__ */ React.createContext({
  triggerFormChange: /* @__PURE__ */ __name(function() {
  }, "triggerFormChange"),
  triggerFormFinish: /* @__PURE__ */ __name(function() {
  }, "triggerFormFinish"),
  registerForm: /* @__PURE__ */ __name(function() {
  }, "registerForm"),
  unregisterForm: /* @__PURE__ */ __name(function() {
  }, "unregisterForm")
}), FormProvider$1 = /* @__PURE__ */ __name(function(_ref) {
  var validateMessages = _ref.validateMessages, onFormChange = _ref.onFormChange, onFormFinish = _ref.onFormFinish, children = _ref.children, formContext = React.useContext(FormContext$1), formsRef = React.useRef({});
  return /* @__PURE__ */ React.createElement(FormContext$1.Provider, {
    value: _objectSpread2$1(_objectSpread2$1({}, formContext), {}, {
      validateMessages: _objectSpread2$1(_objectSpread2$1({}, formContext.validateMessages), validateMessages),
      // =========================================================
      // =                  Global Form Control                  =
      // =========================================================
      triggerFormChange: /* @__PURE__ */ __name(function(name, changedFields) {
        onFormChange && onFormChange(name, {
          changedFields,
          forms: formsRef.current
        }), formContext.triggerFormChange(name, changedFields);
      }, "triggerFormChange"),
      triggerFormFinish: /* @__PURE__ */ __name(function(name, values) {
        onFormFinish && onFormFinish(name, {
          values,
          forms: formsRef.current
        }), formContext.triggerFormFinish(name, values);
      }, "triggerFormFinish"),
      registerForm: /* @__PURE__ */ __name(function(name, form) {
        name && (formsRef.current = _objectSpread2$1(_objectSpread2$1({}, formsRef.current), {}, _defineProperty$2({}, name, form))), formContext.registerForm(name, form);
      }, "registerForm"),
      unregisterForm: /* @__PURE__ */ __name(function(name) {
        var newForms = _objectSpread2$1({}, formsRef.current);
        delete newForms[name], formsRef.current = newForms, formContext.unregisterForm(name);
      }, "unregisterForm")
    })
  }, children);
}, "FormProvider"), _excluded$K = ["name", "initialValues", "fields", "form", "preserve", "children", "component", "validateMessages", "validateTrigger", "onValuesChange", "onFieldsChange", "onFinish", "onFinishFailed", "clearOnDestroy"], Form$3 = /* @__PURE__ */ __name(function(_ref, ref) {
  var name = _ref.name, initialValues = _ref.initialValues, fields = _ref.fields, form = _ref.form, preserve2 = _ref.preserve, children = _ref.children, _ref$component = _ref.component, Component2 = _ref$component === void 0 ? "form" : _ref$component, validateMessages = _ref.validateMessages, _ref$validateTrigger = _ref.validateTrigger, validateTrigger = _ref$validateTrigger === void 0 ? "onChange" : _ref$validateTrigger, onValuesChange = _ref.onValuesChange, _onFieldsChange = _ref.onFieldsChange, _onFinish = _ref.onFinish, onFinishFailed = _ref.onFinishFailed, clearOnDestroy = _ref.clearOnDestroy, restProps = _objectWithoutProperties(_ref, _excluded$K), nativeElementRef = React.useRef(null), formContext = React.useContext(FormContext$1), _useForm = useForm$1(form), _useForm2 = _slicedToArray(_useForm, 1), formInstance = _useForm2[0], _getInternalHooks = formInstance.getInternalHooks(HOOK_MARK), useSubscribe = _getInternalHooks.useSubscribe, setInitialValues = _getInternalHooks.setInitialValues, setCallbacks = _getInternalHooks.setCallbacks, setValidateMessages = _getInternalHooks.setValidateMessages, setPreserve = _getInternalHooks.setPreserve, destroyForm = _getInternalHooks.destroyForm;
  React.useImperativeHandle(ref, function() {
    return _objectSpread2$1(_objectSpread2$1({}, formInstance), {}, {
      nativeElement: nativeElementRef.current
    });
  }), React.useEffect(function() {
    return formContext.registerForm(name, formInstance), function() {
      formContext.unregisterForm(name);
    };
  }, [formContext, formInstance, name]), setValidateMessages(_objectSpread2$1(_objectSpread2$1({}, formContext.validateMessages), validateMessages)), setCallbacks({
    onValuesChange,
    onFieldsChange: /* @__PURE__ */ __name(function(changedFields) {
      if (formContext.triggerFormChange(name, changedFields), _onFieldsChange) {
        for (var _len = arguments.length, rest = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++)
          rest[_key - 1] = arguments[_key];
        _onFieldsChange.apply(void 0, [changedFields].concat(rest));
      }
    }, "onFieldsChange"),
    onFinish: /* @__PURE__ */ __name(function(values) {
      formContext.triggerFormFinish(name, values), _onFinish && _onFinish(values);
    }, "onFinish"),
    onFinishFailed
  }), setPreserve(preserve2);
  var mountRef = React.useRef(null);
  setInitialValues(initialValues, !mountRef.current), mountRef.current || (mountRef.current = !0), React.useEffect(
    function() {
      return function() {
        return destroyForm(clearOnDestroy);
      };
    },
    // eslint-disable-next-line react-hooks/exhaustive-deps
    []
  );
  var childrenNode, childrenRenderProps = typeof children == "function";
  if (childrenRenderProps) {
    var _values = formInstance.getFieldsValue(!0);
    childrenNode = children(_values, formInstance);
  } else
    childrenNode = children;
  useSubscribe(!childrenRenderProps);
  var prevFieldsRef = React.useRef();
  React.useEffect(function() {
    isSimilar(prevFieldsRef.current || [], fields || []) || formInstance.setFields(fields || []), prevFieldsRef.current = fields;
  }, [fields, formInstance]);
  var formContextValue = React.useMemo(function() {
    return _objectSpread2$1(_objectSpread2$1({}, formInstance), {}, {
      validateTrigger
    });
  }, [formInstance, validateTrigger]), wrapperNode = /* @__PURE__ */ React.createElement(ListContext.Provider, {
    value: null
  }, /* @__PURE__ */ React.createElement(Context.Provider, {
    value: formContextValue
  }, childrenNode));
  return Component2 === !1 ? wrapperNode : /* @__PURE__ */ React.createElement(Component2, _extends({}, restProps, {
    ref: nativeElementRef,
    onSubmit: /* @__PURE__ */ __name(function(event) {
      event.preventDefault(), event.stopPropagation(), formInstance.submit();
    }, "onSubmit"),
    onReset: /* @__PURE__ */ __name(function(event) {
      var _restProps$onReset;
      event.preventDefault(), formInstance.resetFields(), (_restProps$onReset = restProps.onReset) === null || _restProps$onReset === void 0 || _restProps$onReset.call(restProps, event);
    }, "onReset")
  }), wrapperNode);
}, "Form");
function stringify$1(value) {
  try {
    return JSON.stringify(value);
  } catch {
    return Math.random();
  }
}
__name(stringify$1, "stringify$1");
var useWatchWarning = process.env.NODE_ENV !== "production" ? function(namePath) {
  var fullyStr = namePath.join("__RC_FIELD_FORM_SPLIT__"), nameStrRef = useRef(fullyStr);
  warningOnce(nameStrRef.current === fullyStr, "`useWatch` is not support dynamic `namePath`. Please provide static instead.");
} : function() {
};
function useWatch$1() {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++)
    args[_key] = arguments[_key];
  var dependencies = args[0], _args$ = args[1], _form = _args$ === void 0 ? {} : _args$, options = isFormInstance(_form) ? {
    form: _form
  } : _form, form = options.form, _useState = useState(), _useState2 = _slicedToArray(_useState, 2), value = _useState2[0], setValue = _useState2[1], valueStr = useMemo$1(function() {
    return stringify$1(value);
  }, [value]), valueStrRef = useRef(valueStr);
  valueStrRef.current = valueStr;
  var fieldContext = useContext$1(Context), formInstance = form || fieldContext, isValidForm = formInstance && formInstance._init;
  process.env.NODE_ENV !== "production" && warningOnce(args.length === 2 ? form ? isValidForm : !0 : isValidForm, "useWatch requires a form instance since it can not auto detect from context.");
  var namePath = getNamePath(dependencies), namePathRef = useRef(namePath);
  return namePathRef.current = namePath, useWatchWarning(namePath), useEffect(
    function() {
      if (isValidForm) {
        var getFieldsValue = formInstance.getFieldsValue, getInternalHooks2 = formInstance.getInternalHooks, _getInternalHooks = getInternalHooks2(HOOK_MARK), registerWatch = _getInternalHooks.registerWatch, getWatchValue = /* @__PURE__ */ __name(function(values, allValues) {
          var watchValue = options.preserve ? allValues : values;
          return typeof dependencies == "function" ? dependencies(watchValue) : get(watchValue, namePathRef.current);
        }, "getWatchValue"), cancelRegister = registerWatch(function(values, allValues) {
          var newValue = getWatchValue(values, allValues), nextValueStr = stringify$1(newValue);
          valueStrRef.current !== nextValueStr && (valueStrRef.current = nextValueStr, setValue(newValue));
        }), initialValue = getWatchValue(getFieldsValue(), getFieldsValue(!0));
        return value !== initialValue && setValue(initialValue), cancelRegister;
      }
    },
    // We do not need re-register since namePath content is the same
    // eslint-disable-next-line react-hooks/exhaustive-deps
    [isValidForm]
  ), value;
}
__name(useWatch$1, "useWatch$1");
var InternalForm$1 = /* @__PURE__ */ React.forwardRef(Form$3), RefForm = InternalForm$1;
RefForm.FormProvider = FormProvider$1;
RefForm.Field = WrapperField;
RefForm.List = List$1;
RefForm.useForm = useForm$1;
RefForm.useWatch = useWatch$1;
const FormContext = /* @__PURE__ */ React.createContext({
  labelAlign: "right",
  vertical: !1,
  itemRef: /* @__PURE__ */ __name(() => {
  }, "itemRef")
}), NoStyleItemContext = /* @__PURE__ */ React.createContext(null), FormProvider2 = /* @__PURE__ */ __name((props) => {
  const providerProps = omit(props, ["prefixCls"]);
  return /* @__PURE__ */ React.createElement(FormProvider$1, Object.assign({}, providerProps));
}, "FormProvider"), FormItemPrefixContext = /* @__PURE__ */ React.createContext({
  prefixCls: ""
}), FormItemInputContext = /* @__PURE__ */ React.createContext({});
process.env.NODE_ENV !== "production" && (FormItemInputContext.displayName = "FormItemInputContext");
const NoFormStyle = /* @__PURE__ */ __name((_ref) => {
  let {
    children,
    status,
    override
  } = _ref;
  const formItemInputContext = React.useContext(FormItemInputContext), newFormItemInputContext = React.useMemo(() => {
    const newContext = Object.assign({}, formItemInputContext);
    return override && delete newContext.isFormItemInput, status && (delete newContext.status, delete newContext.hasFeedback, delete newContext.feedbackIcon), newContext;
  }, [status, override, formItemInputContext]);
  return /* @__PURE__ */ React.createElement(FormItemInputContext.Provider, {
    value: newFormItemInputContext
  }, children);
}, "NoFormStyle"), VariantContext = /* @__PURE__ */ React.createContext(void 0), ContextIsolator = /* @__PURE__ */ __name((props) => {
  const {
    space,
    form,
    children
  } = props;
  if (children == null)
    return null;
  let result = children;
  return form && (result = /* @__PURE__ */ React__default.createElement(NoFormStyle, {
    override: !0,
    status: !0
  }, result)), space && (result = /* @__PURE__ */ React__default.createElement(NoCompactStyle, null, result)), result;
}, "ContextIsolator");
var isStyleNameSupport = /* @__PURE__ */ __name(function(styleName) {
  if (canUseDom() && window.document.documentElement) {
    var styleNameList = Array.isArray(styleName) ? styleName : [styleName], documentElement = window.document.documentElement;
    return styleNameList.some(function(name) {
      return name in documentElement.style;
    });
  }
  return !1;
}, "isStyleNameSupport"), isStyleValueSupport = /* @__PURE__ */ __name(function(styleName, value) {
  if (!isStyleNameSupport(styleName))
    return !1;
  var ele = document.createElement("div"), origin = ele.style[styleName];
  return ele.style[styleName] = value, ele.style[styleName] !== origin;
}, "isStyleValueSupport");
function isStyleSupport(styleName, styleValue) {
  return !Array.isArray(styleName) && styleValue !== void 0 ? isStyleValueSupport(styleName, styleValue) : isStyleNameSupport(styleName);
}
__name(isStyleSupport, "isStyleSupport");
const Element$1 = /* @__PURE__ */ __name((props) => {
  const {
    prefixCls,
    className,
    style: style2,
    size,
    shape
  } = props, sizeCls = cn({
    [`${prefixCls}-lg`]: size === "large",
    [`${prefixCls}-sm`]: size === "small"
  }), shapeCls = cn({
    [`${prefixCls}-circle`]: shape === "circle",
    [`${prefixCls}-square`]: shape === "square",
    [`${prefixCls}-round`]: shape === "round"
  }), sizeStyle = React.useMemo(() => typeof size == "number" ? {
    width: size,
    height: size,
    lineHeight: `${size}px`
  } : {}, [size]);
  return /* @__PURE__ */ React.createElement("span", {
    className: cn(prefixCls, sizeCls, shapeCls, className),
    style: Object.assign(Object.assign({}, sizeStyle), style2)
  });
}, "Element$1"), skeletonClsLoading = new Keyframe("ant-skeleton-loading", {
  "0%": {
    backgroundPosition: "100% 50%"
  },
  "100%": {
    backgroundPosition: "0 50%"
  }
}), genSkeletonElementCommonSize = /* @__PURE__ */ __name((size) => ({
  height: size,
  lineHeight: unit$1(size)
}), "genSkeletonElementCommonSize"), genSkeletonElementAvatarSize = /* @__PURE__ */ __name((size) => Object.assign({
  width: size
}, genSkeletonElementCommonSize(size)), "genSkeletonElementAvatarSize"), genSkeletonColor = /* @__PURE__ */ __name((token2) => ({
  background: token2.skeletonLoadingBackground,
  backgroundSize: "400% 100%",
  animationName: skeletonClsLoading,
  animationDuration: token2.skeletonLoadingMotionDuration,
  animationTimingFunction: "ease",
  animationIterationCount: "infinite"
}), "genSkeletonColor"), genSkeletonElementInputSize = /* @__PURE__ */ __name((size, calc) => Object.assign({
  width: calc(size).mul(5).equal(),
  minWidth: calc(size).mul(5).equal()
}, genSkeletonElementCommonSize(size)), "genSkeletonElementInputSize"), genSkeletonElementAvatar = /* @__PURE__ */ __name((token2) => {
  const {
    skeletonAvatarCls,
    gradientFromColor,
    controlHeight,
    controlHeightLG,
    controlHeightSM
  } = token2;
  return {
    [skeletonAvatarCls]: Object.assign({
      display: "inline-block",
      verticalAlign: "top",
      background: gradientFromColor
    }, genSkeletonElementAvatarSize(controlHeight)),
    [`${skeletonAvatarCls}${skeletonAvatarCls}-circle`]: {
      borderRadius: "50%"
    },
    [`${skeletonAvatarCls}${skeletonAvatarCls}-lg`]: Object.assign({}, genSkeletonElementAvatarSize(controlHeightLG)),
    [`${skeletonAvatarCls}${skeletonAvatarCls}-sm`]: Object.assign({}, genSkeletonElementAvatarSize(controlHeightSM))
  };
}, "genSkeletonElementAvatar"), genSkeletonElementInput = /* @__PURE__ */ __name((token2) => {
  const {
    controlHeight,
    borderRadiusSM,
    skeletonInputCls,
    controlHeightLG,
    controlHeightSM,
    gradientFromColor,
    calc
  } = token2;
  return {
    [skeletonInputCls]: Object.assign({
      display: "inline-block",
      verticalAlign: "top",
      background: gradientFromColor,
      borderRadius: borderRadiusSM
    }, genSkeletonElementInputSize(controlHeight, calc)),
    [`${skeletonInputCls}-lg`]: Object.assign({}, genSkeletonElementInputSize(controlHeightLG, calc)),
    [`${skeletonInputCls}-sm`]: Object.assign({}, genSkeletonElementInputSize(controlHeightSM, calc))
  };
}, "genSkeletonElementInput"), genSkeletonElementImageSize = /* @__PURE__ */ __name((size) => Object.assign({
  width: size
}, genSkeletonElementCommonSize(size)), "genSkeletonElementImageSize"), genSkeletonElementImage = /* @__PURE__ */ __name((token2) => {
  const {
    skeletonImageCls,
    imageSizeBase,
    gradientFromColor,
    borderRadiusSM,
    calc
  } = token2;
  return {
    [skeletonImageCls]: Object.assign(Object.assign({
      display: "inline-flex",
      alignItems: "center",
      justifyContent: "center",
      verticalAlign: "middle",
      background: gradientFromColor,
      borderRadius: borderRadiusSM
    }, genSkeletonElementImageSize(calc(imageSizeBase).mul(2).equal())), {
      [`${skeletonImageCls}-path`]: {
        fill: "#bfbfbf"
      },
      [`${skeletonImageCls}-svg`]: Object.assign(Object.assign({}, genSkeletonElementImageSize(imageSizeBase)), {
        maxWidth: calc(imageSizeBase).mul(4).equal(),
        maxHeight: calc(imageSizeBase).mul(4).equal()
      }),
      [`${skeletonImageCls}-svg${skeletonImageCls}-svg-circle`]: {
        borderRadius: "50%"
      }
    }),
    [`${skeletonImageCls}${skeletonImageCls}-circle`]: {
      borderRadius: "50%"
    }
  };
}, "genSkeletonElementImage"), genSkeletonElementButtonShape = /* @__PURE__ */ __name((token2, size, buttonCls) => {
  const {
    skeletonButtonCls
  } = token2;
  return {
    [`${buttonCls}${skeletonButtonCls}-circle`]: {
      width: size,
      minWidth: size,
      borderRadius: "50%"
    },
    [`${buttonCls}${skeletonButtonCls}-round`]: {
      borderRadius: size
    }
  };
}, "genSkeletonElementButtonShape"), genSkeletonElementButtonSize = /* @__PURE__ */ __name((size, calc) => Object.assign({
  width: calc(size).mul(2).equal(),
  minWidth: calc(size).mul(2).equal()
}, genSkeletonElementCommonSize(size)), "genSkeletonElementButtonSize"), genSkeletonElementButton = /* @__PURE__ */ __name((token2) => {
  const {
    borderRadiusSM,
    skeletonButtonCls,
    controlHeight,
    controlHeightLG,
    controlHeightSM,
    gradientFromColor,
    calc
  } = token2;
  return Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({
    [skeletonButtonCls]: Object.assign({
      display: "inline-block",
      verticalAlign: "top",
      background: gradientFromColor,
      borderRadius: borderRadiusSM,
      width: calc(controlHeight).mul(2).equal(),
      minWidth: calc(controlHeight).mul(2).equal()
    }, genSkeletonElementButtonSize(controlHeight, calc))
  }, genSkeletonElementButtonShape(token2, controlHeight, skeletonButtonCls)), {
    [`${skeletonButtonCls}-lg`]: Object.assign({}, genSkeletonElementButtonSize(controlHeightLG, calc))
  }), genSkeletonElementButtonShape(token2, controlHeightLG, `${skeletonButtonCls}-lg`)), {
    [`${skeletonButtonCls}-sm`]: Object.assign({}, genSkeletonElementButtonSize(controlHeightSM, calc))
  }), genSkeletonElementButtonShape(token2, controlHeightSM, `${skeletonButtonCls}-sm`));
}, "genSkeletonElementButton"), genBaseStyle$6 = /* @__PURE__ */ __name((token2) => {
  const {
    componentCls,
    skeletonAvatarCls,
    skeletonTitleCls,
    skeletonParagraphCls,
    skeletonButtonCls,
    skeletonInputCls,
    skeletonImageCls,
    controlHeight,
    controlHeightLG,
    controlHeightSM,
    gradientFromColor,
    padding,
    marginSM,
    borderRadius,
    titleHeight,
    blockRadius,
    paragraphLiHeight,
    controlHeightXS,
    paragraphMarginTop
  } = token2;
  return {
    [componentCls]: {
      display: "table",
      width: "100%",
      [`${componentCls}-header`]: {
        display: "table-cell",
        paddingInlineEnd: padding,
        verticalAlign: "top",
        // Avatar
        [skeletonAvatarCls]: Object.assign({
          display: "inline-block",
          verticalAlign: "top",
          background: gradientFromColor
        }, genSkeletonElementAvatarSize(controlHeight)),
        [`${skeletonAvatarCls}-circle`]: {
          borderRadius: "50%"
        },
        [`${skeletonAvatarCls}-lg`]: Object.assign({}, genSkeletonElementAvatarSize(controlHeightLG)),
        [`${skeletonAvatarCls}-sm`]: Object.assign({}, genSkeletonElementAvatarSize(controlHeightSM))
      },
      [`${componentCls}-content`]: {
        display: "table-cell",
        width: "100%",
        verticalAlign: "top",
        // Title
        [skeletonTitleCls]: {
          width: "100%",
          height: titleHeight,
          background: gradientFromColor,
          borderRadius: blockRadius,
          [`+ ${skeletonParagraphCls}`]: {
            marginBlockStart: controlHeightSM
          }
        },
        // paragraph
        [skeletonParagraphCls]: {
          padding: 0,
          "> li": {
            width: "100%",
            height: paragraphLiHeight,
            listStyle: "none",
            background: gradientFromColor,
            borderRadius: blockRadius,
            "+ li": {
              marginBlockStart: controlHeightXS
            }
          }
        },
        [`${skeletonParagraphCls}> li:last-child:not(:first-child):not(:nth-child(2))`]: {
          width: "61%"
        }
      },
      [`&-round ${componentCls}-content`]: {
        [`${skeletonTitleCls}, ${skeletonParagraphCls} > li`]: {
          borderRadius
        }
      }
    },
    [`${componentCls}-with-avatar ${componentCls}-content`]: {
      // Title
      [skeletonTitleCls]: {
        marginBlockStart: marginSM,
        [`+ ${skeletonParagraphCls}`]: {
          marginBlockStart: paragraphMarginTop
        }
      }
    },
    // Skeleton element
    [`${componentCls}${componentCls}-element`]: Object.assign(Object.assign(Object.assign(Object.assign({
      display: "inline-block",
      width: "auto"
    }, genSkeletonElementButton(token2)), genSkeletonElementAvatar(token2)), genSkeletonElementInput(token2)), genSkeletonElementImage(token2)),
    // Skeleton Block Button, Input
    [`${componentCls}${componentCls}-block`]: {
      width: "100%",
      [skeletonButtonCls]: {
        width: "100%"
      },
      [skeletonInputCls]: {
        width: "100%"
      }
    },
    // With active animation
    [`${componentCls}${componentCls}-active`]: {
      [`
        ${skeletonTitleCls},
        ${skeletonParagraphCls} > li,
        ${skeletonAvatarCls},
        ${skeletonButtonCls},
        ${skeletonInputCls},
        ${skeletonImageCls}
      `]: Object.assign({}, genSkeletonColor(token2))
    }
  };
}, "genBaseStyle$6"), prepareComponentToken$m = /* @__PURE__ */ __name((token2) => {
  const {
    colorFillContent,
    colorFill
  } = token2, gradientFromColor = colorFillContent, gradientToColor = colorFill;
  return {
    color: gradientFromColor,
    colorGradientEnd: gradientToColor,
    gradientFromColor,
    gradientToColor,
    titleHeight: token2.controlHeight / 2,
    blockRadius: token2.borderRadiusSM,
    paragraphMarginTop: token2.marginLG + token2.marginXXS,
    paragraphLiHeight: token2.controlHeight / 2
  };
}, "prepareComponentToken$m"), useStyle$r = genStyleHooks("Skeleton", (token2) => {
  const {
    componentCls,
    calc
  } = token2, skeletonToken = merge(token2, {
    skeletonAvatarCls: `${componentCls}-avatar`,
    skeletonTitleCls: `${componentCls}-title`,
    skeletonParagraphCls: `${componentCls}-paragraph`,
    skeletonButtonCls: `${componentCls}-button`,
    skeletonInputCls: `${componentCls}-input`,
    skeletonImageCls: `${componentCls}-image`,
    imageSizeBase: calc(token2.controlHeight).mul(1.5).equal(),
    borderRadius: 100,
    // Large number to make capsule shape
    skeletonLoadingBackground: `linear-gradient(90deg, ${token2.gradientFromColor} 25%, ${token2.gradientToColor} 37%, ${token2.gradientFromColor} 63%)`,
    skeletonLoadingMotionDuration: "1.4s"
  });
  return [genBaseStyle$6(skeletonToken)];
}, prepareComponentToken$m, {
  deprecatedTokens: [["color", "gradientFromColor"], ["colorGradientEnd", "gradientToColor"]]
}), SkeletonAvatar = /* @__PURE__ */ __name((props) => {
  const {
    prefixCls: customizePrefixCls,
    className,
    rootClassName,
    active,
    shape = "circle",
    size = "default"
  } = props, {
    getPrefixCls
  } = React.useContext(ConfigContext), prefixCls = getPrefixCls("skeleton", customizePrefixCls), [wrapCSSVar, hashId, cssVarCls] = useStyle$r(prefixCls), otherProps = omit(props, ["prefixCls", "className"]), cls = cn(prefixCls, `${prefixCls}-element`, {
    [`${prefixCls}-active`]: active
  }, className, rootClassName, hashId, cssVarCls);
  return wrapCSSVar(/* @__PURE__ */ React.createElement("div", {
    className: cls
  }, /* @__PURE__ */ React.createElement(Element$1, Object.assign({
    prefixCls: `${prefixCls}-avatar`,
    shape,
    size
  }, otherProps))));
}, "SkeletonAvatar"), SkeletonButton = /* @__PURE__ */ __name((props) => {
  const {
    prefixCls: customizePrefixCls,
    className,
    rootClassName,
    active,
    block = !1,
    size = "default"
  } = props, {
    getPrefixCls
  } = React.useContext(ConfigContext), prefixCls = getPrefixCls("skeleton", customizePrefixCls), [wrapCSSVar, hashId, cssVarCls] = useStyle$r(prefixCls), otherProps = omit(props, ["prefixCls"]), cls = cn(prefixCls, `${prefixCls}-element`, {
    [`${prefixCls}-active`]: active,
    [`${prefixCls}-block`]: block
  }, className, rootClassName, hashId, cssVarCls);
  return wrapCSSVar(/* @__PURE__ */ React.createElement("div", {
    className: cls
  }, /* @__PURE__ */ React.createElement(Element$1, Object.assign({
    prefixCls: `${prefixCls}-button`,
    size
  }, otherProps))));
}, "SkeletonButton"), path$1 = "M365.714286 329.142857q0 45.714286-32.036571 77.677714t-77.677714 32.036571-77.677714-32.036571-32.036571-77.677714 32.036571-77.677714 77.677714-32.036571 77.677714 32.036571 32.036571 77.677714zM950.857143 548.571429l0 256-804.571429 0 0-109.714286 182.857143-182.857143 91.428571 91.428571 292.571429-292.571429zM1005.714286 146.285714l-914.285714 0q-7.460571 0-12.873143 5.412571t-5.412571 12.873143l0 694.857143q0 7.460571 5.412571 12.873143t12.873143 5.412571l914.285714 0q7.460571 0 12.873143-5.412571t5.412571-12.873143l0-694.857143q0-7.460571-5.412571-12.873143t-12.873143-5.412571zM1097.142857 164.571429l0 694.857143q0 37.741714-26.843429 64.585143t-64.585143 26.843429l-914.285714 0q-37.741714 0-64.585143-26.843429t-26.843429-64.585143l0-694.857143q0-37.741714 26.843429-64.585143t64.585143-26.843429l914.285714 0q37.741714 0 64.585143 26.843429t26.843429 64.585143z", SkeletonImage = /* @__PURE__ */ __name((props) => {
  const {
    prefixCls: customizePrefixCls,
    className,
    rootClassName,
    style: style2,
    active
  } = props, {
    getPrefixCls
  } = React.useContext(ConfigContext), prefixCls = getPrefixCls("skeleton", customizePrefixCls), [wrapCSSVar, hashId, cssVarCls] = useStyle$r(prefixCls), cls = cn(prefixCls, `${prefixCls}-element`, {
    [`${prefixCls}-active`]: active
  }, className, rootClassName, hashId, cssVarCls);
  return wrapCSSVar(/* @__PURE__ */ React.createElement("div", {
    className: cls
  }, /* @__PURE__ */ React.createElement("div", {
    className: cn(`${prefixCls}-image`, className),
    style: style2
  }, /* @__PURE__ */ React.createElement("svg", {
    viewBox: "0 0 1098 1024",
    xmlns: "http://www.w3.org/2000/svg",
    className: `${prefixCls}-image-svg`
  }, /* @__PURE__ */ React.createElement("title", null, "Image placeholder"), /* @__PURE__ */ React.createElement("path", {
    d: path$1,
    className: `${prefixCls}-image-path`
  })))));
}, "SkeletonImage"), SkeletonInput = /* @__PURE__ */ __name((props) => {
  const {
    prefixCls: customizePrefixCls,
    className,
    rootClassName,
    active,
    block,
    size = "default"
  } = props, {
    getPrefixCls
  } = React.useContext(ConfigContext), prefixCls = getPrefixCls("skeleton", customizePrefixCls), [wrapCSSVar, hashId, cssVarCls] = useStyle$r(prefixCls), otherProps = omit(props, ["prefixCls"]), cls = cn(prefixCls, `${prefixCls}-element`, {
    [`${prefixCls}-active`]: active,
    [`${prefixCls}-block`]: block
  }, className, rootClassName, hashId, cssVarCls);
  return wrapCSSVar(/* @__PURE__ */ React.createElement("div", {
    className: cls
  }, /* @__PURE__ */ React.createElement(Element$1, Object.assign({
    prefixCls: `${prefixCls}-input`,
    size
  }, otherProps))));
}, "SkeletonInput"), SkeletonNode = /* @__PURE__ */ __name((props) => {
  const {
    prefixCls: customizePrefixCls,
    className,
    rootClassName,
    style: style2,
    active,
    children
  } = props, {
    getPrefixCls
  } = React.useContext(ConfigContext), prefixCls = getPrefixCls("skeleton", customizePrefixCls), [wrapCSSVar, hashId, cssVarCls] = useStyle$r(prefixCls), cls = cn(prefixCls, `${prefixCls}-element`, {
    [`${prefixCls}-active`]: active
  }, hashId, className, rootClassName, cssVarCls);
  return wrapCSSVar(/* @__PURE__ */ React.createElement("div", {
    className: cls
  }, /* @__PURE__ */ React.createElement("div", {
    className: cn(`${prefixCls}-image`, className),
    style: style2
  }, children)));
}, "SkeletonNode"), getWidth = /* @__PURE__ */ __name((index2, props) => {
  const {
    width,
    rows = 2
  } = props;
  if (Array.isArray(width))
    return width[index2];
  if (rows - 1 === index2)
    return width;
}, "getWidth"), Paragraph$1 = /* @__PURE__ */ __name((props) => {
  const {
    prefixCls,
    className,
    style: style2,
    rows
  } = props, rowList = _toConsumableArray(new Array(rows)).map((_2, index2) => (
    // eslint-disable-next-line react/no-array-index-key
    /* @__PURE__ */ React.createElement("li", {
      key: index2,
      style: {
        width: getWidth(index2, props)
      }
    })
  ));
  return /* @__PURE__ */ React.createElement("ul", {
    className: cn(prefixCls, className),
    style: style2
  }, rowList);
}, "Paragraph$1"), Title$2 = /* @__PURE__ */ __name((_ref) => {
  let {
    prefixCls,
    className,
    width,
    style: style2
  } = _ref;
  return (
    // biome-ignore lint/a11y/useHeadingContent: HOC here
    /* @__PURE__ */ React.createElement("h3", {
      className: cn(prefixCls, className),
      style: Object.assign({
        width
      }, style2)
    })
  );
}, "Title$2");
function getComponentProps(prop) {
  return prop && typeof prop == "object" ? prop : {};
}
__name(getComponentProps, "getComponentProps");
function getAvatarBasicProps(hasTitle, hasParagraph) {
  return hasTitle && !hasParagraph ? {
    size: "large",
    shape: "square"
  } : {
    size: "large",
    shape: "circle"
  };
}
__name(getAvatarBasicProps, "getAvatarBasicProps");
function getTitleBasicProps(hasAvatar, hasParagraph) {
  return !hasAvatar && hasParagraph ? {
    width: "38%"
  } : hasAvatar && hasParagraph ? {
    width: "50%"
  } : {};
}
__name(getTitleBasicProps, "getTitleBasicProps");
function getParagraphBasicProps(hasAvatar, hasTitle) {
  const basicProps = {};
  return (!hasAvatar || !hasTitle) && (basicProps.width = "61%"), !hasAvatar && hasTitle ? basicProps.rows = 3 : basicProps.rows = 2, basicProps;
}
__name(getParagraphBasicProps, "getParagraphBasicProps");
const Skeleton = /* @__PURE__ */ __name((props) => {
  const {
    prefixCls: customizePrefixCls,
    loading,
    className,
    rootClassName,
    style: style2,
    children,
    avatar = !1,
    title: title2 = !0,
    paragraph = !0,
    active,
    round: round2
  } = props, {
    getPrefixCls,
    direction,
    skeleton
  } = React.useContext(ConfigContext), prefixCls = getPrefixCls("skeleton", customizePrefixCls), [wrapCSSVar, hashId, cssVarCls] = useStyle$r(prefixCls);
  if (loading || !("loading" in props)) {
    const hasAvatar = !!avatar, hasTitle = !!title2, hasParagraph = !!paragraph;
    let avatarNode;
    if (hasAvatar) {
      const avatarProps = Object.assign(Object.assign({
        prefixCls: `${prefixCls}-avatar`
      }, getAvatarBasicProps(hasTitle, hasParagraph)), getComponentProps(avatar));
      avatarNode = /* @__PURE__ */ React.createElement("div", {
        className: `${prefixCls}-header`
      }, /* @__PURE__ */ React.createElement(Element$1, Object.assign({}, avatarProps)));
    }
    let contentNode;
    if (hasTitle || hasParagraph) {
      let $title;
      if (hasTitle) {
        const titleProps = Object.assign(Object.assign({
          prefixCls: `${prefixCls}-title`
        }, getTitleBasicProps(hasAvatar, hasParagraph)), getComponentProps(title2));
        $title = /* @__PURE__ */ React.createElement(Title$2, Object.assign({}, titleProps));
      }
      let paragraphNode;
      if (hasParagraph) {
        const paragraphProps = Object.assign(Object.assign({
          prefixCls: `${prefixCls}-paragraph`
        }, getParagraphBasicProps(hasAvatar, hasTitle)), getComponentProps(paragraph));
        paragraphNode = /* @__PURE__ */ React.createElement(Paragraph$1, Object.assign({}, paragraphProps));
      }
      contentNode = /* @__PURE__ */ React.createElement("div", {
        className: `${prefixCls}-content`
      }, $title, paragraphNode);
    }
    const cls = cn(prefixCls, {
      [`${prefixCls}-with-avatar`]: hasAvatar,
      [`${prefixCls}-active`]: active,
      [`${prefixCls}-rtl`]: direction === "rtl",
      [`${prefixCls}-round`]: round2
    }, skeleton == null ? void 0 : skeleton.className, className, rootClassName, hashId, cssVarCls);
    return wrapCSSVar(/* @__PURE__ */ React.createElement("div", {
      className: cls,
      style: Object.assign(Object.assign({}, skeleton == null ? void 0 : skeleton.style), style2)
    }, avatarNode, contentNode));
  }
  return children ?? null;
}, "Skeleton");
Skeleton.Button = SkeletonButton;
Skeleton.Avatar = SkeletonAvatar;
Skeleton.Input = SkeletonInput;
Skeleton.Image = SkeletonImage;
Skeleton.Node = SkeletonNode;
process.env.NODE_ENV !== "production" && (Skeleton.displayName = "Skeleton");
function withPureRenderTheme(Component2) {
  return (props) => /* @__PURE__ */ React.createElement(ConfigProvider, {
    theme: {
      token: {
        motion: !1,
        zIndexPopupBase: 0
      }
    }
  }, /* @__PURE__ */ React.createElement(Component2, Object.assign({}, props)));
}
__name(withPureRenderTheme, "withPureRenderTheme");
const genPurePanel = /* @__PURE__ */ __name((Component2, defaultPrefixCls2, getDropdownCls, postProps) => withPureRenderTheme(/* @__PURE__ */ __name((props) => {
  const {
    prefixCls: customizePrefixCls,
    style: style2
  } = props, holderRef = React.useRef(null), [popupHeight, setPopupHeight] = React.useState(0), [popupWidth, setPopupWidth] = React.useState(0), [open, setOpen] = useMergedState(!1, {
    value: props.open
  }), {
    getPrefixCls
  } = React.useContext(ConfigContext), prefixCls = getPrefixCls(defaultPrefixCls2 || "select", customizePrefixCls);
  React.useEffect(() => {
    if (setOpen(!0), typeof ResizeObserver < "u") {
      const resizeObserver2 = new ResizeObserver((entries) => {
        const element = entries[0].target;
        setPopupHeight(element.offsetHeight + 8), setPopupWidth(element.offsetWidth);
      }), interval = setInterval(() => {
        var _a;
        const dropdownCls = getDropdownCls ? `.${getDropdownCls(prefixCls)}` : `.${prefixCls}-dropdown`, popup = (_a = holderRef.current) === null || _a === void 0 ? void 0 : _a.querySelector(dropdownCls);
        popup && (clearInterval(interval), resizeObserver2.observe(popup));
      }, 10);
      return () => {
        clearInterval(interval), resizeObserver2.disconnect();
      };
    }
  }, []);
  let mergedProps = Object.assign(Object.assign({}, props), {
    style: Object.assign(Object.assign({}, style2), {
      margin: 0
    }),
    open,
    visible: open,
    getPopupContainer: /* @__PURE__ */ __name(() => holderRef.current, "getPopupContainer")
  });
  postProps && (mergedProps = postProps(mergedProps));
  const mergedStyle = {
    paddingBottom: popupHeight,
    position: "relative",
    minWidth: popupWidth
  };
  return /* @__PURE__ */ React.createElement("div", {
    ref: holderRef,
    style: mergedStyle
  }, /* @__PURE__ */ React.createElement(Component2, Object.assign({}, mergedProps)));
}, "PurePanel")), "genPurePanel"), isMobile = /* @__PURE__ */ __name(function() {
  if (typeof navigator > "u" || typeof window > "u")
    return !1;
  var agent = navigator.userAgent || navigator.vendor || window.opera;
  return /(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino|android|ipad|playbook|silk/i.test(agent) || /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw-(n|u)|c55\/|capi|ccwa|cdm-|cell|chtm|cldc|cmd-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc-s|devi|dica|dmob|do(c|p)o|ds(12|-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(-|_)|g1 u|g560|gene|gf-5|g-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd-(m|p|t)|hei-|hi(pt|ta)|hp( i|ip)|hs-c|ht(c(-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i-(20|go|ma)|i230|iac( |-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|-[a-w])|libw|lynx|m1-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|-([1-8]|c))|phil|pire|pl(ay|uc)|pn-2|po(ck|rt|se)|prox|psio|pt-g|qa-a|qc(07|12|21|32|60|-[2-7]|i-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h-|oo|p-)|sdk\/|se(c(-|0|1)|47|mc|nd|ri)|sgh-|shar|sie(-|m)|sk-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h-|v-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl-|tdg-|tel(i|m)|tim-|t-mo|to(pl|sh)|ts(70|m-|m3|m5)|tx-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas-|your|zeto|zte-/i.test(agent == null ? void 0 : agent.substr(0, 4));
}, "isMobile");
var TransBtn = /* @__PURE__ */ __name(function(props) {
  var className = props.className, customizeIcon = props.customizeIcon, customizeIconProps = props.customizeIconProps, children = props.children, _onMouseDown = props.onMouseDown, onClick = props.onClick, icon = typeof customizeIcon == "function" ? customizeIcon(customizeIconProps) : customizeIcon;
  return /* @__PURE__ */ React.createElement("span", {
    className,
    onMouseDown: /* @__PURE__ */ __name(function(event) {
      event.preventDefault(), _onMouseDown == null || _onMouseDown(event);
    }, "onMouseDown"),
    style: {
      userSelect: "none",
      WebkitUserSelect: "none"
    },
    unselectable: "on",
    onClick,
    "aria-hidden": !0
  }, icon !== void 0 ? icon : /* @__PURE__ */ React.createElement("span", {
    className: cn(className.split(/\s+/).map(function(cls) {
      return "".concat(cls, "-icon");
    }))
  }, children));
}, "TransBtn"), useAllowClear = /* @__PURE__ */ __name(function(prefixCls, onClearMouseDown, displayValues, allowClear, clearIcon) {
  var disabled = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : !1, mergedSearchValue = arguments.length > 6 ? arguments[6] : void 0, mode = arguments.length > 7 ? arguments[7] : void 0, mergedClearIcon = React__default.useMemo(function() {
    if (_typeof$4(allowClear) === "object")
      return allowClear.clearIcon;
    if (clearIcon)
      return clearIcon;
  }, [allowClear, clearIcon]), mergedAllowClear = React__default.useMemo(function() {
    return !!(!disabled && allowClear && (displayValues.length || mergedSearchValue) && !(mode === "combobox" && mergedSearchValue === ""));
  }, [allowClear, disabled, displayValues.length, mergedSearchValue, mode]);
  return {
    allowClear: mergedAllowClear,
    clearIcon: /* @__PURE__ */ React__default.createElement(TransBtn, {
      className: "".concat(prefixCls, "-clear"),
      onMouseDown: onClearMouseDown,
      customizeIcon: mergedClearIcon
    }, "×")
  };
}, "useAllowClear"), BaseSelectContext = /* @__PURE__ */ React.createContext(null);
function useBaseProps() {
  return React.useContext(BaseSelectContext);
}
__name(useBaseProps, "useBaseProps");
function useDelayReset() {
  var timeout = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 10, _React$useState = React.useState(!1), _React$useState2 = _slicedToArray(_React$useState, 2), bool = _React$useState2[0], setBool = _React$useState2[1], delayRef = React.useRef(null), cancelLatest = /* @__PURE__ */ __name(function() {
    window.clearTimeout(delayRef.current);
  }, "cancelLatest");
  React.useEffect(function() {
    return cancelLatest;
  }, []);
  var delaySetBool = /* @__PURE__ */ __name(function(value, callback) {
    cancelLatest(), delayRef.current = window.setTimeout(function() {
      setBool(value), callback && callback();
    }, timeout);
  }, "delaySetBool");
  return [bool, delaySetBool, cancelLatest];
}
__name(useDelayReset, "useDelayReset");
function useLock() {
  var duration = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 250, lockRef = React.useRef(null), timeoutRef = React.useRef(null);
  React.useEffect(function() {
    return function() {
      window.clearTimeout(timeoutRef.current);
    };
  }, []);
  function doLock(locked) {
    (locked || lockRef.current === null) && (lockRef.current = locked), window.clearTimeout(timeoutRef.current), timeoutRef.current = window.setTimeout(function() {
      lockRef.current = null;
    }, duration);
  }
  return __name(doLock, "doLock"), [function() {
    return lockRef.current;
  }, doLock];
}
__name(useLock, "useLock");
function useSelectTriggerControl(elements, open, triggerOpen, customizedTrigger) {
  var propsRef = React.useRef(null);
  propsRef.current = {
    open,
    triggerOpen,
    customizedTrigger
  }, React.useEffect(function() {
    function onGlobalMouseDown(event) {
      var _propsRef$current;
      if (!((_propsRef$current = propsRef.current) !== null && _propsRef$current !== void 0 && _propsRef$current.customizedTrigger)) {
        var target = event.target;
        target.shadowRoot && event.composed && (target = event.composedPath()[0] || target), propsRef.current.open && elements().filter(function(element) {
          return element;
        }).every(function(element) {
          return !element.contains(target) && element !== target;
        }) && propsRef.current.triggerOpen(!1);
      }
    }
    return __name(onGlobalMouseDown, "onGlobalMouseDown"), window.addEventListener("mousedown", onGlobalMouseDown), function() {
      return window.removeEventListener("mousedown", onGlobalMouseDown);
    };
  }, []);
}
__name(useSelectTriggerControl, "useSelectTriggerControl");
function isValidateOpenKey(currentKeyCode) {
  return (
    // Undefined for Edge bug:
    // https://github.com/ant-design/ant-design/issues/51292
    currentKeyCode && // Other keys
    ![
      // System function button
      KeyCode.ESC,
      KeyCode.SHIFT,
      KeyCode.BACKSPACE,
      KeyCode.TAB,
      KeyCode.WIN_KEY,
      KeyCode.ALT,
      KeyCode.META,
      KeyCode.WIN_KEY_RIGHT,
      KeyCode.CTRL,
      KeyCode.SEMICOLON,
      KeyCode.EQUALS,
      KeyCode.CAPS_LOCK,
      KeyCode.CONTEXT_MENU,
      // F1-F12
      KeyCode.F1,
      KeyCode.F2,
      KeyCode.F3,
      KeyCode.F4,
      KeyCode.F5,
      KeyCode.F6,
      KeyCode.F7,
      KeyCode.F8,
      KeyCode.F9,
      KeyCode.F10,
      KeyCode.F11,
      KeyCode.F12
    ].includes(currentKeyCode)
  );
}
__name(isValidateOpenKey, "isValidateOpenKey");
var _excluded$J = ["prefixCls", "invalidate", "item", "renderItem", "responsive", "responsiveDisabled", "registerSize", "itemKey", "className", "style", "children", "display", "order", "component"], UNDEFINED = void 0;
function InternalItem(props, ref) {
  var prefixCls = props.prefixCls, invalidate = props.invalidate, item = props.item, renderItem = props.renderItem, responsive = props.responsive, responsiveDisabled = props.responsiveDisabled, registerSize = props.registerSize, itemKey2 = props.itemKey, className = props.className, style2 = props.style, children = props.children, display = props.display, order2 = props.order, _props$component = props.component, Component2 = _props$component === void 0 ? "div" : _props$component, restProps = _objectWithoutProperties(props, _excluded$J), mergedHidden = responsive && !display;
  function internalRegisterSize(width) {
    registerSize(itemKey2, width);
  }
  __name(internalRegisterSize, "internalRegisterSize"), React.useEffect(function() {
    return function() {
      internalRegisterSize(null);
    };
  }, []);
  var childNode = renderItem && item !== UNDEFINED ? renderItem(item, {
    index: order2
  }) : children, overflowStyle;
  invalidate || (overflowStyle = {
    opacity: mergedHidden ? 0 : 1,
    height: mergedHidden ? 0 : UNDEFINED,
    overflowY: mergedHidden ? "hidden" : UNDEFINED,
    order: responsive ? order2 : UNDEFINED,
    pointerEvents: mergedHidden ? "none" : UNDEFINED,
    position: mergedHidden ? "absolute" : UNDEFINED
  });
  var overflowProps = {};
  mergedHidden && (overflowProps["aria-hidden"] = !0);
  var itemNode = /* @__PURE__ */ React.createElement(Component2, _extends({
    className: cn(!invalidate && prefixCls, className),
    style: _objectSpread2$1(_objectSpread2$1({}, overflowStyle), style2)
  }, overflowProps, restProps, {
    ref
  }), childNode);
  return responsive && (itemNode = /* @__PURE__ */ React.createElement(RefResizeObserver, {
    onResize: /* @__PURE__ */ __name(function(_ref) {
      var offsetWidth = _ref.offsetWidth;
      internalRegisterSize(offsetWidth);
    }, "onResize"),
    disabled: responsiveDisabled
  }, itemNode)), itemNode;
}
__name(InternalItem, "InternalItem");
var Item$2 = /* @__PURE__ */ React.forwardRef(InternalItem);
Item$2.displayName = "Item";
function channelUpdate(callback) {
  if (typeof MessageChannel > "u")
    wrapperRaf(callback);
  else {
    var channel = new MessageChannel();
    channel.port1.onmessage = function() {
      return callback();
    }, channel.port2.postMessage(void 0);
  }
}
__name(channelUpdate, "channelUpdate");
function useBatcher() {
  var updateFuncRef = React.useRef(null), notifyEffectUpdate = /* @__PURE__ */ __name(function(callback) {
    updateFuncRef.current || (updateFuncRef.current = [], channelUpdate(function() {
      unstable_batchedUpdates(function() {
        updateFuncRef.current.forEach(function(fn) {
          fn();
        }), updateFuncRef.current = null;
      });
    })), updateFuncRef.current.push(callback);
  }, "notifyEffectUpdate");
  return notifyEffectUpdate;
}
__name(useBatcher, "useBatcher");
function useEffectState(notifyEffectUpdate, defaultValue) {
  var _React$useState = React.useState(defaultValue), _React$useState2 = _slicedToArray(_React$useState, 2), stateValue = _React$useState2[0], setStateValue = _React$useState2[1], setEffectVal = useEvent(function(nextValue) {
    notifyEffectUpdate(function() {
      setStateValue(nextValue);
    });
  });
  return [stateValue, setEffectVal];
}
__name(useEffectState, "useEffectState");
var OverflowContext = /* @__PURE__ */ React__default.createContext(null), _excluded$I = ["component"], _excluded2$8 = ["className"], _excluded3$2 = ["className"], InternalRawItem = /* @__PURE__ */ __name(function(props, ref) {
  var context = React.useContext(OverflowContext);
  if (!context) {
    var _props$component = props.component, Component2 = _props$component === void 0 ? "div" : _props$component, _restProps = _objectWithoutProperties(props, _excluded$I);
    return /* @__PURE__ */ React.createElement(Component2, _extends({}, _restProps, {
      ref
    }));
  }
  var contextClassName = context.className, restContext = _objectWithoutProperties(context, _excluded2$8), className = props.className, restProps = _objectWithoutProperties(props, _excluded3$2);
  return /* @__PURE__ */ React.createElement(OverflowContext.Provider, {
    value: null
  }, /* @__PURE__ */ React.createElement(Item$2, _extends({
    ref,
    className: cn(contextClassName, className)
  }, restContext, restProps)));
}, "InternalRawItem"), RawItem = /* @__PURE__ */ React.forwardRef(InternalRawItem);
RawItem.displayName = "RawItem";
var _excluded$H = ["prefixCls", "data", "renderItem", "renderRawItem", "itemKey", "itemWidth", "ssr", "style", "className", "maxCount", "renderRest", "renderRawRest", "suffix", "component", "itemComponent", "onVisibleChange"], RESPONSIVE = "responsive", INVALIDATE = "invalidate";
function defaultRenderRest(omittedItems) {
  return "+ ".concat(omittedItems.length, " ...");
}
__name(defaultRenderRest, "defaultRenderRest");
function Overflow(props, ref) {
  var _props$prefixCls = props.prefixCls, prefixCls = _props$prefixCls === void 0 ? "rc-overflow" : _props$prefixCls, _props$data = props.data, data = _props$data === void 0 ? [] : _props$data, renderItem = props.renderItem, renderRawItem = props.renderRawItem, itemKey2 = props.itemKey, _props$itemWidth = props.itemWidth, itemWidth = _props$itemWidth === void 0 ? 10 : _props$itemWidth, ssr = props.ssr, style2 = props.style, className = props.className, maxCount = props.maxCount, renderRest = props.renderRest, renderRawRest = props.renderRawRest, suffix = props.suffix, _props$component = props.component, Component2 = _props$component === void 0 ? "div" : _props$component, itemComponent = props.itemComponent, onVisibleChange = props.onVisibleChange, restProps = _objectWithoutProperties(props, _excluded$H), fullySSR = ssr === "full", notifyEffectUpdate = useBatcher(), _useEffectState = useEffectState(notifyEffectUpdate, null), _useEffectState2 = _slicedToArray(_useEffectState, 2), containerWidth = _useEffectState2[0], setContainerWidth = _useEffectState2[1], mergedContainerWidth = containerWidth || 0, _useEffectState3 = useEffectState(notifyEffectUpdate, /* @__PURE__ */ new Map()), _useEffectState4 = _slicedToArray(_useEffectState3, 2), itemWidths = _useEffectState4[0], setItemWidths = _useEffectState4[1], _useEffectState5 = useEffectState(notifyEffectUpdate, 0), _useEffectState6 = _slicedToArray(_useEffectState5, 2), prevRestWidth = _useEffectState6[0], setPrevRestWidth = _useEffectState6[1], _useEffectState7 = useEffectState(notifyEffectUpdate, 0), _useEffectState8 = _slicedToArray(_useEffectState7, 2), restWidth = _useEffectState8[0], setRestWidth = _useEffectState8[1], _useEffectState9 = useEffectState(notifyEffectUpdate, 0), _useEffectState10 = _slicedToArray(_useEffectState9, 2), suffixWidth = _useEffectState10[0], setSuffixWidth = _useEffectState10[1], _useState = useState(null), _useState2 = _slicedToArray(_useState, 2), suffixFixedStart = _useState2[0], setSuffixFixedStart = _useState2[1], _useState3 = useState(null), _useState4 = _slicedToArray(_useState3, 2), displayCount = _useState4[0], setDisplayCount = _useState4[1], mergedDisplayCount = React.useMemo(function() {
    return displayCount === null && fullySSR ? Number.MAX_SAFE_INTEGER : displayCount || 0;
  }, [displayCount, containerWidth]), _useState5 = useState(!1), _useState6 = _slicedToArray(_useState5, 2), restReady = _useState6[0], setRestReady = _useState6[1], itemPrefixCls = "".concat(prefixCls, "-item"), mergedRestWidth = Math.max(prevRestWidth, restWidth), isResponsive = maxCount === RESPONSIVE, shouldResponsive = data.length && isResponsive, invalidate = maxCount === INVALIDATE, showRest = shouldResponsive || typeof maxCount == "number" && data.length > maxCount, mergedData = useMemo$1(function() {
    var items = data;
    return shouldResponsive ? containerWidth === null && fullySSR ? items = data : items = data.slice(0, Math.min(data.length, mergedContainerWidth / itemWidth)) : typeof maxCount == "number" && (items = data.slice(0, maxCount)), items;
  }, [data, itemWidth, containerWidth, maxCount, shouldResponsive]), omittedItems = useMemo$1(function() {
    return shouldResponsive ? data.slice(mergedDisplayCount + 1) : data.slice(mergedData.length);
  }, [data, mergedData, shouldResponsive, mergedDisplayCount]), getKey2 = useCallback(function(item, index2) {
    var _ref;
    return typeof itemKey2 == "function" ? itemKey2(item) : (_ref = itemKey2 && (item == null ? void 0 : item[itemKey2])) !== null && _ref !== void 0 ? _ref : index2;
  }, [itemKey2]), mergedRenderItem = useCallback(renderItem || function(item) {
    return item;
  }, [renderItem]);
  function updateDisplayCount(count, suffixFixedStartVal, notReady) {
    displayCount === count && (suffixFixedStartVal === void 0 || suffixFixedStartVal === suffixFixedStart) || (setDisplayCount(count), notReady || (setRestReady(count < data.length - 1), onVisibleChange == null || onVisibleChange(count)), suffixFixedStartVal !== void 0 && setSuffixFixedStart(suffixFixedStartVal));
  }
  __name(updateDisplayCount, "updateDisplayCount");
  function onOverflowResize(_2, element) {
    setContainerWidth(element.clientWidth);
  }
  __name(onOverflowResize, "onOverflowResize");
  function registerSize(key, width) {
    setItemWidths(function(origin) {
      var clone = new Map(origin);
      return width === null ? clone.delete(key) : clone.set(key, width), clone;
    });
  }
  __name(registerSize, "registerSize");
  function registerOverflowSize(_2, width) {
    setRestWidth(width), setPrevRestWidth(restWidth);
  }
  __name(registerOverflowSize, "registerOverflowSize");
  function registerSuffixSize(_2, width) {
    setSuffixWidth(width);
  }
  __name(registerSuffixSize, "registerSuffixSize");
  function getItemWidth(index2) {
    return itemWidths.get(getKey2(mergedData[index2], index2));
  }
  __name(getItemWidth, "getItemWidth"), useLayoutEffect$1(function() {
    if (mergedContainerWidth && typeof mergedRestWidth == "number" && mergedData) {
      var totalWidth = suffixWidth, len = mergedData.length, lastIndex = len - 1;
      if (!len) {
        updateDisplayCount(0, null);
        return;
      }
      for (var i = 0; i < len; i += 1) {
        var currentItemWidth = getItemWidth(i);
        if (fullySSR && (currentItemWidth = currentItemWidth || 0), currentItemWidth === void 0) {
          updateDisplayCount(i - 1, void 0, !0);
          break;
        }
        if (totalWidth += currentItemWidth, // Only one means `totalWidth` is the final width
        lastIndex === 0 && totalWidth <= mergedContainerWidth || // Last two width will be the final width
        i === lastIndex - 1 && totalWidth + getItemWidth(lastIndex) <= mergedContainerWidth) {
          updateDisplayCount(lastIndex, null);
          break;
        } else if (totalWidth + mergedRestWidth > mergedContainerWidth) {
          updateDisplayCount(i - 1, totalWidth - currentItemWidth - suffixWidth + restWidth);
          break;
        }
      }
      suffix && getItemWidth(0) + suffixWidth > mergedContainerWidth && setSuffixFixedStart(null);
    }
  }, [mergedContainerWidth, itemWidths, restWidth, suffixWidth, getKey2, mergedData]);
  var displayRest = restReady && !!omittedItems.length, suffixStyle = {};
  suffixFixedStart !== null && shouldResponsive && (suffixStyle = {
    position: "absolute",
    left: suffixFixedStart,
    top: 0
  });
  var itemSharedProps = {
    prefixCls: itemPrefixCls,
    responsive: shouldResponsive,
    component: itemComponent,
    invalidate
  }, internalRenderItemNode = renderRawItem ? function(item, index2) {
    var key = getKey2(item, index2);
    return /* @__PURE__ */ React.createElement(OverflowContext.Provider, {
      key,
      value: _objectSpread2$1(_objectSpread2$1({}, itemSharedProps), {}, {
        order: index2,
        item,
        itemKey: key,
        registerSize,
        display: index2 <= mergedDisplayCount
      })
    }, renderRawItem(item, index2));
  } : function(item, index2) {
    var key = getKey2(item, index2);
    return /* @__PURE__ */ React.createElement(Item$2, _extends({}, itemSharedProps, {
      order: index2,
      key,
      item,
      renderItem: mergedRenderItem,
      itemKey: key,
      registerSize,
      display: index2 <= mergedDisplayCount
    }));
  }, restContextProps = {
    order: displayRest ? mergedDisplayCount : Number.MAX_SAFE_INTEGER,
    className: "".concat(itemPrefixCls, "-rest"),
    registerSize: registerOverflowSize,
    display: displayRest
  }, mergedRenderRest = renderRest || defaultRenderRest, restNode = renderRawRest ? /* @__PURE__ */ React.createElement(OverflowContext.Provider, {
    value: _objectSpread2$1(_objectSpread2$1({}, itemSharedProps), restContextProps)
  }, renderRawRest(omittedItems)) : /* @__PURE__ */ React.createElement(Item$2, _extends({}, itemSharedProps, restContextProps), typeof mergedRenderRest == "function" ? mergedRenderRest(omittedItems) : mergedRenderRest), overflowNode = /* @__PURE__ */ React.createElement(Component2, _extends({
    className: cn(!invalidate && prefixCls, className),
    style: style2,
    ref
  }, restProps), mergedData.map(internalRenderItemNode), showRest ? restNode : null, suffix && /* @__PURE__ */ React.createElement(Item$2, _extends({}, itemSharedProps, {
    responsive: isResponsive,
    responsiveDisabled: !shouldResponsive,
    order: mergedDisplayCount,
    className: "".concat(itemPrefixCls, "-suffix"),
    registerSize: registerSuffixSize,
    display: !0,
    style: suffixStyle
  }), suffix));
  return isResponsive ? /* @__PURE__ */ React.createElement(RefResizeObserver, {
    onResize: onOverflowResize,
    disabled: !shouldResponsive
  }, overflowNode) : overflowNode;
}
__name(Overflow, "Overflow");
var ForwardOverflow = /* @__PURE__ */ React.forwardRef(Overflow);
ForwardOverflow.displayName = "Overflow";
ForwardOverflow.Item = RawItem;
ForwardOverflow.RESPONSIVE = RESPONSIVE;
ForwardOverflow.INVALIDATE = INVALIDATE;
var Input$5 = /* @__PURE__ */ __name(function(props, ref) {
  var _inputNode2, prefixCls = props.prefixCls, id2 = props.id, inputElement = props.inputElement, disabled = props.disabled, tabIndex = props.tabIndex, autoFocus = props.autoFocus, autoComplete = props.autoComplete, editable = props.editable, activeDescendantId = props.activeDescendantId, value = props.value, maxLength = props.maxLength, _onKeyDown = props.onKeyDown, _onMouseDown = props.onMouseDown, _onChange = props.onChange, onPaste = props.onPaste, _onCompositionStart = props.onCompositionStart, _onCompositionEnd = props.onCompositionEnd, _onBlur = props.onBlur, open = props.open, attrs = props.attrs, inputNode = inputElement || /* @__PURE__ */ React.createElement("input", null), _inputNode = inputNode, originRef = _inputNode.ref, originProps = _inputNode.props, onOriginKeyDown = originProps.onKeyDown, onOriginChange = originProps.onChange, onOriginMouseDown = originProps.onMouseDown, onOriginCompositionStart = originProps.onCompositionStart, onOriginCompositionEnd = originProps.onCompositionEnd, onOriginBlur = originProps.onBlur, style2 = originProps.style;
  return warning$3(!("maxLength" in inputNode.props), "Passing 'maxLength' to input element directly may not work because input in BaseSelect is controlled."), inputNode = /* @__PURE__ */ React.cloneElement(inputNode, _objectSpread2$1(_objectSpread2$1(_objectSpread2$1({
    type: "search"
  }, originProps), {}, {
    // Override over origin props
    id: id2,
    ref: composeRef(ref, originRef),
    disabled,
    tabIndex,
    autoComplete: autoComplete || "off",
    autoFocus,
    className: cn("".concat(prefixCls, "-selection-search-input"), (_inputNode2 = inputNode) === null || _inputNode2 === void 0 || (_inputNode2 = _inputNode2.props) === null || _inputNode2 === void 0 ? void 0 : _inputNode2.className),
    role: "combobox",
    "aria-expanded": open || !1,
    "aria-haspopup": "listbox",
    "aria-owns": "".concat(id2, "_list"),
    "aria-autocomplete": "list",
    "aria-controls": "".concat(id2, "_list"),
    "aria-activedescendant": open ? activeDescendantId : void 0
  }, attrs), {}, {
    value: editable ? value : "",
    maxLength,
    readOnly: !editable,
    unselectable: editable ? null : "on",
    style: _objectSpread2$1(_objectSpread2$1({}, style2), {}, {
      opacity: editable ? null : 0
    }),
    onKeyDown: /* @__PURE__ */ __name(function(event) {
      _onKeyDown(event), onOriginKeyDown && onOriginKeyDown(event);
    }, "onKeyDown"),
    onMouseDown: /* @__PURE__ */ __name(function(event) {
      _onMouseDown(event), onOriginMouseDown && onOriginMouseDown(event);
    }, "onMouseDown"),
    onChange: /* @__PURE__ */ __name(function(event) {
      _onChange(event), onOriginChange && onOriginChange(event);
    }, "onChange"),
    onCompositionStart: /* @__PURE__ */ __name(function(event) {
      _onCompositionStart(event), onOriginCompositionStart && onOriginCompositionStart(event);
    }, "onCompositionStart"),
    onCompositionEnd: /* @__PURE__ */ __name(function(event) {
      _onCompositionEnd(event), onOriginCompositionEnd && onOriginCompositionEnd(event);
    }, "onCompositionEnd"),
    onPaste,
    onBlur: /* @__PURE__ */ __name(function(event) {
      _onBlur(event), onOriginBlur && onOriginBlur(event);
    }, "onBlur")
  })), inputNode;
}, "Input"), RefInput = /* @__PURE__ */ React.forwardRef(Input$5);
process.env.NODE_ENV !== "production" && (RefInput.displayName = "Input");
function toArray$5(value) {
  return Array.isArray(value) ? value : value !== void 0 ? [value] : [];
}
__name(toArray$5, "toArray$5");
var isClient = typeof window < "u" && window.document && window.document.documentElement, isBrowserClient$2 = process.env.NODE_ENV !== "test" && isClient;
function hasValue(value) {
  return value != null;
}
__name(hasValue, "hasValue");
function isComboNoValue(value) {
  return !value && value !== 0;
}
__name(isComboNoValue, "isComboNoValue");
function isTitleType$1(title2) {
  return ["string", "number"].includes(_typeof$4(title2));
}
__name(isTitleType$1, "isTitleType$1");
function getTitle(item) {
  var title2 = void 0;
  return item && (isTitleType$1(item.title) ? title2 = item.title.toString() : isTitleType$1(item.label) && (title2 = item.label.toString())), title2;
}
__name(getTitle, "getTitle");
function useLayoutEffect2(effect, deps) {
  isBrowserClient$2 ? React.useLayoutEffect(effect, deps) : React.useEffect(effect, deps);
}
__name(useLayoutEffect2, "useLayoutEffect");
function itemKey$1(value) {
  var _value$key;
  return (_value$key = value.key) !== null && _value$key !== void 0 ? _value$key : value.value;
}
__name(itemKey$1, "itemKey$1");
var onPreventMouseDown = /* @__PURE__ */ __name(function(event) {
  event.preventDefault(), event.stopPropagation();
}, "onPreventMouseDown"), SelectSelector = /* @__PURE__ */ __name(function(props) {
  var id2 = props.id, prefixCls = props.prefixCls, values = props.values, open = props.open, searchValue = props.searchValue, autoClearSearchValue = props.autoClearSearchValue, inputRef = props.inputRef, placeholder = props.placeholder, disabled = props.disabled, mode = props.mode, showSearch = props.showSearch, autoFocus = props.autoFocus, autoComplete = props.autoComplete, activeDescendantId = props.activeDescendantId, tabIndex = props.tabIndex, removeIcon = props.removeIcon, maxTagCount = props.maxTagCount, maxTagTextLength = props.maxTagTextLength, _props$maxTagPlacehol = props.maxTagPlaceholder, maxTagPlaceholder = _props$maxTagPlacehol === void 0 ? function(omittedValues) {
    return "+ ".concat(omittedValues.length, " ...");
  } : _props$maxTagPlacehol, tagRender = props.tagRender, onToggleOpen = props.onToggleOpen, onRemove = props.onRemove, onInputChange = props.onInputChange, onInputPaste = props.onInputPaste, onInputKeyDown = props.onInputKeyDown, onInputMouseDown = props.onInputMouseDown, onInputCompositionStart = props.onInputCompositionStart, onInputCompositionEnd = props.onInputCompositionEnd, onInputBlur = props.onInputBlur, measureRef = React.useRef(null), _useState = useState(0), _useState2 = _slicedToArray(_useState, 2), inputWidth = _useState2[0], setInputWidth = _useState2[1], _useState3 = useState(!1), _useState4 = _slicedToArray(_useState3, 2), focused = _useState4[0], setFocused = _useState4[1], selectionPrefixCls = "".concat(prefixCls, "-selection"), inputValue = open || mode === "multiple" && autoClearSearchValue === !1 || mode === "tags" ? searchValue : "", inputEditable = mode === "tags" || mode === "multiple" && autoClearSearchValue === !1 || showSearch && (open || focused);
  useLayoutEffect2(function() {
    setInputWidth(measureRef.current.scrollWidth);
  }, [inputValue]);
  var defaultRenderSelector = /* @__PURE__ */ __name(function(item, content, itemDisabled, closable, onClose) {
    return /* @__PURE__ */ React.createElement("span", {
      title: getTitle(item),
      className: cn("".concat(selectionPrefixCls, "-item"), _defineProperty$2({}, "".concat(selectionPrefixCls, "-item-disabled"), itemDisabled))
    }, /* @__PURE__ */ React.createElement("span", {
      className: "".concat(selectionPrefixCls, "-item-content")
    }, content), closable && /* @__PURE__ */ React.createElement(TransBtn, {
      className: "".concat(selectionPrefixCls, "-item-remove"),
      onMouseDown: onPreventMouseDown,
      onClick: onClose,
      customizeIcon: removeIcon
    }, "×"));
  }, "defaultRenderSelector"), customizeRenderSelector = /* @__PURE__ */ __name(function(value, content, itemDisabled, closable, onClose, isMaxTag) {
    var onMouseDown = /* @__PURE__ */ __name(function(e2) {
      onPreventMouseDown(e2), onToggleOpen(!open);
    }, "onMouseDown");
    return /* @__PURE__ */ React.createElement("span", {
      onMouseDown
    }, tagRender({
      label: content,
      value,
      disabled: itemDisabled,
      closable,
      onClose,
      isMaxTag: !!isMaxTag
    }));
  }, "customizeRenderSelector"), renderItem = /* @__PURE__ */ __name(function(valueItem) {
    var itemDisabled = valueItem.disabled, label2 = valueItem.label, value = valueItem.value, closable = !disabled && !itemDisabled, displayLabel = label2;
    if (typeof maxTagTextLength == "number" && (typeof label2 == "string" || typeof label2 == "number")) {
      var strLabel = String(displayLabel);
      strLabel.length > maxTagTextLength && (displayLabel = "".concat(strLabel.slice(0, maxTagTextLength), "..."));
    }
    var onClose = /* @__PURE__ */ __name(function(event) {
      event && event.stopPropagation(), onRemove(valueItem);
    }, "onClose");
    return typeof tagRender == "function" ? customizeRenderSelector(value, displayLabel, itemDisabled, closable, onClose) : defaultRenderSelector(valueItem, displayLabel, itemDisabled, closable, onClose);
  }, "renderItem"), renderRest = /* @__PURE__ */ __name(function(omittedValues) {
    if (!values.length)
      return null;
    var content = typeof maxTagPlaceholder == "function" ? maxTagPlaceholder(omittedValues) : maxTagPlaceholder;
    return typeof tagRender == "function" ? customizeRenderSelector(void 0, content, !1, !1, void 0, !0) : defaultRenderSelector({
      title: content
    }, content, !1);
  }, "renderRest"), inputNode = /* @__PURE__ */ React.createElement("div", {
    className: "".concat(selectionPrefixCls, "-search"),
    style: {
      width: inputWidth
    },
    onFocus: /* @__PURE__ */ __name(function() {
      setFocused(!0);
    }, "onFocus"),
    onBlur: /* @__PURE__ */ __name(function() {
      setFocused(!1);
    }, "onBlur")
  }, /* @__PURE__ */ React.createElement(RefInput, {
    ref: inputRef,
    open,
    prefixCls,
    id: id2,
    inputElement: null,
    disabled,
    autoFocus,
    autoComplete,
    editable: inputEditable,
    activeDescendantId,
    value: inputValue,
    onKeyDown: onInputKeyDown,
    onMouseDown: onInputMouseDown,
    onChange: onInputChange,
    onPaste: onInputPaste,
    onCompositionStart: onInputCompositionStart,
    onCompositionEnd: onInputCompositionEnd,
    onBlur: onInputBlur,
    tabIndex,
    attrs: pickAttrs(props, !0)
  }), /* @__PURE__ */ React.createElement("span", {
    ref: measureRef,
    className: "".concat(selectionPrefixCls, "-search-mirror"),
    "aria-hidden": !0
  }, inputValue, " ")), selectionNode = /* @__PURE__ */ React.createElement(ForwardOverflow, {
    prefixCls: "".concat(selectionPrefixCls, "-overflow"),
    data: values,
    renderItem,
    renderRest,
    suffix: inputNode,
    itemKey: itemKey$1,
    maxCount: maxTagCount
  });
  return /* @__PURE__ */ React.createElement("span", {
    className: "".concat(selectionPrefixCls, "-wrap")
  }, selectionNode, !values.length && !inputValue && /* @__PURE__ */ React.createElement("span", {
    className: "".concat(selectionPrefixCls, "-placeholder")
  }, placeholder));
}, "SelectSelector"), SingleSelector$1 = /* @__PURE__ */ __name(function(props) {
  var inputElement = props.inputElement, prefixCls = props.prefixCls, id2 = props.id, inputRef = props.inputRef, disabled = props.disabled, autoFocus = props.autoFocus, autoComplete = props.autoComplete, activeDescendantId = props.activeDescendantId, mode = props.mode, open = props.open, values = props.values, placeholder = props.placeholder, tabIndex = props.tabIndex, showSearch = props.showSearch, searchValue = props.searchValue, activeValue = props.activeValue, maxLength = props.maxLength, onInputKeyDown = props.onInputKeyDown, onInputMouseDown = props.onInputMouseDown, onInputChange = props.onInputChange, onInputPaste = props.onInputPaste, onInputCompositionStart = props.onInputCompositionStart, onInputCompositionEnd = props.onInputCompositionEnd, onInputBlur = props.onInputBlur, title2 = props.title, _React$useState = React.useState(!1), _React$useState2 = _slicedToArray(_React$useState, 2), inputChanged = _React$useState2[0], setInputChanged = _React$useState2[1], combobox = mode === "combobox", inputEditable = combobox || showSearch, item = values[0], inputValue = searchValue || "";
  combobox && activeValue && !inputChanged && (inputValue = activeValue), React.useEffect(function() {
    combobox && setInputChanged(!1);
  }, [combobox, activeValue]);
  var hasTextInput = mode !== "combobox" && !open && !showSearch ? !1 : !!inputValue, selectionTitle = title2 === void 0 ? getTitle(item) : title2, placeholderNode = React.useMemo(function() {
    return item ? null : /* @__PURE__ */ React.createElement("span", {
      className: "".concat(prefixCls, "-selection-placeholder"),
      style: hasTextInput ? {
        visibility: "hidden"
      } : void 0
    }, placeholder);
  }, [item, hasTextInput, placeholder, prefixCls]);
  return /* @__PURE__ */ React.createElement("span", {
    className: "".concat(prefixCls, "-selection-wrap")
  }, /* @__PURE__ */ React.createElement("span", {
    className: "".concat(prefixCls, "-selection-search")
  }, /* @__PURE__ */ React.createElement(RefInput, {
    ref: inputRef,
    prefixCls,
    id: id2,
    open,
    inputElement,
    disabled,
    autoFocus,
    autoComplete,
    editable: inputEditable,
    activeDescendantId,
    value: inputValue,
    onKeyDown: onInputKeyDown,
    onMouseDown: onInputMouseDown,
    onChange: /* @__PURE__ */ __name(function(e2) {
      setInputChanged(!0), onInputChange(e2);
    }, "onChange"),
    onPaste: onInputPaste,
    onCompositionStart: onInputCompositionStart,
    onCompositionEnd: onInputCompositionEnd,
    onBlur: onInputBlur,
    tabIndex,
    attrs: pickAttrs(props, !0),
    maxLength: combobox ? maxLength : void 0
  })), !combobox && item ? /* @__PURE__ */ React.createElement("span", {
    className: "".concat(prefixCls, "-selection-item"),
    title: selectionTitle,
    style: hasTextInput ? {
      visibility: "hidden"
    } : void 0
  }, item.label) : null, placeholderNode);
}, "SingleSelector"), Selector = /* @__PURE__ */ __name(function(props, ref) {
  var inputRef = useRef(null), compositionStatusRef = useRef(!1), prefixCls = props.prefixCls, open = props.open, mode = props.mode, showSearch = props.showSearch, tokenWithEnter = props.tokenWithEnter, disabled = props.disabled, prefix = props.prefix, autoClearSearchValue = props.autoClearSearchValue, onSearch = props.onSearch, onSearchSubmit = props.onSearchSubmit, onToggleOpen = props.onToggleOpen, onInputKeyDown = props.onInputKeyDown, onInputBlur = props.onInputBlur, domRef = props.domRef;
  React.useImperativeHandle(ref, function() {
    return {
      focus: /* @__PURE__ */ __name(function(options) {
        inputRef.current.focus(options);
      }, "focus"),
      blur: /* @__PURE__ */ __name(function() {
        inputRef.current.blur();
      }, "blur")
    };
  });
  var _useLock = useLock(0), _useLock2 = _slicedToArray(_useLock, 2), getInputMouseDown = _useLock2[0], setInputMouseDown = _useLock2[1], onInternalInputKeyDown = /* @__PURE__ */ __name(function(event) {
    var which = event.which, isTextAreaElement = inputRef.current instanceof HTMLTextAreaElement;
    !isTextAreaElement && open && (which === KeyCode.UP || which === KeyCode.DOWN) && event.preventDefault(), onInputKeyDown && onInputKeyDown(event), which === KeyCode.ENTER && mode === "tags" && !compositionStatusRef.current && !open && (onSearchSubmit == null || onSearchSubmit(event.target.value)), !(isTextAreaElement && !open && ~[KeyCode.UP, KeyCode.DOWN, KeyCode.LEFT, KeyCode.RIGHT].indexOf(which)) && isValidateOpenKey(which) && onToggleOpen(!0);
  }, "onInternalInputKeyDown"), onInternalInputMouseDown = /* @__PURE__ */ __name(function() {
    setInputMouseDown(!0);
  }, "onInternalInputMouseDown"), pastedTextRef = useRef(null), triggerOnSearch = /* @__PURE__ */ __name(function(value) {
    onSearch(value, !0, compositionStatusRef.current) !== !1 && onToggleOpen(!0);
  }, "triggerOnSearch"), onInputCompositionStart = /* @__PURE__ */ __name(function() {
    compositionStatusRef.current = !0;
  }, "onInputCompositionStart"), onInputCompositionEnd = /* @__PURE__ */ __name(function(e2) {
    compositionStatusRef.current = !1, mode !== "combobox" && triggerOnSearch(e2.target.value);
  }, "onInputCompositionEnd"), onInputChange = /* @__PURE__ */ __name(function(event) {
    var value = event.target.value;
    if (tokenWithEnter && pastedTextRef.current && /[\r\n]/.test(pastedTextRef.current)) {
      var replacedText = pastedTextRef.current.replace(/[\r\n]+$/, "").replace(/\r\n/g, " ").replace(/[\r\n]/g, " ");
      value = value.replace(replacedText, pastedTextRef.current);
    }
    pastedTextRef.current = null, triggerOnSearch(value);
  }, "onInputChange"), onInputPaste = /* @__PURE__ */ __name(function(e2) {
    var clipboardData = e2.clipboardData, value = clipboardData == null ? void 0 : clipboardData.getData("text");
    pastedTextRef.current = value || "";
  }, "onInputPaste"), onClick = /* @__PURE__ */ __name(function(_ref) {
    var target = _ref.target;
    if (target !== inputRef.current) {
      var isIE = document.body.style.msTouchAction !== void 0;
      isIE ? setTimeout(function() {
        inputRef.current.focus();
      }) : inputRef.current.focus();
    }
  }, "onClick"), onMouseDown = /* @__PURE__ */ __name(function(event) {
    var inputMouseDown = getInputMouseDown();
    event.target !== inputRef.current && !inputMouseDown && !(mode === "combobox" && disabled) && event.preventDefault(), (mode !== "combobox" && (!showSearch || !inputMouseDown) || !open) && (open && autoClearSearchValue !== !1 && onSearch("", !0, !1), onToggleOpen());
  }, "onMouseDown"), sharedProps = {
    inputRef,
    onInputKeyDown: onInternalInputKeyDown,
    onInputMouseDown: onInternalInputMouseDown,
    onInputChange,
    onInputPaste,
    onInputCompositionStart,
    onInputCompositionEnd,
    onInputBlur
  }, selectNode = mode === "multiple" || mode === "tags" ? /* @__PURE__ */ React.createElement(SelectSelector, _extends({}, props, sharedProps)) : /* @__PURE__ */ React.createElement(SingleSelector$1, _extends({}, props, sharedProps));
  return /* @__PURE__ */ React.createElement("div", {
    ref: domRef,
    className: "".concat(prefixCls, "-selector"),
    onClick,
    onMouseDown
  }, prefix && /* @__PURE__ */ React.createElement("div", {
    className: "".concat(prefixCls, "-prefix")
  }, prefix), selectNode);
}, "Selector"), ForwardSelector = /* @__PURE__ */ React.forwardRef(Selector);
process.env.NODE_ENV !== "production" && (ForwardSelector.displayName = "Selector");
function Arrow(props) {
  var prefixCls = props.prefixCls, align = props.align, arrow = props.arrow, arrowPos = props.arrowPos, _ref = arrow || {}, className = _ref.className, content = _ref.content, _arrowPos$x = arrowPos.x, x = _arrowPos$x === void 0 ? 0 : _arrowPos$x, _arrowPos$y = arrowPos.y, y = _arrowPos$y === void 0 ? 0 : _arrowPos$y, arrowRef = React.useRef();
  if (!align || !align.points)
    return null;
  var alignStyle = {
    position: "absolute"
  };
  if (align.autoArrow !== !1) {
    var popupPoints = align.points[0], targetPoints = align.points[1], popupTB = popupPoints[0], popupLR = popupPoints[1], targetTB = targetPoints[0], targetLR = targetPoints[1];
    popupTB === targetTB || !["t", "b"].includes(popupTB) ? alignStyle.top = y : popupTB === "t" ? alignStyle.top = 0 : alignStyle.bottom = 0, popupLR === targetLR || !["l", "r"].includes(popupLR) ? alignStyle.left = x : popupLR === "l" ? alignStyle.left = 0 : alignStyle.right = 0;
  }
  return /* @__PURE__ */ React.createElement("div", {
    ref: arrowRef,
    className: cn("".concat(prefixCls, "-arrow"), className),
    style: alignStyle
  }, content);
}
__name(Arrow, "Arrow");
function Mask(props) {
  var prefixCls = props.prefixCls, open = props.open, zIndex = props.zIndex, mask = props.mask, motion2 = props.motion;
  return mask ? /* @__PURE__ */ React.createElement(CSSMotion, _extends({}, motion2, {
    motionAppear: !0,
    visible: open,
    removeOnLeave: !0
  }), function(_ref) {
    var className = _ref.className;
    return /* @__PURE__ */ React.createElement("div", {
      style: {
        zIndex
      },
      className: cn("".concat(prefixCls, "-mask"), className)
    });
  }) : null;
}
__name(Mask, "Mask");
var PopupContent = /* @__PURE__ */ React.memo(function(_ref) {
  var children = _ref.children;
  return children;
}, function(_2, next2) {
  return next2.cache;
});
process.env.NODE_ENV !== "production" && (PopupContent.displayName = "PopupContent");
var Popup$2 = /* @__PURE__ */ React.forwardRef(function(props, ref) {
  var popup = props.popup, className = props.className, prefixCls = props.prefixCls, style2 = props.style, target = props.target, _onVisibleChanged = props.onVisibleChanged, open = props.open, keepDom = props.keepDom, fresh = props.fresh, onClick = props.onClick, mask = props.mask, arrow = props.arrow, arrowPos = props.arrowPos, align = props.align, motion2 = props.motion, maskMotion = props.maskMotion, forceRender = props.forceRender, getPopupContainer = props.getPopupContainer, autoDestroy = props.autoDestroy, Portal2 = props.portal, zIndex = props.zIndex, onMouseEnter = props.onMouseEnter, onMouseLeave = props.onMouseLeave, onPointerEnter = props.onPointerEnter, onPointerDownCapture = props.onPointerDownCapture, ready = props.ready, offsetX = props.offsetX, offsetY = props.offsetY, offsetR = props.offsetR, offsetB = props.offsetB, onAlign = props.onAlign, onPrepare = props.onPrepare, stretch = props.stretch, targetWidth = props.targetWidth, targetHeight = props.targetHeight, childNode = typeof popup == "function" ? popup() : popup, isNodeVisible = open || keepDom, getPopupContainerNeedParams = (getPopupContainer == null ? void 0 : getPopupContainer.length) > 0, _React$useState = React.useState(!getPopupContainer || !getPopupContainerNeedParams), _React$useState2 = _slicedToArray(_React$useState, 2), show = _React$useState2[0], setShow = _React$useState2[1];
  if (useLayoutEffect$1(function() {
    !show && getPopupContainerNeedParams && target && setShow(!0);
  }, [show, getPopupContainerNeedParams, target]), !show)
    return null;
  var AUTO = "auto", offsetStyle = {
    left: "-1000vw",
    top: "-1000vh",
    right: AUTO,
    bottom: AUTO
  };
  if (ready || !open) {
    var _experimental, points = align.points, dynamicInset = align.dynamicInset || ((_experimental = align._experimental) === null || _experimental === void 0 ? void 0 : _experimental.dynamicInset), alignRight = dynamicInset && points[0][1] === "r", alignBottom = dynamicInset && points[0][0] === "b";
    alignRight ? (offsetStyle.right = offsetR, offsetStyle.left = AUTO) : (offsetStyle.left = offsetX, offsetStyle.right = AUTO), alignBottom ? (offsetStyle.bottom = offsetB, offsetStyle.top = AUTO) : (offsetStyle.top = offsetY, offsetStyle.bottom = AUTO);
  }
  var miscStyle = {};
  return stretch && (stretch.includes("height") && targetHeight ? miscStyle.height = targetHeight : stretch.includes("minHeight") && targetHeight && (miscStyle.minHeight = targetHeight), stretch.includes("width") && targetWidth ? miscStyle.width = targetWidth : stretch.includes("minWidth") && targetWidth && (miscStyle.minWidth = targetWidth)), open || (miscStyle.pointerEvents = "none"), /* @__PURE__ */ React.createElement(Portal2, {
    open: forceRender || isNodeVisible,
    getContainer: getPopupContainer && function() {
      return getPopupContainer(target);
    },
    autoDestroy
  }, /* @__PURE__ */ React.createElement(Mask, {
    prefixCls,
    open,
    zIndex,
    mask,
    motion: maskMotion
  }), /* @__PURE__ */ React.createElement(RefResizeObserver, {
    onResize: onAlign,
    disabled: !open
  }, function(resizeObserverRef) {
    return /* @__PURE__ */ React.createElement(CSSMotion, _extends({
      motionAppear: !0,
      motionEnter: !0,
      motionLeave: !0,
      removeOnLeave: !1,
      forceRender,
      leavedClassName: "".concat(prefixCls, "-hidden")
    }, motion2, {
      onAppearPrepare: onPrepare,
      onEnterPrepare: onPrepare,
      visible: open,
      onVisibleChanged: /* @__PURE__ */ __name(function(nextVisible) {
        var _motion$onVisibleChan;
        motion2 == null || (_motion$onVisibleChan = motion2.onVisibleChanged) === null || _motion$onVisibleChan === void 0 || _motion$onVisibleChan.call(motion2, nextVisible), _onVisibleChanged(nextVisible);
      }, "onVisibleChanged")
    }), function(_ref, motionRef) {
      var motionClassName = _ref.className, motionStyle = _ref.style, cls = cn(prefixCls, motionClassName, className);
      return /* @__PURE__ */ React.createElement("div", {
        ref: composeRef(resizeObserverRef, ref, motionRef),
        className: cls,
        style: _objectSpread2$1(_objectSpread2$1(_objectSpread2$1(_objectSpread2$1({
          "--arrow-x": "".concat(arrowPos.x || 0, "px"),
          "--arrow-y": "".concat(arrowPos.y || 0, "px")
        }, offsetStyle), miscStyle), motionStyle), {}, {
          boxSizing: "border-box",
          zIndex
        }, style2),
        onMouseEnter,
        onMouseLeave,
        onPointerEnter,
        onClick,
        onPointerDownCapture
      }, arrow && /* @__PURE__ */ React.createElement(Arrow, {
        prefixCls,
        arrow,
        arrowPos,
        align
      }), /* @__PURE__ */ React.createElement(PopupContent, {
        cache: !open && !fresh
      }, childNode));
    });
  }));
});
process.env.NODE_ENV !== "production" && (Popup$2.displayName = "Popup");
var TriggerWrapper = /* @__PURE__ */ React.forwardRef(function(props, ref) {
  var children = props.children, getTriggerDOMNode = props.getTriggerDOMNode, canUseRef = supportRef(children), setRef = React.useCallback(function(node2) {
    fillRef(ref, getTriggerDOMNode ? getTriggerDOMNode(node2) : node2);
  }, [getTriggerDOMNode]), mergedRef = useComposeRef(setRef, getNodeRef(children));
  return canUseRef ? /* @__PURE__ */ React.cloneElement(children, {
    ref: mergedRef
  }) : children;
});
process.env.NODE_ENV !== "production" && (TriggerWrapper.displayName = "TriggerWrapper");
var TriggerContext = /* @__PURE__ */ React.createContext(null);
function toArray$4(val) {
  return val ? Array.isArray(val) ? val : [val] : [];
}
__name(toArray$4, "toArray$4");
function useAction(mobile, action, showAction, hideAction) {
  return React.useMemo(function() {
    var mergedShowAction = toArray$4(showAction ?? action), mergedHideAction = toArray$4(hideAction ?? action), showActionSet = new Set(mergedShowAction), hideActionSet = new Set(mergedHideAction);
    return mobile && (showActionSet.has("hover") && (showActionSet.delete("hover"), showActionSet.add("click")), hideActionSet.has("hover") && (hideActionSet.delete("hover"), hideActionSet.add("click"))), [showActionSet, hideActionSet];
  }, [mobile, action, showAction, hideAction]);
}
__name(useAction, "useAction");
function isPointsEq() {
  var a1 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [], a2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [], isAlignPoint = arguments.length > 2 ? arguments[2] : void 0;
  return isAlignPoint ? a1[0] === a2[0] : a1[0] === a2[0] && a1[1] === a2[1];
}
__name(isPointsEq, "isPointsEq");
function getAlignPopupClassName(builtinPlacements, prefixCls, align, isAlignPoint) {
  for (var points = align.points, placements2 = Object.keys(builtinPlacements), i = 0; i < placements2.length; i += 1) {
    var _builtinPlacements$pl, placement = placements2[i];
    if (isPointsEq((_builtinPlacements$pl = builtinPlacements[placement]) === null || _builtinPlacements$pl === void 0 ? void 0 : _builtinPlacements$pl.points, points, isAlignPoint))
      return "".concat(prefixCls, "-placement-").concat(placement);
  }
  return "";
}
__name(getAlignPopupClassName, "getAlignPopupClassName");
function getMotion$1(prefixCls, motion2, animation, transitionName) {
  return motion2 || (animation ? {
    motionName: "".concat(prefixCls, "-").concat(animation)
  } : transitionName ? {
    motionName: transitionName
  } : null);
}
__name(getMotion$1, "getMotion$1");
function getWin(ele) {
  return ele.ownerDocument.defaultView;
}
__name(getWin, "getWin");
function collectScroller(ele) {
  for (var scrollerList = [], current = ele == null ? void 0 : ele.parentElement, scrollStyle = ["hidden", "scroll", "clip", "auto"]; current; ) {
    var _getWin$getComputedSt = getWin(current).getComputedStyle(current), overflowX = _getWin$getComputedSt.overflowX, overflowY = _getWin$getComputedSt.overflowY, overflow = _getWin$getComputedSt.overflow;
    [overflowX, overflowY, overflow].some(function(o2) {
      return scrollStyle.includes(o2);
    }) && scrollerList.push(current), current = current.parentElement;
  }
  return scrollerList;
}
__name(collectScroller, "collectScroller");
function toNum(num) {
  var defaultValue = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;
  return Number.isNaN(num) ? defaultValue : num;
}
__name(toNum, "toNum");
function getPxValue(val) {
  return toNum(parseFloat(val), 0);
}
__name(getPxValue, "getPxValue");
function getVisibleArea(initArea, scrollerList) {
  var visibleArea = _objectSpread2$1({}, initArea);
  return (scrollerList || []).forEach(function(ele) {
    if (!(ele instanceof HTMLBodyElement || ele instanceof HTMLHtmlElement)) {
      var _getWin$getComputedSt2 = getWin(ele).getComputedStyle(ele), overflow = _getWin$getComputedSt2.overflow, overflowClipMargin = _getWin$getComputedSt2.overflowClipMargin, borderTopWidth = _getWin$getComputedSt2.borderTopWidth, borderBottomWidth = _getWin$getComputedSt2.borderBottomWidth, borderLeftWidth = _getWin$getComputedSt2.borderLeftWidth, borderRightWidth = _getWin$getComputedSt2.borderRightWidth, eleRect = ele.getBoundingClientRect(), eleOutHeight = ele.offsetHeight, eleInnerHeight = ele.clientHeight, eleOutWidth = ele.offsetWidth, eleInnerWidth = ele.clientWidth, borderTopNum = getPxValue(borderTopWidth), borderBottomNum = getPxValue(borderBottomWidth), borderLeftNum = getPxValue(borderLeftWidth), borderRightNum = getPxValue(borderRightWidth), scaleX = toNum(Math.round(eleRect.width / eleOutWidth * 1e3) / 1e3), scaleY = toNum(Math.round(eleRect.height / eleOutHeight * 1e3) / 1e3), eleScrollWidth = (eleOutWidth - eleInnerWidth - borderLeftNum - borderRightNum) * scaleX, eleScrollHeight = (eleOutHeight - eleInnerHeight - borderTopNum - borderBottomNum) * scaleY, scaledBorderTopWidth = borderTopNum * scaleY, scaledBorderBottomWidth = borderBottomNum * scaleY, scaledBorderLeftWidth = borderLeftNum * scaleX, scaledBorderRightWidth = borderRightNum * scaleX, clipMarginWidth = 0, clipMarginHeight = 0;
      if (overflow === "clip") {
        var clipNum = getPxValue(overflowClipMargin);
        clipMarginWidth = clipNum * scaleX, clipMarginHeight = clipNum * scaleY;
      }
      var eleLeft = eleRect.x + scaledBorderLeftWidth - clipMarginWidth, eleTop = eleRect.y + scaledBorderTopWidth - clipMarginHeight, eleRight = eleLeft + eleRect.width + 2 * clipMarginWidth - scaledBorderLeftWidth - scaledBorderRightWidth - eleScrollWidth, eleBottom = eleTop + eleRect.height + 2 * clipMarginHeight - scaledBorderTopWidth - scaledBorderBottomWidth - eleScrollHeight;
      visibleArea.left = Math.max(visibleArea.left, eleLeft), visibleArea.top = Math.max(visibleArea.top, eleTop), visibleArea.right = Math.min(visibleArea.right, eleRight), visibleArea.bottom = Math.min(visibleArea.bottom, eleBottom);
    }
  }), visibleArea;
}
__name(getVisibleArea, "getVisibleArea");
function getUnitOffset(size) {
  var offset2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0, offsetStr = "".concat(offset2), cells = offsetStr.match(/^(.*)\%$/);
  return cells ? size * (parseFloat(cells[1]) / 100) : parseFloat(offsetStr);
}
__name(getUnitOffset, "getUnitOffset");
function getNumberOffset(rect, offset2) {
  var _ref = offset2 || [], _ref2 = _slicedToArray(_ref, 2), offsetX = _ref2[0], offsetY = _ref2[1];
  return [getUnitOffset(rect.width, offsetX), getUnitOffset(rect.height, offsetY)];
}
__name(getNumberOffset, "getNumberOffset");
function splitPoints() {
  var points = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "";
  return [points[0], points[1]];
}
__name(splitPoints, "splitPoints");
function getAlignPoint(rect, points) {
  var topBottom = points[0], leftRight = points[1], x, y;
  return topBottom === "t" ? y = rect.y : topBottom === "b" ? y = rect.y + rect.height : y = rect.y + rect.height / 2, leftRight === "l" ? x = rect.x : leftRight === "r" ? x = rect.x + rect.width : x = rect.x + rect.width / 2, {
    x,
    y
  };
}
__name(getAlignPoint, "getAlignPoint");
function reversePoints(points, index2) {
  var reverseMap = {
    t: "b",
    b: "t",
    l: "r",
    r: "l"
  };
  return points.map(function(point, i) {
    return i === index2 ? reverseMap[point] || "c" : point;
  }).join("");
}
__name(reversePoints, "reversePoints");
function useAlign(open, popupEle, target, placement, builtinPlacements, popupAlign, onPopupAlign) {
  var _React$useState = React.useState({
    ready: !1,
    offsetX: 0,
    offsetY: 0,
    offsetR: 0,
    offsetB: 0,
    arrowX: 0,
    arrowY: 0,
    scaleX: 1,
    scaleY: 1,
    align: builtinPlacements[placement] || {}
  }), _React$useState2 = _slicedToArray(_React$useState, 2), offsetInfo = _React$useState2[0], setOffsetInfo = _React$useState2[1], alignCountRef = React.useRef(0), scrollerList = React.useMemo(function() {
    return popupEle ? collectScroller(popupEle) : [];
  }, [popupEle]), prevFlipRef = React.useRef({}), resetFlipCache = /* @__PURE__ */ __name(function() {
    prevFlipRef.current = {};
  }, "resetFlipCache");
  open || resetFlipCache();
  var onAlign = useEvent(function() {
    if (popupEle && target && open) {
      let getIntersectionVisibleArea = function(offsetX, offsetY) {
        var area = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : visibleArea, l2 = popupRect.x + offsetX, t2 = popupRect.y + offsetY, r2 = l2 + popupWidth, b = t2 + popupHeight, visibleL = Math.max(l2, area.left), visibleT = Math.max(t2, area.top), visibleR = Math.min(r2, area.right), visibleB = Math.min(b, area.bottom);
        return Math.max(0, (visibleR - visibleL) * (visibleB - visibleT));
      }, syncNextPopupPosition = function() {
        nextPopupY = popupRect.y + nextOffsetY, nextPopupBottom = nextPopupY + popupHeight, nextPopupX = popupRect.x + nextOffsetX, nextPopupRight = nextPopupX + popupWidth;
      };
      __name(getIntersectionVisibleArea, "getIntersectionVisibleArea"), __name(syncNextPopupPosition, "syncNextPopupPosition");
      var _popupElement$parentE, _popupRect$x, _popupRect$y, _popupElement$parentE2, popupElement = popupEle, doc = popupElement.ownerDocument, win = getWin(popupElement), _win$getComputedStyle = win.getComputedStyle(popupElement), width = _win$getComputedStyle.width, height = _win$getComputedStyle.height, popupPosition = _win$getComputedStyle.position, originLeft = popupElement.style.left, originTop = popupElement.style.top, originRight = popupElement.style.right, originBottom = popupElement.style.bottom, originOverflow = popupElement.style.overflow, placementInfo = _objectSpread2$1(_objectSpread2$1({}, builtinPlacements[placement]), popupAlign), placeholderElement = doc.createElement("div");
      (_popupElement$parentE = popupElement.parentElement) === null || _popupElement$parentE === void 0 || _popupElement$parentE.appendChild(placeholderElement), placeholderElement.style.left = "".concat(popupElement.offsetLeft, "px"), placeholderElement.style.top = "".concat(popupElement.offsetTop, "px"), placeholderElement.style.position = popupPosition, placeholderElement.style.height = "".concat(popupElement.offsetHeight, "px"), placeholderElement.style.width = "".concat(popupElement.offsetWidth, "px"), popupElement.style.left = "0", popupElement.style.top = "0", popupElement.style.right = "auto", popupElement.style.bottom = "auto", popupElement.style.overflow = "hidden";
      var targetRect;
      if (Array.isArray(target))
        targetRect = {
          x: target[0],
          y: target[1],
          width: 0,
          height: 0
        };
      else {
        var _rect$x, _rect$y, rect = target.getBoundingClientRect();
        rect.x = (_rect$x = rect.x) !== null && _rect$x !== void 0 ? _rect$x : rect.left, rect.y = (_rect$y = rect.y) !== null && _rect$y !== void 0 ? _rect$y : rect.top, targetRect = {
          x: rect.x,
          y: rect.y,
          width: rect.width,
          height: rect.height
        };
      }
      var popupRect = popupElement.getBoundingClientRect();
      popupRect.x = (_popupRect$x = popupRect.x) !== null && _popupRect$x !== void 0 ? _popupRect$x : popupRect.left, popupRect.y = (_popupRect$y = popupRect.y) !== null && _popupRect$y !== void 0 ? _popupRect$y : popupRect.top;
      var _doc$documentElement = doc.documentElement, clientWidth = _doc$documentElement.clientWidth, clientHeight = _doc$documentElement.clientHeight, scrollWidth = _doc$documentElement.scrollWidth, scrollHeight = _doc$documentElement.scrollHeight, scrollTop = _doc$documentElement.scrollTop, scrollLeft = _doc$documentElement.scrollLeft, popupHeight = popupRect.height, popupWidth = popupRect.width, targetHeight = targetRect.height, targetWidth = targetRect.width, visibleRegion = {
        left: 0,
        top: 0,
        right: clientWidth,
        bottom: clientHeight
      }, scrollRegion = {
        left: -scrollLeft,
        top: -scrollTop,
        right: scrollWidth - scrollLeft,
        bottom: scrollHeight - scrollTop
      }, htmlRegion = placementInfo.htmlRegion, VISIBLE = "visible", VISIBLE_FIRST = "visibleFirst";
      htmlRegion !== "scroll" && htmlRegion !== VISIBLE_FIRST && (htmlRegion = VISIBLE);
      var isVisibleFirst = htmlRegion === VISIBLE_FIRST, scrollRegionArea = getVisibleArea(scrollRegion, scrollerList), visibleRegionArea = getVisibleArea(visibleRegion, scrollerList), visibleArea = htmlRegion === VISIBLE ? visibleRegionArea : scrollRegionArea, adjustCheckVisibleArea = isVisibleFirst ? visibleRegionArea : visibleArea;
      popupElement.style.left = "auto", popupElement.style.top = "auto", popupElement.style.right = "0", popupElement.style.bottom = "0";
      var popupMirrorRect = popupElement.getBoundingClientRect();
      popupElement.style.left = originLeft, popupElement.style.top = originTop, popupElement.style.right = originRight, popupElement.style.bottom = originBottom, popupElement.style.overflow = originOverflow, (_popupElement$parentE2 = popupElement.parentElement) === null || _popupElement$parentE2 === void 0 || _popupElement$parentE2.removeChild(placeholderElement);
      var _scaleX = toNum(Math.round(popupWidth / parseFloat(width) * 1e3) / 1e3), _scaleY = toNum(Math.round(popupHeight / parseFloat(height) * 1e3) / 1e3);
      if (_scaleX === 0 || _scaleY === 0 || isDOM(target) && !isVisible(target))
        return;
      var offset2 = placementInfo.offset, targetOffset2 = placementInfo.targetOffset, _getNumberOffset = getNumberOffset(popupRect, offset2), _getNumberOffset2 = _slicedToArray(_getNumberOffset, 2), popupOffsetX = _getNumberOffset2[0], popupOffsetY = _getNumberOffset2[1], _getNumberOffset3 = getNumberOffset(targetRect, targetOffset2), _getNumberOffset4 = _slicedToArray(_getNumberOffset3, 2), targetOffsetX = _getNumberOffset4[0], targetOffsetY = _getNumberOffset4[1];
      targetRect.x -= targetOffsetX, targetRect.y -= targetOffsetY;
      var _ref3 = placementInfo.points || [], _ref4 = _slicedToArray(_ref3, 2), popupPoint = _ref4[0], targetPoint = _ref4[1], targetPoints = splitPoints(targetPoint), popupPoints = splitPoints(popupPoint), targetAlignPoint = getAlignPoint(targetRect, targetPoints), popupAlignPoint = getAlignPoint(popupRect, popupPoints), nextAlignInfo = _objectSpread2$1({}, placementInfo), nextOffsetX = targetAlignPoint.x - popupAlignPoint.x + popupOffsetX, nextOffsetY = targetAlignPoint.y - popupAlignPoint.y + popupOffsetY, originIntersectionVisibleArea = getIntersectionVisibleArea(nextOffsetX, nextOffsetY), originIntersectionRecommendArea = getIntersectionVisibleArea(nextOffsetX, nextOffsetY, visibleRegionArea), targetAlignPointTL = getAlignPoint(targetRect, ["t", "l"]), popupAlignPointTL = getAlignPoint(popupRect, ["t", "l"]), targetAlignPointBR = getAlignPoint(targetRect, ["b", "r"]), popupAlignPointBR = getAlignPoint(popupRect, ["b", "r"]), overflow = placementInfo.overflow || {}, adjustX = overflow.adjustX, adjustY = overflow.adjustY, shiftX = overflow.shiftX, shiftY = overflow.shiftY, supportAdjust = /* @__PURE__ */ __name(function(val) {
        return typeof val == "boolean" ? val : val >= 0;
      }, "supportAdjust"), nextPopupY, nextPopupBottom, nextPopupX, nextPopupRight;
      syncNextPopupPosition();
      var needAdjustY = supportAdjust(adjustY), sameTB = popupPoints[0] === targetPoints[0];
      if (needAdjustY && popupPoints[0] === "t" && (nextPopupBottom > adjustCheckVisibleArea.bottom || prevFlipRef.current.bt)) {
        var tmpNextOffsetY = nextOffsetY;
        sameTB ? tmpNextOffsetY -= popupHeight - targetHeight : tmpNextOffsetY = targetAlignPointTL.y - popupAlignPointBR.y - popupOffsetY;
        var newVisibleArea = getIntersectionVisibleArea(nextOffsetX, tmpNextOffsetY), newVisibleRecommendArea = getIntersectionVisibleArea(nextOffsetX, tmpNextOffsetY, visibleRegionArea);
        // Of course use larger one
        newVisibleArea > originIntersectionVisibleArea || newVisibleArea === originIntersectionVisibleArea && (!isVisibleFirst || // Choose recommend one
        newVisibleRecommendArea >= originIntersectionRecommendArea) ? (prevFlipRef.current.bt = !0, nextOffsetY = tmpNextOffsetY, popupOffsetY = -popupOffsetY, nextAlignInfo.points = [reversePoints(popupPoints, 0), reversePoints(targetPoints, 0)]) : prevFlipRef.current.bt = !1;
      }
      if (needAdjustY && popupPoints[0] === "b" && (nextPopupY < adjustCheckVisibleArea.top || prevFlipRef.current.tb)) {
        var _tmpNextOffsetY = nextOffsetY;
        sameTB ? _tmpNextOffsetY += popupHeight - targetHeight : _tmpNextOffsetY = targetAlignPointBR.y - popupAlignPointTL.y - popupOffsetY;
        var _newVisibleArea = getIntersectionVisibleArea(nextOffsetX, _tmpNextOffsetY), _newVisibleRecommendArea = getIntersectionVisibleArea(nextOffsetX, _tmpNextOffsetY, visibleRegionArea);
        // Of course use larger one
        _newVisibleArea > originIntersectionVisibleArea || _newVisibleArea === originIntersectionVisibleArea && (!isVisibleFirst || // Choose recommend one
        _newVisibleRecommendArea >= originIntersectionRecommendArea) ? (prevFlipRef.current.tb = !0, nextOffsetY = _tmpNextOffsetY, popupOffsetY = -popupOffsetY, nextAlignInfo.points = [reversePoints(popupPoints, 0), reversePoints(targetPoints, 0)]) : prevFlipRef.current.tb = !1;
      }
      var needAdjustX = supportAdjust(adjustX), sameLR = popupPoints[1] === targetPoints[1];
      if (needAdjustX && popupPoints[1] === "l" && (nextPopupRight > adjustCheckVisibleArea.right || prevFlipRef.current.rl)) {
        var tmpNextOffsetX = nextOffsetX;
        sameLR ? tmpNextOffsetX -= popupWidth - targetWidth : tmpNextOffsetX = targetAlignPointTL.x - popupAlignPointBR.x - popupOffsetX;
        var _newVisibleArea2 = getIntersectionVisibleArea(tmpNextOffsetX, nextOffsetY), _newVisibleRecommendArea2 = getIntersectionVisibleArea(tmpNextOffsetX, nextOffsetY, visibleRegionArea);
        // Of course use larger one
        _newVisibleArea2 > originIntersectionVisibleArea || _newVisibleArea2 === originIntersectionVisibleArea && (!isVisibleFirst || // Choose recommend one
        _newVisibleRecommendArea2 >= originIntersectionRecommendArea) ? (prevFlipRef.current.rl = !0, nextOffsetX = tmpNextOffsetX, popupOffsetX = -popupOffsetX, nextAlignInfo.points = [reversePoints(popupPoints, 1), reversePoints(targetPoints, 1)]) : prevFlipRef.current.rl = !1;
      }
      if (needAdjustX && popupPoints[1] === "r" && (nextPopupX < adjustCheckVisibleArea.left || prevFlipRef.current.lr)) {
        var _tmpNextOffsetX = nextOffsetX;
        sameLR ? _tmpNextOffsetX += popupWidth - targetWidth : _tmpNextOffsetX = targetAlignPointBR.x - popupAlignPointTL.x - popupOffsetX;
        var _newVisibleArea3 = getIntersectionVisibleArea(_tmpNextOffsetX, nextOffsetY), _newVisibleRecommendArea3 = getIntersectionVisibleArea(_tmpNextOffsetX, nextOffsetY, visibleRegionArea);
        // Of course use larger one
        _newVisibleArea3 > originIntersectionVisibleArea || _newVisibleArea3 === originIntersectionVisibleArea && (!isVisibleFirst || // Choose recommend one
        _newVisibleRecommendArea3 >= originIntersectionRecommendArea) ? (prevFlipRef.current.lr = !0, nextOffsetX = _tmpNextOffsetX, popupOffsetX = -popupOffsetX, nextAlignInfo.points = [reversePoints(popupPoints, 1), reversePoints(targetPoints, 1)]) : prevFlipRef.current.lr = !1;
      }
      syncNextPopupPosition();
      var numShiftX = shiftX === !0 ? 0 : shiftX;
      typeof numShiftX == "number" && (nextPopupX < visibleRegionArea.left && (nextOffsetX -= nextPopupX - visibleRegionArea.left - popupOffsetX, targetRect.x + targetWidth < visibleRegionArea.left + numShiftX && (nextOffsetX += targetRect.x - visibleRegionArea.left + targetWidth - numShiftX)), nextPopupRight > visibleRegionArea.right && (nextOffsetX -= nextPopupRight - visibleRegionArea.right - popupOffsetX, targetRect.x > visibleRegionArea.right - numShiftX && (nextOffsetX += targetRect.x - visibleRegionArea.right + numShiftX)));
      var numShiftY = shiftY === !0 ? 0 : shiftY;
      typeof numShiftY == "number" && (nextPopupY < visibleRegionArea.top && (nextOffsetY -= nextPopupY - visibleRegionArea.top - popupOffsetY, targetRect.y + targetHeight < visibleRegionArea.top + numShiftY && (nextOffsetY += targetRect.y - visibleRegionArea.top + targetHeight - numShiftY)), nextPopupBottom > visibleRegionArea.bottom && (nextOffsetY -= nextPopupBottom - visibleRegionArea.bottom - popupOffsetY, targetRect.y > visibleRegionArea.bottom - numShiftY && (nextOffsetY += targetRect.y - visibleRegionArea.bottom + numShiftY)));
      var popupLeft = popupRect.x + nextOffsetX, popupRight = popupLeft + popupWidth, popupTop = popupRect.y + nextOffsetY, popupBottom = popupTop + popupHeight, targetLeft = targetRect.x, targetRight = targetLeft + targetWidth, targetTop = targetRect.y, targetBottom = targetTop + targetHeight, maxLeft = Math.max(popupLeft, targetLeft), minRight = Math.min(popupRight, targetRight), xCenter = (maxLeft + minRight) / 2, nextArrowX = xCenter - popupLeft, maxTop = Math.max(popupTop, targetTop), minBottom = Math.min(popupBottom, targetBottom), yCenter = (maxTop + minBottom) / 2, nextArrowY = yCenter - popupTop;
      onPopupAlign == null || onPopupAlign(popupEle, nextAlignInfo);
      var offsetX4Right = popupMirrorRect.right - popupRect.x - (nextOffsetX + popupRect.width), offsetY4Bottom = popupMirrorRect.bottom - popupRect.y - (nextOffsetY + popupRect.height);
      _scaleX === 1 && (nextOffsetX = Math.round(nextOffsetX), offsetX4Right = Math.round(offsetX4Right)), _scaleY === 1 && (nextOffsetY = Math.round(nextOffsetY), offsetY4Bottom = Math.round(offsetY4Bottom));
      var nextOffsetInfo = {
        ready: !0,
        offsetX: nextOffsetX / _scaleX,
        offsetY: nextOffsetY / _scaleY,
        offsetR: offsetX4Right / _scaleX,
        offsetB: offsetY4Bottom / _scaleY,
        arrowX: nextArrowX / _scaleX,
        arrowY: nextArrowY / _scaleY,
        scaleX: _scaleX,
        scaleY: _scaleY,
        align: nextAlignInfo
      };
      setOffsetInfo(nextOffsetInfo);
    }
  }), triggerAlign = /* @__PURE__ */ __name(function() {
    alignCountRef.current += 1;
    var id2 = alignCountRef.current;
    Promise.resolve().then(function() {
      alignCountRef.current === id2 && onAlign();
    });
  }, "triggerAlign"), resetReady = /* @__PURE__ */ __name(function() {
    setOffsetInfo(function(ori) {
      return _objectSpread2$1(_objectSpread2$1({}, ori), {}, {
        ready: !1
      });
    });
  }, "resetReady");
  return useLayoutEffect$1(resetReady, [placement]), useLayoutEffect$1(function() {
    open || resetReady();
  }, [open]), [offsetInfo.ready, offsetInfo.offsetX, offsetInfo.offsetY, offsetInfo.offsetR, offsetInfo.offsetB, offsetInfo.arrowX, offsetInfo.arrowY, offsetInfo.scaleX, offsetInfo.scaleY, offsetInfo.align, triggerAlign];
}
__name(useAlign, "useAlign");
function useWatch(open, target, popup, onAlign, onScroll) {
  useLayoutEffect$1(function() {
    if (open && target && popup) {
      let notifyScroll = function() {
        onAlign(), onScroll();
      };
      __name(notifyScroll, "notifyScroll");
      var targetElement = target, popupElement = popup, targetScrollList = collectScroller(targetElement), popupScrollList = collectScroller(popupElement), win = getWin(popupElement), mergedList = new Set([win].concat(_toConsumableArray(targetScrollList), _toConsumableArray(popupScrollList)));
      return mergedList.forEach(function(scroller) {
        scroller.addEventListener("scroll", notifyScroll, {
          passive: !0
        });
      }), win.addEventListener("resize", notifyScroll, {
        passive: !0
      }), onAlign(), function() {
        mergedList.forEach(function(scroller) {
          scroller.removeEventListener("scroll", notifyScroll), win.removeEventListener("resize", notifyScroll);
        });
      };
    }
  }, [open, target, popup]);
}
__name(useWatch, "useWatch");
function useWinClick(open, clickToHide, targetEle, popupEle, mask, maskClosable, inPopupOrChild, triggerOpen) {
  var openRef = React.useRef(open);
  openRef.current = open;
  var popupPointerDownRef = React.useRef(!1);
  React.useEffect(function() {
    if (clickToHide && popupEle && (!mask || maskClosable)) {
      var onPointerDown = /* @__PURE__ */ __name(function() {
        popupPointerDownRef.current = !1;
      }, "onPointerDown"), onTriggerClose = /* @__PURE__ */ __name(function(e2) {
        var _e$composedPath;
        openRef.current && !inPopupOrChild(((_e$composedPath = e2.composedPath) === null || _e$composedPath === void 0 || (_e$composedPath = _e$composedPath.call(e2)) === null || _e$composedPath === void 0 ? void 0 : _e$composedPath[0]) || e2.target) && !popupPointerDownRef.current && triggerOpen(!1);
      }, "onTriggerClose"), win = getWin(popupEle);
      win.addEventListener("pointerdown", onPointerDown, !0), win.addEventListener("mousedown", onTriggerClose, !0), win.addEventListener("contextmenu", onTriggerClose, !0);
      var targetShadowRoot = getShadowRoot(targetEle);
      if (targetShadowRoot && (targetShadowRoot.addEventListener("mousedown", onTriggerClose, !0), targetShadowRoot.addEventListener("contextmenu", onTriggerClose, !0)), process.env.NODE_ENV !== "production") {
        var _targetEle$getRootNod, _popupEle$getRootNode, targetRoot = targetEle == null || (_targetEle$getRootNod = targetEle.getRootNode) === null || _targetEle$getRootNod === void 0 ? void 0 : _targetEle$getRootNod.call(targetEle), popupRoot = (_popupEle$getRootNode = popupEle.getRootNode) === null || _popupEle$getRootNode === void 0 ? void 0 : _popupEle$getRootNode.call(popupEle);
        warning$3(targetRoot === popupRoot, "trigger element and popup element should in same shadow root.");
      }
      return function() {
        win.removeEventListener("pointerdown", onPointerDown, !0), win.removeEventListener("mousedown", onTriggerClose, !0), win.removeEventListener("contextmenu", onTriggerClose, !0), targetShadowRoot && (targetShadowRoot.removeEventListener("mousedown", onTriggerClose, !0), targetShadowRoot.removeEventListener("contextmenu", onTriggerClose, !0));
      };
    }
  }, [clickToHide, targetEle, popupEle, mask, maskClosable]);
  function onPopupPointerDown() {
    popupPointerDownRef.current = !0;
  }
  return __name(onPopupPointerDown, "onPopupPointerDown"), onPopupPointerDown;
}
__name(useWinClick, "useWinClick");
var _excluded$G = ["prefixCls", "children", "action", "showAction", "hideAction", "popupVisible", "defaultPopupVisible", "onPopupVisibleChange", "afterPopupVisibleChange", "mouseEnterDelay", "mouseLeaveDelay", "focusDelay", "blurDelay", "mask", "maskClosable", "getPopupContainer", "forceRender", "autoDestroy", "destroyPopupOnHide", "popup", "popupClassName", "popupStyle", "popupPlacement", "builtinPlacements", "popupAlign", "zIndex", "stretch", "getPopupClassNameFromAlign", "fresh", "alignPoint", "onPopupClick", "onPopupAlign", "arrow", "popupMotion", "maskMotion", "popupTransitionName", "popupAnimation", "maskTransitionName", "maskAnimation", "className", "getTriggerDOMNode"];
function generateTrigger() {
  var PortalComponent = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : Portal, Trigger2 = /* @__PURE__ */ React.forwardRef(function(props, ref) {
    var _props$prefixCls = props.prefixCls, prefixCls = _props$prefixCls === void 0 ? "rc-trigger-popup" : _props$prefixCls, children = props.children, _props$action = props.action, action = _props$action === void 0 ? "hover" : _props$action, showAction = props.showAction, hideAction = props.hideAction, popupVisible = props.popupVisible, defaultPopupVisible = props.defaultPopupVisible, onPopupVisibleChange = props.onPopupVisibleChange, afterPopupVisibleChange = props.afterPopupVisibleChange, mouseEnterDelay = props.mouseEnterDelay, _props$mouseLeaveDela = props.mouseLeaveDelay, mouseLeaveDelay = _props$mouseLeaveDela === void 0 ? 0.1 : _props$mouseLeaveDela, focusDelay = props.focusDelay, blurDelay = props.blurDelay, mask = props.mask, _props$maskClosable = props.maskClosable, maskClosable = _props$maskClosable === void 0 ? !0 : _props$maskClosable, getPopupContainer = props.getPopupContainer, forceRender = props.forceRender, autoDestroy = props.autoDestroy, destroyPopupOnHide = props.destroyPopupOnHide, popup = props.popup, popupClassName = props.popupClassName, popupStyle = props.popupStyle, popupPlacement = props.popupPlacement, _props$builtinPlaceme = props.builtinPlacements, builtinPlacements = _props$builtinPlaceme === void 0 ? {} : _props$builtinPlaceme, popupAlign = props.popupAlign, zIndex = props.zIndex, stretch = props.stretch, getPopupClassNameFromAlign = props.getPopupClassNameFromAlign, fresh = props.fresh, alignPoint = props.alignPoint, onPopupClick = props.onPopupClick, onPopupAlign = props.onPopupAlign, arrow = props.arrow, popupMotion = props.popupMotion, maskMotion = props.maskMotion, popupTransitionName = props.popupTransitionName, popupAnimation = props.popupAnimation, maskTransitionName = props.maskTransitionName, maskAnimation = props.maskAnimation, className = props.className, getTriggerDOMNode = props.getTriggerDOMNode, restProps = _objectWithoutProperties(props, _excluded$G), mergedAutoDestroy = autoDestroy || destroyPopupOnHide || !1, _React$useState = React.useState(!1), _React$useState2 = _slicedToArray(_React$useState, 2), mobile = _React$useState2[0], setMobile = _React$useState2[1];
    useLayoutEffect$1(function() {
      setMobile(isMobile());
    }, []);
    var subPopupElements = React.useRef({}), parentContext = React.useContext(TriggerContext), context = React.useMemo(function() {
      return {
        registerSubPopup: /* @__PURE__ */ __name(function(id3, subPopupEle) {
          subPopupElements.current[id3] = subPopupEle, parentContext == null || parentContext.registerSubPopup(id3, subPopupEle);
        }, "registerSubPopup")
      };
    }, [parentContext]), id2 = useId$2(), _React$useState3 = React.useState(null), _React$useState4 = _slicedToArray(_React$useState3, 2), popupEle = _React$useState4[0], setPopupEle = _React$useState4[1], externalPopupRef = React.useRef(null), setPopupRef = useEvent(function(node2) {
      externalPopupRef.current = node2, isDOM(node2) && popupEle !== node2 && setPopupEle(node2), parentContext == null || parentContext.registerSubPopup(id2, node2);
    }), _React$useState5 = React.useState(null), _React$useState6 = _slicedToArray(_React$useState5, 2), targetEle = _React$useState6[0], setTargetEle = _React$useState6[1], externalForwardRef = React.useRef(null), setTargetRef = useEvent(function(node2) {
      isDOM(node2) && targetEle !== node2 && (setTargetEle(node2), externalForwardRef.current = node2);
    }), child = React.Children.only(children), originChildProps = (child == null ? void 0 : child.props) || {}, cloneProps = {}, inPopupOrChild = useEvent(function(ele) {
      var _getShadowRoot, _getShadowRoot2, childDOM = targetEle;
      return (childDOM == null ? void 0 : childDOM.contains(ele)) || ((_getShadowRoot = getShadowRoot(childDOM)) === null || _getShadowRoot === void 0 ? void 0 : _getShadowRoot.host) === ele || ele === childDOM || (popupEle == null ? void 0 : popupEle.contains(ele)) || ((_getShadowRoot2 = getShadowRoot(popupEle)) === null || _getShadowRoot2 === void 0 ? void 0 : _getShadowRoot2.host) === ele || ele === popupEle || Object.values(subPopupElements.current).some(function(subPopupEle) {
        return (subPopupEle == null ? void 0 : subPopupEle.contains(ele)) || ele === subPopupEle;
      });
    }), mergePopupMotion = getMotion$1(prefixCls, popupMotion, popupAnimation, popupTransitionName), mergeMaskMotion = getMotion$1(prefixCls, maskMotion, maskAnimation, maskTransitionName), _React$useState7 = React.useState(defaultPopupVisible || !1), _React$useState8 = _slicedToArray(_React$useState7, 2), internalOpen = _React$useState8[0], setInternalOpen = _React$useState8[1], mergedOpen = popupVisible ?? internalOpen, setMergedOpen = useEvent(function(nextOpen) {
      popupVisible === void 0 && setInternalOpen(nextOpen);
    });
    useLayoutEffect$1(function() {
      setInternalOpen(popupVisible || !1);
    }, [popupVisible]);
    var openRef = React.useRef(mergedOpen);
    openRef.current = mergedOpen;
    var lastTriggerRef = React.useRef([]);
    lastTriggerRef.current = [];
    var internalTriggerOpen = useEvent(function(nextOpen) {
      var _lastTriggerRef$curre;
      setMergedOpen(nextOpen), ((_lastTriggerRef$curre = lastTriggerRef.current[lastTriggerRef.current.length - 1]) !== null && _lastTriggerRef$curre !== void 0 ? _lastTriggerRef$curre : mergedOpen) !== nextOpen && (lastTriggerRef.current.push(nextOpen), onPopupVisibleChange == null || onPopupVisibleChange(nextOpen));
    }), delayRef = React.useRef(), clearDelay = /* @__PURE__ */ __name(function() {
      clearTimeout(delayRef.current);
    }, "clearDelay"), triggerOpen = /* @__PURE__ */ __name(function(nextOpen) {
      var delay = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
      clearDelay(), delay === 0 ? internalTriggerOpen(nextOpen) : delayRef.current = setTimeout(function() {
        internalTriggerOpen(nextOpen);
      }, delay * 1e3);
    }, "triggerOpen");
    React.useEffect(function() {
      return clearDelay;
    }, []);
    var _React$useState9 = React.useState(!1), _React$useState10 = _slicedToArray(_React$useState9, 2), inMotion = _React$useState10[0], setInMotion = _React$useState10[1];
    useLayoutEffect$1(function(firstMount) {
      (!firstMount || mergedOpen) && setInMotion(!0);
    }, [mergedOpen]);
    var _React$useState11 = React.useState(null), _React$useState12 = _slicedToArray(_React$useState11, 2), motionPrepareResolve = _React$useState12[0], setMotionPrepareResolve = _React$useState12[1], _React$useState13 = React.useState(null), _React$useState14 = _slicedToArray(_React$useState13, 2), mousePos = _React$useState14[0], setMousePos = _React$useState14[1], setMousePosByEvent = /* @__PURE__ */ __name(function(event) {
      setMousePos([event.clientX, event.clientY]);
    }, "setMousePosByEvent"), _useAlign = useAlign(mergedOpen, popupEle, alignPoint && mousePos !== null ? mousePos : targetEle, popupPlacement, builtinPlacements, popupAlign, onPopupAlign), _useAlign2 = _slicedToArray(_useAlign, 11), ready = _useAlign2[0], offsetX = _useAlign2[1], offsetY = _useAlign2[2], offsetR = _useAlign2[3], offsetB = _useAlign2[4], arrowX = _useAlign2[5], arrowY = _useAlign2[6], scaleX = _useAlign2[7], scaleY = _useAlign2[8], alignInfo = _useAlign2[9], onAlign = _useAlign2[10], _useAction = useAction(mobile, action, showAction, hideAction), _useAction2 = _slicedToArray(_useAction, 2), showActions = _useAction2[0], hideActions = _useAction2[1], clickToShow = showActions.has("click"), clickToHide = hideActions.has("click") || hideActions.has("contextMenu"), triggerAlign = useEvent(function() {
      inMotion || onAlign();
    }), onScroll = /* @__PURE__ */ __name(function() {
      openRef.current && alignPoint && clickToHide && triggerOpen(!1);
    }, "onScroll");
    useWatch(mergedOpen, targetEle, popupEle, triggerAlign, onScroll), useLayoutEffect$1(function() {
      triggerAlign();
    }, [mousePos, popupPlacement]), useLayoutEffect$1(function() {
      mergedOpen && !(builtinPlacements != null && builtinPlacements[popupPlacement]) && triggerAlign();
    }, [JSON.stringify(popupAlign)]);
    var alignedClassName = React.useMemo(function() {
      var baseClassName = getAlignPopupClassName(builtinPlacements, prefixCls, alignInfo, alignPoint);
      return cn(baseClassName, getPopupClassNameFromAlign == null ? void 0 : getPopupClassNameFromAlign(alignInfo));
    }, [alignInfo, getPopupClassNameFromAlign, builtinPlacements, prefixCls, alignPoint]);
    React.useImperativeHandle(ref, function() {
      return {
        nativeElement: externalForwardRef.current,
        popupElement: externalPopupRef.current,
        forceAlign: triggerAlign
      };
    });
    var _React$useState15 = React.useState(0), _React$useState16 = _slicedToArray(_React$useState15, 2), targetWidth = _React$useState16[0], setTargetWidth = _React$useState16[1], _React$useState17 = React.useState(0), _React$useState18 = _slicedToArray(_React$useState17, 2), targetHeight = _React$useState18[0], setTargetHeight = _React$useState18[1], syncTargetSize = /* @__PURE__ */ __name(function() {
      if (stretch && targetEle) {
        var rect = targetEle.getBoundingClientRect();
        setTargetWidth(rect.width), setTargetHeight(rect.height);
      }
    }, "syncTargetSize"), onTargetResize = /* @__PURE__ */ __name(function() {
      syncTargetSize(), triggerAlign();
    }, "onTargetResize"), onVisibleChanged = /* @__PURE__ */ __name(function(visible) {
      setInMotion(!1), onAlign(), afterPopupVisibleChange == null || afterPopupVisibleChange(visible);
    }, "onVisibleChanged"), onPrepare = /* @__PURE__ */ __name(function() {
      return new Promise(function(resolve) {
        syncTargetSize(), setMotionPrepareResolve(function() {
          return resolve;
        });
      });
    }, "onPrepare");
    useLayoutEffect$1(function() {
      motionPrepareResolve && (onAlign(), motionPrepareResolve(), setMotionPrepareResolve(null));
    }, [motionPrepareResolve]);
    function wrapperAction(eventName, nextOpen, delay, preEvent) {
      cloneProps[eventName] = function(event) {
        var _originChildProps$eve;
        preEvent == null || preEvent(event), triggerOpen(nextOpen, delay);
        for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++)
          args[_key - 1] = arguments[_key];
        (_originChildProps$eve = originChildProps[eventName]) === null || _originChildProps$eve === void 0 || _originChildProps$eve.call.apply(_originChildProps$eve, [originChildProps, event].concat(args));
      };
    }
    __name(wrapperAction, "wrapperAction"), (clickToShow || clickToHide) && (cloneProps.onClick = function(event) {
      var _originChildProps$onC;
      openRef.current && clickToHide ? triggerOpen(!1) : !openRef.current && clickToShow && (setMousePosByEvent(event), triggerOpen(!0));
      for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++)
        args[_key2 - 1] = arguments[_key2];
      (_originChildProps$onC = originChildProps.onClick) === null || _originChildProps$onC === void 0 || _originChildProps$onC.call.apply(_originChildProps$onC, [originChildProps, event].concat(args));
    });
    var onPopupPointerDown = useWinClick(mergedOpen, clickToHide, targetEle, popupEle, mask, maskClosable, inPopupOrChild, triggerOpen), hoverToShow = showActions.has("hover"), hoverToHide = hideActions.has("hover"), onPopupMouseEnter, onPopupMouseLeave;
    hoverToShow && (wrapperAction("onMouseEnter", !0, mouseEnterDelay, function(event) {
      setMousePosByEvent(event);
    }), wrapperAction("onPointerEnter", !0, mouseEnterDelay, function(event) {
      setMousePosByEvent(event);
    }), onPopupMouseEnter = /* @__PURE__ */ __name(function(event) {
      (mergedOpen || inMotion) && popupEle !== null && popupEle !== void 0 && popupEle.contains(event.target) && triggerOpen(!0, mouseEnterDelay);
    }, "onPopupMouseEnter"), alignPoint && (cloneProps.onMouseMove = function(event) {
      var _originChildProps$onM;
      (_originChildProps$onM = originChildProps.onMouseMove) === null || _originChildProps$onM === void 0 || _originChildProps$onM.call(originChildProps, event);
    })), hoverToHide && (wrapperAction("onMouseLeave", !1, mouseLeaveDelay), wrapperAction("onPointerLeave", !1, mouseLeaveDelay), onPopupMouseLeave = /* @__PURE__ */ __name(function() {
      triggerOpen(!1, mouseLeaveDelay);
    }, "onPopupMouseLeave")), showActions.has("focus") && wrapperAction("onFocus", !0, focusDelay), hideActions.has("focus") && wrapperAction("onBlur", !1, blurDelay), showActions.has("contextMenu") && (cloneProps.onContextMenu = function(event) {
      var _originChildProps$onC2;
      openRef.current && hideActions.has("contextMenu") ? triggerOpen(!1) : (setMousePosByEvent(event), triggerOpen(!0)), event.preventDefault();
      for (var _len3 = arguments.length, args = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++)
        args[_key3 - 1] = arguments[_key3];
      (_originChildProps$onC2 = originChildProps.onContextMenu) === null || _originChildProps$onC2 === void 0 || _originChildProps$onC2.call.apply(_originChildProps$onC2, [originChildProps, event].concat(args));
    }), className && (cloneProps.className = cn(originChildProps.className, className));
    var mergedChildrenProps = _objectSpread2$1(_objectSpread2$1({}, originChildProps), cloneProps), passedProps = {}, passedEventList = ["onContextMenu", "onClick", "onMouseDown", "onTouchStart", "onMouseEnter", "onMouseLeave", "onFocus", "onBlur"];
    passedEventList.forEach(function(eventName) {
      restProps[eventName] && (passedProps[eventName] = function() {
        for (var _mergedChildrenProps$, _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++)
          args[_key4] = arguments[_key4];
        (_mergedChildrenProps$ = mergedChildrenProps[eventName]) === null || _mergedChildrenProps$ === void 0 || _mergedChildrenProps$.call.apply(_mergedChildrenProps$, [mergedChildrenProps].concat(args)), restProps[eventName].apply(restProps, args);
      });
    });
    var triggerNode = /* @__PURE__ */ React.cloneElement(child, _objectSpread2$1(_objectSpread2$1({}, mergedChildrenProps), passedProps)), arrowPos = {
      x: arrowX,
      y: arrowY
    }, innerArrow = arrow ? _objectSpread2$1({}, arrow !== !0 ? arrow : {}) : null;
    return /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement(RefResizeObserver, {
      disabled: !mergedOpen,
      ref: setTargetRef,
      onResize: onTargetResize
    }, /* @__PURE__ */ React.createElement(TriggerWrapper, {
      getTriggerDOMNode
    }, triggerNode)), /* @__PURE__ */ React.createElement(TriggerContext.Provider, {
      value: context
    }, /* @__PURE__ */ React.createElement(Popup$2, {
      portal: PortalComponent,
      ref: setPopupRef,
      prefixCls,
      popup,
      className: cn(popupClassName, alignedClassName),
      style: popupStyle,
      target: targetEle,
      onMouseEnter: onPopupMouseEnter,
      onMouseLeave: onPopupMouseLeave,
      onPointerEnter: onPopupMouseEnter,
      zIndex,
      open: mergedOpen,
      keepDom: inMotion,
      fresh,
      onClick: onPopupClick,
      onPointerDownCapture: onPopupPointerDown,
      mask,
      motion: mergePopupMotion,
      maskMotion: mergeMaskMotion,
      onVisibleChanged,
      onPrepare,
      forceRender,
      autoDestroy: mergedAutoDestroy,
      getPopupContainer,
      align: alignInfo,
      arrow: innerArrow,
      arrowPos,
      ready,
      offsetX,
      offsetY,
      offsetR,
      offsetB,
      onAlign: triggerAlign,
      stretch,
      targetWidth: targetWidth / scaleX,
      targetHeight: targetHeight / scaleY
    })));
  });
  return process.env.NODE_ENV !== "production" && (Trigger2.displayName = "Trigger"), Trigger2;
}
__name(generateTrigger, "generateTrigger");
const Trigger = generateTrigger(Portal);
var _excluded$F = ["prefixCls", "disabled", "visible", "children", "popupElement", "animation", "transitionName", "dropdownStyle", "dropdownClassName", "direction", "placement", "builtinPlacements", "dropdownMatchSelectWidth", "dropdownRender", "dropdownAlign", "getPopupContainer", "empty", "getTriggerDOMNode", "onPopupVisibleChange", "onPopupMouseEnter"], getBuiltInPlacements$1 = /* @__PURE__ */ __name(function(dropdownMatchSelectWidth) {
  var adjustX = dropdownMatchSelectWidth === !0 ? 0 : 1;
  return {
    bottomLeft: {
      points: ["tl", "bl"],
      offset: [0, 4],
      overflow: {
        adjustX,
        adjustY: 1
      },
      htmlRegion: "scroll"
    },
    bottomRight: {
      points: ["tr", "br"],
      offset: [0, 4],
      overflow: {
        adjustX,
        adjustY: 1
      },
      htmlRegion: "scroll"
    },
    topLeft: {
      points: ["bl", "tl"],
      offset: [0, -4],
      overflow: {
        adjustX,
        adjustY: 1
      },
      htmlRegion: "scroll"
    },
    topRight: {
      points: ["br", "tr"],
      offset: [0, -4],
      overflow: {
        adjustX,
        adjustY: 1
      },
      htmlRegion: "scroll"
    }
  };
}, "getBuiltInPlacements"), SelectTrigger = /* @__PURE__ */ __name(function(props, ref) {
  var prefixCls = props.prefixCls;
  props.disabled;
  var visible = props.visible, children = props.children, popupElement = props.popupElement, animation = props.animation, transitionName = props.transitionName, dropdownStyle = props.dropdownStyle, dropdownClassName = props.dropdownClassName, _props$direction = props.direction, direction = _props$direction === void 0 ? "ltr" : _props$direction, placement = props.placement, builtinPlacements = props.builtinPlacements, dropdownMatchSelectWidth = props.dropdownMatchSelectWidth, dropdownRender = props.dropdownRender, dropdownAlign = props.dropdownAlign, getPopupContainer = props.getPopupContainer, empty2 = props.empty, getTriggerDOMNode = props.getTriggerDOMNode, onPopupVisibleChange = props.onPopupVisibleChange, onPopupMouseEnter = props.onPopupMouseEnter, restProps = _objectWithoutProperties(props, _excluded$F), dropdownPrefixCls = "".concat(prefixCls, "-dropdown"), popupNode = popupElement;
  dropdownRender && (popupNode = dropdownRender(popupElement));
  var mergedBuiltinPlacements2 = React.useMemo(function() {
    return builtinPlacements || getBuiltInPlacements$1(dropdownMatchSelectWidth);
  }, [builtinPlacements, dropdownMatchSelectWidth]), mergedTransitionName = animation ? "".concat(dropdownPrefixCls, "-").concat(animation) : transitionName, isNumberPopupWidth = typeof dropdownMatchSelectWidth == "number", stretch = React.useMemo(function() {
    return isNumberPopupWidth ? null : dropdownMatchSelectWidth === !1 ? "minWidth" : "width";
  }, [dropdownMatchSelectWidth, isNumberPopupWidth]), popupStyle = dropdownStyle;
  isNumberPopupWidth && (popupStyle = _objectSpread2$1(_objectSpread2$1({}, popupStyle), {}, {
    width: dropdownMatchSelectWidth
  }));
  var triggerPopupRef = React.useRef(null);
  return React.useImperativeHandle(ref, function() {
    return {
      getPopupElement: /* @__PURE__ */ __name(function() {
        var _triggerPopupRef$curr;
        return (_triggerPopupRef$curr = triggerPopupRef.current) === null || _triggerPopupRef$curr === void 0 ? void 0 : _triggerPopupRef$curr.popupElement;
      }, "getPopupElement")
    };
  }), /* @__PURE__ */ React.createElement(Trigger, _extends({}, restProps, {
    showAction: onPopupVisibleChange ? ["click"] : [],
    hideAction: onPopupVisibleChange ? ["click"] : [],
    popupPlacement: placement || (direction === "rtl" ? "bottomRight" : "bottomLeft"),
    builtinPlacements: mergedBuiltinPlacements2,
    prefixCls: dropdownPrefixCls,
    popupTransitionName: mergedTransitionName,
    popup: /* @__PURE__ */ React.createElement("div", {
      onMouseEnter: onPopupMouseEnter
    }, popupNode),
    ref: triggerPopupRef,
    stretch,
    popupAlign: dropdownAlign,
    popupVisible: visible,
    getPopupContainer,
    popupClassName: cn(dropdownClassName, _defineProperty$2({}, "".concat(dropdownPrefixCls, "-empty"), empty2)),
    popupStyle,
    getTriggerDOMNode,
    onPopupVisibleChange
  }), children);
}, "SelectTrigger"), RefSelectTrigger = /* @__PURE__ */ React.forwardRef(SelectTrigger);
process.env.NODE_ENV !== "production" && (RefSelectTrigger.displayName = "SelectTrigger");
function getKey$1(data, index2) {
  var key = data.key, value;
  return "value" in data && (value = data.value), key ?? (value !== void 0 ? value : "rc-index-key-".concat(index2));
}
__name(getKey$1, "getKey$1");
function isValidCount(value) {
  return typeof value < "u" && !Number.isNaN(value);
}
__name(isValidCount, "isValidCount");
function fillFieldNames$1(fieldNames, childrenAsData) {
  var _ref = fieldNames || {}, label2 = _ref.label, value = _ref.value, options = _ref.options, groupLabel = _ref.groupLabel, mergedLabel = label2 || (childrenAsData ? "children" : "label");
  return {
    label: mergedLabel,
    value: value || "value",
    options: options || "options",
    groupLabel: groupLabel || mergedLabel
  };
}
__name(fillFieldNames$1, "fillFieldNames$1");
function flattenOptions(options) {
  var _ref2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, fieldNames = _ref2.fieldNames, childrenAsData = _ref2.childrenAsData, flattenList = [], _fillFieldNames = fillFieldNames$1(fieldNames, !1), fieldLabel = _fillFieldNames.label, fieldValue = _fillFieldNames.value, fieldOptions = _fillFieldNames.options, groupLabel = _fillFieldNames.groupLabel;
  function dig(list, isGroupOption) {
    Array.isArray(list) && list.forEach(function(data) {
      if (isGroupOption || !(fieldOptions in data)) {
        var value = data[fieldValue];
        flattenList.push({
          key: getKey$1(data, flattenList.length),
          groupOption: isGroupOption,
          data,
          label: data[fieldLabel],
          value
        });
      } else {
        var grpLabel = data[groupLabel];
        grpLabel === void 0 && childrenAsData && (grpLabel = data.label), flattenList.push({
          key: getKey$1(data, flattenList.length),
          group: !0,
          data,
          label: grpLabel
        }), dig(data[fieldOptions], !0);
      }
    });
  }
  return __name(dig, "dig"), dig(options, !1), flattenList;
}
__name(flattenOptions, "flattenOptions");
function injectPropsWithOption(option) {
  var newOption = _objectSpread2$1({}, option);
  return "props" in newOption || Object.defineProperty(newOption, "props", {
    get: /* @__PURE__ */ __name(function() {
      return warningOnce(!1, "Return type is option instead of Option instance. Please read value directly instead of reading from `props`."), newOption;
    }, "get")
  }), newOption;
}
__name(injectPropsWithOption, "injectPropsWithOption");
var getSeparatedContent = /* @__PURE__ */ __name(function(text, tokens, end) {
  if (!tokens || !tokens.length)
    return null;
  var match2 = !1, separate = /* @__PURE__ */ __name(function separate2(str, _ref3) {
    var _ref4 = _toArray(_ref3), token2 = _ref4[0], restTokens = _ref4.slice(1);
    if (!token2)
      return [str];
    var list2 = str.split(token2);
    return match2 = match2 || list2.length > 1, list2.reduce(function(prevList, unitStr) {
      return [].concat(_toConsumableArray(prevList), _toConsumableArray(separate2(unitStr, restTokens)));
    }, []).filter(Boolean);
  }, "separate"), list = separate(text, tokens);
  return match2 ? typeof end < "u" ? list.slice(0, end) : list : null;
}, "getSeparatedContent"), SelectContext = /* @__PURE__ */ React.createContext(null);
function Polite(props) {
  var visible = props.visible, values = props.values;
  if (!visible)
    return null;
  var MAX_COUNT = 50;
  return /* @__PURE__ */ React.createElement("span", {
    "aria-live": "polite",
    style: {
      width: 0,
      height: 0,
      position: "absolute",
      overflow: "hidden",
      opacity: 0
    }
  }, "".concat(values.slice(0, MAX_COUNT).map(function(_ref) {
    var label2 = _ref.label, value = _ref.value;
    return ["number", "string"].includes(_typeof$4(label2)) ? label2 : value;
  }).join(", ")), values.length > MAX_COUNT ? ", ..." : null);
}
__name(Polite, "Polite");
var _excluded$E = ["id", "prefixCls", "className", "showSearch", "tagRender", "direction", "omitDomProps", "displayValues", "onDisplayValuesChange", "emptyOptions", "notFoundContent", "onClear", "mode", "disabled", "loading", "getInputElement", "getRawInputElement", "open", "defaultOpen", "onDropdownVisibleChange", "activeValue", "onActiveValueChange", "activeDescendantId", "searchValue", "autoClearSearchValue", "onSearch", "onSearchSplit", "tokenSeparators", "allowClear", "prefix", "suffixIcon", "clearIcon", "OptionList", "animation", "transitionName", "dropdownStyle", "dropdownClassName", "dropdownMatchSelectWidth", "dropdownRender", "dropdownAlign", "placement", "builtinPlacements", "getPopupContainer", "showAction", "onFocus", "onBlur", "onKeyUp", "onKeyDown", "onMouseDown"], DEFAULT_OMIT_PROPS = ["value", "onChange", "removeIcon", "placeholder", "autoFocus", "maxTagCount", "maxTagTextLength", "maxTagPlaceholder", "choiceTransitionName", "onInputKeyDown", "onPopupScroll", "tabIndex"], isMultiple = /* @__PURE__ */ __name(function(mode) {
  return mode === "tags" || mode === "multiple";
}, "isMultiple"), BaseSelect = /* @__PURE__ */ React.forwardRef(function(props, ref) {
  var _customizeRawInputEle, id2 = props.id, prefixCls = props.prefixCls, className = props.className, showSearch = props.showSearch, tagRender = props.tagRender, direction = props.direction, omitDomProps = props.omitDomProps, displayValues = props.displayValues, onDisplayValuesChange = props.onDisplayValuesChange, emptyOptions = props.emptyOptions, _props$notFoundConten = props.notFoundContent, notFoundContent = _props$notFoundConten === void 0 ? "Not Found" : _props$notFoundConten, onClear = props.onClear, mode = props.mode, disabled = props.disabled, loading = props.loading, getInputElement = props.getInputElement, getRawInputElement = props.getRawInputElement, open = props.open, defaultOpen = props.defaultOpen, onDropdownVisibleChange = props.onDropdownVisibleChange, activeValue = props.activeValue, onActiveValueChange = props.onActiveValueChange, activeDescendantId = props.activeDescendantId, searchValue = props.searchValue, autoClearSearchValue = props.autoClearSearchValue, onSearch = props.onSearch, onSearchSplit = props.onSearchSplit, tokenSeparators = props.tokenSeparators, allowClear = props.allowClear, prefix = props.prefix, suffixIcon = props.suffixIcon, clearIcon = props.clearIcon, OptionList3 = props.OptionList, animation = props.animation, transitionName = props.transitionName, dropdownStyle = props.dropdownStyle, dropdownClassName = props.dropdownClassName, dropdownMatchSelectWidth = props.dropdownMatchSelectWidth, dropdownRender = props.dropdownRender, dropdownAlign = props.dropdownAlign, placement = props.placement, builtinPlacements = props.builtinPlacements, getPopupContainer = props.getPopupContainer, _props$showAction = props.showAction, showAction = _props$showAction === void 0 ? [] : _props$showAction, onFocus = props.onFocus, onBlur = props.onBlur, onKeyUp = props.onKeyUp, onKeyDown2 = props.onKeyDown, onMouseDown = props.onMouseDown, restProps = _objectWithoutProperties(props, _excluded$E), multiple = isMultiple(mode), mergedShowSearch = (showSearch !== void 0 ? showSearch : multiple) || mode === "combobox", domProps = _objectSpread2$1({}, restProps);
  DEFAULT_OMIT_PROPS.forEach(function(propName) {
    delete domProps[propName];
  }), omitDomProps == null || omitDomProps.forEach(function(propName) {
    delete domProps[propName];
  });
  var _React$useState = React.useState(!1), _React$useState2 = _slicedToArray(_React$useState, 2), mobile = _React$useState2[0], setMobile = _React$useState2[1];
  React.useEffect(function() {
    setMobile(isMobile());
  }, []);
  var containerRef = React.useRef(null), selectorDomRef = React.useRef(null), triggerRef = React.useRef(null), selectorRef = React.useRef(null), listRef = React.useRef(null), blurRef = React.useRef(!1), _useDelayReset = useDelayReset(), _useDelayReset2 = _slicedToArray(_useDelayReset, 3), mockFocused = _useDelayReset2[0], setMockFocused = _useDelayReset2[1], cancelSetMockFocused = _useDelayReset2[2];
  React.useImperativeHandle(ref, function() {
    var _selectorRef$current, _selectorRef$current2;
    return {
      focus: (_selectorRef$current = selectorRef.current) === null || _selectorRef$current === void 0 ? void 0 : _selectorRef$current.focus,
      blur: (_selectorRef$current2 = selectorRef.current) === null || _selectorRef$current2 === void 0 ? void 0 : _selectorRef$current2.blur,
      scrollTo: /* @__PURE__ */ __name(function(arg) {
        var _listRef$current;
        return (_listRef$current = listRef.current) === null || _listRef$current === void 0 ? void 0 : _listRef$current.scrollTo(arg);
      }, "scrollTo"),
      nativeElement: containerRef.current || selectorDomRef.current
    };
  });
  var mergedSearchValue = React.useMemo(function() {
    var _displayValues$;
    if (mode !== "combobox")
      return searchValue;
    var val = (_displayValues$ = displayValues[0]) === null || _displayValues$ === void 0 ? void 0 : _displayValues$.value;
    return typeof val == "string" || typeof val == "number" ? String(val) : "";
  }, [searchValue, mode, displayValues]), customizeInputElement = mode === "combobox" && typeof getInputElement == "function" && getInputElement() || null, customizeRawInputElement = typeof getRawInputElement == "function" && getRawInputElement(), customizeRawInputRef = useComposeRef(selectorDomRef, customizeRawInputElement == null || (_customizeRawInputEle = customizeRawInputElement.props) === null || _customizeRawInputEle === void 0 ? void 0 : _customizeRawInputEle.ref), _React$useState3 = React.useState(!1), _React$useState4 = _slicedToArray(_React$useState3, 2), rendered = _React$useState4[0], setRendered = _React$useState4[1];
  useLayoutEffect$1(function() {
    setRendered(!0);
  }, []);
  var _useMergedState = useMergedState(!1, {
    defaultValue: defaultOpen,
    value: open
  }), _useMergedState2 = _slicedToArray(_useMergedState, 2), innerOpen = _useMergedState2[0], setInnerOpen = _useMergedState2[1], mergedOpen = rendered ? innerOpen : !1, emptyListContent = !notFoundContent && emptyOptions;
  (disabled || emptyListContent && mergedOpen && mode === "combobox") && (mergedOpen = !1);
  var triggerOpen = emptyListContent ? !1 : mergedOpen, onToggleOpen = React.useCallback(function(newOpen) {
    var nextOpen = newOpen !== void 0 ? newOpen : !mergedOpen;
    disabled || (setInnerOpen(nextOpen), mergedOpen !== nextOpen && (onDropdownVisibleChange == null || onDropdownVisibleChange(nextOpen)));
  }, [disabled, mergedOpen, setInnerOpen, onDropdownVisibleChange]), tokenWithEnter = React.useMemo(function() {
    return (tokenSeparators || []).some(function(tokenSeparator) {
      return [`
`, `\r
`].includes(tokenSeparator);
    });
  }, [tokenSeparators]), _ref = React.useContext(SelectContext) || {}, maxCount = _ref.maxCount, rawValues = _ref.rawValues, onInternalSearch = /* @__PURE__ */ __name(function(searchText, fromTyping, isCompositing) {
    if (!(multiple && isValidCount(maxCount) && (rawValues == null ? void 0 : rawValues.size) >= maxCount)) {
      var ret = !0, newSearchText = searchText;
      onActiveValueChange == null || onActiveValueChange(null);
      var separatedList = getSeparatedContent(searchText, tokenSeparators, isValidCount(maxCount) ? maxCount - rawValues.size : void 0), patchLabels = isCompositing ? null : separatedList;
      return mode !== "combobox" && patchLabels && (newSearchText = "", onSearchSplit == null || onSearchSplit(patchLabels), onToggleOpen(!1), ret = !1), onSearch && mergedSearchValue !== newSearchText && onSearch(newSearchText, {
        source: fromTyping ? "typing" : "effect"
      }), ret;
    }
  }, "onInternalSearch"), onInternalSearchSubmit = /* @__PURE__ */ __name(function(searchText) {
    !searchText || !searchText.trim() || onSearch(searchText, {
      source: "submit"
    });
  }, "onInternalSearchSubmit");
  React.useEffect(function() {
    !mergedOpen && !multiple && mode !== "combobox" && onInternalSearch("", !1, !1);
  }, [mergedOpen]), React.useEffect(function() {
    innerOpen && disabled && setInnerOpen(!1), disabled && !blurRef.current && setMockFocused(!1);
  }, [disabled]);
  var _useLock = useLock(), _useLock2 = _slicedToArray(_useLock, 2), getClearLock = _useLock2[0], setClearLock = _useLock2[1], keyLockRef = React.useRef(!1), onInternalKeyDown = /* @__PURE__ */ __name(function(event) {
    var clearLock = getClearLock(), key = event.key, isEnterKey = key === "Enter";
    if (isEnterKey && (mode !== "combobox" && event.preventDefault(), mergedOpen || onToggleOpen(!0)), setClearLock(!!mergedSearchValue), key === "Backspace" && !clearLock && multiple && !mergedSearchValue && displayValues.length) {
      for (var cloneDisplayValues = _toConsumableArray(displayValues), removedDisplayValue = null, i = cloneDisplayValues.length - 1; i >= 0; i -= 1) {
        var current = cloneDisplayValues[i];
        if (!current.disabled) {
          cloneDisplayValues.splice(i, 1), removedDisplayValue = current;
          break;
        }
      }
      removedDisplayValue && onDisplayValuesChange(cloneDisplayValues, {
        type: "remove",
        values: [removedDisplayValue]
      });
    }
    for (var _len = arguments.length, rest = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++)
      rest[_key - 1] = arguments[_key];
    if (mergedOpen && (!isEnterKey || !keyLockRef.current)) {
      var _listRef$current2;
      isEnterKey && (keyLockRef.current = !0), (_listRef$current2 = listRef.current) === null || _listRef$current2 === void 0 || _listRef$current2.onKeyDown.apply(_listRef$current2, [event].concat(rest));
    }
    onKeyDown2 == null || onKeyDown2.apply(void 0, [event].concat(rest));
  }, "onInternalKeyDown"), onInternalKeyUp = /* @__PURE__ */ __name(function(event) {
    for (var _len2 = arguments.length, rest = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++)
      rest[_key2 - 1] = arguments[_key2];
    if (mergedOpen) {
      var _listRef$current3;
      (_listRef$current3 = listRef.current) === null || _listRef$current3 === void 0 || _listRef$current3.onKeyUp.apply(_listRef$current3, [event].concat(rest));
    }
    event.key === "Enter" && (keyLockRef.current = !1), onKeyUp == null || onKeyUp.apply(void 0, [event].concat(rest));
  }, "onInternalKeyUp"), onSelectorRemove = /* @__PURE__ */ __name(function(val) {
    var newValues = displayValues.filter(function(i) {
      return i !== val;
    });
    onDisplayValuesChange(newValues, {
      type: "remove",
      values: [val]
    });
  }, "onSelectorRemove"), onInputBlur = /* @__PURE__ */ __name(function() {
    keyLockRef.current = !1;
  }, "onInputBlur"), focusRef = React.useRef(!1), onContainerFocus = /* @__PURE__ */ __name(function() {
    setMockFocused(!0), disabled || (onFocus && !focusRef.current && onFocus.apply(void 0, arguments), showAction.includes("focus") && onToggleOpen(!0)), focusRef.current = !0;
  }, "onContainerFocus"), onContainerBlur = /* @__PURE__ */ __name(function() {
    blurRef.current = !0, setMockFocused(!1, function() {
      focusRef.current = !1, blurRef.current = !1, onToggleOpen(!1);
    }), !disabled && (mergedSearchValue && (mode === "tags" ? onSearch(mergedSearchValue, {
      source: "submit"
    }) : mode === "multiple" && onSearch("", {
      source: "blur"
    })), onBlur && onBlur.apply(void 0, arguments));
  }, "onContainerBlur"), activeTimeoutIds = [];
  React.useEffect(function() {
    return function() {
      activeTimeoutIds.forEach(function(timeoutId) {
        return clearTimeout(timeoutId);
      }), activeTimeoutIds.splice(0, activeTimeoutIds.length);
    };
  }, []);
  var onInternalMouseDown = /* @__PURE__ */ __name(function(event) {
    var _triggerRef$current, target = event.target, popupElement = (_triggerRef$current = triggerRef.current) === null || _triggerRef$current === void 0 ? void 0 : _triggerRef$current.getPopupElement();
    if (popupElement && popupElement.contains(target)) {
      var timeoutId = setTimeout(function() {
        var index2 = activeTimeoutIds.indexOf(timeoutId);
        if (index2 !== -1 && activeTimeoutIds.splice(index2, 1), cancelSetMockFocused(), !mobile && !popupElement.contains(document.activeElement)) {
          var _selectorRef$current3;
          (_selectorRef$current3 = selectorRef.current) === null || _selectorRef$current3 === void 0 || _selectorRef$current3.focus();
        }
      });
      activeTimeoutIds.push(timeoutId);
    }
    for (var _len3 = arguments.length, restArgs = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++)
      restArgs[_key3 - 1] = arguments[_key3];
    onMouseDown == null || onMouseDown.apply(void 0, [event].concat(restArgs));
  }, "onInternalMouseDown"), _React$useState5 = React.useState({}), _React$useState6 = _slicedToArray(_React$useState5, 2), forceUpdate = _React$useState6[1];
  function onPopupMouseEnter() {
    forceUpdate({});
  }
  __name(onPopupMouseEnter, "onPopupMouseEnter");
  var onTriggerVisibleChange;
  customizeRawInputElement && (onTriggerVisibleChange = /* @__PURE__ */ __name(function(newOpen) {
    onToggleOpen(newOpen);
  }, "onTriggerVisibleChange")), useSelectTriggerControl(function() {
    var _triggerRef$current2;
    return [containerRef.current, (_triggerRef$current2 = triggerRef.current) === null || _triggerRef$current2 === void 0 ? void 0 : _triggerRef$current2.getPopupElement()];
  }, triggerOpen, onToggleOpen, !!customizeRawInputElement);
  var baseSelectContext = React.useMemo(function() {
    return _objectSpread2$1(_objectSpread2$1({}, props), {}, {
      notFoundContent,
      open: mergedOpen,
      triggerOpen,
      id: id2,
      showSearch: mergedShowSearch,
      multiple,
      toggleOpen: onToggleOpen
    });
  }, [props, notFoundContent, triggerOpen, mergedOpen, id2, mergedShowSearch, multiple, onToggleOpen]), showSuffixIcon = !!suffixIcon || loading, arrowNode;
  showSuffixIcon && (arrowNode = /* @__PURE__ */ React.createElement(TransBtn, {
    className: cn("".concat(prefixCls, "-arrow"), _defineProperty$2({}, "".concat(prefixCls, "-arrow-loading"), loading)),
    customizeIcon: suffixIcon,
    customizeIconProps: {
      loading,
      searchValue: mergedSearchValue,
      open: mergedOpen,
      focused: mockFocused,
      showSearch: mergedShowSearch
    }
  }));
  var onClearMouseDown = /* @__PURE__ */ __name(function() {
    var _selectorRef$current4;
    onClear == null || onClear(), (_selectorRef$current4 = selectorRef.current) === null || _selectorRef$current4 === void 0 || _selectorRef$current4.focus(), onDisplayValuesChange([], {
      type: "clear",
      values: displayValues
    }), onInternalSearch("", !1, !1);
  }, "onClearMouseDown"), _useAllowClear = useAllowClear(prefixCls, onClearMouseDown, displayValues, allowClear, clearIcon, disabled, mergedSearchValue, mode), mergedAllowClear = _useAllowClear.allowClear, clearNode = _useAllowClear.clearIcon, optionList = /* @__PURE__ */ React.createElement(OptionList3, {
    ref: listRef
  }), mergedClassName = cn(prefixCls, className, _defineProperty$2(_defineProperty$2(_defineProperty$2(_defineProperty$2(_defineProperty$2(_defineProperty$2(_defineProperty$2(_defineProperty$2(_defineProperty$2(_defineProperty$2({}, "".concat(prefixCls, "-focused"), mockFocused), "".concat(prefixCls, "-multiple"), multiple), "".concat(prefixCls, "-single"), !multiple), "".concat(prefixCls, "-allow-clear"), allowClear), "".concat(prefixCls, "-show-arrow"), showSuffixIcon), "".concat(prefixCls, "-disabled"), disabled), "".concat(prefixCls, "-loading"), loading), "".concat(prefixCls, "-open"), mergedOpen), "".concat(prefixCls, "-customize-input"), customizeInputElement), "".concat(prefixCls, "-show-search"), mergedShowSearch)), selectorNode = /* @__PURE__ */ React.createElement(RefSelectTrigger, {
    ref: triggerRef,
    disabled,
    prefixCls,
    visible: triggerOpen,
    popupElement: optionList,
    animation,
    transitionName,
    dropdownStyle,
    dropdownClassName,
    direction,
    dropdownMatchSelectWidth,
    dropdownRender,
    dropdownAlign,
    placement,
    builtinPlacements,
    getPopupContainer,
    empty: emptyOptions,
    getTriggerDOMNode: /* @__PURE__ */ __name(function(node2) {
      return (
        // TODO: This is workaround and should be removed in `rc-select`
        // And use new standard `nativeElement` for ref.
        // But we should update `rc-resize-observer` first.
        selectorDomRef.current || node2
      );
    }, "getTriggerDOMNode"),
    onPopupVisibleChange: onTriggerVisibleChange,
    onPopupMouseEnter
  }, customizeRawInputElement ? /* @__PURE__ */ React.cloneElement(customizeRawInputElement, {
    ref: customizeRawInputRef
  }) : /* @__PURE__ */ React.createElement(ForwardSelector, _extends({}, props, {
    domRef: selectorDomRef,
    prefixCls,
    inputElement: customizeInputElement,
    ref: selectorRef,
    id: id2,
    prefix,
    showSearch: mergedShowSearch,
    autoClearSearchValue,
    mode,
    activeDescendantId,
    tagRender,
    values: displayValues,
    open: mergedOpen,
    onToggleOpen,
    activeValue,
    searchValue: mergedSearchValue,
    onSearch: onInternalSearch,
    onSearchSubmit: onInternalSearchSubmit,
    onRemove: onSelectorRemove,
    tokenWithEnter,
    onInputBlur
  }))), renderNode;
  return customizeRawInputElement ? renderNode = selectorNode : renderNode = /* @__PURE__ */ React.createElement("div", _extends({
    className: mergedClassName
  }, domProps, {
    ref: containerRef,
    onMouseDown: onInternalMouseDown,
    onKeyDown: onInternalKeyDown,
    onKeyUp: onInternalKeyUp,
    onFocus: onContainerFocus,
    onBlur: onContainerBlur
  }), /* @__PURE__ */ React.createElement(Polite, {
    visible: mockFocused && !mergedOpen,
    values: displayValues
  }), selectorNode, arrowNode, mergedAllowClear && clearNode), /* @__PURE__ */ React.createElement(BaseSelectContext.Provider, {
    value: baseSelectContext
  }, renderNode);
});
process.env.NODE_ENV !== "production" && (BaseSelect.displayName = "BaseSelect");
var OptGroup = /* @__PURE__ */ __name(function() {
  return null;
}, "OptGroup");
OptGroup.isSelectOptGroup = !0;
var Option$1 = /* @__PURE__ */ __name(function() {
  return null;
}, "Option");
Option$1.isSelectOption = !0;
var Filler = /* @__PURE__ */ React.forwardRef(function(_ref, ref) {
  var height = _ref.height, offsetY = _ref.offsetY, offsetX = _ref.offsetX, children = _ref.children, prefixCls = _ref.prefixCls, onInnerResize = _ref.onInnerResize, innerProps = _ref.innerProps, rtl = _ref.rtl, extra = _ref.extra, outerStyle = {}, innerStyle2 = {
    display: "flex",
    flexDirection: "column"
  };
  return offsetY !== void 0 && (outerStyle = {
    height,
    position: "relative",
    overflow: "hidden"
  }, innerStyle2 = _objectSpread2$1(_objectSpread2$1({}, innerStyle2), {}, _defineProperty$2(_defineProperty$2(_defineProperty$2(_defineProperty$2(_defineProperty$2({
    transform: "translateY(".concat(offsetY, "px)")
  }, rtl ? "marginRight" : "marginLeft", -offsetX), "position", "absolute"), "left", 0), "right", 0), "top", 0))), /* @__PURE__ */ React.createElement("div", {
    style: outerStyle
  }, /* @__PURE__ */ React.createElement(RefResizeObserver, {
    onResize: /* @__PURE__ */ __name(function(_ref2) {
      var offsetHeight = _ref2.offsetHeight;
      offsetHeight && onInnerResize && onInnerResize();
    }, "onResize")
  }, /* @__PURE__ */ React.createElement("div", _extends({
    style: innerStyle2,
    className: cn(_defineProperty$2({}, "".concat(prefixCls, "-holder-inner"), prefixCls)),
    ref
  }, innerProps), children, extra)));
});
Filler.displayName = "Filler";
function Item$1(_ref) {
  var children = _ref.children, setRef = _ref.setRef, refFunc = React.useCallback(function(node2) {
    setRef(node2);
  }, []);
  return /* @__PURE__ */ React.cloneElement(children, {
    ref: refFunc
  });
}
__name(Item$1, "Item$1");
function useChildren$1(list, startIndex, endIndex, scrollWidth, offsetX, setNodeRef, renderFunc, _ref) {
  var getKey2 = _ref.getKey;
  return list.slice(startIndex, endIndex + 1).map(function(item, index2) {
    var eleIndex = startIndex + index2, node2 = renderFunc(item, eleIndex, {
      style: {
        width: scrollWidth
      },
      offsetX
    }), key = getKey2(item);
    return /* @__PURE__ */ React.createElement(Item$1, {
      key,
      setRef: /* @__PURE__ */ __name(function(ele) {
        return setNodeRef(item, ele);
      }, "setRef")
    }, node2);
  });
}
__name(useChildren$1, "useChildren$1");
function findListDiffIndex(originList, targetList, getKey2) {
  var originLen = originList.length, targetLen = targetList.length, shortList, longList;
  if (originLen === 0 && targetLen === 0)
    return null;
  originLen < targetLen ? (shortList = originList, longList = targetList) : (shortList = targetList, longList = originList);
  var notExistKey = {
    __EMPTY_ITEM__: !0
  };
  function getItemKey(item) {
    return item !== void 0 ? getKey2(item) : notExistKey;
  }
  __name(getItemKey, "getItemKey");
  for (var diffIndex = null, multiple = Math.abs(originLen - targetLen) !== 1, i = 0; i < longList.length; i += 1) {
    var shortKey = getItemKey(shortList[i]), longKey = getItemKey(longList[i]);
    if (shortKey !== longKey) {
      diffIndex = i, multiple = multiple || shortKey !== getItemKey(longList[i + 1]);
      break;
    }
  }
  return diffIndex === null ? null : {
    index: diffIndex,
    multiple
  };
}
__name(findListDiffIndex, "findListDiffIndex");
function useDiffItem(data, getKey2, onDiff) {
  var _React$useState = React.useState(data), _React$useState2 = _slicedToArray(_React$useState, 2), prevData = _React$useState2[0], setPrevData = _React$useState2[1], _React$useState3 = React.useState(null), _React$useState4 = _slicedToArray(_React$useState3, 2), diffItem = _React$useState4[0], setDiffItem = _React$useState4[1];
  return React.useEffect(function() {
    var diff = findListDiffIndex(prevData || [], data || [], getKey2);
    (diff == null ? void 0 : diff.index) !== void 0 && setDiffItem(data[diff.index]), setPrevData(data);
  }, [data]), [diffItem];
}
__name(useDiffItem, "useDiffItem");
var isFF = (typeof navigator > "u" ? "undefined" : _typeof$4(navigator)) === "object" && /Firefox/i.test(navigator.userAgent);
const useOriginScroll = /* @__PURE__ */ __name(function(isScrollAtTop, isScrollAtBottom, isScrollAtLeft, isScrollAtRight) {
  var lockRef = useRef(!1), lockTimeoutRef = useRef(null);
  function lockScroll() {
    clearTimeout(lockTimeoutRef.current), lockRef.current = !0, lockTimeoutRef.current = setTimeout(function() {
      lockRef.current = !1;
    }, 50);
  }
  __name(lockScroll, "lockScroll");
  var scrollPingRef = useRef({
    top: isScrollAtTop,
    bottom: isScrollAtBottom,
    left: isScrollAtLeft,
    right: isScrollAtRight
  });
  return scrollPingRef.current.top = isScrollAtTop, scrollPingRef.current.bottom = isScrollAtBottom, scrollPingRef.current.left = isScrollAtLeft, scrollPingRef.current.right = isScrollAtRight, function(isHorizontal, delta) {
    var smoothOffset = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !1, originScroll = isHorizontal ? (
      // Pass origin wheel when on the left
      delta < 0 && scrollPingRef.current.left || // Pass origin wheel when on the right
      delta > 0 && scrollPingRef.current.right
    ) : delta < 0 && scrollPingRef.current.top || // Pass origin wheel when on the bottom
    delta > 0 && scrollPingRef.current.bottom;
    return smoothOffset && originScroll ? (clearTimeout(lockTimeoutRef.current), lockRef.current = !1) : (!originScroll || lockRef.current) && lockScroll(), !lockRef.current && originScroll;
  };
}, "useOriginScroll");
function useFrameWheel(inVirtual, isScrollAtTop, isScrollAtBottom, isScrollAtLeft, isScrollAtRight, horizontalScroll, onWheelDelta) {
  var offsetRef = useRef(0), nextFrameRef = useRef(null), wheelValueRef = useRef(null), isMouseScrollRef = useRef(!1), originScroll = useOriginScroll(isScrollAtTop, isScrollAtBottom, isScrollAtLeft, isScrollAtRight);
  function onWheelY(e2, deltaY) {
    if (wrapperRaf.cancel(nextFrameRef.current), !originScroll(!1, deltaY)) {
      var event = e2;
      if (!event._virtualHandled)
        event._virtualHandled = !0;
      else
        return;
      offsetRef.current += deltaY, wheelValueRef.current = deltaY, isFF || event.preventDefault(), nextFrameRef.current = wrapperRaf(function() {
        var patchMultiple = isMouseScrollRef.current ? 10 : 1;
        onWheelDelta(offsetRef.current * patchMultiple, !1), offsetRef.current = 0;
      });
    }
  }
  __name(onWheelY, "onWheelY");
  function onWheelX(event, deltaX) {
    onWheelDelta(deltaX, !0), isFF || event.preventDefault();
  }
  __name(onWheelX, "onWheelX");
  var wheelDirectionRef = useRef(null), wheelDirectionCleanRef = useRef(null);
  function onWheel(event) {
    if (inVirtual) {
      wrapperRaf.cancel(wheelDirectionCleanRef.current), wheelDirectionCleanRef.current = wrapperRaf(function() {
        wheelDirectionRef.current = null;
      }, 2);
      var deltaX = event.deltaX, deltaY = event.deltaY, shiftKey = event.shiftKey, mergedDeltaX = deltaX, mergedDeltaY = deltaY;
      (wheelDirectionRef.current === "sx" || !wheelDirectionRef.current && shiftKey && deltaY && !deltaX) && (mergedDeltaX = deltaY, mergedDeltaY = 0, wheelDirectionRef.current = "sx");
      var absX = Math.abs(mergedDeltaX), absY = Math.abs(mergedDeltaY);
      wheelDirectionRef.current === null && (wheelDirectionRef.current = horizontalScroll && absX > absY ? "x" : "y"), wheelDirectionRef.current === "y" ? onWheelY(event, mergedDeltaY) : onWheelX(event, mergedDeltaX);
    }
  }
  __name(onWheel, "onWheel");
  function onFireFoxScroll(event) {
    inVirtual && (isMouseScrollRef.current = event.detail === wheelValueRef.current);
  }
  return __name(onFireFoxScroll, "onFireFoxScroll"), [onWheel, onFireFoxScroll];
}
__name(useFrameWheel, "useFrameWheel");
function useGetSize(mergedData, getKey2, heights, itemHeight) {
  var _React$useMemo = React.useMemo(function() {
    return [/* @__PURE__ */ new Map(), []];
  }, [mergedData, heights.id, itemHeight]), _React$useMemo2 = _slicedToArray(_React$useMemo, 2), key2Index = _React$useMemo2[0], bottomList = _React$useMemo2[1], getSize3 = /* @__PURE__ */ __name(function(startKey) {
    var endKey = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : startKey, startIndex = key2Index.get(startKey), endIndex = key2Index.get(endKey);
    if (startIndex === void 0 || endIndex === void 0)
      for (var dataLen = mergedData.length, i = bottomList.length; i < dataLen; i += 1) {
        var _heights$get, item = mergedData[i], key = getKey2(item);
        key2Index.set(key, i);
        var cacheHeight = (_heights$get = heights.get(key)) !== null && _heights$get !== void 0 ? _heights$get : itemHeight;
        if (bottomList[i] = (bottomList[i - 1] || 0) + cacheHeight, key === startKey && (startIndex = i), key === endKey && (endIndex = i), startIndex !== void 0 && endIndex !== void 0)
          break;
      }
    return {
      top: bottomList[startIndex - 1] || 0,
      bottom: bottomList[endIndex]
    };
  }, "getSize");
  return getSize3;
}
__name(useGetSize, "useGetSize");
var CacheMap = /* @__PURE__ */ function() {
  function CacheMap2() {
    _classCallCheck$1(this, CacheMap2), _defineProperty$2(this, "maps", void 0), _defineProperty$2(this, "id", 0), _defineProperty$2(this, "diffKeys", /* @__PURE__ */ new Set()), this.maps = /* @__PURE__ */ Object.create(null);
  }
  return __name(CacheMap2, "CacheMap"), _createClass$1(CacheMap2, [{
    key: "set",
    value: /* @__PURE__ */ __name(function(key, value) {
      this.maps[key] = value, this.id += 1, this.diffKeys.add(key);
    }, "set")
  }, {
    key: "get",
    value: /* @__PURE__ */ __name(function(key) {
      return this.maps[key];
    }, "get")
    /**
     * CacheMap will record the key changed.
     * To help to know what's update in the next render.
     */
  }, {
    key: "resetRecord",
    value: /* @__PURE__ */ __name(function() {
      this.diffKeys.clear();
    }, "resetRecord")
  }, {
    key: "getRecord",
    value: /* @__PURE__ */ __name(function() {
      return this.diffKeys;
    }, "getRecord")
  }]), CacheMap2;
}();
function parseNumber(value) {
  var num = parseFloat(value);
  return isNaN(num) ? 0 : num;
}
__name(parseNumber, "parseNumber");
function useHeights(getKey2, onItemAdd, onItemRemove) {
  var _React$useState = React.useState(0), _React$useState2 = _slicedToArray(_React$useState, 2), updatedMark = _React$useState2[0], setUpdatedMark = _React$useState2[1], instanceRef = useRef(/* @__PURE__ */ new Map()), heightsRef = useRef(new CacheMap()), promiseIdRef = useRef(0);
  function cancelRaf() {
    promiseIdRef.current += 1;
  }
  __name(cancelRaf, "cancelRaf");
  function collectHeight() {
    var sync = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : !1;
    cancelRaf();
    var doCollect = /* @__PURE__ */ __name(function() {
      var changed = !1;
      instanceRef.current.forEach(function(element, key) {
        if (element && element.offsetParent) {
          var htmlElement = findDOMNode(element), offsetHeight = htmlElement.offsetHeight, _getComputedStyle = getComputedStyle(htmlElement), marginTop = _getComputedStyle.marginTop, marginBottom = _getComputedStyle.marginBottom, marginTopNum = parseNumber(marginTop), marginBottomNum = parseNumber(marginBottom), totalHeight = offsetHeight + marginTopNum + marginBottomNum;
          heightsRef.current.get(key) !== totalHeight && (heightsRef.current.set(key, totalHeight), changed = !0);
        }
      }), changed && setUpdatedMark(function(c) {
        return c + 1;
      });
    }, "doCollect");
    if (sync)
      doCollect();
    else {
      promiseIdRef.current += 1;
      var id2 = promiseIdRef.current;
      Promise.resolve().then(function() {
        id2 === promiseIdRef.current && doCollect();
      });
    }
  }
  __name(collectHeight, "collectHeight");
  function setInstanceRef(item, instance2) {
    var key = getKey2(item);
    instanceRef.current.get(key), instance2 ? (instanceRef.current.set(key, instance2), collectHeight()) : instanceRef.current.delete(key);
  }
  return __name(setInstanceRef, "setInstanceRef"), useEffect(function() {
    return cancelRaf;
  }, []), [setInstanceRef, collectHeight, heightsRef.current, updatedMark];
}
__name(useHeights, "useHeights");
var SMOOTH_PTG = 14 / 15;
function useMobileTouchMove(inVirtual, listRef, callback) {
  var touchedRef = useRef(!1), touchXRef = useRef(0), touchYRef = useRef(0), elementRef = useRef(null), intervalRef = useRef(null), cleanUpEvents, onTouchMove = /* @__PURE__ */ __name(function(e2) {
    if (touchedRef.current) {
      var currentX = Math.ceil(e2.touches[0].pageX), currentY = Math.ceil(e2.touches[0].pageY), offsetX = touchXRef.current - currentX, offsetY = touchYRef.current - currentY, _isHorizontal = Math.abs(offsetX) > Math.abs(offsetY);
      _isHorizontal ? touchXRef.current = currentX : touchYRef.current = currentY;
      var scrollHandled = callback(_isHorizontal, _isHorizontal ? offsetX : offsetY, !1, e2);
      scrollHandled && e2.preventDefault(), clearInterval(intervalRef.current), scrollHandled && (intervalRef.current = setInterval(function() {
        _isHorizontal ? offsetX *= SMOOTH_PTG : offsetY *= SMOOTH_PTG;
        var offset2 = Math.floor(_isHorizontal ? offsetX : offsetY);
        (!callback(_isHorizontal, offset2, !0) || Math.abs(offset2) <= 0.1) && clearInterval(intervalRef.current);
      }, 16));
    }
  }, "onTouchMove"), onTouchEnd = /* @__PURE__ */ __name(function() {
    touchedRef.current = !1, cleanUpEvents();
  }, "onTouchEnd"), onTouchStart = /* @__PURE__ */ __name(function(e2) {
    cleanUpEvents(), e2.touches.length === 1 && !touchedRef.current && (touchedRef.current = !0, touchXRef.current = Math.ceil(e2.touches[0].pageX), touchYRef.current = Math.ceil(e2.touches[0].pageY), elementRef.current = e2.target, elementRef.current.addEventListener("touchmove", onTouchMove, {
      passive: !1
    }), elementRef.current.addEventListener("touchend", onTouchEnd, {
      passive: !0
    }));
  }, "onTouchStart");
  cleanUpEvents = /* @__PURE__ */ __name(function() {
    elementRef.current && (elementRef.current.removeEventListener("touchmove", onTouchMove), elementRef.current.removeEventListener("touchend", onTouchEnd));
  }, "cleanUpEvents"), useLayoutEffect$1(function() {
    return inVirtual && listRef.current.addEventListener("touchstart", onTouchStart, {
      passive: !0
    }), function() {
      var _listRef$current;
      (_listRef$current = listRef.current) === null || _listRef$current === void 0 || _listRef$current.removeEventListener("touchstart", onTouchStart), cleanUpEvents(), clearInterval(intervalRef.current);
    };
  }, [inVirtual]);
}
__name(useMobileTouchMove, "useMobileTouchMove");
function smoothScrollOffset(offset2) {
  return Math.floor(Math.pow(offset2, 0.5));
}
__name(smoothScrollOffset, "smoothScrollOffset");
function getPageXY(e2, horizontal) {
  var obj = "touches" in e2 ? e2.touches[0] : e2;
  return obj[horizontal ? "pageX" : "pageY"] - window[horizontal ? "scrollX" : "scrollY"];
}
__name(getPageXY, "getPageXY");
function useScrollDrag(inVirtual, componentRef, onScrollOffset) {
  React.useEffect(function() {
    var ele = componentRef.current;
    if (inVirtual && ele) {
      var mouseDownLock = !1, rafId, _offset, stopScroll = /* @__PURE__ */ __name(function() {
        wrapperRaf.cancel(rafId);
      }, "stopScroll"), continueScroll = /* @__PURE__ */ __name(function continueScroll2() {
        stopScroll(), rafId = wrapperRaf(function() {
          onScrollOffset(_offset), continueScroll2();
        });
      }, "continueScroll"), onMouseDown = /* @__PURE__ */ __name(function(e2) {
        var event = e2;
        event._virtualHandled || (event._virtualHandled = !0, mouseDownLock = !0);
      }, "onMouseDown"), onMouseUp = /* @__PURE__ */ __name(function() {
        mouseDownLock = !1, stopScroll();
      }, "onMouseUp"), onMouseMove = /* @__PURE__ */ __name(function(e2) {
        if (mouseDownLock) {
          var mouseY = getPageXY(e2, !1), _ele$getBoundingClien = ele.getBoundingClientRect(), top = _ele$getBoundingClien.top, bottom = _ele$getBoundingClien.bottom;
          if (mouseY <= top) {
            var diff = top - mouseY;
            _offset = -smoothScrollOffset(diff), continueScroll();
          } else if (mouseY >= bottom) {
            var _diff = mouseY - bottom;
            _offset = smoothScrollOffset(_diff), continueScroll();
          } else
            stopScroll();
        }
      }, "onMouseMove");
      return ele.addEventListener("mousedown", onMouseDown), ele.ownerDocument.addEventListener("mouseup", onMouseUp), ele.ownerDocument.addEventListener("mousemove", onMouseMove), function() {
        ele.removeEventListener("mousedown", onMouseDown), ele.ownerDocument.removeEventListener("mouseup", onMouseUp), ele.ownerDocument.removeEventListener("mousemove", onMouseMove), stopScroll();
      };
    }
  }, [inVirtual]);
}
__name(useScrollDrag, "useScrollDrag");
var MAX_TIMES = 10;
function useScrollTo$1(containerRef, data, heights, itemHeight, getKey2, collectHeight, syncScrollTop, triggerFlash) {
  var scrollRef = React.useRef(), _React$useState = React.useState(null), _React$useState2 = _slicedToArray(_React$useState, 2), syncState = _React$useState2[0], setSyncState = _React$useState2[1];
  return useLayoutEffect$1(function() {
    if (syncState && syncState.times < MAX_TIMES) {
      if (!containerRef.current) {
        setSyncState(function(ori) {
          return _objectSpread2$1({}, ori);
        });
        return;
      }
      collectHeight();
      var targetAlign = syncState.targetAlign, originAlign = syncState.originAlign, index2 = syncState.index, offset2 = syncState.offset, height = containerRef.current.clientHeight, needCollectHeight = !1, newTargetAlign = targetAlign, targetTop = null;
      if (height) {
        for (var mergedAlign = targetAlign || originAlign, stackTop = 0, itemTop = 0, itemBottom = 0, maxLen = Math.min(data.length - 1, index2), i = 0; i <= maxLen; i += 1) {
          var key = getKey2(data[i]);
          itemTop = stackTop;
          var cacheHeight = heights.get(key);
          itemBottom = itemTop + (cacheHeight === void 0 ? itemHeight : cacheHeight), stackTop = itemBottom;
        }
        for (var leftHeight = mergedAlign === "top" ? offset2 : height - offset2, _i = maxLen; _i >= 0; _i -= 1) {
          var _key = getKey2(data[_i]), _cacheHeight = heights.get(_key);
          if (_cacheHeight === void 0) {
            needCollectHeight = !0;
            break;
          }
          if (leftHeight -= _cacheHeight, leftHeight <= 0)
            break;
        }
        switch (mergedAlign) {
          case "top":
            targetTop = itemTop - offset2;
            break;
          case "bottom":
            targetTop = itemBottom - height + offset2;
            break;
          default: {
            var scrollTop = containerRef.current.scrollTop, scrollBottom = scrollTop + height;
            itemTop < scrollTop ? newTargetAlign = "top" : itemBottom > scrollBottom && (newTargetAlign = "bottom");
          }
        }
        targetTop !== null && syncScrollTop(targetTop), targetTop !== syncState.lastTop && (needCollectHeight = !0);
      }
      needCollectHeight && setSyncState(_objectSpread2$1(_objectSpread2$1({}, syncState), {}, {
        times: syncState.times + 1,
        targetAlign: newTargetAlign,
        lastTop: targetTop
      }));
    } else process.env.NODE_ENV !== "production" && (syncState == null ? void 0 : syncState.times) === MAX_TIMES && warningOnce(!1, "Seems `scrollTo` with `rc-virtual-list` reach the max limitation. Please fire issue for us. Thanks.");
  }, [syncState, containerRef.current]), function(arg) {
    if (arg == null) {
      triggerFlash();
      return;
    }
    if (wrapperRaf.cancel(scrollRef.current), typeof arg == "number")
      syncScrollTop(arg);
    else if (arg && _typeof$4(arg) === "object") {
      var index2, align = arg.align;
      "index" in arg ? index2 = arg.index : index2 = data.findIndex(function(item) {
        return getKey2(item) === arg.key;
      });
      var _arg$offset = arg.offset, offset2 = _arg$offset === void 0 ? 0 : _arg$offset;
      setSyncState({
        times: 0,
        index: index2,
        offset: offset2,
        originAlign: align
      });
    }
  };
}
__name(useScrollTo$1, "useScrollTo$1");
var ScrollBar = /* @__PURE__ */ React.forwardRef(function(props, ref) {
  var prefixCls = props.prefixCls, rtl = props.rtl, scrollOffset = props.scrollOffset, scrollRange = props.scrollRange, onStartMove = props.onStartMove, onStopMove = props.onStopMove, onScroll = props.onScroll, horizontal = props.horizontal, spinSize = props.spinSize, containerSize = props.containerSize, style2 = props.style, propsThumbStyle = props.thumbStyle, showScrollBar = props.showScrollBar, _React$useState = React.useState(!1), _React$useState2 = _slicedToArray(_React$useState, 2), dragging = _React$useState2[0], setDragging = _React$useState2[1], _React$useState3 = React.useState(null), _React$useState4 = _slicedToArray(_React$useState3, 2), pageXY = _React$useState4[0], setPageXY = _React$useState4[1], _React$useState5 = React.useState(null), _React$useState6 = _slicedToArray(_React$useState5, 2), startTop = _React$useState6[0], setStartTop = _React$useState6[1], isLTR = !rtl, scrollbarRef = React.useRef(), thumbRef = React.useRef(), _React$useState7 = React.useState(showScrollBar), _React$useState8 = _slicedToArray(_React$useState7, 2), visible = _React$useState8[0], setVisible = _React$useState8[1], visibleTimeoutRef = React.useRef(), delayHidden = /* @__PURE__ */ __name(function() {
    showScrollBar === !0 || showScrollBar === !1 || (clearTimeout(visibleTimeoutRef.current), setVisible(!0), visibleTimeoutRef.current = setTimeout(function() {
      setVisible(!1);
    }, 3e3));
  }, "delayHidden"), enableScrollRange = scrollRange - containerSize || 0, enableOffsetRange = containerSize - spinSize || 0, top = React.useMemo(function() {
    if (scrollOffset === 0 || enableScrollRange === 0)
      return 0;
    var ptg = scrollOffset / enableScrollRange;
    return ptg * enableOffsetRange;
  }, [scrollOffset, enableScrollRange, enableOffsetRange]), onContainerMouseDown = /* @__PURE__ */ __name(function(e2) {
    e2.stopPropagation(), e2.preventDefault();
  }, "onContainerMouseDown"), stateRef = React.useRef({
    top,
    dragging,
    pageY: pageXY,
    startTop
  });
  stateRef.current = {
    top,
    dragging,
    pageY: pageXY,
    startTop
  };
  var onThumbMouseDown = /* @__PURE__ */ __name(function(e2) {
    setDragging(!0), setPageXY(getPageXY(e2, horizontal)), setStartTop(stateRef.current.top), onStartMove(), e2.stopPropagation(), e2.preventDefault();
  }, "onThumbMouseDown");
  React.useEffect(function() {
    var onScrollbarTouchStart = /* @__PURE__ */ __name(function(e2) {
      e2.preventDefault();
    }, "onScrollbarTouchStart"), scrollbarEle = scrollbarRef.current, thumbEle = thumbRef.current;
    return scrollbarEle.addEventListener("touchstart", onScrollbarTouchStart, {
      passive: !1
    }), thumbEle.addEventListener("touchstart", onThumbMouseDown, {
      passive: !1
    }), function() {
      scrollbarEle.removeEventListener("touchstart", onScrollbarTouchStart), thumbEle.removeEventListener("touchstart", onThumbMouseDown);
    };
  }, []);
  var enableScrollRangeRef = React.useRef();
  enableScrollRangeRef.current = enableScrollRange;
  var enableOffsetRangeRef = React.useRef();
  enableOffsetRangeRef.current = enableOffsetRange, React.useEffect(function() {
    if (dragging) {
      var moveRafId, onMouseMove = /* @__PURE__ */ __name(function(e2) {
        var _stateRef$current = stateRef.current, stateDragging = _stateRef$current.dragging, statePageY = _stateRef$current.pageY, stateStartTop = _stateRef$current.startTop;
        wrapperRaf.cancel(moveRafId);
        var rect = scrollbarRef.current.getBoundingClientRect(), scale = containerSize / (horizontal ? rect.width : rect.height);
        if (stateDragging) {
          var offset2 = (getPageXY(e2, horizontal) - statePageY) * scale, newTop = stateStartTop;
          !isLTR && horizontal ? newTop -= offset2 : newTop += offset2;
          var tmpEnableScrollRange = enableScrollRangeRef.current, tmpEnableOffsetRange = enableOffsetRangeRef.current, ptg = tmpEnableOffsetRange ? newTop / tmpEnableOffsetRange : 0, newScrollTop = Math.ceil(ptg * tmpEnableScrollRange);
          newScrollTop = Math.max(newScrollTop, 0), newScrollTop = Math.min(newScrollTop, tmpEnableScrollRange), moveRafId = wrapperRaf(function() {
            onScroll(newScrollTop, horizontal);
          });
        }
      }, "onMouseMove"), onMouseUp = /* @__PURE__ */ __name(function() {
        setDragging(!1), onStopMove();
      }, "onMouseUp");
      return window.addEventListener("mousemove", onMouseMove, {
        passive: !0
      }), window.addEventListener("touchmove", onMouseMove, {
        passive: !0
      }), window.addEventListener("mouseup", onMouseUp, {
        passive: !0
      }), window.addEventListener("touchend", onMouseUp, {
        passive: !0
      }), function() {
        window.removeEventListener("mousemove", onMouseMove), window.removeEventListener("touchmove", onMouseMove), window.removeEventListener("mouseup", onMouseUp), window.removeEventListener("touchend", onMouseUp), wrapperRaf.cancel(moveRafId);
      };
    }
  }, [dragging]), React.useEffect(function() {
    return delayHidden(), function() {
      clearTimeout(visibleTimeoutRef.current);
    };
  }, [scrollOffset]), React.useImperativeHandle(ref, function() {
    return {
      delayHidden
    };
  });
  var scrollbarPrefixCls = "".concat(prefixCls, "-scrollbar"), containerStyle = {
    position: "absolute",
    visibility: visible ? null : "hidden"
  }, thumbStyle = {
    position: "absolute",
    background: "rgba(0, 0, 0, 0.5)",
    borderRadius: 99,
    cursor: "pointer",
    userSelect: "none"
  };
  return horizontal ? (containerStyle.height = 8, containerStyle.left = 0, containerStyle.right = 0, containerStyle.bottom = 0, thumbStyle.height = "100%", thumbStyle.width = spinSize, isLTR ? thumbStyle.left = top : thumbStyle.right = top) : (containerStyle.width = 8, containerStyle.top = 0, containerStyle.bottom = 0, isLTR ? containerStyle.right = 0 : containerStyle.left = 0, thumbStyle.width = "100%", thumbStyle.height = spinSize, thumbStyle.top = top), /* @__PURE__ */ React.createElement("div", {
    ref: scrollbarRef,
    className: cn(scrollbarPrefixCls, _defineProperty$2(_defineProperty$2(_defineProperty$2({}, "".concat(scrollbarPrefixCls, "-horizontal"), horizontal), "".concat(scrollbarPrefixCls, "-vertical"), !horizontal), "".concat(scrollbarPrefixCls, "-visible"), visible)),
    style: _objectSpread2$1(_objectSpread2$1({}, containerStyle), style2),
    onMouseDown: onContainerMouseDown,
    onMouseMove: delayHidden
  }, /* @__PURE__ */ React.createElement("div", {
    ref: thumbRef,
    className: cn("".concat(scrollbarPrefixCls, "-thumb"), _defineProperty$2({}, "".concat(scrollbarPrefixCls, "-thumb-moving"), dragging)),
    style: _objectSpread2$1(_objectSpread2$1({}, thumbStyle), propsThumbStyle),
    onMouseDown: onThumbMouseDown
  }));
});
process.env.NODE_ENV !== "production" && (ScrollBar.displayName = "ScrollBar");
var MIN_SIZE = 20;
function getSpinSize() {
  var containerSize = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0, scrollRange = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0, baseSize = containerSize / scrollRange * containerSize;
  return isNaN(baseSize) && (baseSize = 0), baseSize = Math.max(baseSize, MIN_SIZE), Math.floor(baseSize);
}
__name(getSpinSize, "getSpinSize");
var _excluded$D = ["prefixCls", "className", "height", "itemHeight", "fullHeight", "style", "data", "children", "itemKey", "virtual", "direction", "scrollWidth", "component", "onScroll", "onVirtualScroll", "onVisibleChange", "innerProps", "extraRender", "styles", "showScrollBar"], EMPTY_DATA$1 = [], ScrollStyle = {
  overflowY: "auto",
  overflowAnchor: "none"
};
function RawList(props, ref) {
  var _props$prefixCls = props.prefixCls, prefixCls = _props$prefixCls === void 0 ? "rc-virtual-list" : _props$prefixCls, className = props.className, height = props.height, itemHeight = props.itemHeight, _props$fullHeight = props.fullHeight, fullHeight = _props$fullHeight === void 0 ? !0 : _props$fullHeight, style2 = props.style, data = props.data, children = props.children, itemKey2 = props.itemKey, virtual = props.virtual, direction = props.direction, scrollWidth = props.scrollWidth, _props$component = props.component, Component2 = _props$component === void 0 ? "div" : _props$component, onScroll = props.onScroll, onVirtualScroll = props.onVirtualScroll, onVisibleChange = props.onVisibleChange, innerProps = props.innerProps, extraRender = props.extraRender, styles2 = props.styles, _props$showScrollBar = props.showScrollBar, showScrollBar = _props$showScrollBar === void 0 ? "optional" : _props$showScrollBar, restProps = _objectWithoutProperties(props, _excluded$D), getKey2 = React.useCallback(function(item) {
    return typeof itemKey2 == "function" ? itemKey2(item) : item == null ? void 0 : item[itemKey2];
  }, [itemKey2]), _useHeights = useHeights(getKey2), _useHeights2 = _slicedToArray(_useHeights, 4), setInstanceRef = _useHeights2[0], collectHeight = _useHeights2[1], heights = _useHeights2[2], heightUpdatedMark = _useHeights2[3], useVirtual = !!(virtual !== !1 && height && itemHeight), containerHeight = React.useMemo(function() {
    return Object.values(heights.maps).reduce(function(total, curr) {
      return total + curr;
    }, 0);
  }, [heights.id, heights.maps]), inVirtual = useVirtual && data && (Math.max(itemHeight * data.length, containerHeight) > height || !!scrollWidth), isRTL = direction === "rtl", mergedClassName = cn(prefixCls, _defineProperty$2({}, "".concat(prefixCls, "-rtl"), isRTL), className), mergedData = data || EMPTY_DATA$1, componentRef = useRef(), fillerInnerRef = useRef(), containerRef = useRef(), _useState = useState(0), _useState2 = _slicedToArray(_useState, 2), offsetTop = _useState2[0], setOffsetTop = _useState2[1], _useState3 = useState(0), _useState4 = _slicedToArray(_useState3, 2), offsetLeft = _useState4[0], setOffsetLeft = _useState4[1], _useState5 = useState(!1), _useState6 = _slicedToArray(_useState5, 2), scrollMoving = _useState6[0], setScrollMoving = _useState6[1], onScrollbarStartMove = /* @__PURE__ */ __name(function() {
    setScrollMoving(!0);
  }, "onScrollbarStartMove"), onScrollbarStopMove = /* @__PURE__ */ __name(function() {
    setScrollMoving(!1);
  }, "onScrollbarStopMove"), sharedConfig = {
    getKey: getKey2
  };
  function syncScrollTop(newTop) {
    setOffsetTop(function(origin) {
      var value;
      typeof newTop == "function" ? value = newTop(origin) : value = newTop;
      var alignedTop = keepInRange(value);
      return componentRef.current.scrollTop = alignedTop, alignedTop;
    });
  }
  __name(syncScrollTop, "syncScrollTop");
  var rangeRef = useRef({
    start: 0,
    end: mergedData.length
  }), diffItemRef = useRef(), _useDiffItem = useDiffItem(mergedData, getKey2), _useDiffItem2 = _slicedToArray(_useDiffItem, 1), diffItem = _useDiffItem2[0];
  diffItemRef.current = diffItem;
  var _React$useMemo = React.useMemo(function() {
    if (!useVirtual)
      return {
        scrollHeight: void 0,
        start: 0,
        end: mergedData.length - 1,
        offset: void 0
      };
    if (!inVirtual) {
      var _fillerInnerRef$curre;
      return {
        scrollHeight: ((_fillerInnerRef$curre = fillerInnerRef.current) === null || _fillerInnerRef$curre === void 0 ? void 0 : _fillerInnerRef$curre.offsetHeight) || 0,
        start: 0,
        end: mergedData.length - 1,
        offset: void 0
      };
    }
    for (var itemTop = 0, startIndex, startOffset, endIndex, dataLen = mergedData.length, i = 0; i < dataLen; i += 1) {
      var _item = mergedData[i], key = getKey2(_item), cacheHeight = heights.get(key), currentItemBottom = itemTop + (cacheHeight === void 0 ? itemHeight : cacheHeight);
      currentItemBottom >= offsetTop && startIndex === void 0 && (startIndex = i, startOffset = itemTop), currentItemBottom > offsetTop + height && endIndex === void 0 && (endIndex = i), itemTop = currentItemBottom;
    }
    return startIndex === void 0 && (startIndex = 0, startOffset = 0, endIndex = Math.ceil(height / itemHeight)), endIndex === void 0 && (endIndex = mergedData.length - 1), endIndex = Math.min(endIndex + 1, mergedData.length - 1), {
      scrollHeight: itemTop,
      start: startIndex,
      end: endIndex,
      offset: startOffset
    };
  }, [inVirtual, useVirtual, offsetTop, mergedData, heightUpdatedMark, height]), scrollHeight = _React$useMemo.scrollHeight, start = _React$useMemo.start, end = _React$useMemo.end, fillerOffset = _React$useMemo.offset;
  rangeRef.current.start = start, rangeRef.current.end = end, React.useLayoutEffect(function() {
    var changedRecord = heights.getRecord();
    if (changedRecord.size === 1) {
      var recordKey = Array.from(changedRecord)[0], startIndexKey = getKey2(mergedData[start]);
      if (startIndexKey === recordKey) {
        var realStartHeight = heights.get(recordKey), diffHeight = realStartHeight - itemHeight;
        syncScrollTop(function(ori) {
          return ori + diffHeight;
        });
      }
    }
    heights.resetRecord();
  }, [scrollHeight]);
  var _React$useState = React.useState({
    width: 0,
    height
  }), _React$useState2 = _slicedToArray(_React$useState, 2), size = _React$useState2[0], setSize = _React$useState2[1], onHolderResize = /* @__PURE__ */ __name(function(sizeInfo) {
    setSize({
      width: sizeInfo.offsetWidth,
      height: sizeInfo.offsetHeight
    });
  }, "onHolderResize"), verticalScrollBarRef = useRef(), horizontalScrollBarRef = useRef(), horizontalScrollBarSpinSize = React.useMemo(function() {
    return getSpinSize(size.width, scrollWidth);
  }, [size.width, scrollWidth]), verticalScrollBarSpinSize = React.useMemo(function() {
    return getSpinSize(size.height, scrollHeight);
  }, [size.height, scrollHeight]), maxScrollHeight = scrollHeight - height, maxScrollHeightRef = useRef(maxScrollHeight);
  maxScrollHeightRef.current = maxScrollHeight;
  function keepInRange(newScrollTop) {
    var newTop = newScrollTop;
    return Number.isNaN(maxScrollHeightRef.current) || (newTop = Math.min(newTop, maxScrollHeightRef.current)), newTop = Math.max(newTop, 0), newTop;
  }
  __name(keepInRange, "keepInRange");
  var isScrollAtTop = offsetTop <= 0, isScrollAtBottom = offsetTop >= maxScrollHeight, isScrollAtLeft = offsetLeft <= 0, isScrollAtRight = offsetLeft >= scrollWidth, originScroll = useOriginScroll(isScrollAtTop, isScrollAtBottom, isScrollAtLeft, isScrollAtRight), getVirtualScrollInfo = /* @__PURE__ */ __name(function() {
    return {
      x: isRTL ? -offsetLeft : offsetLeft,
      y: offsetTop
    };
  }, "getVirtualScrollInfo"), lastVirtualScrollInfoRef = useRef(getVirtualScrollInfo()), triggerScroll = useEvent(function(params) {
    if (onVirtualScroll) {
      var nextInfo = _objectSpread2$1(_objectSpread2$1({}, getVirtualScrollInfo()), params);
      (lastVirtualScrollInfoRef.current.x !== nextInfo.x || lastVirtualScrollInfoRef.current.y !== nextInfo.y) && (onVirtualScroll(nextInfo), lastVirtualScrollInfoRef.current = nextInfo);
    }
  });
  function onScrollBar(newScrollOffset, horizontal) {
    var newOffset = newScrollOffset;
    horizontal ? (flushSync(function() {
      setOffsetLeft(newOffset);
    }), triggerScroll()) : syncScrollTop(newOffset);
  }
  __name(onScrollBar, "onScrollBar");
  function onFallbackScroll(e2) {
    var newScrollTop = e2.currentTarget.scrollTop;
    newScrollTop !== offsetTop && syncScrollTop(newScrollTop), onScroll == null || onScroll(e2), triggerScroll();
  }
  __name(onFallbackScroll, "onFallbackScroll");
  var keepInHorizontalRange = /* @__PURE__ */ __name(function(nextOffsetLeft) {
    var tmpOffsetLeft = nextOffsetLeft, max = scrollWidth ? scrollWidth - size.width : 0;
    return tmpOffsetLeft = Math.max(tmpOffsetLeft, 0), tmpOffsetLeft = Math.min(tmpOffsetLeft, max), tmpOffsetLeft;
  }, "keepInHorizontalRange"), onWheelDelta = useEvent(function(offsetXY, fromHorizontal) {
    fromHorizontal ? (flushSync(function() {
      setOffsetLeft(function(left) {
        var nextOffsetLeft = left + (isRTL ? -offsetXY : offsetXY);
        return keepInHorizontalRange(nextOffsetLeft);
      });
    }), triggerScroll()) : syncScrollTop(function(top) {
      var newTop = top + offsetXY;
      return newTop;
    });
  }), _useFrameWheel = useFrameWheel(useVirtual, isScrollAtTop, isScrollAtBottom, isScrollAtLeft, isScrollAtRight, !!scrollWidth, onWheelDelta), _useFrameWheel2 = _slicedToArray(_useFrameWheel, 2), onRawWheel = _useFrameWheel2[0], onFireFoxScroll = _useFrameWheel2[1];
  useMobileTouchMove(useVirtual, componentRef, function(isHorizontal, delta, smoothOffset, e2) {
    var event = e2;
    return originScroll(isHorizontal, delta, smoothOffset) ? !1 : !event || !event._virtualHandled ? (event && (event._virtualHandled = !0), onRawWheel({
      preventDefault: /* @__PURE__ */ __name(function() {
      }, "preventDefault"),
      deltaX: isHorizontal ? delta : 0,
      deltaY: isHorizontal ? 0 : delta
    }), !0) : !1;
  }), useScrollDrag(inVirtual, componentRef, function(offset2) {
    syncScrollTop(function(top) {
      return top + offset2;
    });
  }), useLayoutEffect$1(function() {
    function onMozMousePixelScroll(e2) {
      var scrollingUpAtTop = isScrollAtTop && e2.detail < 0, scrollingDownAtBottom = isScrollAtBottom && e2.detail > 0;
      useVirtual && !scrollingUpAtTop && !scrollingDownAtBottom && e2.preventDefault();
    }
    __name(onMozMousePixelScroll, "onMozMousePixelScroll");
    var componentEle = componentRef.current;
    return componentEle.addEventListener("wheel", onRawWheel, {
      passive: !1
    }), componentEle.addEventListener("DOMMouseScroll", onFireFoxScroll, {
      passive: !0
    }), componentEle.addEventListener("MozMousePixelScroll", onMozMousePixelScroll, {
      passive: !1
    }), function() {
      componentEle.removeEventListener("wheel", onRawWheel), componentEle.removeEventListener("DOMMouseScroll", onFireFoxScroll), componentEle.removeEventListener("MozMousePixelScroll", onMozMousePixelScroll);
    };
  }, [useVirtual, isScrollAtTop, isScrollAtBottom]), useLayoutEffect$1(function() {
    if (scrollWidth) {
      var newOffsetLeft = keepInHorizontalRange(offsetLeft);
      setOffsetLeft(newOffsetLeft), triggerScroll({
        x: newOffsetLeft
      });
    }
  }, [size.width, scrollWidth]);
  var delayHideScrollBar = /* @__PURE__ */ __name(function() {
    var _verticalScrollBarRef, _horizontalScrollBarR;
    (_verticalScrollBarRef = verticalScrollBarRef.current) === null || _verticalScrollBarRef === void 0 || _verticalScrollBarRef.delayHidden(), (_horizontalScrollBarR = horizontalScrollBarRef.current) === null || _horizontalScrollBarR === void 0 || _horizontalScrollBarR.delayHidden();
  }, "delayHideScrollBar"), _scrollTo = useScrollTo$1(componentRef, mergedData, heights, itemHeight, getKey2, function() {
    return collectHeight(!0);
  }, syncScrollTop, delayHideScrollBar);
  React.useImperativeHandle(ref, function() {
    return {
      nativeElement: containerRef.current,
      getScrollInfo: getVirtualScrollInfo,
      scrollTo: /* @__PURE__ */ __name(function(config) {
        function isPosScroll(arg) {
          return arg && _typeof$4(arg) === "object" && ("left" in arg || "top" in arg);
        }
        __name(isPosScroll, "isPosScroll"), isPosScroll(config) ? (config.left !== void 0 && setOffsetLeft(keepInHorizontalRange(config.left)), _scrollTo(config.top)) : _scrollTo(config);
      }, "scrollTo")
    };
  }), useLayoutEffect$1(function() {
    if (onVisibleChange) {
      var renderList = mergedData.slice(start, end + 1);
      onVisibleChange(renderList, mergedData);
    }
  }, [start, end, mergedData]);
  var getSize3 = useGetSize(mergedData, getKey2, heights, itemHeight), extraContent = extraRender == null ? void 0 : extraRender({
    start,
    end,
    virtual: inVirtual,
    offsetX: offsetLeft,
    offsetY: fillerOffset,
    rtl: isRTL,
    getSize: getSize3
  }), listChildren = useChildren$1(mergedData, start, end, scrollWidth, offsetLeft, setInstanceRef, children, sharedConfig), componentStyle = null;
  height && (componentStyle = _objectSpread2$1(_defineProperty$2({}, fullHeight ? "height" : "maxHeight", height), ScrollStyle), useVirtual && (componentStyle.overflowY = "hidden", scrollWidth && (componentStyle.overflowX = "hidden"), scrollMoving && (componentStyle.pointerEvents = "none")));
  var containerProps = {};
  return isRTL && (containerProps.dir = "rtl"), /* @__PURE__ */ React.createElement("div", _extends({
    ref: containerRef,
    style: _objectSpread2$1(_objectSpread2$1({}, style2), {}, {
      position: "relative"
    }),
    className: mergedClassName
  }, containerProps, restProps), /* @__PURE__ */ React.createElement(RefResizeObserver, {
    onResize: onHolderResize
  }, /* @__PURE__ */ React.createElement(Component2, {
    className: "".concat(prefixCls, "-holder"),
    style: componentStyle,
    ref: componentRef,
    onScroll: onFallbackScroll,
    onMouseEnter: delayHideScrollBar
  }, /* @__PURE__ */ React.createElement(Filler, {
    prefixCls,
    height: scrollHeight,
    offsetX: offsetLeft,
    offsetY: fillerOffset,
    scrollWidth,
    onInnerResize: collectHeight,
    ref: fillerInnerRef,
    innerProps,
    rtl: isRTL,
    extra: extraContent
  }, listChildren))), inVirtual && scrollHeight > height && /* @__PURE__ */ React.createElement(ScrollBar, {
    ref: verticalScrollBarRef,
    prefixCls,
    scrollOffset: offsetTop,
    scrollRange: scrollHeight,
    rtl: isRTL,
    onScroll: onScrollBar,
    onStartMove: onScrollbarStartMove,
    onStopMove: onScrollbarStopMove,
    spinSize: verticalScrollBarSpinSize,
    containerSize: size.height,
    style: styles2 == null ? void 0 : styles2.verticalScrollBar,
    thumbStyle: styles2 == null ? void 0 : styles2.verticalScrollBarThumb,
    showScrollBar
  }), inVirtual && scrollWidth > size.width && /* @__PURE__ */ React.createElement(ScrollBar, {
    ref: horizontalScrollBarRef,
    prefixCls,
    scrollOffset: offsetLeft,
    scrollRange: scrollWidth,
    rtl: isRTL,
    onScroll: onScrollBar,
    onStartMove: onScrollbarStartMove,
    onStopMove: onScrollbarStopMove,
    spinSize: horizontalScrollBarSpinSize,
    containerSize: size.width,
    horizontal: !0,
    style: styles2 == null ? void 0 : styles2.horizontalScrollBar,
    thumbStyle: styles2 == null ? void 0 : styles2.horizontalScrollBarThumb,
    showScrollBar
  }));
}
__name(RawList, "RawList");
var List = /* @__PURE__ */ React.forwardRef(RawList);
List.displayName = "List";
function isPlatformMac() {
  return /(mac\sos|macintosh)/i.test(navigator.appVersion);
}
__name(isPlatformMac, "isPlatformMac");
var _excluded$C = ["disabled", "title", "children", "style", "className"];
function isTitleType(content) {
  return typeof content == "string" || typeof content == "number";
}
__name(isTitleType, "isTitleType");
var OptionList = /* @__PURE__ */ __name(function(_2, ref) {
  var _useBaseProps = useBaseProps(), prefixCls = _useBaseProps.prefixCls, id2 = _useBaseProps.id, open = _useBaseProps.open, multiple = _useBaseProps.multiple, mode = _useBaseProps.mode, searchValue = _useBaseProps.searchValue, toggleOpen = _useBaseProps.toggleOpen, notFoundContent = _useBaseProps.notFoundContent, onPopupScroll = _useBaseProps.onPopupScroll, _React$useContext = React.useContext(SelectContext), maxCount = _React$useContext.maxCount, flattenOptions2 = _React$useContext.flattenOptions, onActiveValue = _React$useContext.onActiveValue, defaultActiveFirstOption = _React$useContext.defaultActiveFirstOption, onSelect = _React$useContext.onSelect, menuItemSelectedIcon = _React$useContext.menuItemSelectedIcon, rawValues = _React$useContext.rawValues, fieldNames = _React$useContext.fieldNames, virtual = _React$useContext.virtual, direction = _React$useContext.direction, listHeight = _React$useContext.listHeight, listItemHeight = _React$useContext.listItemHeight, optionRender = _React$useContext.optionRender, itemPrefixCls = "".concat(prefixCls, "-item"), memoFlattenOptions = useMemo(function() {
    return flattenOptions2;
  }, [open, flattenOptions2], function(prev2, next2) {
    return next2[0] && prev2[1] !== next2[1];
  }), listRef = React.useRef(null), overMaxCount = React.useMemo(function() {
    return multiple && isValidCount(maxCount) && (rawValues == null ? void 0 : rawValues.size) >= maxCount;
  }, [multiple, maxCount, rawValues == null ? void 0 : rawValues.size]), onListMouseDown = /* @__PURE__ */ __name(function(event) {
    event.preventDefault();
  }, "onListMouseDown"), scrollIntoView = /* @__PURE__ */ __name(function(args) {
    var _listRef$current;
    (_listRef$current = listRef.current) === null || _listRef$current === void 0 || _listRef$current.scrollTo(typeof args == "number" ? {
      index: args
    } : args);
  }, "scrollIntoView"), isSelected = React.useCallback(function(value) {
    return mode === "combobox" ? !1 : rawValues.has(value);
  }, [mode, _toConsumableArray(rawValues).toString(), rawValues.size]), getEnabledActiveIndex = /* @__PURE__ */ __name(function(index2) {
    for (var offset2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1, len = memoFlattenOptions.length, i = 0; i < len; i += 1) {
      var current = (index2 + i * offset2 + len) % len, _ref = memoFlattenOptions[current] || {}, group = _ref.group, data = _ref.data;
      if (!group && !(data != null && data.disabled) && (isSelected(data.value) || !overMaxCount))
        return current;
    }
    return -1;
  }, "getEnabledActiveIndex"), _React$useState = React.useState(function() {
    return getEnabledActiveIndex(0);
  }), _React$useState2 = _slicedToArray(_React$useState, 2), activeIndex = _React$useState2[0], setActiveIndex = _React$useState2[1], setActive = /* @__PURE__ */ __name(function(index2) {
    var fromKeyboard = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1;
    setActiveIndex(index2);
    var info = {
      source: fromKeyboard ? "keyboard" : "mouse"
    }, flattenItem = memoFlattenOptions[index2];
    if (!flattenItem) {
      onActiveValue(null, -1, info);
      return;
    }
    onActiveValue(flattenItem.value, index2, info);
  }, "setActive");
  useEffect(function() {
    setActive(defaultActiveFirstOption !== !1 ? getEnabledActiveIndex(0) : -1);
  }, [memoFlattenOptions.length, searchValue]);
  var isAriaSelected = React.useCallback(function(value) {
    return mode === "combobox" ? String(value).toLowerCase() === searchValue.toLowerCase() : rawValues.has(value);
  }, [mode, searchValue, _toConsumableArray(rawValues).toString(), rawValues.size]);
  useEffect(function() {
    var timeoutId = setTimeout(function() {
      if (!multiple && open && rawValues.size === 1) {
        var value = Array.from(rawValues)[0], index2 = memoFlattenOptions.findIndex(function(_ref2) {
          var data = _ref2.data;
          return data.value === value;
        });
        index2 !== -1 && (setActive(index2), scrollIntoView(index2));
      }
    });
    if (open) {
      var _listRef$current2;
      (_listRef$current2 = listRef.current) === null || _listRef$current2 === void 0 || _listRef$current2.scrollTo(void 0);
    }
    return function() {
      return clearTimeout(timeoutId);
    };
  }, [open, searchValue]);
  var onSelectValue = /* @__PURE__ */ __name(function(value) {
    value !== void 0 && onSelect(value, {
      selected: !rawValues.has(value)
    }), multiple || toggleOpen(!1);
  }, "onSelectValue");
  if (React.useImperativeHandle(ref, function() {
    return {
      onKeyDown: /* @__PURE__ */ __name(function(event) {
        var which = event.which, ctrlKey = event.ctrlKey;
        switch (which) {
          case KeyCode.N:
          case KeyCode.P:
          case KeyCode.UP:
          case KeyCode.DOWN: {
            var offset2 = 0;
            if (which === KeyCode.UP ? offset2 = -1 : which === KeyCode.DOWN ? offset2 = 1 : isPlatformMac() && ctrlKey && (which === KeyCode.N ? offset2 = 1 : which === KeyCode.P && (offset2 = -1)), offset2 !== 0) {
              var nextActiveIndex = getEnabledActiveIndex(activeIndex + offset2, offset2);
              scrollIntoView(nextActiveIndex), setActive(nextActiveIndex, !0);
            }
            break;
          }
          case KeyCode.TAB:
          case KeyCode.ENTER: {
            var _item$data, item = memoFlattenOptions[activeIndex];
            item && !(item != null && (_item$data = item.data) !== null && _item$data !== void 0 && _item$data.disabled) && !overMaxCount ? onSelectValue(item.value) : onSelectValue(void 0), open && event.preventDefault();
            break;
          }
          case KeyCode.ESC:
            toggleOpen(!1), open && event.stopPropagation();
        }
      }, "onKeyDown"),
      onKeyUp: /* @__PURE__ */ __name(function() {
      }, "onKeyUp"),
      scrollTo: /* @__PURE__ */ __name(function(index2) {
        scrollIntoView(index2);
      }, "scrollTo")
    };
  }), memoFlattenOptions.length === 0)
    return /* @__PURE__ */ React.createElement("div", {
      role: "listbox",
      id: "".concat(id2, "_list"),
      className: "".concat(itemPrefixCls, "-empty"),
      onMouseDown: onListMouseDown
    }, notFoundContent);
  var omitFieldNameList = Object.keys(fieldNames).map(function(key) {
    return fieldNames[key];
  }), getLabel = /* @__PURE__ */ __name(function(item) {
    return item.label;
  }, "getLabel");
  function getItemAriaProps(item, index2) {
    var group = item.group;
    return {
      role: group ? "presentation" : "option",
      id: "".concat(id2, "_list_").concat(index2)
    };
  }
  __name(getItemAriaProps, "getItemAriaProps");
  var renderItem = /* @__PURE__ */ __name(function(index2) {
    var item = memoFlattenOptions[index2];
    if (!item)
      return null;
    var itemData = item.data || {}, value = itemData.value, group = item.group, attrs = pickAttrs(itemData, !0), mergedLabel = getLabel(item);
    return item ? /* @__PURE__ */ React.createElement("div", _extends({
      "aria-label": typeof mergedLabel == "string" && !group ? mergedLabel : null
    }, attrs, {
      key: index2
    }, getItemAriaProps(item, index2), {
      "aria-selected": isAriaSelected(value)
    }), value) : null;
  }, "renderItem"), a11yProps = {
    role: "listbox",
    id: "".concat(id2, "_list")
  };
  return /* @__PURE__ */ React.createElement(React.Fragment, null, virtual && /* @__PURE__ */ React.createElement("div", _extends({}, a11yProps, {
    style: {
      height: 0,
      width: 0,
      overflow: "hidden"
    }
  }), renderItem(activeIndex - 1), renderItem(activeIndex), renderItem(activeIndex + 1)), /* @__PURE__ */ React.createElement(List, {
    itemKey: "key",
    ref: listRef,
    data: memoFlattenOptions,
    height: listHeight,
    itemHeight: listItemHeight,
    fullHeight: !1,
    onMouseDown: onListMouseDown,
    onScroll: onPopupScroll,
    virtual,
    direction,
    innerProps: virtual ? null : a11yProps
  }, function(item, itemIndex) {
    var group = item.group, groupOption = item.groupOption, data = item.data, label2 = item.label, value = item.value, key = data.key;
    if (group) {
      var _data$title, groupTitle = (_data$title = data.title) !== null && _data$title !== void 0 ? _data$title : isTitleType(label2) ? label2.toString() : void 0;
      return /* @__PURE__ */ React.createElement("div", {
        className: cn(itemPrefixCls, "".concat(itemPrefixCls, "-group"), data.className),
        title: groupTitle
      }, label2 !== void 0 ? label2 : key);
    }
    var disabled = data.disabled, title2 = data.title;
    data.children;
    var style2 = data.style, className = data.className, otherProps = _objectWithoutProperties(data, _excluded$C), passedProps = omit(otherProps, omitFieldNameList), selected = isSelected(value), mergedDisabled = disabled || !selected && overMaxCount, optionPrefixCls = "".concat(itemPrefixCls, "-option"), optionClassName = cn(itemPrefixCls, optionPrefixCls, className, _defineProperty$2(_defineProperty$2(_defineProperty$2(_defineProperty$2({}, "".concat(optionPrefixCls, "-grouped"), groupOption), "".concat(optionPrefixCls, "-active"), activeIndex === itemIndex && !mergedDisabled), "".concat(optionPrefixCls, "-disabled"), mergedDisabled), "".concat(optionPrefixCls, "-selected"), selected)), mergedLabel = getLabel(item), iconVisible = !menuItemSelectedIcon || typeof menuItemSelectedIcon == "function" || selected, content = typeof mergedLabel == "number" ? mergedLabel : mergedLabel || value, optionTitle2 = isTitleType(content) ? content.toString() : void 0;
    return title2 !== void 0 && (optionTitle2 = title2), /* @__PURE__ */ React.createElement("div", _extends({}, pickAttrs(passedProps), virtual ? {} : getItemAriaProps(item, itemIndex), {
      "aria-selected": isAriaSelected(value),
      className: optionClassName,
      title: optionTitle2,
      onMouseMove: /* @__PURE__ */ __name(function() {
        activeIndex === itemIndex || mergedDisabled || setActive(itemIndex);
      }, "onMouseMove"),
      onClick: /* @__PURE__ */ __name(function() {
        mergedDisabled || onSelectValue(value);
      }, "onClick"),
      style: style2
    }), /* @__PURE__ */ React.createElement("div", {
      className: "".concat(optionPrefixCls, "-content")
    }, typeof optionRender == "function" ? optionRender(item, {
      index: itemIndex
    }) : content), /* @__PURE__ */ React.isValidElement(menuItemSelectedIcon) || selected, iconVisible && /* @__PURE__ */ React.createElement(TransBtn, {
      className: "".concat(itemPrefixCls, "-option-state"),
      customizeIcon: menuItemSelectedIcon,
      customizeIconProps: {
        value,
        disabled: mergedDisabled,
        isSelected: selected
      }
    }, selected ? "✓" : null));
  }));
}, "OptionList"), RefOptionList = /* @__PURE__ */ React.forwardRef(OptionList);
process.env.NODE_ENV !== "production" && (RefOptionList.displayName = "OptionList");
const useCache = /* @__PURE__ */ __name(function(labeledValues, valueOptions) {
  var cacheRef = React.useRef({
    values: /* @__PURE__ */ new Map(),
    options: /* @__PURE__ */ new Map()
  }), filledLabeledValues = React.useMemo(function() {
    var _cacheRef$current = cacheRef.current, prevValueCache = _cacheRef$current.values, prevOptionCache = _cacheRef$current.options, patchedValues = labeledValues.map(function(item) {
      if (item.label === void 0) {
        var _prevValueCache$get;
        return _objectSpread2$1(_objectSpread2$1({}, item), {}, {
          label: (_prevValueCache$get = prevValueCache.get(item.value)) === null || _prevValueCache$get === void 0 ? void 0 : _prevValueCache$get.label
        });
      }
      return item;
    }), valueCache = /* @__PURE__ */ new Map(), optionCache = /* @__PURE__ */ new Map();
    return patchedValues.forEach(function(item) {
      valueCache.set(item.value, item), optionCache.set(item.value, valueOptions.get(item.value) || prevOptionCache.get(item.value));
    }), cacheRef.current.values = valueCache, cacheRef.current.options = optionCache, patchedValues;
  }, [labeledValues, valueOptions]), getOption = React.useCallback(function(val) {
    return valueOptions.get(val) || cacheRef.current.options.get(val);
  }, [valueOptions]);
  return [filledLabeledValues, getOption];
}, "useCache");
function includes(test, search) {
  return toArray$5(test).join("").toUpperCase().includes(search);
}
__name(includes, "includes");
const useFilterOptions = /* @__PURE__ */ __name(function(options, fieldNames, searchValue, filterOption, optionFilterProp) {
  return React.useMemo(function() {
    if (!searchValue || filterOption === !1)
      return options;
    var fieldOptions = fieldNames.options, fieldLabel = fieldNames.label, fieldValue = fieldNames.value, filteredOptions = [], customizeFilter = typeof filterOption == "function", upperSearch = searchValue.toUpperCase(), filterFunc = customizeFilter ? filterOption : function(_2, option) {
      return optionFilterProp ? includes(option[optionFilterProp], upperSearch) : option[fieldOptions] ? includes(option[fieldLabel !== "children" ? fieldLabel : "label"], upperSearch) : includes(option[fieldValue], upperSearch);
    }, wrapOption = customizeFilter ? function(opt) {
      return injectPropsWithOption(opt);
    } : function(opt) {
      return opt;
    };
    return options.forEach(function(item) {
      if (item[fieldOptions]) {
        var matchGroup = filterFunc(searchValue, wrapOption(item));
        if (matchGroup)
          filteredOptions.push(item);
        else {
          var subOptions = item[fieldOptions].filter(function(subItem) {
            return filterFunc(searchValue, wrapOption(subItem));
          });
          subOptions.length && filteredOptions.push(_objectSpread2$1(_objectSpread2$1({}, item), {}, _defineProperty$2({}, fieldOptions, subOptions)));
        }
        return;
      }
      filterFunc(searchValue, wrapOption(item)) && filteredOptions.push(item);
    }), filteredOptions;
  }, [options, filterOption, optionFilterProp, searchValue, fieldNames]);
}, "useFilterOptions");
var uuid$2 = 0, isBrowserClient$1 = process.env.NODE_ENV !== "test" && canUseDom();
function getUUID$1() {
  var retId;
  return isBrowserClient$1 ? (retId = uuid$2, uuid$2 += 1) : retId = "TEST_OR_SSR", retId;
}
__name(getUUID$1, "getUUID$1");
function useId$1(id2) {
  var _React$useState = React.useState(), _React$useState2 = _slicedToArray(_React$useState, 2), innerId = _React$useState2[0], setInnerId = _React$useState2[1];
  return React.useEffect(function() {
    setInnerId("rc_select_".concat(getUUID$1()));
  }, []), id2 || innerId;
}
__name(useId$1, "useId$1");
var _excluded$B = ["children", "value"], _excluded2$7 = ["children"];
function convertNodeToOption(node2) {
  var _ref = node2, key = _ref.key, _ref$props = _ref.props, children = _ref$props.children, value = _ref$props.value, restProps = _objectWithoutProperties(_ref$props, _excluded$B);
  return _objectSpread2$1({
    key,
    value: value !== void 0 ? value : key,
    children
  }, restProps);
}
__name(convertNodeToOption, "convertNodeToOption");
function convertChildrenToData(nodes) {
  var optionOnly = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1;
  return toArray$7(nodes).map(function(node2, index2) {
    if (!/* @__PURE__ */ React.isValidElement(node2) || !node2.type)
      return null;
    var _ref2 = node2, isSelectOptGroup = _ref2.type.isSelectOptGroup, key = _ref2.key, _ref2$props = _ref2.props, children = _ref2$props.children, restProps = _objectWithoutProperties(_ref2$props, _excluded2$7);
    return optionOnly || !isSelectOptGroup ? convertNodeToOption(node2) : _objectSpread2$1(_objectSpread2$1({
      key: "__RC_SELECT_GRP__".concat(key === null ? index2 : key, "__"),
      label: key
    }, restProps), {}, {
      options: convertChildrenToData(children)
    });
  }).filter(function(data) {
    return data;
  });
}
__name(convertChildrenToData, "convertChildrenToData");
var useOptions = /* @__PURE__ */ __name(function(options, children, fieldNames, optionFilterProp, optionLabelProp) {
  return React.useMemo(function() {
    var mergedOptions = options, childrenAsData = !options;
    childrenAsData && (mergedOptions = convertChildrenToData(children));
    var valueOptions = /* @__PURE__ */ new Map(), labelOptions = /* @__PURE__ */ new Map(), setLabelOptions = /* @__PURE__ */ __name(function(labelOptionsMap, option, key) {
      key && typeof key == "string" && labelOptionsMap.set(option[key], option);
    }, "setLabelOptions"), dig = /* @__PURE__ */ __name(function dig2(optionList) {
      for (var isChildren = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1, i = 0; i < optionList.length; i += 1) {
        var option = optionList[i];
        !option[fieldNames.options] || isChildren ? (valueOptions.set(option[fieldNames.value], option), setLabelOptions(labelOptions, option, fieldNames.label), setLabelOptions(labelOptions, option, optionFilterProp), setLabelOptions(labelOptions, option, optionLabelProp)) : dig2(option[fieldNames.options], !0);
      }
    }, "dig");
    return dig(mergedOptions), {
      options: mergedOptions,
      valueOptions,
      labelOptions
    };
  }, [options, children, fieldNames, optionFilterProp, optionLabelProp]);
}, "useOptions");
function useRefFunc(callback) {
  var funcRef = React.useRef();
  funcRef.current = callback;
  var cacheFn = React.useCallback(function() {
    return funcRef.current.apply(funcRef, arguments);
  }, []);
  return cacheFn;
}
__name(useRefFunc, "useRefFunc");
function warningProps(props) {
  var mode = props.mode, options = props.options, children = props.children, backfill = props.backfill, allowClear = props.allowClear, placeholder = props.placeholder, getInputElement = props.getInputElement, showSearch = props.showSearch, onSearch = props.onSearch, defaultOpen = props.defaultOpen, autoFocus = props.autoFocus, labelInValue = props.labelInValue, value = props.value, inputValue = props.inputValue, optionLabelProp = props.optionLabelProp, multiple = isMultiple(mode), mergedShowSearch = showSearch !== void 0 ? showSearch : multiple || mode === "combobox", mergedOptions = options || convertChildrenToData(children);
  if (warningOnce(mode !== "tags" || mergedOptions.every(function(opt) {
    return !opt.disabled;
  }), "Please avoid setting option to disabled in tags mode since user can always type text as tag."), mode === "tags" || mode === "combobox") {
    var hasNumberValue = mergedOptions.some(function(item) {
      return item.options ? item.options.some(function(opt) {
        return typeof ("value" in opt ? opt.value : opt.key) == "number";
      }) : typeof ("value" in item ? item.value : item.key) == "number";
    });
    warningOnce(!hasNumberValue, "`value` of Option should not use number type when `mode` is `tags` or `combobox`.");
  }
  if (warningOnce(mode !== "combobox" || !optionLabelProp, "`combobox` mode not support `optionLabelProp`. Please set `value` on Option directly."), warningOnce(mode === "combobox" || !backfill, "`backfill` only works with `combobox` mode."), warningOnce(mode === "combobox" || !getInputElement, "`getInputElement` only work with `combobox` mode."), noteOnce(mode !== "combobox" || !getInputElement || !allowClear || !placeholder, "Customize `getInputElement` should customize clear and placeholder logic instead of configuring `allowClear` and `placeholder`."), onSearch && !mergedShowSearch && mode !== "combobox" && mode !== "tags" && warningOnce(!1, "`onSearch` should work with `showSearch` instead of use alone."), noteOnce(!defaultOpen || autoFocus, "`defaultOpen` makes Select open without focus which means it will not close by click outside. You can set `autoFocus` if needed."), value != null) {
    var values = toArray$5(value);
    warningOnce(!labelInValue || values.every(function(val) {
      return _typeof$4(val) === "object" && ("key" in val || "value" in val);
    }), "`value` should in shape of `{ value: string | number, label?: ReactNode }` when you set `labelInValue` to `true`"), warningOnce(!multiple || Array.isArray(value), "`value` should be array when `mode` is `multiple` or `tags`");
  }
  if (children) {
    var invalidateChildType = null;
    toArray$7(children).some(function(node2) {
      if (!/* @__PURE__ */ React.isValidElement(node2) || !node2.type)
        return !1;
      var _ref = node2, type4 = _ref.type;
      if (type4.isSelectOption)
        return !1;
      if (type4.isSelectOptGroup) {
        var allChildrenValid = toArray$7(node2.props.children).every(function(subNode) {
          return !/* @__PURE__ */ React.isValidElement(subNode) || !node2.type || subNode.type.isSelectOption ? !0 : (invalidateChildType = subNode.type, !1);
        });
        return !allChildrenValid;
      }
      return invalidateChildType = type4, !0;
    }), invalidateChildType && warningOnce(!1, "`children` should be `Select.Option` or `Select.OptGroup` instead of `".concat(invalidateChildType.displayName || invalidateChildType.name || invalidateChildType, "`.")), warningOnce(inputValue === void 0, "`inputValue` is deprecated, please use `searchValue` instead.");
  }
}
__name(warningProps, "warningProps");
function warningNullOptions(options, fieldNames) {
  if (options) {
    var recursiveOptions = /* @__PURE__ */ __name(function recursiveOptions2(optionsList) {
      for (var inGroup = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1, i = 0; i < optionsList.length; i++) {
        var option = optionsList[i];
        if (option[fieldNames == null ? void 0 : fieldNames.value] === null)
          return warningOnce(!1, "`value` in Select options should not be `null`."), !0;
        if (!inGroup && Array.isArray(option[fieldNames == null ? void 0 : fieldNames.options]) && recursiveOptions2(option[fieldNames == null ? void 0 : fieldNames.options], !0))
          break;
      }
    }, "recursiveOptions");
    recursiveOptions(options);
  }
}
__name(warningNullOptions, "warningNullOptions");
var _excluded$A = ["id", "mode", "prefixCls", "backfill", "fieldNames", "inputValue", "searchValue", "onSearch", "autoClearSearchValue", "onSelect", "onDeselect", "dropdownMatchSelectWidth", "filterOption", "filterSort", "optionFilterProp", "optionLabelProp", "options", "optionRender", "children", "defaultActiveFirstOption", "menuItemSelectedIcon", "virtual", "direction", "listHeight", "listItemHeight", "labelRender", "value", "defaultValue", "labelInValue", "onChange", "maxCount"], OMIT_DOM_PROPS = ["inputValue"];
function isRawValue(value) {
  return !value || _typeof$4(value) !== "object";
}
__name(isRawValue, "isRawValue");
var Select$2 = /* @__PURE__ */ React.forwardRef(function(props, ref) {
  var id2 = props.id, mode = props.mode, _props$prefixCls = props.prefixCls, prefixCls = _props$prefixCls === void 0 ? "rc-select" : _props$prefixCls, backfill = props.backfill, fieldNames = props.fieldNames, inputValue = props.inputValue, searchValue = props.searchValue, onSearch = props.onSearch, _props$autoClearSearc = props.autoClearSearchValue, autoClearSearchValue = _props$autoClearSearc === void 0 ? !0 : _props$autoClearSearc, onSelect = props.onSelect, onDeselect = props.onDeselect, _props$dropdownMatchS = props.dropdownMatchSelectWidth, dropdownMatchSelectWidth = _props$dropdownMatchS === void 0 ? !0 : _props$dropdownMatchS, filterOption = props.filterOption, filterSort = props.filterSort, optionFilterProp = props.optionFilterProp, optionLabelProp = props.optionLabelProp, options = props.options, optionRender = props.optionRender, children = props.children, defaultActiveFirstOption = props.defaultActiveFirstOption, menuItemSelectedIcon = props.menuItemSelectedIcon, virtual = props.virtual, direction = props.direction, _props$listHeight = props.listHeight, listHeight = _props$listHeight === void 0 ? 200 : _props$listHeight, _props$listItemHeight = props.listItemHeight, listItemHeight = _props$listItemHeight === void 0 ? 20 : _props$listItemHeight, labelRender = props.labelRender, value = props.value, defaultValue = props.defaultValue, labelInValue = props.labelInValue, onChange = props.onChange, maxCount = props.maxCount, restProps = _objectWithoutProperties(props, _excluded$A), mergedId = useId$1(id2), multiple = isMultiple(mode), childrenAsData = !!(!options && children), mergedFilterOption = React.useMemo(function() {
    return filterOption === void 0 && mode === "combobox" ? !1 : filterOption;
  }, [filterOption, mode]), mergedFieldNames = React.useMemo(
    function() {
      return fillFieldNames$1(fieldNames, childrenAsData);
    },
    /* eslint-disable react-hooks/exhaustive-deps */
    [
      // We stringify fieldNames to avoid unnecessary re-renders.
      JSON.stringify(fieldNames),
      childrenAsData
    ]
    /* eslint-enable react-hooks/exhaustive-deps */
  ), _useMergedState = useMergedState("", {
    value: searchValue !== void 0 ? searchValue : inputValue,
    postState: /* @__PURE__ */ __name(function(search) {
      return search || "";
    }, "postState")
  }), _useMergedState2 = _slicedToArray(_useMergedState, 2), mergedSearchValue = _useMergedState2[0], setSearchValue = _useMergedState2[1], parsedOptions = useOptions(options, children, mergedFieldNames, optionFilterProp, optionLabelProp), valueOptions = parsedOptions.valueOptions, labelOptions = parsedOptions.labelOptions, mergedOptions = parsedOptions.options, convert2LabelValues = React.useCallback(function(draftValues) {
    var valueList = toArray$5(draftValues);
    return valueList.map(function(val) {
      var rawValue, rawLabel, rawKey, rawDisabled, rawTitle;
      if (isRawValue(val))
        rawValue = val;
      else {
        var _val$value;
        rawKey = val.key, rawLabel = val.label, rawValue = (_val$value = val.value) !== null && _val$value !== void 0 ? _val$value : rawKey;
      }
      var option = valueOptions.get(rawValue);
      if (option) {
        var _option$key;
        if (rawLabel === void 0 && (rawLabel = option == null ? void 0 : option[optionLabelProp || mergedFieldNames.label]), rawKey === void 0 && (rawKey = (_option$key = option == null ? void 0 : option.key) !== null && _option$key !== void 0 ? _option$key : rawValue), rawDisabled = option == null ? void 0 : option.disabled, rawTitle = option == null ? void 0 : option.title, process.env.NODE_ENV !== "production" && !optionLabelProp) {
          var optionLabel = option == null ? void 0 : option[mergedFieldNames.label];
          optionLabel !== void 0 && !/* @__PURE__ */ React.isValidElement(optionLabel) && !/* @__PURE__ */ React.isValidElement(rawLabel) && optionLabel !== rawLabel && warningOnce(!1, "`label` of `value` is not same as `label` in Select options.");
        }
      }
      return {
        label: rawLabel,
        value: rawValue,
        key: rawKey,
        disabled: rawDisabled,
        title: rawTitle
      };
    });
  }, [mergedFieldNames, optionLabelProp, valueOptions]), _useMergedState3 = useMergedState(defaultValue, {
    value
  }), _useMergedState4 = _slicedToArray(_useMergedState3, 2), internalValue = _useMergedState4[0], setInternalValue = _useMergedState4[1], rawLabeledValues = React.useMemo(function() {
    var _values$, newInternalValue = multiple && internalValue === null ? [] : internalValue, values = convert2LabelValues(newInternalValue);
    return mode === "combobox" && isComboNoValue((_values$ = values[0]) === null || _values$ === void 0 ? void 0 : _values$.value) ? [] : values;
  }, [internalValue, convert2LabelValues, mode, multiple]), _useCache = useCache(rawLabeledValues, valueOptions), _useCache2 = _slicedToArray(_useCache, 2), mergedValues = _useCache2[0], getMixedOption = _useCache2[1], displayValues = React.useMemo(function() {
    if (!mode && mergedValues.length === 1) {
      var firstValue = mergedValues[0];
      if (firstValue.value === null && (firstValue.label === null || firstValue.label === void 0))
        return [];
    }
    return mergedValues.map(function(item) {
      var _ref;
      return _objectSpread2$1(_objectSpread2$1({}, item), {}, {
        label: (_ref = typeof labelRender == "function" ? labelRender(item) : item.label) !== null && _ref !== void 0 ? _ref : item.value
      });
    });
  }, [mode, mergedValues, labelRender]), rawValues = React.useMemo(function() {
    return new Set(mergedValues.map(function(val) {
      return val.value;
    }));
  }, [mergedValues]);
  React.useEffect(function() {
    if (mode === "combobox") {
      var _mergedValues$, strValue = (_mergedValues$ = mergedValues[0]) === null || _mergedValues$ === void 0 ? void 0 : _mergedValues$.value;
      setSearchValue(hasValue(strValue) ? String(strValue) : "");
    }
  }, [mergedValues]);
  var createTagOption = useRefFunc(function(val, label2) {
    var mergedLabel = label2 ?? val;
    return _defineProperty$2(_defineProperty$2({}, mergedFieldNames.value, val), mergedFieldNames.label, mergedLabel);
  }), filledTagOptions = React.useMemo(function() {
    if (mode !== "tags")
      return mergedOptions;
    var cloneOptions = _toConsumableArray(mergedOptions), existOptions = /* @__PURE__ */ __name(function(val) {
      return valueOptions.has(val);
    }, "existOptions");
    return _toConsumableArray(mergedValues).sort(function(a, b) {
      return a.value < b.value ? -1 : 1;
    }).forEach(function(item) {
      var val = item.value;
      existOptions(val) || cloneOptions.push(createTagOption(val, item.label));
    }), cloneOptions;
  }, [createTagOption, mergedOptions, valueOptions, mergedValues, mode]), filteredOptions = useFilterOptions(filledTagOptions, mergedFieldNames, mergedSearchValue, mergedFilterOption, optionFilterProp), filledSearchOptions = React.useMemo(function() {
    return mode !== "tags" || !mergedSearchValue || filteredOptions.some(function(item) {
      return item[optionFilterProp || "value"] === mergedSearchValue;
    }) || filteredOptions.some(function(item) {
      return item[mergedFieldNames.value] === mergedSearchValue;
    }) ? filteredOptions : [createTagOption(mergedSearchValue)].concat(_toConsumableArray(filteredOptions));
  }, [createTagOption, optionFilterProp, mode, filteredOptions, mergedSearchValue, mergedFieldNames]), sorter = /* @__PURE__ */ __name(function sorter2(inputOptions) {
    var sortedOptions = _toConsumableArray(inputOptions).sort(function(a, b) {
      return filterSort(a, b, {
        searchValue: mergedSearchValue
      });
    });
    return sortedOptions.map(function(item) {
      return Array.isArray(item.options) ? _objectSpread2$1(_objectSpread2$1({}, item), {}, {
        options: item.options.length > 0 ? sorter2(item.options) : item.options
      }) : item;
    });
  }, "sorter"), orderedFilteredOptions = React.useMemo(function() {
    return filterSort ? sorter(filledSearchOptions) : filledSearchOptions;
  }, [filledSearchOptions, filterSort, mergedSearchValue]), displayOptions = React.useMemo(function() {
    return flattenOptions(orderedFilteredOptions, {
      fieldNames: mergedFieldNames,
      childrenAsData
    });
  }, [orderedFilteredOptions, mergedFieldNames, childrenAsData]), triggerChange = /* @__PURE__ */ __name(function(values) {
    var labeledValues = convert2LabelValues(values);
    if (setInternalValue(labeledValues), onChange && // Trigger event only when value changed
    (labeledValues.length !== mergedValues.length || labeledValues.some(function(newVal, index2) {
      var _mergedValues$index;
      return ((_mergedValues$index = mergedValues[index2]) === null || _mergedValues$index === void 0 ? void 0 : _mergedValues$index.value) !== (newVal == null ? void 0 : newVal.value);
    }))) {
      var returnValues = labelInValue ? labeledValues : labeledValues.map(function(v) {
        return v.value;
      }), returnOptions = labeledValues.map(function(v) {
        return injectPropsWithOption(getMixedOption(v.value));
      });
      onChange(
        // Value
        multiple ? returnValues : returnValues[0],
        // Option
        multiple ? returnOptions : returnOptions[0]
      );
    }
  }, "triggerChange"), _React$useState = React.useState(null), _React$useState2 = _slicedToArray(_React$useState, 2), activeValue = _React$useState2[0], setActiveValue = _React$useState2[1], _React$useState3 = React.useState(0), _React$useState4 = _slicedToArray(_React$useState3, 2), accessibilityIndex = _React$useState4[0], setAccessibilityIndex = _React$useState4[1], mergedDefaultActiveFirstOption = defaultActiveFirstOption !== void 0 ? defaultActiveFirstOption : mode !== "combobox", onActiveValue = React.useCallback(function(active, index2) {
    var _ref3 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, _ref3$source = _ref3.source, source = _ref3$source === void 0 ? "keyboard" : _ref3$source;
    setAccessibilityIndex(index2), backfill && mode === "combobox" && active !== null && source === "keyboard" && setActiveValue(String(active));
  }, [backfill, mode]), triggerSelect = /* @__PURE__ */ __name(function(val, selected, type4) {
    var getSelectEnt = /* @__PURE__ */ __name(function() {
      var _option$key2, option = getMixedOption(val);
      return [labelInValue ? {
        label: option == null ? void 0 : option[mergedFieldNames.label],
        value: val,
        key: (_option$key2 = option == null ? void 0 : option.key) !== null && _option$key2 !== void 0 ? _option$key2 : val
      } : val, injectPropsWithOption(option)];
    }, "getSelectEnt");
    if (selected && onSelect) {
      var _getSelectEnt = getSelectEnt(), _getSelectEnt2 = _slicedToArray(_getSelectEnt, 2), wrappedValue = _getSelectEnt2[0], _option = _getSelectEnt2[1];
      onSelect(wrappedValue, _option);
    } else if (!selected && onDeselect && type4 !== "clear") {
      var _getSelectEnt3 = getSelectEnt(), _getSelectEnt4 = _slicedToArray(_getSelectEnt3, 2), _wrappedValue = _getSelectEnt4[0], _option2 = _getSelectEnt4[1];
      onDeselect(_wrappedValue, _option2);
    }
  }, "triggerSelect"), onInternalSelect = useRefFunc(function(val, info) {
    var cloneValues, mergedSelect = multiple ? info.selected : !0;
    mergedSelect ? cloneValues = multiple ? [].concat(_toConsumableArray(mergedValues), [val]) : [val] : cloneValues = mergedValues.filter(function(v) {
      return v.value !== val;
    }), triggerChange(cloneValues), triggerSelect(val, mergedSelect), mode === "combobox" ? setActiveValue("") : (!isMultiple || autoClearSearchValue) && (setSearchValue(""), setActiveValue(""));
  }), onDisplayValuesChange = /* @__PURE__ */ __name(function(nextValues, info) {
    triggerChange(nextValues);
    var type4 = info.type, values = info.values;
    (type4 === "remove" || type4 === "clear") && values.forEach(function(item) {
      triggerSelect(item.value, !1, type4);
    });
  }, "onDisplayValuesChange"), onInternalSearch = /* @__PURE__ */ __name(function(searchText, info) {
    if (setSearchValue(searchText), setActiveValue(null), info.source === "submit") {
      var formatted = (searchText || "").trim();
      if (formatted) {
        var newRawValues = Array.from(new Set([].concat(_toConsumableArray(rawValues), [formatted])));
        triggerChange(newRawValues), triggerSelect(formatted, !0), setSearchValue("");
      }
      return;
    }
    info.source !== "blur" && (mode === "combobox" && triggerChange(searchText), onSearch == null || onSearch(searchText));
  }, "onInternalSearch"), onInternalSearchSplit = /* @__PURE__ */ __name(function(words) {
    var patchValues = words;
    mode !== "tags" && (patchValues = words.map(function(word) {
      var opt = labelOptions.get(word);
      return opt == null ? void 0 : opt.value;
    }).filter(function(val) {
      return val !== void 0;
    }));
    var newRawValues = Array.from(new Set([].concat(_toConsumableArray(rawValues), _toConsumableArray(patchValues))));
    triggerChange(newRawValues), newRawValues.forEach(function(newRawValue) {
      triggerSelect(newRawValue, !0);
    });
  }, "onInternalSearchSplit"), selectContext = React.useMemo(function() {
    var realVirtual = virtual !== !1 && dropdownMatchSelectWidth !== !1;
    return _objectSpread2$1(_objectSpread2$1({}, parsedOptions), {}, {
      flattenOptions: displayOptions,
      onActiveValue,
      defaultActiveFirstOption: mergedDefaultActiveFirstOption,
      onSelect: onInternalSelect,
      menuItemSelectedIcon,
      rawValues,
      fieldNames: mergedFieldNames,
      virtual: realVirtual,
      direction,
      listHeight,
      listItemHeight,
      childrenAsData,
      maxCount,
      optionRender
    });
  }, [maxCount, parsedOptions, displayOptions, onActiveValue, mergedDefaultActiveFirstOption, onInternalSelect, menuItemSelectedIcon, rawValues, mergedFieldNames, virtual, dropdownMatchSelectWidth, direction, listHeight, listItemHeight, childrenAsData, optionRender]);
  return process.env.NODE_ENV !== "production" && (warningProps(props), warningNullOptions(mergedOptions, mergedFieldNames)), /* @__PURE__ */ React.createElement(SelectContext.Provider, {
    value: selectContext
  }, /* @__PURE__ */ React.createElement(BaseSelect, _extends({}, restProps, {
    // >>> MISC
    id: mergedId,
    prefixCls,
    ref,
    omitDomProps: OMIT_DOM_PROPS,
    mode,
    displayValues,
    onDisplayValuesChange,
    direction,
    searchValue: mergedSearchValue,
    onSearch: onInternalSearch,
    autoClearSearchValue,
    onSearchSplit: onInternalSearchSplit,
    dropdownMatchSelectWidth,
    OptionList: RefOptionList,
    emptyOptions: !displayOptions.length,
    activeValue,
    activeDescendantId: "".concat(mergedId, "_list_").concat(accessibilityIndex)
  })));
});
process.env.NODE_ENV !== "production" && (Select$2.displayName = "Select");
var TypedSelect = Select$2;
TypedSelect.Option = Option$1;
TypedSelect.OptGroup = OptGroup;
function getStatusClassNames(prefixCls, status, hasFeedback) {
  return cn({
    [`${prefixCls}-status-success`]: status === "success",
    [`${prefixCls}-status-warning`]: status === "warning",
    [`${prefixCls}-status-error`]: status === "error",
    [`${prefixCls}-status-validating`]: status === "validating",
    [`${prefixCls}-has-feedback`]: hasFeedback
  });
}
__name(getStatusClassNames, "getStatusClassNames");
const getMergedStatus = /* @__PURE__ */ __name((contextStatus, customStatus) => customStatus || contextStatus, "getMergedStatus"), Empty$2 = /* @__PURE__ */ __name(() => {
  const [, token2] = useToken(), [locale2] = useLocale$1("Empty"), themeStyle = new TinyColor(token2.colorBgBase).toHsl().l < 0.5 ? {
    opacity: 0.65
  } : {};
  return /* @__PURE__ */ React.createElement("svg", {
    style: themeStyle,
    width: "184",
    height: "152",
    viewBox: "0 0 184 152",
    xmlns: "http://www.w3.org/2000/svg"
  }, /* @__PURE__ */ React.createElement("title", null, (locale2 == null ? void 0 : locale2.description) || "Empty"), /* @__PURE__ */ React.createElement("g", {
    fill: "none",
    fillRule: "evenodd"
  }, /* @__PURE__ */ React.createElement("g", {
    transform: "translate(24 31.67)"
  }, /* @__PURE__ */ React.createElement("ellipse", {
    fillOpacity: ".8",
    fill: "#F5F5F7",
    cx: "67.797",
    cy: "106.89",
    rx: "67.797",
    ry: "12.668"
  }), /* @__PURE__ */ React.createElement("path", {
    d: "M122.034 69.674L98.109 40.229c-1.148-1.386-2.826-2.225-4.593-2.225h-51.44c-1.766 0-3.444.839-4.592 2.225L13.56 69.674v15.383h108.475V69.674z",
    fill: "#AEB8C2"
  }), /* @__PURE__ */ React.createElement("path", {
    d: "M101.537 86.214L80.63 61.102c-1.001-1.207-2.507-1.867-4.048-1.867H31.724c-1.54 0-3.047.66-4.048 1.867L6.769 86.214v13.792h94.768V86.214z",
    fill: "url(#linearGradient-1)",
    transform: "translate(13.56)"
  }), /* @__PURE__ */ React.createElement("path", {
    d: "M33.83 0h67.933a4 4 0 0 1 4 4v93.344a4 4 0 0 1-4 4H33.83a4 4 0 0 1-4-4V4a4 4 0 0 1 4-4z",
    fill: "#F5F5F7"
  }), /* @__PURE__ */ React.createElement("path", {
    d: "M42.678 9.953h50.237a2 2 0 0 1 2 2V36.91a2 2 0 0 1-2 2H42.678a2 2 0 0 1-2-2V11.953a2 2 0 0 1 2-2zM42.94 49.767h49.713a2.262 2.262 0 1 1 0 4.524H42.94a2.262 2.262 0 0 1 0-4.524zM42.94 61.53h49.713a2.262 2.262 0 1 1 0 4.525H42.94a2.262 2.262 0 0 1 0-4.525zM121.813 105.032c-.775 3.071-3.497 5.36-6.735 5.36H20.515c-3.238 0-5.96-2.29-6.734-5.36a7.309 7.309 0 0 1-.222-1.79V69.675h26.318c2.907 0 5.25 2.448 5.25 5.42v.04c0 2.971 2.37 5.37 5.277 5.37h34.785c2.907 0 5.277-2.421 5.277-5.393V75.1c0-2.972 2.343-5.426 5.25-5.426h26.318v33.569c0 .617-.077 1.216-.221 1.789z",
    fill: "#DCE0E6"
  })), /* @__PURE__ */ React.createElement("path", {
    d: "M149.121 33.292l-6.83 2.65a1 1 0 0 1-1.317-1.23l1.937-6.207c-2.589-2.944-4.109-6.534-4.109-10.408C138.802 8.102 148.92 0 161.402 0 173.881 0 184 8.102 184 18.097c0 9.995-10.118 18.097-22.599 18.097-4.528 0-8.744-1.066-12.28-2.902z",
    fill: "#DCE0E6"
  }), /* @__PURE__ */ React.createElement("g", {
    transform: "translate(149.65 15.383)",
    fill: "#FFF"
  }, /* @__PURE__ */ React.createElement("ellipse", {
    cx: "20.654",
    cy: "3.167",
    rx: "2.849",
    ry: "2.815"
  }), /* @__PURE__ */ React.createElement("path", {
    d: "M5.698 5.63H0L2.898.704zM9.259.704h4.985V5.63H9.259z"
  }))));
}, "Empty$2");
process.env.NODE_ENV !== "production" && (Empty$2.displayName = "EmptyImage");
const Simple = /* @__PURE__ */ __name(() => {
  const [, token2] = useToken(), [locale2] = useLocale$1("Empty"), {
    colorFill,
    colorFillTertiary,
    colorFillQuaternary,
    colorBgContainer
  } = token2, {
    borderColor,
    shadowColor,
    contentColor
  } = useMemo$1(() => ({
    borderColor: new TinyColor(colorFill).onBackground(colorBgContainer).toHexShortString(),
    shadowColor: new TinyColor(colorFillTertiary).onBackground(colorBgContainer).toHexShortString(),
    contentColor: new TinyColor(colorFillQuaternary).onBackground(colorBgContainer).toHexShortString()
  }), [colorFill, colorFillTertiary, colorFillQuaternary, colorBgContainer]);
  return /* @__PURE__ */ React.createElement("svg", {
    width: "64",
    height: "41",
    viewBox: "0 0 64 41",
    xmlns: "http://www.w3.org/2000/svg"
  }, /* @__PURE__ */ React.createElement("title", null, (locale2 == null ? void 0 : locale2.description) || "Empty"), /* @__PURE__ */ React.createElement("g", {
    transform: "translate(0 1)",
    fill: "none",
    fillRule: "evenodd"
  }, /* @__PURE__ */ React.createElement("ellipse", {
    fill: shadowColor,
    cx: "32",
    cy: "33",
    rx: "32",
    ry: "7"
  }), /* @__PURE__ */ React.createElement("g", {
    fillRule: "nonzero",
    stroke: borderColor
  }, /* @__PURE__ */ React.createElement("path", {
    d: "M55 12.76L44.854 1.258C44.367.474 43.656 0 42.907 0H21.093c-.749 0-1.46.474-1.947 1.257L9 12.761V22h46v-9.24z"
  }), /* @__PURE__ */ React.createElement("path", {
    d: "M41.613 15.931c0-1.605.994-2.93 2.227-2.931H55v18.137C55 33.26 53.68 35 52.05 35h-40.1C10.32 35 9 33.259 9 31.137V13h11.16c1.233 0 2.227 1.323 2.227 2.928v.022c0 1.605 1.005 2.901 2.237 2.901h14.752c1.232 0 2.237-1.308 2.237-2.913v-.007z",
    fill: contentColor
  }))));
}, "Simple");
process.env.NODE_ENV !== "production" && (Simple.displayName = "SimpleImage");
const genSharedEmptyStyle = /* @__PURE__ */ __name((token2) => {
  const {
    componentCls,
    margin,
    marginXS,
    marginXL,
    fontSize,
    lineHeight
  } = token2;
  return {
    [componentCls]: {
      marginInline: marginXS,
      fontSize,
      lineHeight,
      textAlign: "center",
      // 原来 &-image 没有父子结构，现在为了外层承担我们的 hashId，改成父子结构
      [`${componentCls}-image`]: {
        height: token2.emptyImgHeight,
        marginBottom: marginXS,
        opacity: token2.opacityImage,
        img: {
          height: "100%"
        },
        svg: {
          maxWidth: "100%",
          height: "100%",
          margin: "auto"
        }
      },
      [`${componentCls}-description`]: {
        color: token2.colorTextDescription
      },
      // 原来 &-footer 没有父子结构，现在为了外层承担我们的 hashId，改成父子结构
      [`${componentCls}-footer`]: {
        marginTop: margin
      },
      "&-normal": {
        marginBlock: marginXL,
        color: token2.colorTextDescription,
        [`${componentCls}-description`]: {
          color: token2.colorTextDescription
        },
        [`${componentCls}-image`]: {
          height: token2.emptyImgHeightMD
        }
      },
      "&-small": {
        marginBlock: marginXS,
        color: token2.colorTextDescription,
        [`${componentCls}-image`]: {
          height: token2.emptyImgHeightSM
        }
      }
    }
  };
}, "genSharedEmptyStyle"), useStyle$q = genStyleHooks("Empty", (token2) => {
  const {
    componentCls,
    controlHeightLG,
    calc
  } = token2, emptyToken = merge(token2, {
    emptyImgCls: `${componentCls}-img`,
    emptyImgHeight: calc(controlHeightLG).mul(2.5).equal(),
    emptyImgHeightMD: controlHeightLG,
    emptyImgHeightSM: calc(controlHeightLG).mul(0.875).equal()
  });
  return [genSharedEmptyStyle(emptyToken)];
});
var __rest$Q = function(s, e2) {
  var t2 = {};
  for (var p in s) Object.prototype.hasOwnProperty.call(s, p) && e2.indexOf(p) < 0 && (t2[p] = s[p]);
  if (s != null && typeof Object.getOwnPropertySymbols == "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++)
    e2.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]) && (t2[p[i]] = s[p[i]]);
  return t2;
};
const defaultEmptyImg = /* @__PURE__ */ React.createElement(Empty$2, null), simpleEmptyImg = /* @__PURE__ */ React.createElement(Simple, null), Empty$1 = /* @__PURE__ */ __name((_a) => {
  var {
    className,
    rootClassName,
    prefixCls: customizePrefixCls,
    image = defaultEmptyImg,
    description,
    children,
    imageStyle,
    style: style2
  } = _a, restProps = __rest$Q(_a, ["className", "rootClassName", "prefixCls", "image", "description", "children", "imageStyle", "style"]);
  const {
    getPrefixCls,
    direction,
    empty: empty2
  } = React.useContext(ConfigContext), prefixCls = getPrefixCls("empty", customizePrefixCls), [wrapCSSVar, hashId, cssVarCls] = useStyle$q(prefixCls), [locale2] = useLocale$1("Empty"), des = typeof description < "u" ? description : locale2 == null ? void 0 : locale2.description, alt = typeof des == "string" ? des : "empty";
  let imageNode = null;
  return typeof image == "string" ? imageNode = /* @__PURE__ */ React.createElement("img", {
    alt,
    src: image
  }) : imageNode = image, wrapCSSVar(/* @__PURE__ */ React.createElement("div", Object.assign({
    className: cn(hashId, cssVarCls, prefixCls, empty2 == null ? void 0 : empty2.className, {
      [`${prefixCls}-normal`]: image === simpleEmptyImg,
      [`${prefixCls}-rtl`]: direction === "rtl"
    }, className, rootClassName),
    style: Object.assign(Object.assign({}, empty2 == null ? void 0 : empty2.style), style2)
  }, restProps), /* @__PURE__ */ React.createElement("div", {
    className: `${prefixCls}-image`,
    style: imageStyle
  }, imageNode), des && /* @__PURE__ */ React.createElement("div", {
    className: `${prefixCls}-description`
  }, des), children && /* @__PURE__ */ React.createElement("div", {
    className: `${prefixCls}-footer`
  }, children)));
}, "Empty$1");
Empty$1.PRESENTED_IMAGE_DEFAULT = defaultEmptyImg;
Empty$1.PRESENTED_IMAGE_SIMPLE = simpleEmptyImg;
process.env.NODE_ENV !== "production" && (Empty$1.displayName = "Empty");
const DefaultRenderEmpty = /* @__PURE__ */ __name((props) => {
  const {
    componentName
  } = props, {
    getPrefixCls
  } = useContext$1(ConfigContext), prefix = getPrefixCls("empty");
  switch (componentName) {
    case "Table":
    case "List":
      return /* @__PURE__ */ React__default.createElement(Empty$1, {
        image: Empty$1.PRESENTED_IMAGE_SIMPLE
      });
    case "Select":
    case "TreeSelect":
    case "Cascader":
    case "Transfer":
    case "Mentions":
      return /* @__PURE__ */ React__default.createElement(Empty$1, {
        image: Empty$1.PRESENTED_IMAGE_SIMPLE,
        className: `${prefix}-small`
      });
    case "Table.filter":
      return null;
    default:
      return /* @__PURE__ */ React__default.createElement(Empty$1, null);
  }
}, "DefaultRenderEmpty"), useVariant = /* @__PURE__ */ __name(function(component, variant) {
  let legacyBordered = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : void 0;
  var _a, _b;
  const {
    variant: configVariant,
    [component]: componentConfig
  } = React.useContext(ConfigContext), ctxVariant = React.useContext(VariantContext), configComponentVariant = componentConfig == null ? void 0 : componentConfig.variant;
  let mergedVariant;
  typeof variant < "u" ? mergedVariant = variant : legacyBordered === !1 ? mergedVariant = "borderless" : mergedVariant = (_b = (_a = ctxVariant ?? configComponentVariant) !== null && _a !== void 0 ? _a : configVariant) !== null && _b !== void 0 ? _b : "outlined";
  const enableVariantCls = Variants.includes(mergedVariant);
  return [mergedVariant, enableVariantCls];
}, "useVariant"), getBuiltInPlacements2 = /* @__PURE__ */ __name((popupOverflow) => {
  const sharedConfig = {
    overflow: {
      adjustX: !0,
      adjustY: !0,
      shiftY: !0
    },
    htmlRegion: popupOverflow === "scroll" ? "scroll" : "visible",
    dynamicInset: !0
  };
  return {
    bottomLeft: Object.assign(Object.assign({}, sharedConfig), {
      points: ["tl", "bl"],
      offset: [0, 4]
    }),
    bottomRight: Object.assign(Object.assign({}, sharedConfig), {
      points: ["tr", "br"],
      offset: [0, 4]
    }),
    topLeft: Object.assign(Object.assign({}, sharedConfig), {
      points: ["bl", "tl"],
      offset: [0, -4]
    }),
    topRight: Object.assign(Object.assign({}, sharedConfig), {
      points: ["br", "tr"],
      offset: [0, -4]
    })
  };
}, "getBuiltInPlacements");
function mergedBuiltinPlacements(buildInPlacements, popupOverflow) {
  return buildInPlacements || getBuiltInPlacements2(popupOverflow);
}
__name(mergedBuiltinPlacements, "mergedBuiltinPlacements");
const genItemStyle = /* @__PURE__ */ __name((token2) => {
  const {
    optionHeight,
    optionFontSize,
    optionLineHeight,
    optionPadding
  } = token2;
  return {
    position: "relative",
    display: "block",
    minHeight: optionHeight,
    padding: optionPadding,
    color: token2.colorText,
    fontWeight: "normal",
    fontSize: optionFontSize,
    lineHeight: optionLineHeight,
    boxSizing: "border-box"
  };
}, "genItemStyle"), genSingleStyle$1 = /* @__PURE__ */ __name((token2) => {
  const {
    antCls,
    componentCls
  } = token2, selectItemCls = `${componentCls}-item`, slideUpEnterActive = `&${antCls}-slide-up-enter${antCls}-slide-up-enter-active`, slideUpAppearActive = `&${antCls}-slide-up-appear${antCls}-slide-up-appear-active`, slideUpLeaveActive = `&${antCls}-slide-up-leave${antCls}-slide-up-leave-active`, dropdownPlacementCls = `${componentCls}-dropdown-placement-`;
  return [
    {
      [`${componentCls}-dropdown`]: Object.assign(Object.assign({}, resetComponent(token2)), {
        position: "absolute",
        top: -9999,
        zIndex: token2.zIndexPopup,
        boxSizing: "border-box",
        padding: token2.paddingXXS,
        overflow: "hidden",
        fontSize: token2.fontSize,
        // Fix select render lag of long text in chrome
        // https://github.com/ant-design/ant-design/issues/11456
        // https://github.com/ant-design/ant-design/issues/11843
        fontVariant: "initial",
        backgroundColor: token2.colorBgElevated,
        borderRadius: token2.borderRadiusLG,
        outline: "none",
        boxShadow: token2.boxShadowSecondary,
        [`
          ${slideUpEnterActive}${dropdownPlacementCls}bottomLeft,
          ${slideUpAppearActive}${dropdownPlacementCls}bottomLeft
        `]: {
          animationName: slideUpIn
        },
        [`
          ${slideUpEnterActive}${dropdownPlacementCls}topLeft,
          ${slideUpAppearActive}${dropdownPlacementCls}topLeft,
          ${slideUpEnterActive}${dropdownPlacementCls}topRight,
          ${slideUpAppearActive}${dropdownPlacementCls}topRight
        `]: {
          animationName: slideDownIn
        },
        [`${slideUpLeaveActive}${dropdownPlacementCls}bottomLeft`]: {
          animationName: slideUpOut
        },
        [`
          ${slideUpLeaveActive}${dropdownPlacementCls}topLeft,
          ${slideUpLeaveActive}${dropdownPlacementCls}topRight
        `]: {
          animationName: slideDownOut
        },
        "&-hidden": {
          display: "none"
        },
        [selectItemCls]: Object.assign(Object.assign({}, genItemStyle(token2)), {
          cursor: "pointer",
          transition: `background ${token2.motionDurationSlow} ease`,
          borderRadius: token2.borderRadiusSM,
          // =========== Group ============
          "&-group": {
            color: token2.colorTextDescription,
            fontSize: token2.fontSizeSM,
            cursor: "default"
          },
          // =========== Option ===========
          "&-option": {
            display: "flex",
            "&-content": Object.assign({
              flex: "auto"
            }, textEllipsis),
            "&-state": {
              flex: "none",
              display: "flex",
              alignItems: "center"
            },
            [`&-active:not(${selectItemCls}-option-disabled)`]: {
              backgroundColor: token2.optionActiveBg
            },
            [`&-selected:not(${selectItemCls}-option-disabled)`]: {
              color: token2.optionSelectedColor,
              fontWeight: token2.optionSelectedFontWeight,
              backgroundColor: token2.optionSelectedBg,
              [`${selectItemCls}-option-state`]: {
                color: token2.colorPrimary
              },
              [`&:has(+ ${selectItemCls}-option-selected:not(${selectItemCls}-option-disabled))`]: {
                borderEndStartRadius: 0,
                borderEndEndRadius: 0,
                [`& + ${selectItemCls}-option-selected:not(${selectItemCls}-option-disabled)`]: {
                  borderStartStartRadius: 0,
                  borderStartEndRadius: 0
                }
              }
            },
            "&-disabled": {
              [`&${selectItemCls}-option-selected`]: {
                backgroundColor: token2.colorBgContainerDisabled
              },
              color: token2.colorTextDisabled,
              cursor: "not-allowed"
            },
            "&-grouped": {
              paddingInlineStart: token2.calc(token2.controlPaddingHorizontal).mul(2).equal()
            }
          },
          "&-empty": Object.assign(Object.assign({}, genItemStyle(token2)), {
            color: token2.colorTextDisabled
          })
        }),
        // =========================== RTL ===========================
        "&-rtl": {
          direction: "rtl"
        }
      })
    },
    // Follow code may reuse in other components
    initSlideMotion(token2, "slide-up"),
    initSlideMotion(token2, "slide-down"),
    initMoveMotion(token2, "move-up"),
    initMoveMotion(token2, "move-down")
  ];
}, "genSingleStyle$1"), getMultipleSelectorUnit = /* @__PURE__ */ __name((token2) => {
  const {
    multipleSelectItemHeight,
    paddingXXS,
    lineWidth,
    INTERNAL_FIXED_ITEM_MARGIN
  } = token2, basePadding = token2.max(token2.calc(paddingXXS).sub(lineWidth).equal(), 0), containerPadding = token2.max(token2.calc(basePadding).sub(INTERNAL_FIXED_ITEM_MARGIN).equal(), 0);
  return {
    basePadding,
    containerPadding,
    itemHeight: unit$1(multipleSelectItemHeight),
    itemLineHeight: unit$1(token2.calc(multipleSelectItemHeight).sub(token2.calc(token2.lineWidth).mul(2)).equal())
  };
}, "getMultipleSelectorUnit"), getSelectItemStyle = /* @__PURE__ */ __name((token2) => {
  const {
    multipleSelectItemHeight,
    selectHeight,
    lineWidth
  } = token2;
  return token2.calc(selectHeight).sub(multipleSelectItemHeight).div(2).sub(lineWidth).equal();
}, "getSelectItemStyle"), genOverflowStyle = /* @__PURE__ */ __name((token2) => {
  const {
    componentCls,
    iconCls,
    borderRadiusSM,
    motionDurationSlow,
    paddingXS,
    multipleItemColorDisabled,
    multipleItemBorderColorDisabled,
    colorIcon,
    colorIconHover,
    INTERNAL_FIXED_ITEM_MARGIN
  } = token2;
  return {
    /**
     * Do not merge `height` & `line-height` under style with `selection` & `search`, since chrome
     * may update to redesign with its align logic.
     */
    // =========================== Overflow ===========================
    [`${componentCls}-selection-overflow`]: {
      position: "relative",
      display: "flex",
      flex: "auto",
      flexWrap: "wrap",
      maxWidth: "100%",
      "&-item": {
        flex: "none",
        alignSelf: "center",
        maxWidth: "100%",
        display: "inline-flex"
      },
      // ======================== Selections ==========================
      [`${componentCls}-selection-item`]: {
        display: "flex",
        alignSelf: "center",
        flex: "none",
        boxSizing: "border-box",
        maxWidth: "100%",
        marginBlock: INTERNAL_FIXED_ITEM_MARGIN,
        borderRadius: borderRadiusSM,
        cursor: "default",
        transition: `font-size ${motionDurationSlow}, line-height ${motionDurationSlow}, height ${motionDurationSlow}`,
        marginInlineEnd: token2.calc(INTERNAL_FIXED_ITEM_MARGIN).mul(2).equal(),
        paddingInlineStart: paddingXS,
        paddingInlineEnd: token2.calc(paddingXS).div(2).equal(),
        [`${componentCls}-disabled&`]: {
          color: multipleItemColorDisabled,
          borderColor: multipleItemBorderColorDisabled,
          cursor: "not-allowed"
        },
        // It's ok not to do this, but 24px makes bottom narrow in view should adjust
        "&-content": {
          display: "inline-block",
          marginInlineEnd: token2.calc(paddingXS).div(2).equal(),
          overflow: "hidden",
          whiteSpace: "pre",
          // fix whitespace wrapping. custom tags display all whitespace within.
          textOverflow: "ellipsis"
        },
        "&-remove": Object.assign(Object.assign({}, resetIcon()), {
          display: "inline-flex",
          alignItems: "center",
          color: colorIcon,
          fontWeight: "bold",
          fontSize: 10,
          lineHeight: "inherit",
          cursor: "pointer",
          [`> ${iconCls}`]: {
            verticalAlign: "-0.2em"
          },
          "&:hover": {
            color: colorIconHover
          }
        })
      }
    }
  };
}, "genOverflowStyle"), genSelectionStyle$1 = /* @__PURE__ */ __name((token2, suffix) => {
  const {
    componentCls,
    INTERNAL_FIXED_ITEM_MARGIN
  } = token2, selectOverflowPrefixCls = `${componentCls}-selection-overflow`, selectItemHeight = token2.multipleSelectItemHeight, selectItemDist = getSelectItemStyle(token2), suffixCls = suffix ? `${componentCls}-${suffix}` : "", multipleSelectorUnit = getMultipleSelectorUnit(token2);
  return {
    [`${componentCls}-multiple${suffixCls}`]: Object.assign(Object.assign({}, genOverflowStyle(token2)), {
      // ========================= Selector =========================
      [`${componentCls}-selector`]: {
        display: "flex",
        alignItems: "center",
        width: "100%",
        height: "100%",
        // Multiple is little different that horizontal is follow the vertical
        paddingInline: multipleSelectorUnit.basePadding,
        paddingBlock: multipleSelectorUnit.containerPadding,
        borderRadius: token2.borderRadius,
        [`${componentCls}-disabled&`]: {
          background: token2.multipleSelectorBgDisabled,
          cursor: "not-allowed"
        },
        "&:after": {
          display: "inline-block",
          width: 0,
          margin: `${unit$1(INTERNAL_FIXED_ITEM_MARGIN)} 0`,
          lineHeight: unit$1(selectItemHeight),
          visibility: "hidden",
          content: '"\\a0"'
        }
      },
      // ======================== Selections ========================
      [`${componentCls}-selection-item`]: {
        height: multipleSelectorUnit.itemHeight,
        lineHeight: unit$1(multipleSelectorUnit.itemLineHeight)
      },
      // ========================== Wrap ===========================
      [`${componentCls}-selection-wrap`]: {
        alignSelf: "flex-start",
        "&:after": {
          lineHeight: unit$1(selectItemHeight),
          marginBlock: INTERNAL_FIXED_ITEM_MARGIN
        }
      },
      // ========================== Input ==========================
      [`${componentCls}-prefix`]: {
        marginInlineStart: token2.calc(token2.inputPaddingHorizontalBase).sub(multipleSelectorUnit.basePadding).equal()
      },
      [`${selectOverflowPrefixCls}-item + ${selectOverflowPrefixCls}-item,
        ${componentCls}-prefix + ${componentCls}-selection-wrap
      `]: {
        [`${componentCls}-selection-search`]: {
          marginInlineStart: 0
        },
        [`${componentCls}-selection-placeholder`]: {
          insetInlineStart: 0
        }
      },
      // https://github.com/ant-design/ant-design/issues/44754
      // Same as `wrap:after`
      [`${selectOverflowPrefixCls}-item-suffix`]: {
        minHeight: multipleSelectorUnit.itemHeight,
        marginBlock: INTERNAL_FIXED_ITEM_MARGIN
      },
      [`${componentCls}-selection-search`]: {
        display: "inline-flex",
        position: "relative",
        maxWidth: "100%",
        marginInlineStart: token2.calc(token2.inputPaddingHorizontalBase).sub(selectItemDist).equal(),
        "\n          &-input,\n          &-mirror\n        ": {
          height: selectItemHeight,
          fontFamily: token2.fontFamily,
          lineHeight: unit$1(selectItemHeight),
          transition: `all ${token2.motionDurationSlow}`
        },
        "&-input": {
          width: "100%",
          minWidth: 4.1
          // fix search cursor missing
        },
        "&-mirror": {
          position: "absolute",
          top: 0,
          insetInlineStart: 0,
          insetInlineEnd: "auto",
          zIndex: 999,
          whiteSpace: "pre",
          // fix whitespace wrapping caused width calculation bug
          visibility: "hidden"
        }
      },
      // ======================= Placeholder =======================
      [`${componentCls}-selection-placeholder`]: {
        position: "absolute",
        top: "50%",
        insetInlineStart: token2.calc(token2.inputPaddingHorizontalBase).sub(multipleSelectorUnit.basePadding).equal(),
        insetInlineEnd: token2.inputPaddingHorizontalBase,
        transform: "translateY(-50%)",
        transition: `all ${token2.motionDurationSlow}`
      }
    })
  };
}, "genSelectionStyle$1");
function genSizeStyle$3(token2, suffix) {
  const {
    componentCls
  } = token2, suffixCls = suffix ? `${componentCls}-${suffix}` : "", rawStyle = {
    [`${componentCls}-multiple${suffixCls}`]: {
      fontSize: token2.fontSize,
      // ========================= Selector =========================
      [`${componentCls}-selector`]: {
        [`${componentCls}-show-search&`]: {
          cursor: "text"
        }
      },
      [`
        &${componentCls}-show-arrow ${componentCls}-selector,
        &${componentCls}-allow-clear ${componentCls}-selector
      `]: {
        paddingInlineEnd: token2.calc(token2.fontSizeIcon).add(token2.controlPaddingHorizontal).equal()
      }
    }
  };
  return [genSelectionStyle$1(token2, suffix), rawStyle];
}
__name(genSizeStyle$3, "genSizeStyle$3");
const genMultipleStyle = /* @__PURE__ */ __name((token2) => {
  const {
    componentCls
  } = token2, smallToken = merge(token2, {
    selectHeight: token2.controlHeightSM,
    multipleSelectItemHeight: token2.multipleItemHeightSM,
    borderRadius: token2.borderRadiusSM,
    borderRadiusSM: token2.borderRadiusXS
  }), largeToken = merge(token2, {
    fontSize: token2.fontSizeLG,
    selectHeight: token2.controlHeightLG,
    multipleSelectItemHeight: token2.multipleItemHeightLG,
    borderRadius: token2.borderRadiusLG,
    borderRadiusSM: token2.borderRadius
  });
  return [
    genSizeStyle$3(token2),
    // ======================== Small ========================
    genSizeStyle$3(smallToken, "sm"),
    // Padding
    {
      [`${componentCls}-multiple${componentCls}-sm`]: {
        [`${componentCls}-selection-placeholder`]: {
          insetInline: token2.calc(token2.controlPaddingHorizontalSM).sub(token2.lineWidth).equal()
        },
        // https://github.com/ant-design/ant-design/issues/29559
        [`${componentCls}-selection-search`]: {
          marginInlineStart: 2
          // Magic Number
        }
      }
    },
    // ======================== Large ========================
    genSizeStyle$3(largeToken, "lg")
  ];
}, "genMultipleStyle");
function genSizeStyle$2(token2, suffix) {
  const {
    componentCls,
    inputPaddingHorizontalBase,
    borderRadius
  } = token2, selectHeightWithoutBorder = token2.calc(token2.controlHeight).sub(token2.calc(token2.lineWidth).mul(2)).equal(), suffixCls = suffix ? `${componentCls}-${suffix}` : "";
  return {
    [`${componentCls}-single${suffixCls}`]: {
      fontSize: token2.fontSize,
      height: token2.controlHeight,
      // ========================= Selector =========================
      [`${componentCls}-selector`]: Object.assign(Object.assign({}, resetComponent(token2, !0)), {
        display: "flex",
        borderRadius,
        flex: "1 1 auto",
        [`${componentCls}-selection-search`]: {
          position: "absolute",
          inset: 0,
          width: "100%",
          "&-input": {
            width: "100%",
            WebkitAppearance: "textfield"
          }
        },
        [`
          ${componentCls}-selection-item,
          ${componentCls}-selection-placeholder
        `]: {
          display: "block",
          padding: 0,
          lineHeight: unit$1(selectHeightWithoutBorder),
          transition: `all ${token2.motionDurationSlow}, visibility 0s`,
          alignSelf: "center"
        },
        [`${componentCls}-selection-placeholder`]: {
          transition: "none",
          pointerEvents: "none"
        },
        // For common baseline align
        [[
          "&:after",
          /* For '' value baseline align */
          `${componentCls}-selection-item:empty:after`,
          /* For undefined value baseline align */
          `${componentCls}-selection-placeholder:empty:after`
        ].join(",")]: {
          display: "inline-block",
          width: 0,
          visibility: "hidden",
          content: '"\\a0"'
        }
      }),
      [`
        &${componentCls}-show-arrow ${componentCls}-selection-item,
        &${componentCls}-show-arrow ${componentCls}-selection-search,
        &${componentCls}-show-arrow ${componentCls}-selection-placeholder
      `]: {
        paddingInlineEnd: token2.showArrowPaddingInlineEnd
      },
      // Opacity selection if open
      [`&${componentCls}-open ${componentCls}-selection-item`]: {
        color: token2.colorTextPlaceholder
      },
      // ========================== Input ==========================
      // We only change the style of non-customize input which is only support by `combobox` mode.
      // Not customize
      [`&:not(${componentCls}-customize-input)`]: {
        [`${componentCls}-selector`]: {
          width: "100%",
          height: "100%",
          alignItems: "center",
          padding: `0 ${unit$1(inputPaddingHorizontalBase)}`,
          [`${componentCls}-selection-search-input`]: {
            height: selectHeightWithoutBorder
          },
          "&:after": {
            lineHeight: unit$1(selectHeightWithoutBorder)
          }
        }
      },
      [`&${componentCls}-customize-input`]: {
        [`${componentCls}-selector`]: {
          "&:after": {
            display: "none"
          },
          [`${componentCls}-selection-search`]: {
            position: "static",
            width: "100%"
          },
          [`${componentCls}-selection-placeholder`]: {
            position: "absolute",
            insetInlineStart: 0,
            insetInlineEnd: 0,
            padding: `0 ${unit$1(inputPaddingHorizontalBase)}`,
            "&:after": {
              display: "none"
            }
          }
        }
      }
    }
  };
}
__name(genSizeStyle$2, "genSizeStyle$2");
function genSingleStyle(token2) {
  const {
    componentCls
  } = token2, inputPaddingHorizontalSM = token2.calc(token2.controlPaddingHorizontalSM).sub(token2.lineWidth).equal();
  return [
    genSizeStyle$2(token2),
    // ======================== Small ========================
    // Shared
    genSizeStyle$2(merge(token2, {
      controlHeight: token2.controlHeightSM,
      borderRadius: token2.borderRadiusSM
    }), "sm"),
    // padding
    {
      [`${componentCls}-single${componentCls}-sm`]: {
        [`&:not(${componentCls}-customize-input)`]: {
          [`${componentCls}-selector`]: {
            padding: `0 ${unit$1(inputPaddingHorizontalSM)}`
          },
          // With arrow should provides `padding-right` to show the arrow
          [`&${componentCls}-show-arrow ${componentCls}-selection-search`]: {
            insetInlineEnd: token2.calc(inputPaddingHorizontalSM).add(token2.calc(token2.fontSize).mul(1.5)).equal()
          },
          [`
            &${componentCls}-show-arrow ${componentCls}-selection-item,
            &${componentCls}-show-arrow ${componentCls}-selection-placeholder
          `]: {
            paddingInlineEnd: token2.calc(token2.fontSize).mul(1.5).equal()
          }
        }
      }
    },
    // ======================== Large ========================
    // Shared
    genSizeStyle$2(merge(token2, {
      controlHeight: token2.singleItemHeightLG,
      fontSize: token2.fontSizeLG,
      borderRadius: token2.borderRadiusLG
    }), "lg")
  ];
}
__name(genSingleStyle, "genSingleStyle");
const prepareComponentToken$l = /* @__PURE__ */ __name((token2) => {
  const {
    fontSize,
    lineHeight,
    lineWidth,
    controlHeight,
    controlHeightSM,
    controlHeightLG,
    paddingXXS,
    controlPaddingHorizontal,
    zIndexPopupBase,
    colorText,
    fontWeightStrong,
    controlItemBgActive,
    controlItemBgHover,
    colorBgContainer,
    colorFillSecondary,
    colorBgContainerDisabled,
    colorTextDisabled,
    colorPrimaryHover,
    colorPrimary,
    controlOutline
  } = token2, dblPaddingXXS = paddingXXS * 2, dblLineWidth = lineWidth * 2, multipleItemHeight = Math.min(controlHeight - dblPaddingXXS, controlHeight - dblLineWidth), multipleItemHeightSM = Math.min(controlHeightSM - dblPaddingXXS, controlHeightSM - dblLineWidth), multipleItemHeightLG = Math.min(controlHeightLG - dblPaddingXXS, controlHeightLG - dblLineWidth);
  return {
    INTERNAL_FIXED_ITEM_MARGIN: Math.floor(paddingXXS / 2),
    zIndexPopup: zIndexPopupBase + 50,
    optionSelectedColor: colorText,
    optionSelectedFontWeight: fontWeightStrong,
    optionSelectedBg: controlItemBgActive,
    optionActiveBg: controlItemBgHover,
    optionPadding: `${(controlHeight - fontSize * lineHeight) / 2}px ${controlPaddingHorizontal}px`,
    optionFontSize: fontSize,
    optionLineHeight: lineHeight,
    optionHeight: controlHeight,
    selectorBg: colorBgContainer,
    clearBg: colorBgContainer,
    singleItemHeightLG: controlHeightLG,
    multipleItemBg: colorFillSecondary,
    multipleItemBorderColor: "transparent",
    multipleItemHeight,
    multipleItemHeightSM,
    multipleItemHeightLG,
    multipleSelectorBgDisabled: colorBgContainerDisabled,
    multipleItemColorDisabled: colorTextDisabled,
    multipleItemBorderColorDisabled: "transparent",
    showArrowPaddingInlineEnd: Math.ceil(token2.fontSize * 1.25),
    hoverBorderColor: colorPrimaryHover,
    activeBorderColor: colorPrimary,
    activeOutlineColor: controlOutline,
    selectAffixPadding: paddingXXS
  };
}, "prepareComponentToken$l"), genBaseOutlinedStyle$1 = /* @__PURE__ */ __name((token2, options) => {
  const {
    componentCls,
    antCls,
    controlOutlineWidth
  } = token2;
  return {
    [`&:not(${componentCls}-customize-input) ${componentCls}-selector`]: {
      border: `${unit$1(token2.lineWidth)} ${token2.lineType} ${options.borderColor}`,
      background: token2.selectorBg
    },
    [`&:not(${componentCls}-disabled):not(${componentCls}-customize-input):not(${antCls}-pagination-size-changer)`]: {
      [`&:hover ${componentCls}-selector`]: {
        borderColor: options.hoverBorderHover
      },
      [`${componentCls}-focused& ${componentCls}-selector`]: {
        borderColor: options.activeBorderColor,
        boxShadow: `0 0 0 ${unit$1(controlOutlineWidth)} ${options.activeOutlineColor}`,
        outline: 0
      },
      [`${componentCls}-prefix`]: {
        color: options.color
      }
    }
  };
}, "genBaseOutlinedStyle$1"), genOutlinedStatusStyle$1 = /* @__PURE__ */ __name((token2, options) => ({
  [`&${token2.componentCls}-status-${options.status}`]: Object.assign({}, genBaseOutlinedStyle$1(token2, options))
}), "genOutlinedStatusStyle$1"), genOutlinedStyle$1 = /* @__PURE__ */ __name((token2) => ({
  "&-outlined": Object.assign(Object.assign(Object.assign(Object.assign({}, genBaseOutlinedStyle$1(token2, {
    borderColor: token2.colorBorder,
    hoverBorderHover: token2.hoverBorderColor,
    activeBorderColor: token2.activeBorderColor,
    activeOutlineColor: token2.activeOutlineColor,
    color: token2.colorText
  })), genOutlinedStatusStyle$1(token2, {
    status: "error",
    borderColor: token2.colorError,
    hoverBorderHover: token2.colorErrorHover,
    activeBorderColor: token2.colorError,
    activeOutlineColor: token2.colorErrorOutline,
    color: token2.colorError
  })), genOutlinedStatusStyle$1(token2, {
    status: "warning",
    borderColor: token2.colorWarning,
    hoverBorderHover: token2.colorWarningHover,
    activeBorderColor: token2.colorWarning,
    activeOutlineColor: token2.colorWarningOutline,
    color: token2.colorWarning
  })), {
    [`&${token2.componentCls}-disabled`]: {
      [`&:not(${token2.componentCls}-customize-input) ${token2.componentCls}-selector`]: {
        background: token2.colorBgContainerDisabled,
        color: token2.colorTextDisabled
      }
    },
    [`&${token2.componentCls}-multiple ${token2.componentCls}-selection-item`]: {
      background: token2.multipleItemBg,
      border: `${unit$1(token2.lineWidth)} ${token2.lineType} ${token2.multipleItemBorderColor}`
    }
  })
}), "genOutlinedStyle$1"), genBaseFilledStyle$1 = /* @__PURE__ */ __name((token2, options) => {
  const {
    componentCls,
    antCls
  } = token2;
  return {
    [`&:not(${componentCls}-customize-input) ${componentCls}-selector`]: {
      background: options.bg,
      border: `${unit$1(token2.lineWidth)} ${token2.lineType} transparent`,
      color: options.color
    },
    [`&:not(${componentCls}-disabled):not(${componentCls}-customize-input):not(${antCls}-pagination-size-changer)`]: {
      [`&:hover ${componentCls}-selector`]: {
        background: options.hoverBg
      },
      [`${componentCls}-focused& ${componentCls}-selector`]: {
        background: token2.selectorBg,
        borderColor: options.activeBorderColor,
        outline: 0
      }
    }
  };
}, "genBaseFilledStyle$1"), genFilledStatusStyle$1 = /* @__PURE__ */ __name((token2, options) => ({
  [`&${token2.componentCls}-status-${options.status}`]: Object.assign({}, genBaseFilledStyle$1(token2, options))
}), "genFilledStatusStyle$1"), genFilledStyle$1 = /* @__PURE__ */ __name((token2) => ({
  "&-filled": Object.assign(Object.assign(Object.assign(Object.assign({}, genBaseFilledStyle$1(token2, {
    bg: token2.colorFillTertiary,
    hoverBg: token2.colorFillSecondary,
    activeBorderColor: token2.activeBorderColor,
    color: token2.colorText
  })), genFilledStatusStyle$1(token2, {
    status: "error",
    bg: token2.colorErrorBg,
    hoverBg: token2.colorErrorBgHover,
    activeBorderColor: token2.colorError,
    color: token2.colorError
  })), genFilledStatusStyle$1(token2, {
    status: "warning",
    bg: token2.colorWarningBg,
    hoverBg: token2.colorWarningBgHover,
    activeBorderColor: token2.colorWarning,
    color: token2.colorWarning
  })), {
    [`&${token2.componentCls}-disabled`]: {
      [`&:not(${token2.componentCls}-customize-input) ${token2.componentCls}-selector`]: {
        borderColor: token2.colorBorder,
        background: token2.colorBgContainerDisabled,
        color: token2.colorTextDisabled
      }
    },
    [`&${token2.componentCls}-multiple ${token2.componentCls}-selection-item`]: {
      background: token2.colorBgContainer,
      border: `${unit$1(token2.lineWidth)} ${token2.lineType} ${token2.colorSplit}`
    }
  })
}), "genFilledStyle$1"), genBorderlessStyle$1 = /* @__PURE__ */ __name((token2) => ({
  "&-borderless": {
    [`${token2.componentCls}-selector`]: {
      background: "transparent",
      border: `${unit$1(token2.lineWidth)} ${token2.lineType} transparent`
    },
    [`&${token2.componentCls}-disabled`]: {
      [`&:not(${token2.componentCls}-customize-input) ${token2.componentCls}-selector`]: {
        color: token2.colorTextDisabled
      }
    },
    [`&${token2.componentCls}-multiple ${token2.componentCls}-selection-item`]: {
      background: token2.multipleItemBg,
      border: `${unit$1(token2.lineWidth)} ${token2.lineType} ${token2.multipleItemBorderColor}`
    },
    // Status
    [`&${token2.componentCls}-status-error`]: {
      [`${token2.componentCls}-prefix, ${token2.componentCls}-selection-item`]: {
        color: token2.colorError
      }
    },
    [`&${token2.componentCls}-status-warning`]: {
      [`${token2.componentCls}-prefix, ${token2.componentCls}-selection-item`]: {
        color: token2.colorWarning
      }
    }
  }
}), "genBorderlessStyle$1"), genVariantsStyle$1 = /* @__PURE__ */ __name((token2) => ({
  [token2.componentCls]: Object.assign(Object.assign(Object.assign({}, genOutlinedStyle$1(token2)), genFilledStyle$1(token2)), genBorderlessStyle$1(token2))
}), "genVariantsStyle$1"), genSelectorStyle = /* @__PURE__ */ __name((token2) => {
  const {
    componentCls
  } = token2;
  return {
    position: "relative",
    transition: `all ${token2.motionDurationMid} ${token2.motionEaseInOut}`,
    input: {
      cursor: "pointer"
    },
    [`${componentCls}-show-search&`]: {
      cursor: "text",
      input: {
        cursor: "auto",
        color: "inherit",
        height: "100%"
      }
    },
    [`${componentCls}-disabled&`]: {
      cursor: "not-allowed",
      input: {
        cursor: "not-allowed"
      }
    }
  };
}, "genSelectorStyle"), getSearchInputWithoutBorderStyle = /* @__PURE__ */ __name((token2) => {
  const {
    componentCls
  } = token2;
  return {
    [`${componentCls}-selection-search-input`]: {
      margin: 0,
      padding: 0,
      background: "transparent",
      border: "none",
      outline: "none",
      appearance: "none",
      fontFamily: "inherit",
      "&::-webkit-search-cancel-button": {
        display: "none",
        "-webkit-appearance": "none"
      }
    }
  };
}, "getSearchInputWithoutBorderStyle"), genBaseStyle$5 = /* @__PURE__ */ __name((token2) => {
  const {
    antCls,
    componentCls,
    inputPaddingHorizontalBase,
    iconCls
  } = token2;
  return {
    [componentCls]: Object.assign(Object.assign({}, resetComponent(token2)), {
      position: "relative",
      display: "inline-flex",
      cursor: "pointer",
      [`&:not(${componentCls}-customize-input) ${componentCls}-selector`]: Object.assign(Object.assign({}, genSelectorStyle(token2)), getSearchInputWithoutBorderStyle(token2)),
      // ======================== Selection ========================
      [`${componentCls}-selection-item`]: Object.assign(Object.assign({
        flex: 1,
        fontWeight: "normal",
        position: "relative",
        userSelect: "none"
      }, textEllipsis), {
        // https://github.com/ant-design/ant-design/issues/40421
        [`> ${antCls}-typography`]: {
          display: "inline"
        }
      }),
      // ======================= Placeholder =======================
      [`${componentCls}-selection-placeholder`]: Object.assign(Object.assign({}, textEllipsis), {
        flex: 1,
        color: token2.colorTextPlaceholder,
        pointerEvents: "none"
      }),
      // ========================== Arrow ==========================
      [`${componentCls}-arrow`]: Object.assign(Object.assign({}, resetIcon()), {
        position: "absolute",
        top: "50%",
        insetInlineStart: "auto",
        insetInlineEnd: inputPaddingHorizontalBase,
        height: token2.fontSizeIcon,
        marginTop: token2.calc(token2.fontSizeIcon).mul(-1).div(2).equal(),
        color: token2.colorTextQuaternary,
        fontSize: token2.fontSizeIcon,
        lineHeight: 1,
        textAlign: "center",
        pointerEvents: "none",
        display: "flex",
        alignItems: "center",
        transition: `opacity ${token2.motionDurationSlow} ease`,
        [iconCls]: {
          verticalAlign: "top",
          transition: `transform ${token2.motionDurationSlow}`,
          "> svg": {
            verticalAlign: "top"
          },
          [`&:not(${componentCls}-suffix)`]: {
            pointerEvents: "auto"
          }
        },
        [`${componentCls}-disabled &`]: {
          cursor: "not-allowed"
        },
        "> *:not(:last-child)": {
          marginInlineEnd: 8
          // FIXME: magic
        }
      }),
      // ========================== Wrap ===========================
      [`${componentCls}-selection-wrap`]: {
        display: "flex",
        width: "100%",
        position: "relative",
        minWidth: 0,
        // https://github.com/ant-design/ant-design/issues/51669
        "&:after": {
          content: '"\\a0"',
          width: 0,
          overflow: "hidden"
        }
      },
      // ========================= Prefix ==========================
      [`${componentCls}-prefix`]: {
        flex: "none",
        marginInlineEnd: token2.selectAffixPadding
      },
      // ========================== Clear ==========================
      [`${componentCls}-clear`]: {
        position: "absolute",
        top: "50%",
        insetInlineStart: "auto",
        insetInlineEnd: inputPaddingHorizontalBase,
        zIndex: 1,
        display: "inline-block",
        width: token2.fontSizeIcon,
        height: token2.fontSizeIcon,
        marginTop: token2.calc(token2.fontSizeIcon).mul(-1).div(2).equal(),
        color: token2.colorTextQuaternary,
        fontSize: token2.fontSizeIcon,
        fontStyle: "normal",
        lineHeight: 1,
        textAlign: "center",
        textTransform: "none",
        cursor: "pointer",
        opacity: 0,
        transition: `color ${token2.motionDurationMid} ease, opacity ${token2.motionDurationSlow} ease`,
        textRendering: "auto",
        "&:before": {
          display: "block"
        },
        "&:hover": {
          color: token2.colorTextTertiary
        }
      },
      [`&:hover ${componentCls}-clear`]: {
        opacity: 1,
        background: token2.colorBgBase,
        borderRadius: "50%"
      }
    }),
    // ========================= Feedback ==========================
    [`${componentCls}-status`]: {
      "&-error, &-warning, &-success, &-validating": {
        [`&${componentCls}-has-feedback`]: {
          [`${componentCls}-clear`]: {
            insetInlineEnd: token2.calc(inputPaddingHorizontalBase).add(token2.fontSize).add(token2.paddingXS).equal()
          }
        }
      }
    }
  };
}, "genBaseStyle$5"), genSelectStyle = /* @__PURE__ */ __name((token2) => {
  const {
    componentCls
  } = token2;
  return [
    {
      [componentCls]: {
        // ==================== In Form ====================
        [`&${componentCls}-in-form-item`]: {
          width: "100%"
        }
      }
    },
    // =====================================================
    // ==                       LTR                       ==
    // =====================================================
    // Base
    genBaseStyle$5(token2),
    // Single
    genSingleStyle(token2),
    // Multiple
    genMultipleStyle(token2),
    // Dropdown
    genSingleStyle$1(token2),
    // =====================================================
    // ==                       RTL                       ==
    // =====================================================
    {
      [`${componentCls}-rtl`]: {
        direction: "rtl"
      }
    },
    // =====================================================
    // ==             Space Compact                       ==
    // =====================================================
    genCompactItemStyle(token2, {
      borderElCls: `${componentCls}-selector`,
      focusElCls: `${componentCls}-focused`
    })
  ];
}, "genSelectStyle"), useSelectStyle = genStyleHooks("Select", (token2, _ref) => {
  let {
    rootPrefixCls
  } = _ref;
  const selectToken = merge(token2, {
    rootPrefixCls,
    inputPaddingHorizontalBase: token2.calc(token2.paddingSM).sub(1).equal(),
    multipleSelectItemHeight: token2.multipleItemHeight,
    selectHeight: token2.controlHeight
  });
  return [genSelectStyle(selectToken), genVariantsStyle$1(selectToken)];
}, prepareComponentToken$l, {
  unitless: {
    optionLineHeight: !0,
    optionSelectedFontWeight: !0
  }
});
var CheckOutlined$1 = { icon: { tag: "svg", attrs: { viewBox: "64 64 896 896", focusable: "false" }, children: [{ tag: "path", attrs: { d: "M912 190h-69.9c-9.8 0-19.1 4.5-25.1 12.2L404.7 724.5 207 474a32 32 0 00-25.1-12.2H112c-6.7 0-10.4 7.7-6.3 12.9l273.9 347c12.8 16.2 37.4 16.2 50.3 0l488.4-618.9c4.1-5.1.4-12.8-6.3-12.8z" } }] }, name: "check", theme: "outlined" }, CheckOutlined = /* @__PURE__ */ __name(function(props, ref) {
  return /* @__PURE__ */ React.createElement(Icon$3, _extends({}, props, {
    ref,
    icon: CheckOutlined$1
  }));
}, "CheckOutlined"), RefIcon$x = /* @__PURE__ */ React.forwardRef(CheckOutlined);
process.env.NODE_ENV !== "production" && (RefIcon$x.displayName = "CheckOutlined");
var DownOutlined$1 = { icon: { tag: "svg", attrs: { viewBox: "64 64 896 896", focusable: "false" }, children: [{ tag: "path", attrs: { d: "M884 256h-75c-5.1 0-9.9 2.5-12.9 6.6L512 654.2 227.9 262.6c-3-4.1-7.8-6.6-12.9-6.6h-75c-6.5 0-10.3 7.4-6.5 12.7l352.6 486.1c12.8 17.6 39 17.6 51.7 0l352.6-486.1c3.9-5.3.1-12.7-6.4-12.7z" } }] }, name: "down", theme: "outlined" }, DownOutlined = /* @__PURE__ */ __name(function(props, ref) {
  return /* @__PURE__ */ React.createElement(Icon$3, _extends({}, props, {
    ref,
    icon: DownOutlined$1
  }));
}, "DownOutlined"), RefIcon$w = /* @__PURE__ */ React.forwardRef(DownOutlined);
process.env.NODE_ENV !== "production" && (RefIcon$w.displayName = "DownOutlined");
var SearchOutlined$1 = { icon: { tag: "svg", attrs: { viewBox: "64 64 896 896", focusable: "false" }, children: [{ tag: "path", attrs: { d: "M909.6 854.5L649.9 594.8C690.2 542.7 712 479 712 412c0-80.2-31.3-155.4-87.9-212.1-56.6-56.7-132-87.9-212.1-87.9s-155.5 31.3-212.1 87.9C143.2 256.5 112 331.8 112 412c0 80.1 31.3 155.5 87.9 212.1C256.5 680.8 331.8 712 412 712c67 0 130.6-21.8 182.7-62l259.7 259.6a8.2 8.2 0 0011.6 0l43.6-43.5a8.2 8.2 0 000-11.6zM570.4 570.4C528 612.7 471.8 636 412 636s-116-23.3-158.4-65.6C211.3 528 188 471.8 188 412s23.3-116.1 65.6-158.4C296 211.3 352.2 188 412 188s116.1 23.2 158.4 65.6S636 352.2 636 412s-23.3 116.1-65.6 158.4z" } }] }, name: "search", theme: "outlined" }, SearchOutlined = /* @__PURE__ */ __name(function(props, ref) {
  return /* @__PURE__ */ React.createElement(Icon$3, _extends({}, props, {
    ref,
    icon: SearchOutlined$1
  }));
}, "SearchOutlined"), RefIcon$v = /* @__PURE__ */ React.forwardRef(SearchOutlined);
process.env.NODE_ENV !== "production" && (RefIcon$v.displayName = "SearchOutlined");
function useIcons$1(_ref) {
  let {
    suffixIcon,
    clearIcon,
    menuItemSelectedIcon,
    removeIcon,
    loading,
    multiple,
    hasFeedback,
    prefixCls,
    showSuffixIcon,
    feedbackIcon,
    showArrow,
    componentName
  } = _ref;
  process.env.NODE_ENV !== "production" && devUseWarning(componentName).deprecated(!clearIcon, "clearIcon", "allowClear={{ clearIcon: React.ReactNode }}");
  const mergedClearIcon = clearIcon ?? /* @__PURE__ */ React.createElement(RefIcon$C, null), getSuffixIconNode = /* @__PURE__ */ __name((arrowIcon) => suffixIcon === null && !hasFeedback && !showArrow ? null : /* @__PURE__ */ React.createElement(React.Fragment, null, showSuffixIcon !== !1 && arrowIcon, hasFeedback && feedbackIcon), "getSuffixIconNode");
  let mergedSuffixIcon = null;
  if (suffixIcon !== void 0)
    mergedSuffixIcon = getSuffixIconNode(suffixIcon);
  else if (loading)
    mergedSuffixIcon = getSuffixIconNode(/* @__PURE__ */ React.createElement(RefIcon$z, {
      spin: !0
    }));
  else {
    const iconCls = `${prefixCls}-suffix`;
    mergedSuffixIcon = /* @__PURE__ */ __name((_ref2) => {
      let {
        open,
        showSearch
      } = _ref2;
      return getSuffixIconNode(open && showSearch ? /* @__PURE__ */ React.createElement(RefIcon$v, {
        className: iconCls
      }) : /* @__PURE__ */ React.createElement(RefIcon$w, {
        className: iconCls
      }));
    }, "mergedSuffixIcon");
  }
  let mergedItemIcon = null;
  menuItemSelectedIcon !== void 0 ? mergedItemIcon = menuItemSelectedIcon : multiple ? mergedItemIcon = /* @__PURE__ */ React.createElement(RefIcon$x, null) : mergedItemIcon = null;
  let mergedRemoveIcon = null;
  return removeIcon !== void 0 ? mergedRemoveIcon = removeIcon : mergedRemoveIcon = /* @__PURE__ */ React.createElement(RefIcon$B, null), {
    clearIcon: mergedClearIcon,
    suffixIcon: mergedSuffixIcon,
    itemIcon: mergedItemIcon,
    removeIcon: mergedRemoveIcon
  };
}
__name(useIcons$1, "useIcons$1");
function useShowArrow(suffixIcon, showArrow) {
  return showArrow !== void 0 ? showArrow : suffixIcon !== null;
}
__name(useShowArrow, "useShowArrow");
var __rest$P = function(s, e2) {
  var t2 = {};
  for (var p in s) Object.prototype.hasOwnProperty.call(s, p) && e2.indexOf(p) < 0 && (t2[p] = s[p]);
  if (s != null && typeof Object.getOwnPropertySymbols == "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++)
    e2.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]) && (t2[p[i]] = s[p[i]]);
  return t2;
};
const SECRET_COMBOBOX_MODE_DO_NOT_USE = "SECRET_COMBOBOX_MODE_DO_NOT_USE", InternalSelect = /* @__PURE__ */ __name((props, ref) => {
  var _a;
  const {
    prefixCls: customizePrefixCls,
    bordered,
    className,
    rootClassName,
    getPopupContainer,
    popupClassName,
    dropdownClassName,
    listHeight = 256,
    placement,
    listItemHeight: customListItemHeight,
    size: customizeSize,
    disabled: customDisabled,
    notFoundContent,
    status: customStatus,
    builtinPlacements,
    dropdownMatchSelectWidth,
    popupMatchSelectWidth,
    direction: propDirection,
    style: style2,
    allowClear,
    variant: customizeVariant,
    dropdownStyle,
    transitionName,
    tagRender,
    maxCount,
    prefix
  } = props, rest = __rest$P(props, ["prefixCls", "bordered", "className", "rootClassName", "getPopupContainer", "popupClassName", "dropdownClassName", "listHeight", "placement", "listItemHeight", "size", "disabled", "notFoundContent", "status", "builtinPlacements", "dropdownMatchSelectWidth", "popupMatchSelectWidth", "direction", "style", "allowClear", "variant", "dropdownStyle", "transitionName", "tagRender", "maxCount", "prefix"]), {
    getPopupContainer: getContextPopupContainer,
    getPrefixCls,
    renderEmpty,
    direction: contextDirection,
    virtual,
    popupMatchSelectWidth: contextPopupMatchSelectWidth,
    popupOverflow,
    select
  } = React.useContext(ConfigContext), [, token2] = useToken(), listItemHeight = customListItemHeight ?? (token2 == null ? void 0 : token2.controlHeight), prefixCls = getPrefixCls("select", customizePrefixCls), rootPrefixCls = getPrefixCls(), direction = propDirection ?? contextDirection, {
    compactSize,
    compactItemClassnames
  } = useCompactItemContext(prefixCls, direction), [variant, enableVariantCls] = useVariant("select", customizeVariant, bordered), rootCls = useCSSVarCls(prefixCls), [wrapCSSVar, hashId, cssVarCls] = useSelectStyle(prefixCls, rootCls), mode = React.useMemo(() => {
    const {
      mode: m2
    } = props;
    if (m2 !== "combobox")
      return m2 === SECRET_COMBOBOX_MODE_DO_NOT_USE ? "combobox" : m2;
  }, [props.mode]), isMultiple3 = mode === "multiple" || mode === "tags", showSuffixIcon = useShowArrow(props.suffixIcon, props.showArrow), mergedPopupMatchSelectWidth = (_a = popupMatchSelectWidth ?? dropdownMatchSelectWidth) !== null && _a !== void 0 ? _a : contextPopupMatchSelectWidth, {
    status: contextStatus,
    hasFeedback,
    isFormItemInput,
    feedbackIcon
  } = React.useContext(FormItemInputContext), mergedStatus = getMergedStatus(contextStatus, customStatus);
  let mergedNotFound;
  notFoundContent !== void 0 ? mergedNotFound = notFoundContent : mode === "combobox" ? mergedNotFound = null : mergedNotFound = (renderEmpty == null ? void 0 : renderEmpty("Select")) || /* @__PURE__ */ React.createElement(DefaultRenderEmpty, {
    componentName: "Select"
  });
  const {
    suffixIcon,
    itemIcon,
    removeIcon,
    clearIcon
  } = useIcons$1(Object.assign(Object.assign({}, rest), {
    multiple: isMultiple3,
    hasFeedback,
    feedbackIcon,
    showSuffixIcon,
    prefixCls,
    componentName: "Select"
  })), mergedAllowClear = allowClear === !0 ? {
    clearIcon
  } : allowClear, selectProps = omit(rest, ["suffixIcon", "itemIcon"]), mergedPopupClassName = cn(popupClassName || dropdownClassName, {
    [`${prefixCls}-dropdown-${direction}`]: direction === "rtl"
  }, rootClassName, cssVarCls, rootCls, hashId), mergedSize = useSize((ctx) => {
    var _a2;
    return (_a2 = customizeSize ?? compactSize) !== null && _a2 !== void 0 ? _a2 : ctx;
  }), disabled = React.useContext(DisabledContext), mergedDisabled = customDisabled ?? disabled, mergedClassName = cn({
    [`${prefixCls}-lg`]: mergedSize === "large",
    [`${prefixCls}-sm`]: mergedSize === "small",
    [`${prefixCls}-rtl`]: direction === "rtl",
    [`${prefixCls}-${variant}`]: enableVariantCls,
    [`${prefixCls}-in-form-item`]: isFormItemInput
  }, getStatusClassNames(prefixCls, mergedStatus, hasFeedback), compactItemClassnames, select == null ? void 0 : select.className, className, rootClassName, cssVarCls, rootCls, hashId), memoPlacement = React.useMemo(() => placement !== void 0 ? placement : direction === "rtl" ? "bottomRight" : "bottomLeft", [placement, direction]);
  if (process.env.NODE_ENV !== "production") {
    const warning3 = devUseWarning("Select");
    warning3.deprecated(!dropdownClassName, "dropdownClassName", "popupClassName"), warning3.deprecated(dropdownMatchSelectWidth === void 0, "dropdownMatchSelectWidth", "popupMatchSelectWidth"), process.env.NODE_ENV !== "production" && warning3(!("showArrow" in props), "deprecated", "`showArrow` is deprecated which will be removed in next major version. It will be a default behavior, you can hide it by setting `suffixIcon` to null."), warning3.deprecated(!("bordered" in props), "bordered", "variant"), process.env.NODE_ENV !== "production" && warning3(!(typeof maxCount < "u" && !isMultiple3), "usage", "`maxCount` only works with mode `multiple` or `tags`");
  }
  const [zIndex] = useZIndex("SelectLike", dropdownStyle == null ? void 0 : dropdownStyle.zIndex);
  return wrapCSSVar(/* @__PURE__ */ React.createElement(TypedSelect, Object.assign({
    ref,
    virtual,
    showSearch: select == null ? void 0 : select.showSearch
  }, selectProps, {
    style: Object.assign(Object.assign({}, select == null ? void 0 : select.style), style2),
    dropdownMatchSelectWidth: mergedPopupMatchSelectWidth,
    transitionName: getTransitionName(rootPrefixCls, "slide-up", transitionName),
    builtinPlacements: mergedBuiltinPlacements(builtinPlacements, popupOverflow),
    listHeight,
    listItemHeight,
    mode,
    prefixCls,
    placement: memoPlacement,
    direction,
    prefix,
    suffixIcon,
    menuItemSelectedIcon: itemIcon,
    removeIcon,
    allowClear: mergedAllowClear,
    notFoundContent: mergedNotFound,
    className: mergedClassName,
    getPopupContainer: getPopupContainer || getContextPopupContainer,
    dropdownClassName: mergedPopupClassName,
    disabled: mergedDisabled,
    dropdownStyle: Object.assign(Object.assign({}, dropdownStyle), {
      zIndex
    }),
    maxCount: isMultiple3 ? maxCount : void 0,
    tagRender: isMultiple3 ? tagRender : void 0
  })));
}, "InternalSelect");
process.env.NODE_ENV !== "production" && (InternalSelect.displayName = "Select");
const Select$1 = /* @__PURE__ */ React.forwardRef(InternalSelect), PurePanel$5 = genPurePanel(Select$1);
Select$1.SECRET_COMBOBOX_MODE_DO_NOT_USE = SECRET_COMBOBOX_MODE_DO_NOT_USE;
Select$1.Option = Option$1;
Select$1.OptGroup = OptGroup;
Select$1._InternalPanelDoNotUseOrYouWillBeFired = PurePanel$5;
process.env.NODE_ENV !== "production" && (Select$1.displayName = "Select");
const responsiveArray = ["xxl", "xl", "lg", "md", "sm", "xs"], getResponsiveMap = /* @__PURE__ */ __name((token2) => ({
  xs: `(max-width: ${token2.screenXSMax}px)`,
  sm: `(min-width: ${token2.screenSM}px)`,
  md: `(min-width: ${token2.screenMD}px)`,
  lg: `(min-width: ${token2.screenLG}px)`,
  xl: `(min-width: ${token2.screenXL}px)`,
  xxl: `(min-width: ${token2.screenXXL}px)`
}), "getResponsiveMap"), validateBreakpoints = /* @__PURE__ */ __name((token2) => {
  const indexableToken = token2, revBreakpoints = [].concat(responsiveArray).reverse();
  return revBreakpoints.forEach((breakpoint, i) => {
    const breakpointUpper = breakpoint.toUpperCase(), screenMin = `screen${breakpointUpper}Min`, screen = `screen${breakpointUpper}`;
    if (!(indexableToken[screenMin] <= indexableToken[screen]))
      throw new Error(`${screenMin}<=${screen} fails : !(${indexableToken[screenMin]}<=${indexableToken[screen]})`);
    if (i < revBreakpoints.length - 1) {
      const screenMax = `screen${breakpointUpper}Max`;
      if (!(indexableToken[screen] <= indexableToken[screenMax]))
        throw new Error(`${screen}<=${screenMax} fails : !(${indexableToken[screen]}<=${indexableToken[screenMax]})`);
      const nextScreenMin = `screen${revBreakpoints[i + 1].toUpperCase()}Min`;
      if (!(indexableToken[screenMax] <= indexableToken[nextScreenMin]))
        throw new Error(`${screenMax}<=${nextScreenMin} fails : !(${indexableToken[screenMax]}<=${indexableToken[nextScreenMin]})`);
    }
  }), token2;
}, "validateBreakpoints");
function useResponsiveObserver() {
  const [, token2] = useToken(), responsiveMap = getResponsiveMap(validateBreakpoints(token2));
  return React__default.useMemo(() => {
    const subscribers = /* @__PURE__ */ new Map();
    let subUid = -1, screens = {};
    return {
      matchHandlers: {},
      dispatch(pointMap) {
        return screens = pointMap, subscribers.forEach((func) => func(screens)), subscribers.size >= 1;
      },
      subscribe(func) {
        return subscribers.size || this.register(), subUid += 1, subscribers.set(subUid, func), func(screens), subUid;
      },
      unsubscribe(paramToken) {
        subscribers.delete(paramToken), subscribers.size || this.unregister();
      },
      unregister() {
        Object.keys(responsiveMap).forEach((screen) => {
          const matchMediaQuery = responsiveMap[screen], handler = this.matchHandlers[matchMediaQuery];
          handler == null || handler.mql.removeListener(handler == null ? void 0 : handler.listener);
        }), subscribers.clear();
      },
      register() {
        Object.keys(responsiveMap).forEach((screen) => {
          const matchMediaQuery = responsiveMap[screen], listener = /* @__PURE__ */ __name((_ref) => {
            let {
              matches
            } = _ref;
            this.dispatch(Object.assign(Object.assign({}, screens), {
              [screen]: matches
            }));
          }, "listener"), mql = window.matchMedia(matchMediaQuery);
          mql.addListener(listener), this.matchHandlers[matchMediaQuery] = {
            mql,
            listener
          }, listener(mql);
        });
      },
      responsiveMap
    };
  }, [token2]);
}
__name(useResponsiveObserver, "useResponsiveObserver");
function useForceUpdate() {
  const [, forceUpdate] = React.useReducer((x) => x + 1, 0);
  return forceUpdate;
}
__name(useForceUpdate, "useForceUpdate");
function useBreakpoint() {
  let refreshOnChange = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : !0;
  const screensRef = useRef({}), forceUpdate = useForceUpdate(), responsiveObserver = useResponsiveObserver();
  return useLayoutEffect$1(() => {
    const token2 = responsiveObserver.subscribe((supportScreens) => {
      screensRef.current = supportScreens, refreshOnChange && forceUpdate();
    });
    return () => responsiveObserver.unsubscribe(token2);
  }, []), screensRef.current;
}
__name(useBreakpoint, "useBreakpoint");
const getRenderPropValue = /* @__PURE__ */ __name((propValue) => propValue ? typeof propValue == "function" ? propValue() : propValue : null, "getRenderPropValue");
function Popup$1(props) {
  var children = props.children, prefixCls = props.prefixCls, id2 = props.id, overlayInnerStyle = props.overlayInnerStyle, className = props.className, style2 = props.style;
  return /* @__PURE__ */ React.createElement("div", {
    className: cn("".concat(prefixCls, "-content"), className),
    style: style2
  }, /* @__PURE__ */ React.createElement("div", {
    className: "".concat(prefixCls, "-inner"),
    id: id2,
    role: "tooltip",
    style: overlayInnerStyle
  }, typeof children == "function" ? children() : children));
}
__name(Popup$1, "Popup$1");
var autoAdjustOverflowTopBottom = {
  shiftX: 64,
  adjustY: 1
}, autoAdjustOverflowLeftRight = {
  adjustX: 1,
  shiftY: !0
}, targetOffset$1 = [0, 0], placements$2 = {
  left: {
    points: ["cr", "cl"],
    overflow: autoAdjustOverflowLeftRight,
    offset: [-4, 0],
    targetOffset: targetOffset$1
  },
  right: {
    points: ["cl", "cr"],
    overflow: autoAdjustOverflowLeftRight,
    offset: [4, 0],
    targetOffset: targetOffset$1
  },
  top: {
    points: ["bc", "tc"],
    overflow: autoAdjustOverflowTopBottom,
    offset: [0, -4],
    targetOffset: targetOffset$1
  },
  bottom: {
    points: ["tc", "bc"],
    overflow: autoAdjustOverflowTopBottom,
    offset: [0, 4],
    targetOffset: targetOffset$1
  },
  topLeft: {
    points: ["bl", "tl"],
    overflow: autoAdjustOverflowTopBottom,
    offset: [0, -4],
    targetOffset: targetOffset$1
  },
  leftTop: {
    points: ["tr", "tl"],
    overflow: autoAdjustOverflowLeftRight,
    offset: [-4, 0],
    targetOffset: targetOffset$1
  },
  topRight: {
    points: ["br", "tr"],
    overflow: autoAdjustOverflowTopBottom,
    offset: [0, -4],
    targetOffset: targetOffset$1
  },
  rightTop: {
    points: ["tl", "tr"],
    overflow: autoAdjustOverflowLeftRight,
    offset: [4, 0],
    targetOffset: targetOffset$1
  },
  bottomRight: {
    points: ["tr", "br"],
    overflow: autoAdjustOverflowTopBottom,
    offset: [0, 4],
    targetOffset: targetOffset$1
  },
  rightBottom: {
    points: ["bl", "br"],
    overflow: autoAdjustOverflowLeftRight,
    offset: [4, 0],
    targetOffset: targetOffset$1
  },
  bottomLeft: {
    points: ["tl", "bl"],
    overflow: autoAdjustOverflowTopBottom,
    offset: [0, 4],
    targetOffset: targetOffset$1
  },
  leftBottom: {
    points: ["br", "bl"],
    overflow: autoAdjustOverflowLeftRight,
    offset: [-4, 0],
    targetOffset: targetOffset$1
  }
}, _excluded$z = ["overlayClassName", "trigger", "mouseEnterDelay", "mouseLeaveDelay", "overlayStyle", "prefixCls", "children", "onVisibleChange", "afterVisibleChange", "transitionName", "animation", "motion", "placement", "align", "destroyTooltipOnHide", "defaultVisible", "getTooltipContainer", "overlayInnerStyle", "arrowContent", "overlay", "id", "showArrow"], Tooltip$2 = /* @__PURE__ */ __name(function(props, ref) {
  var overlayClassName = props.overlayClassName, _props$trigger = props.trigger, trigger = _props$trigger === void 0 ? ["hover"] : _props$trigger, _props$mouseEnterDela = props.mouseEnterDelay, mouseEnterDelay = _props$mouseEnterDela === void 0 ? 0 : _props$mouseEnterDela, _props$mouseLeaveDela = props.mouseLeaveDelay, mouseLeaveDelay = _props$mouseLeaveDela === void 0 ? 0.1 : _props$mouseLeaveDela, overlayStyle = props.overlayStyle, _props$prefixCls = props.prefixCls, prefixCls = _props$prefixCls === void 0 ? "rc-tooltip" : _props$prefixCls, children = props.children, onVisibleChange = props.onVisibleChange, afterVisibleChange = props.afterVisibleChange, transitionName = props.transitionName, animation = props.animation, motion2 = props.motion, _props$placement = props.placement, placement = _props$placement === void 0 ? "right" : _props$placement, _props$align = props.align, align = _props$align === void 0 ? {} : _props$align, _props$destroyTooltip = props.destroyTooltipOnHide, destroyTooltipOnHide = _props$destroyTooltip === void 0 ? !1 : _props$destroyTooltip, defaultVisible = props.defaultVisible, getTooltipContainer = props.getTooltipContainer, overlayInnerStyle = props.overlayInnerStyle;
  props.arrowContent;
  var overlay2 = props.overlay, id2 = props.id, _props$showArrow = props.showArrow, showArrow = _props$showArrow === void 0 ? !0 : _props$showArrow, restProps = _objectWithoutProperties(props, _excluded$z), triggerRef = useRef(null);
  useImperativeHandle(ref, function() {
    return triggerRef.current;
  });
  var extraProps = _objectSpread2$1({}, restProps);
  "visible" in props && (extraProps.popupVisible = props.visible);
  var getPopupElement = /* @__PURE__ */ __name(function() {
    return /* @__PURE__ */ React.createElement(Popup$1, {
      key: "content",
      prefixCls,
      id: id2,
      overlayInnerStyle
    }, overlay2);
  }, "getPopupElement");
  return /* @__PURE__ */ React.createElement(Trigger, _extends({
    popupClassName: overlayClassName,
    prefixCls,
    popup: getPopupElement,
    action: trigger,
    builtinPlacements: placements$2,
    popupPlacement: placement,
    ref: triggerRef,
    popupAlign: align,
    getPopupContainer: getTooltipContainer,
    onPopupVisibleChange: onVisibleChange,
    afterPopupVisibleChange: afterVisibleChange,
    popupTransitionName: transitionName,
    popupAnimation: animation,
    popupMotion: motion2,
    defaultPopupVisible: defaultVisible,
    autoDestroy: destroyTooltipOnHide,
    mouseLeaveDelay,
    popupStyle: overlayStyle,
    mouseEnterDelay,
    arrow: showArrow
  }, extraProps), children);
}, "Tooltip");
const Tooltip$3 = /* @__PURE__ */ forwardRef(Tooltip$2);
function getArrowToken(token2) {
  const {
    sizePopupArrow,
    borderRadiusXS,
    borderRadiusOuter
  } = token2, unitWidth = sizePopupArrow / 2, ax = 0, ay = unitWidth, bx = borderRadiusOuter * 1 / Math.sqrt(2), by = unitWidth - borderRadiusOuter * (1 - 1 / Math.sqrt(2)), cx = unitWidth - borderRadiusXS * (1 / Math.sqrt(2)), cy = borderRadiusOuter * (Math.sqrt(2) - 1) + borderRadiusXS * (1 / Math.sqrt(2)), dx = 2 * unitWidth - cx, dy = cy, ex = 2 * unitWidth - bx, ey = by, fx = 2 * unitWidth - ax, fy = ay, shadowWidth = unitWidth * Math.sqrt(2) + borderRadiusOuter * (Math.sqrt(2) - 2), polygonOffset = borderRadiusOuter * (Math.sqrt(2) - 1), arrowPolygon = `polygon(${polygonOffset}px 100%, 50% ${polygonOffset}px, ${2 * unitWidth - polygonOffset}px 100%, ${polygonOffset}px 100%)`, arrowPath = `path('M ${ax} ${ay} A ${borderRadiusOuter} ${borderRadiusOuter} 0 0 0 ${bx} ${by} L ${cx} ${cy} A ${borderRadiusXS} ${borderRadiusXS} 0 0 1 ${dx} ${dy} L ${ex} ${ey} A ${borderRadiusOuter} ${borderRadiusOuter} 0 0 0 ${fx} ${fy} Z')`;
  return {
    arrowShadowWidth: shadowWidth,
    arrowPath,
    arrowPolygon
  };
}
__name(getArrowToken, "getArrowToken");
const genRoundedArrow = /* @__PURE__ */ __name((token2, bgColor, boxShadow) => {
  const {
    sizePopupArrow,
    arrowPolygon,
    arrowPath,
    arrowShadowWidth,
    borderRadiusXS,
    calc
  } = token2;
  return {
    pointerEvents: "none",
    width: sizePopupArrow,
    height: sizePopupArrow,
    overflow: "hidden",
    "&::before": {
      position: "absolute",
      bottom: 0,
      insetInlineStart: 0,
      width: sizePopupArrow,
      height: calc(sizePopupArrow).div(2).equal(),
      background: bgColor,
      clipPath: {
        _multi_value_: !0,
        value: [arrowPolygon, arrowPath]
      },
      content: '""'
    },
    "&::after": {
      content: '""',
      position: "absolute",
      width: arrowShadowWidth,
      height: arrowShadowWidth,
      bottom: 0,
      insetInline: 0,
      margin: "auto",
      borderRadius: {
        _skip_check_: !0,
        value: `0 0 ${unit$1(borderRadiusXS)} 0`
      },
      transform: "translateY(50%) rotate(-135deg)",
      boxShadow,
      zIndex: 0,
      background: "transparent"
    }
  };
}, "genRoundedArrow"), MAX_VERTICAL_CONTENT_RADIUS = 8;
function getArrowOffsetToken(options) {
  const {
    contentRadius,
    limitVerticalRadius
  } = options, arrowOffset = contentRadius > 12 ? contentRadius + 2 : 12;
  return {
    arrowOffsetHorizontal: arrowOffset,
    arrowOffsetVertical: limitVerticalRadius ? MAX_VERTICAL_CONTENT_RADIUS : arrowOffset
  };
}
__name(getArrowOffsetToken, "getArrowOffsetToken");
function isInject(valid, code) {
  return valid ? code : {};
}
__name(isInject, "isInject");
function getArrowStyle(token2, colorBg, options) {
  const {
    componentCls,
    boxShadowPopoverArrow,
    arrowOffsetVertical,
    arrowOffsetHorizontal
  } = token2, {
    arrowDistance = 0,
    arrowPlacement = {
      left: !0,
      right: !0,
      top: !0,
      bottom: !0
    }
  } = options || {};
  return {
    [componentCls]: Object.assign(Object.assign(Object.assign(Object.assign({
      // ============================ Basic ============================
      [`${componentCls}-arrow`]: [Object.assign(Object.assign({
        position: "absolute",
        zIndex: 1,
        display: "block"
      }, genRoundedArrow(token2, colorBg, boxShadowPopoverArrow)), {
        "&:before": {
          background: colorBg
        }
      })]
    }, isInject(!!arrowPlacement.top, {
      [[`&-placement-top > ${componentCls}-arrow`, `&-placement-topLeft > ${componentCls}-arrow`, `&-placement-topRight > ${componentCls}-arrow`].join(",")]: {
        bottom: arrowDistance,
        transform: "translateY(100%) rotate(180deg)"
      },
      [`&-placement-top > ${componentCls}-arrow`]: {
        left: {
          _skip_check_: !0,
          value: "50%"
        },
        transform: "translateX(-50%) translateY(100%) rotate(180deg)"
      },
      "&-placement-topLeft": {
        "--arrow-offset-horizontal": arrowOffsetHorizontal,
        [`> ${componentCls}-arrow`]: {
          left: {
            _skip_check_: !0,
            value: arrowOffsetHorizontal
          }
        }
      },
      "&-placement-topRight": {
        "--arrow-offset-horizontal": `calc(100% - ${unit$1(arrowOffsetHorizontal)})`,
        [`> ${componentCls}-arrow`]: {
          right: {
            _skip_check_: !0,
            value: arrowOffsetHorizontal
          }
        }
      }
    })), isInject(!!arrowPlacement.bottom, {
      [[`&-placement-bottom > ${componentCls}-arrow`, `&-placement-bottomLeft > ${componentCls}-arrow`, `&-placement-bottomRight > ${componentCls}-arrow`].join(",")]: {
        top: arrowDistance,
        transform: "translateY(-100%)"
      },
      [`&-placement-bottom > ${componentCls}-arrow`]: {
        left: {
          _skip_check_: !0,
          value: "50%"
        },
        transform: "translateX(-50%) translateY(-100%)"
      },
      "&-placement-bottomLeft": {
        "--arrow-offset-horizontal": arrowOffsetHorizontal,
        [`> ${componentCls}-arrow`]: {
          left: {
            _skip_check_: !0,
            value: arrowOffsetHorizontal
          }
        }
      },
      "&-placement-bottomRight": {
        "--arrow-offset-horizontal": `calc(100% - ${unit$1(arrowOffsetHorizontal)})`,
        [`> ${componentCls}-arrow`]: {
          right: {
            _skip_check_: !0,
            value: arrowOffsetHorizontal
          }
        }
      }
    })), isInject(!!arrowPlacement.left, {
      [[`&-placement-left > ${componentCls}-arrow`, `&-placement-leftTop > ${componentCls}-arrow`, `&-placement-leftBottom > ${componentCls}-arrow`].join(",")]: {
        right: {
          _skip_check_: !0,
          value: arrowDistance
        },
        transform: "translateX(100%) rotate(90deg)"
      },
      [`&-placement-left > ${componentCls}-arrow`]: {
        top: {
          _skip_check_: !0,
          value: "50%"
        },
        transform: "translateY(-50%) translateX(100%) rotate(90deg)"
      },
      [`&-placement-leftTop > ${componentCls}-arrow`]: {
        top: arrowOffsetVertical
      },
      [`&-placement-leftBottom > ${componentCls}-arrow`]: {
        bottom: arrowOffsetVertical
      }
    })), isInject(!!arrowPlacement.right, {
      [[`&-placement-right > ${componentCls}-arrow`, `&-placement-rightTop > ${componentCls}-arrow`, `&-placement-rightBottom > ${componentCls}-arrow`].join(",")]: {
        left: {
          _skip_check_: !0,
          value: arrowDistance
        },
        transform: "translateX(-100%) rotate(-90deg)"
      },
      [`&-placement-right > ${componentCls}-arrow`]: {
        top: {
          _skip_check_: !0,
          value: "50%"
        },
        transform: "translateY(-50%) translateX(-100%) rotate(-90deg)"
      },
      [`&-placement-rightTop > ${componentCls}-arrow`]: {
        top: arrowOffsetVertical
      },
      [`&-placement-rightBottom > ${componentCls}-arrow`]: {
        bottom: arrowOffsetVertical
      }
    }))
  };
}
__name(getArrowStyle, "getArrowStyle");
function getOverflowOptions(placement, arrowOffset, arrowWidth, autoAdjustOverflow2) {
  if (autoAdjustOverflow2 === !1)
    return {
      adjustX: !1,
      adjustY: !1
    };
  const overflow = autoAdjustOverflow2 && typeof autoAdjustOverflow2 == "object" ? autoAdjustOverflow2 : {}, baseOverflow = {};
  switch (placement) {
    case "top":
    case "bottom":
      baseOverflow.shiftX = arrowOffset.arrowOffsetHorizontal * 2 + arrowWidth, baseOverflow.shiftY = !0, baseOverflow.adjustY = !0;
      break;
    case "left":
    case "right":
      baseOverflow.shiftY = arrowOffset.arrowOffsetVertical * 2 + arrowWidth, baseOverflow.shiftX = !0, baseOverflow.adjustX = !0;
      break;
  }
  const mergedOverflow = Object.assign(Object.assign({}, baseOverflow), overflow);
  return mergedOverflow.shiftX || (mergedOverflow.adjustX = !0), mergedOverflow.shiftY || (mergedOverflow.adjustY = !0), mergedOverflow;
}
__name(getOverflowOptions, "getOverflowOptions");
const PlacementAlignMap = {
  left: {
    points: ["cr", "cl"]
  },
  right: {
    points: ["cl", "cr"]
  },
  top: {
    points: ["bc", "tc"]
  },
  bottom: {
    points: ["tc", "bc"]
  },
  topLeft: {
    points: ["bl", "tl"]
  },
  leftTop: {
    points: ["tr", "tl"]
  },
  topRight: {
    points: ["br", "tr"]
  },
  rightTop: {
    points: ["tl", "tr"]
  },
  bottomRight: {
    points: ["tr", "br"]
  },
  rightBottom: {
    points: ["bl", "br"]
  },
  bottomLeft: {
    points: ["tl", "bl"]
  },
  leftBottom: {
    points: ["br", "bl"]
  }
}, ArrowCenterPlacementAlignMap = {
  topLeft: {
    points: ["bl", "tc"]
  },
  leftTop: {
    points: ["tr", "cl"]
  },
  topRight: {
    points: ["br", "tc"]
  },
  rightTop: {
    points: ["tl", "cr"]
  },
  bottomRight: {
    points: ["tr", "bc"]
  },
  rightBottom: {
    points: ["bl", "cr"]
  },
  bottomLeft: {
    points: ["tl", "bc"]
  },
  leftBottom: {
    points: ["br", "cl"]
  }
}, DisableAutoArrowList = /* @__PURE__ */ new Set(["topLeft", "topRight", "bottomLeft", "bottomRight", "leftTop", "leftBottom", "rightTop", "rightBottom"]);
function getPlacements(config) {
  const {
    arrowWidth,
    autoAdjustOverflow: autoAdjustOverflow2,
    arrowPointAtCenter,
    offset: offset2,
    borderRadius,
    visibleFirst
  } = config, halfArrowWidth = arrowWidth / 2, placementMap = {};
  return Object.keys(PlacementAlignMap).forEach((key) => {
    const template = arrowPointAtCenter && ArrowCenterPlacementAlignMap[key] || PlacementAlignMap[key], placementInfo = Object.assign(Object.assign({}, template), {
      offset: [0, 0],
      dynamicInset: !0
    });
    switch (placementMap[key] = placementInfo, DisableAutoArrowList.has(key) && (placementInfo.autoArrow = !1), key) {
      case "top":
      case "topLeft":
      case "topRight":
        placementInfo.offset[1] = -halfArrowWidth - offset2;
        break;
      case "bottom":
      case "bottomLeft":
      case "bottomRight":
        placementInfo.offset[1] = halfArrowWidth + offset2;
        break;
      case "left":
      case "leftTop":
      case "leftBottom":
        placementInfo.offset[0] = -halfArrowWidth - offset2;
        break;
      case "right":
      case "rightTop":
      case "rightBottom":
        placementInfo.offset[0] = halfArrowWidth + offset2;
        break;
    }
    const arrowOffset = getArrowOffsetToken({
      contentRadius: borderRadius,
      limitVerticalRadius: !0
    });
    if (arrowPointAtCenter)
      switch (key) {
        case "topLeft":
        case "bottomLeft":
          placementInfo.offset[0] = -arrowOffset.arrowOffsetHorizontal - halfArrowWidth;
          break;
        case "topRight":
        case "bottomRight":
          placementInfo.offset[0] = arrowOffset.arrowOffsetHorizontal + halfArrowWidth;
          break;
        case "leftTop":
        case "rightTop":
          placementInfo.offset[1] = -arrowOffset.arrowOffsetHorizontal * 2 + halfArrowWidth;
          break;
        case "leftBottom":
        case "rightBottom":
          placementInfo.offset[1] = arrowOffset.arrowOffsetHorizontal * 2 - halfArrowWidth;
          break;
      }
    placementInfo.overflow = getOverflowOptions(key, arrowOffset, arrowWidth, autoAdjustOverflow2), visibleFirst && (placementInfo.htmlRegion = "visibleFirst");
  }), placementMap;
}
__name(getPlacements, "getPlacements");
const genTooltipStyle = /* @__PURE__ */ __name((token2) => {
  const {
    calc,
    componentCls,
    // ant-tooltip
    tooltipMaxWidth,
    tooltipColor,
    tooltipBg,
    tooltipBorderRadius,
    zIndexPopup,
    controlHeight,
    boxShadowSecondary,
    paddingSM,
    paddingXS,
    arrowOffsetHorizontal,
    sizePopupArrow
  } = token2, edgeAlignMinWidth = calc(tooltipBorderRadius).add(sizePopupArrow).add(arrowOffsetHorizontal).equal(), centerAlignMinWidth = calc(tooltipBorderRadius).mul(2).add(sizePopupArrow).equal();
  return [
    {
      [componentCls]: Object.assign(Object.assign(Object.assign(Object.assign({}, resetComponent(token2)), {
        position: "absolute",
        zIndex: zIndexPopup,
        display: "block",
        width: "max-content",
        maxWidth: tooltipMaxWidth,
        visibility: "visible",
        // When use `autoArrow`, origin will follow the arrow position
        "--valid-offset-x": "var(--arrow-offset-horizontal, var(--arrow-x))",
        transformOrigin: ["var(--valid-offset-x, 50%)", "var(--arrow-y, 50%)"].join(" "),
        "&-hidden": {
          display: "none"
        },
        "--antd-arrow-background-color": tooltipBg,
        // Wrapper for the tooltip content
        [`${componentCls}-inner`]: {
          minWidth: centerAlignMinWidth,
          minHeight: controlHeight,
          padding: `${unit$1(token2.calc(paddingSM).div(2).equal())} ${unit$1(paddingXS)}`,
          color: tooltipColor,
          textAlign: "start",
          textDecoration: "none",
          wordWrap: "break-word",
          backgroundColor: tooltipBg,
          borderRadius: tooltipBorderRadius,
          boxShadow: boxShadowSecondary,
          boxSizing: "border-box"
        },
        // Align placement should have another min width
        [["&-placement-topLeft", "&-placement-topRight", "&-placement-bottomLeft", "&-placement-bottomRight"].join(",")]: {
          minWidth: edgeAlignMinWidth
        },
        // Limit left and right placement radius
        [["&-placement-left", "&-placement-leftTop", "&-placement-leftBottom", "&-placement-right", "&-placement-rightTop", "&-placement-rightBottom"].join(",")]: {
          [`${componentCls}-inner`]: {
            borderRadius: token2.min(tooltipBorderRadius, MAX_VERTICAL_CONTENT_RADIUS)
          }
        },
        [`${componentCls}-content`]: {
          position: "relative"
        }
      }), genPresetColor(token2, (colorKey, _ref) => {
        let {
          darkColor
        } = _ref;
        return {
          [`&${componentCls}-${colorKey}`]: {
            [`${componentCls}-inner`]: {
              backgroundColor: darkColor
            },
            [`${componentCls}-arrow`]: {
              "--antd-arrow-background-color": darkColor
            }
          }
        };
      })), {
        // RTL
        "&-rtl": {
          direction: "rtl"
        }
      })
    },
    // Arrow Style
    getArrowStyle(token2, "var(--antd-arrow-background-color)"),
    // Pure Render
    {
      [`${componentCls}-pure`]: {
        position: "relative",
        maxWidth: "none",
        margin: token2.sizePopupArrow
      }
    }
  ];
}, "genTooltipStyle"), prepareComponentToken$k = /* @__PURE__ */ __name((token2) => Object.assign(Object.assign({
  zIndexPopup: token2.zIndexPopupBase + 70
}, getArrowOffsetToken({
  contentRadius: token2.borderRadius,
  limitVerticalRadius: !0
})), getArrowToken(merge(token2, {
  borderRadiusOuter: Math.min(token2.borderRadiusOuter, 4)
}))), "prepareComponentToken$k"), useStyle$p = /* @__PURE__ */ __name(function(prefixCls) {
  let injectStyle = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !0;
  return genStyleHooks("Tooltip", (token2) => {
    const {
      borderRadius,
      colorTextLightSolid,
      colorBgSpotlight
    } = token2, TooltipToken = merge(token2, {
      // default variables
      tooltipMaxWidth: 250,
      tooltipColor: colorTextLightSolid,
      tooltipBorderRadius: borderRadius,
      tooltipBg: colorBgSpotlight
    });
    return [genTooltipStyle(TooltipToken), initZoomMotion(token2, "zoom-big-fast")];
  }, prepareComponentToken$k, {
    resetStyle: !1,
    // Popover use Tooltip as internal component. We do not need to handle this.
    injectStyle
  })(prefixCls);
}, "useStyle$p"), inverseColors = PresetColors.map((color) => `${color}-inverse`), PresetStatusColorTypes = ["success", "processing", "error", "default", "warning"];
function isPresetColor(color) {
  return (arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !0) ? [].concat(_toConsumableArray(inverseColors), _toConsumableArray(PresetColors)).includes(color) : PresetColors.includes(color);
}
__name(isPresetColor, "isPresetColor");
function isPresetStatusColor(color) {
  return PresetStatusColorTypes.includes(color);
}
__name(isPresetStatusColor, "isPresetStatusColor");
function parseColor(prefixCls, color) {
  const isInternalColor = isPresetColor(color), className = cn({
    [`${prefixCls}-${color}`]: color && isInternalColor
  }), overlayStyle = {}, arrowStyle = {};
  return color && !isInternalColor && (overlayStyle.background = color, arrowStyle["--antd-arrow-background-color"] = color), {
    className,
    overlayStyle,
    arrowStyle
  };
}
__name(parseColor, "parseColor");
const PurePanel$4 = /* @__PURE__ */ __name((props) => {
  const {
    prefixCls: customizePrefixCls,
    className,
    placement = "top",
    title: title2,
    color,
    overlayInnerStyle
  } = props, {
    getPrefixCls
  } = React.useContext(ConfigContext), prefixCls = getPrefixCls("tooltip", customizePrefixCls), [wrapCSSVar, hashId, cssVarCls] = useStyle$p(prefixCls), colorInfo = parseColor(prefixCls, color), arrowContentStyle = colorInfo.arrowStyle, formattedOverlayInnerStyle = Object.assign(Object.assign({}, overlayInnerStyle), colorInfo.overlayStyle), cls = cn(hashId, cssVarCls, prefixCls, `${prefixCls}-pure`, `${prefixCls}-placement-${placement}`, className, colorInfo.className);
  return wrapCSSVar(/* @__PURE__ */ React.createElement("div", {
    className: cls,
    style: arrowContentStyle
  }, /* @__PURE__ */ React.createElement("div", {
    className: `${prefixCls}-arrow`
  }), /* @__PURE__ */ React.createElement(Popup$1, Object.assign({}, props, {
    className: hashId,
    prefixCls,
    overlayInnerStyle: formattedOverlayInnerStyle
  }), title2)));
}, "PurePanel$4");
var __rest$O = function(s, e2) {
  var t2 = {};
  for (var p in s) Object.prototype.hasOwnProperty.call(s, p) && e2.indexOf(p) < 0 && (t2[p] = s[p]);
  if (s != null && typeof Object.getOwnPropertySymbols == "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++)
    e2.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]) && (t2[p[i]] = s[p[i]]);
  return t2;
};
const InternalTooltip = /* @__PURE__ */ React.forwardRef((props, ref) => {
  var _a, _b;
  const {
    prefixCls: customizePrefixCls,
    openClassName,
    getTooltipContainer,
    overlayClassName,
    color,
    overlayInnerStyle,
    children,
    afterOpenChange,
    afterVisibleChange,
    destroyTooltipOnHide,
    arrow = !0,
    title: title2,
    overlay: overlay2,
    builtinPlacements,
    arrowPointAtCenter = !1,
    autoAdjustOverflow: autoAdjustOverflow2 = !0
  } = props, mergedShowArrow = !!arrow, [, token2] = useToken(), {
    getPopupContainer: getContextPopupContainer,
    getPrefixCls,
    direction
  } = React.useContext(ConfigContext), warning3 = devUseWarning("Tooltip"), tooltipRef = React.useRef(null), forceAlign = /* @__PURE__ */ __name(() => {
    var _a2;
    (_a2 = tooltipRef.current) === null || _a2 === void 0 || _a2.forceAlign();
  }, "forceAlign");
  React.useImperativeHandle(ref, () => {
    var _a2;
    return {
      forceAlign,
      forcePopupAlign: /* @__PURE__ */ __name(() => {
        warning3.deprecated(!1, "forcePopupAlign", "forceAlign"), forceAlign();
      }, "forcePopupAlign"),
      nativeElement: (_a2 = tooltipRef.current) === null || _a2 === void 0 ? void 0 : _a2.nativeElement
    };
  }), process.env.NODE_ENV !== "production" && ([["visible", "open"], ["defaultVisible", "defaultOpen"], ["onVisibleChange", "onOpenChange"], ["afterVisibleChange", "afterOpenChange"], ["arrowPointAtCenter", "arrow={{ pointAtCenter: true }}"]].forEach((_ref) => {
    let [deprecatedName, newName] = _ref;
    warning3.deprecated(!(deprecatedName in props), deprecatedName, newName);
  }), process.env.NODE_ENV !== "production" && warning3(!destroyTooltipOnHide || typeof destroyTooltipOnHide == "boolean", "usage", "`destroyTooltipOnHide` no need config `keepParent` anymore. Please use `boolean` value directly."), process.env.NODE_ENV !== "production" && warning3(!arrow || typeof arrow == "boolean" || !("arrowPointAtCenter" in arrow), "deprecated", "`arrowPointAtCenter` in `arrow` is deprecated. Please use `pointAtCenter` instead."));
  const [open, setOpen] = useMergedState(!1, {
    value: (_a = props.open) !== null && _a !== void 0 ? _a : props.visible,
    defaultValue: (_b = props.defaultOpen) !== null && _b !== void 0 ? _b : props.defaultVisible
  }), noTitle = !title2 && !overlay2 && title2 !== 0, onOpenChange = /* @__PURE__ */ __name((vis) => {
    var _a2, _b2;
    setOpen(noTitle ? !1 : vis), noTitle || ((_a2 = props.onOpenChange) === null || _a2 === void 0 || _a2.call(props, vis), (_b2 = props.onVisibleChange) === null || _b2 === void 0 || _b2.call(props, vis));
  }, "onOpenChange"), tooltipPlacements = React.useMemo(() => {
    var _a2, _b2;
    let mergedArrowPointAtCenter = arrowPointAtCenter;
    return typeof arrow == "object" && (mergedArrowPointAtCenter = (_b2 = (_a2 = arrow.pointAtCenter) !== null && _a2 !== void 0 ? _a2 : arrow.arrowPointAtCenter) !== null && _b2 !== void 0 ? _b2 : arrowPointAtCenter), builtinPlacements || getPlacements({
      arrowPointAtCenter: mergedArrowPointAtCenter,
      autoAdjustOverflow: autoAdjustOverflow2,
      arrowWidth: mergedShowArrow ? token2.sizePopupArrow : 0,
      borderRadius: token2.borderRadius,
      offset: token2.marginXXS,
      visibleFirst: !0
    });
  }, [arrowPointAtCenter, arrow, builtinPlacements, token2]), memoOverlay = React.useMemo(() => title2 === 0 ? title2 : overlay2 || title2 || "", [overlay2, title2]), memoOverlayWrapper = /* @__PURE__ */ React.createElement(ContextIsolator, {
    space: !0
  }, typeof memoOverlay == "function" ? memoOverlay() : memoOverlay), {
    getPopupContainer,
    placement = "top",
    mouseEnterDelay = 0.1,
    mouseLeaveDelay = 0.1,
    overlayStyle,
    rootClassName
  } = props, otherProps = __rest$O(props, ["getPopupContainer", "placement", "mouseEnterDelay", "mouseLeaveDelay", "overlayStyle", "rootClassName"]), prefixCls = getPrefixCls("tooltip", customizePrefixCls), rootPrefixCls = getPrefixCls(), injectFromPopover = props["data-popover-inject"];
  let tempOpen = open;
  !("open" in props) && !("visible" in props) && noTitle && (tempOpen = !1);
  const child = /* @__PURE__ */ React.isValidElement(children) && !isFragment(children) ? children : /* @__PURE__ */ React.createElement("span", null, children), childProps = child.props, childCls = !childProps.className || typeof childProps.className == "string" ? cn(childProps.className, openClassName || `${prefixCls}-open`) : childProps.className, [wrapCSSVar, hashId, cssVarCls] = useStyle$p(prefixCls, !injectFromPopover), colorInfo = parseColor(prefixCls, color), arrowContentStyle = colorInfo.arrowStyle, formattedOverlayInnerStyle = Object.assign(Object.assign({}, overlayInnerStyle), colorInfo.overlayStyle), customOverlayClassName = cn(overlayClassName, {
    [`${prefixCls}-rtl`]: direction === "rtl"
  }, colorInfo.className, rootClassName, hashId, cssVarCls), [zIndex, contextZIndex] = useZIndex("Tooltip", otherProps.zIndex), content = /* @__PURE__ */ React.createElement(Tooltip$3, Object.assign({}, otherProps, {
    zIndex,
    showArrow: mergedShowArrow,
    placement,
    mouseEnterDelay,
    mouseLeaveDelay,
    prefixCls,
    overlayClassName: customOverlayClassName,
    overlayStyle: Object.assign(Object.assign({}, arrowContentStyle), overlayStyle),
    getTooltipContainer: getPopupContainer || getTooltipContainer || getContextPopupContainer,
    ref: tooltipRef,
    builtinPlacements: tooltipPlacements,
    overlay: memoOverlayWrapper,
    visible: tempOpen,
    onVisibleChange: onOpenChange,
    afterVisibleChange: afterOpenChange ?? afterVisibleChange,
    overlayInnerStyle: formattedOverlayInnerStyle,
    arrowContent: /* @__PURE__ */ React.createElement("span", {
      className: `${prefixCls}-arrow-content`
    }),
    motion: {
      motionName: getTransitionName(rootPrefixCls, "zoom-big-fast", props.transitionName),
      motionDeadline: 1e3
    },
    destroyTooltipOnHide: !!destroyTooltipOnHide
  }), tempOpen ? cloneElement(child, {
    className: childCls
  }) : child);
  return wrapCSSVar(/* @__PURE__ */ React.createElement(zIndexContext.Provider, {
    value: contextZIndex
  }, content));
}), Tooltip$1 = InternalTooltip;
process.env.NODE_ENV !== "production" && (Tooltip$1.displayName = "Tooltip");
Tooltip$1._InternalPanelDoNotUseOrYouWillBeFired = PurePanel$4;
const genBaseStyle$4 = /* @__PURE__ */ __name((token2) => {
  const {
    componentCls,
    popoverColor,
    titleMinWidth,
    fontWeightStrong,
    innerPadding,
    boxShadowSecondary,
    colorTextHeading,
    borderRadiusLG,
    zIndexPopup,
    titleMarginBottom,
    colorBgElevated,
    popoverBg,
    titleBorderBottom,
    innerContentPadding,
    titlePadding
  } = token2;
  return [
    {
      [componentCls]: Object.assign(Object.assign({}, resetComponent(token2)), {
        position: "absolute",
        top: 0,
        // use `left` to fix https://github.com/ant-design/ant-design/issues/39195
        left: {
          _skip_check_: !0,
          value: 0
        },
        zIndex: zIndexPopup,
        fontWeight: "normal",
        whiteSpace: "normal",
        textAlign: "start",
        cursor: "auto",
        userSelect: "text",
        // When use `autoArrow`, origin will follow the arrow position
        "--valid-offset-x": "var(--arrow-offset-horizontal, var(--arrow-x))",
        transformOrigin: ["var(--valid-offset-x, 50%)", "var(--arrow-y, 50%)"].join(" "),
        "--antd-arrow-background-color": colorBgElevated,
        width: "max-content",
        maxWidth: "100vw",
        "&-rtl": {
          direction: "rtl"
        },
        "&-hidden": {
          display: "none"
        },
        [`${componentCls}-content`]: {
          position: "relative"
        },
        [`${componentCls}-inner`]: {
          backgroundColor: popoverBg,
          backgroundClip: "padding-box",
          borderRadius: borderRadiusLG,
          boxShadow: boxShadowSecondary,
          padding: innerPadding
        },
        [`${componentCls}-title`]: {
          minWidth: titleMinWidth,
          marginBottom: titleMarginBottom,
          color: colorTextHeading,
          fontWeight: fontWeightStrong,
          borderBottom: titleBorderBottom,
          padding: titlePadding
        },
        [`${componentCls}-inner-content`]: {
          color: popoverColor,
          padding: innerContentPadding
        }
      })
    },
    // Arrow Style
    getArrowStyle(token2, "var(--antd-arrow-background-color)"),
    // Pure Render
    {
      [`${componentCls}-pure`]: {
        position: "relative",
        maxWidth: "none",
        margin: token2.sizePopupArrow,
        display: "inline-block",
        [`${componentCls}-content`]: {
          display: "inline-block"
        }
      }
    }
  ];
}, "genBaseStyle$4"), genColorStyle = /* @__PURE__ */ __name((token2) => {
  const {
    componentCls
  } = token2;
  return {
    [componentCls]: PresetColors.map((colorKey) => {
      const lightColor = token2[`${colorKey}6`];
      return {
        [`&${componentCls}-${colorKey}`]: {
          "--antd-arrow-background-color": lightColor,
          [`${componentCls}-inner`]: {
            backgroundColor: lightColor
          },
          [`${componentCls}-arrow`]: {
            background: "transparent"
          }
        }
      };
    })
  };
}, "genColorStyle"), prepareComponentToken$j = /* @__PURE__ */ __name((token2) => {
  const {
    lineWidth,
    controlHeight,
    fontHeight,
    padding,
    wireframe,
    zIndexPopupBase,
    borderRadiusLG,
    marginXS,
    lineType,
    colorSplit,
    paddingSM
  } = token2, titlePaddingBlockDist = controlHeight - fontHeight, popoverTitlePaddingBlockTop = titlePaddingBlockDist / 2, popoverTitlePaddingBlockBottom = titlePaddingBlockDist / 2 - lineWidth, popoverPaddingHorizontal = padding;
  return Object.assign(Object.assign(Object.assign({
    titleMinWidth: 177,
    zIndexPopup: zIndexPopupBase + 30
  }, getArrowToken(token2)), getArrowOffsetToken({
    contentRadius: borderRadiusLG,
    limitVerticalRadius: !0
  })), {
    // internal
    innerPadding: wireframe ? 0 : 12,
    titleMarginBottom: wireframe ? 0 : marginXS,
    titlePadding: wireframe ? `${popoverTitlePaddingBlockTop}px ${popoverPaddingHorizontal}px ${popoverTitlePaddingBlockBottom}px` : 0,
    titleBorderBottom: wireframe ? `${lineWidth}px ${lineType} ${colorSplit}` : "none",
    innerContentPadding: wireframe ? `${paddingSM}px ${popoverPaddingHorizontal}px` : 0
  });
}, "prepareComponentToken$j"), useStyle$o = genStyleHooks("Popover", (token2) => {
  const {
    colorBgElevated,
    colorText
  } = token2, popoverToken = merge(token2, {
    popoverBg: colorBgElevated,
    popoverColor: colorText
  });
  return [genBaseStyle$4(popoverToken), genColorStyle(popoverToken), initZoomMotion(popoverToken, "zoom-big")];
}, prepareComponentToken$j, {
  resetStyle: !1,
  deprecatedTokens: [["width", "titleMinWidth"], ["minWidth", "titleMinWidth"]]
});
var __rest$N = function(s, e2) {
  var t2 = {};
  for (var p in s) Object.prototype.hasOwnProperty.call(s, p) && e2.indexOf(p) < 0 && (t2[p] = s[p]);
  if (s != null && typeof Object.getOwnPropertySymbols == "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++)
    e2.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]) && (t2[p[i]] = s[p[i]]);
  return t2;
};
const Overlay$1 = /* @__PURE__ */ __name((_ref) => {
  let {
    title: title2,
    content,
    prefixCls
  } = _ref;
  return !title2 && !content ? null : /* @__PURE__ */ React.createElement(React.Fragment, null, title2 && /* @__PURE__ */ React.createElement("div", {
    className: `${prefixCls}-title`
  }, title2), content && /* @__PURE__ */ React.createElement("div", {
    className: `${prefixCls}-inner-content`
  }, content));
}, "Overlay$1"), RawPurePanel = /* @__PURE__ */ __name((props) => {
  const {
    hashId,
    prefixCls,
    className,
    style: style2,
    placement = "top",
    title: title2,
    content,
    children
  } = props, titleNode = getRenderPropValue(title2), contentNode = getRenderPropValue(content), cls = cn(hashId, prefixCls, `${prefixCls}-pure`, `${prefixCls}-placement-${placement}`, className);
  return /* @__PURE__ */ React.createElement("div", {
    className: cls,
    style: style2
  }, /* @__PURE__ */ React.createElement("div", {
    className: `${prefixCls}-arrow`
  }), /* @__PURE__ */ React.createElement(Popup$1, Object.assign({}, props, {
    className: hashId,
    prefixCls
  }), children || /* @__PURE__ */ React.createElement(Overlay$1, {
    prefixCls,
    title: titleNode,
    content: contentNode
  })));
}, "RawPurePanel"), PurePanel$3 = /* @__PURE__ */ __name((props) => {
  const {
    prefixCls: customizePrefixCls,
    className
  } = props, restProps = __rest$N(props, ["prefixCls", "className"]), {
    getPrefixCls
  } = React.useContext(ConfigContext), prefixCls = getPrefixCls("popover", customizePrefixCls), [wrapCSSVar, hashId, cssVarCls] = useStyle$o(prefixCls);
  return wrapCSSVar(/* @__PURE__ */ React.createElement(RawPurePanel, Object.assign({}, restProps, {
    prefixCls,
    hashId,
    className: cn(className, cssVarCls)
  })));
}, "PurePanel$3");
var __rest$M = function(s, e2) {
  var t2 = {};
  for (var p in s) Object.prototype.hasOwnProperty.call(s, p) && e2.indexOf(p) < 0 && (t2[p] = s[p]);
  if (s != null && typeof Object.getOwnPropertySymbols == "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++)
    e2.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]) && (t2[p[i]] = s[p[i]]);
  return t2;
};
const InternalPopover = /* @__PURE__ */ React.forwardRef((props, ref) => {
  var _a, _b;
  const {
    prefixCls: customizePrefixCls,
    title: title2,
    content,
    overlayClassName,
    placement = "top",
    trigger = "hover",
    children,
    mouseEnterDelay = 0.1,
    mouseLeaveDelay = 0.1,
    onOpenChange,
    overlayStyle = {}
  } = props, otherProps = __rest$M(props, ["prefixCls", "title", "content", "overlayClassName", "placement", "trigger", "children", "mouseEnterDelay", "mouseLeaveDelay", "onOpenChange", "overlayStyle"]), {
    getPrefixCls
  } = React.useContext(ConfigContext), prefixCls = getPrefixCls("popover", customizePrefixCls), [wrapCSSVar, hashId, cssVarCls] = useStyle$o(prefixCls), rootPrefixCls = getPrefixCls(), overlayCls = cn(overlayClassName, hashId, cssVarCls), [open, setOpen] = useMergedState(!1, {
    value: (_a = props.open) !== null && _a !== void 0 ? _a : props.visible,
    defaultValue: (_b = props.defaultOpen) !== null && _b !== void 0 ? _b : props.defaultVisible
  }), settingOpen = /* @__PURE__ */ __name((value, e2) => {
    setOpen(value, !0), onOpenChange == null || onOpenChange(value, e2);
  }, "settingOpen"), onKeyDown2 = /* @__PURE__ */ __name((e2) => {
    e2.keyCode === KeyCode.ESC && settingOpen(!1, e2);
  }, "onKeyDown"), onInternalOpenChange = /* @__PURE__ */ __name((value) => {
    settingOpen(value);
  }, "onInternalOpenChange"), titleNode = getRenderPropValue(title2), contentNode = getRenderPropValue(content);
  return wrapCSSVar(/* @__PURE__ */ React.createElement(Tooltip$1, Object.assign({
    placement,
    trigger,
    mouseEnterDelay,
    mouseLeaveDelay,
    overlayStyle
  }, otherProps, {
    prefixCls,
    overlayClassName: overlayCls,
    ref,
    open,
    onOpenChange: onInternalOpenChange,
    overlay: titleNode || contentNode ? /* @__PURE__ */ React.createElement(Overlay$1, {
      prefixCls,
      title: titleNode,
      content: contentNode
    }) : null,
    transitionName: getTransitionName(rootPrefixCls, "zoom-big", otherProps.transitionName),
    "data-popover-inject": !0
  }), cloneElement(children, {
    onKeyDown: /* @__PURE__ */ __name((e2) => {
      var _a2, _b2;
      /* @__PURE__ */ React.isValidElement(children) && ((_b2 = children == null ? void 0 : (_a2 = children.props).onKeyDown) === null || _b2 === void 0 || _b2.call(_a2, e2)), onKeyDown2(e2);
    }, "onKeyDown")
  })));
}), Popover$1 = InternalPopover;
Popover$1._InternalPanelDoNotUseOrYouWillBeFired = PurePanel$3;
process.env.NODE_ENV !== "production" && (Popover$1.displayName = "Popover");
const antStatusProcessing = new Keyframe("antStatusProcessing", {
  "0%": {
    transform: "scale(0.8)",
    opacity: 0.5
  },
  "100%": {
    transform: "scale(2.4)",
    opacity: 0
  }
}), antZoomBadgeIn = new Keyframe("antZoomBadgeIn", {
  "0%": {
    transform: "scale(0) translate(50%, -50%)",
    opacity: 0
  },
  "100%": {
    transform: "scale(1) translate(50%, -50%)"
  }
}), antZoomBadgeOut = new Keyframe("antZoomBadgeOut", {
  "0%": {
    transform: "scale(1) translate(50%, -50%)"
  },
  "100%": {
    transform: "scale(0) translate(50%, -50%)",
    opacity: 0
  }
}), antNoWrapperZoomBadgeIn = new Keyframe("antNoWrapperZoomBadgeIn", {
  "0%": {
    transform: "scale(0)",
    opacity: 0
  },
  "100%": {
    transform: "scale(1)"
  }
}), antNoWrapperZoomBadgeOut = new Keyframe("antNoWrapperZoomBadgeOut", {
  "0%": {
    transform: "scale(1)"
  },
  "100%": {
    transform: "scale(0)",
    opacity: 0
  }
}), antBadgeLoadingCircle = new Keyframe("antBadgeLoadingCircle", {
  "0%": {
    transformOrigin: "50%"
  },
  "100%": {
    transform: "translate(50%, -50%) rotate(360deg)",
    transformOrigin: "50%"
  }
}), genSharedBadgeStyle = /* @__PURE__ */ __name((token2) => {
  const {
    componentCls,
    iconCls,
    antCls,
    badgeShadowSize,
    textFontSize,
    textFontSizeSM,
    statusSize,
    dotSize,
    textFontWeight,
    indicatorHeight,
    indicatorHeightSM,
    marginXS,
    calc
  } = token2, numberPrefixCls = `${antCls}-scroll-number`, colorPreset = genPresetColor(token2, (colorKey, _ref) => {
    let {
      darkColor
    } = _ref;
    return {
      [`&${componentCls} ${componentCls}-color-${colorKey}`]: {
        background: darkColor,
        [`&:not(${componentCls}-count)`]: {
          color: darkColor
        },
        "a:hover &": {
          background: darkColor
        }
      }
    };
  });
  return {
    [componentCls]: Object.assign(Object.assign(Object.assign(Object.assign({}, resetComponent(token2)), {
      position: "relative",
      display: "inline-block",
      width: "fit-content",
      lineHeight: 1,
      [`${componentCls}-count`]: {
        display: "inline-flex",
        justifyContent: "center",
        zIndex: token2.indicatorZIndex,
        minWidth: indicatorHeight,
        height: indicatorHeight,
        color: token2.badgeTextColor,
        fontWeight: textFontWeight,
        fontSize: textFontSize,
        lineHeight: unit$1(indicatorHeight),
        whiteSpace: "nowrap",
        textAlign: "center",
        background: token2.badgeColor,
        borderRadius: calc(indicatorHeight).div(2).equal(),
        boxShadow: `0 0 0 ${unit$1(badgeShadowSize)} ${token2.badgeShadowColor}`,
        transition: `background ${token2.motionDurationMid}`,
        a: {
          color: token2.badgeTextColor
        },
        "a:hover": {
          color: token2.badgeTextColor
        },
        "a:hover &": {
          background: token2.badgeColorHover
        }
      },
      [`${componentCls}-count-sm`]: {
        minWidth: indicatorHeightSM,
        height: indicatorHeightSM,
        fontSize: textFontSizeSM,
        lineHeight: unit$1(indicatorHeightSM),
        borderRadius: calc(indicatorHeightSM).div(2).equal()
      },
      [`${componentCls}-multiple-words`]: {
        padding: `0 ${unit$1(token2.paddingXS)}`,
        bdi: {
          unicodeBidi: "plaintext"
        }
      },
      [`${componentCls}-dot`]: {
        zIndex: token2.indicatorZIndex,
        width: dotSize,
        minWidth: dotSize,
        height: dotSize,
        background: token2.badgeColor,
        borderRadius: "100%",
        boxShadow: `0 0 0 ${unit$1(badgeShadowSize)} ${token2.badgeShadowColor}`
      },
      [`${componentCls}-count, ${componentCls}-dot, ${numberPrefixCls}-custom-component`]: {
        position: "absolute",
        top: 0,
        insetInlineEnd: 0,
        transform: "translate(50%, -50%)",
        transformOrigin: "100% 0%",
        [`&${iconCls}-spin`]: {
          animationName: antBadgeLoadingCircle,
          animationDuration: "1s",
          animationIterationCount: "infinite",
          animationTimingFunction: "linear"
        }
      },
      [`&${componentCls}-status`]: {
        lineHeight: "inherit",
        verticalAlign: "baseline",
        [`${componentCls}-status-dot`]: {
          position: "relative",
          top: -1,
          // Magic number, but seems better experience
          display: "inline-block",
          width: statusSize,
          height: statusSize,
          verticalAlign: "middle",
          borderRadius: "50%"
        },
        [`${componentCls}-status-success`]: {
          backgroundColor: token2.colorSuccess
        },
        [`${componentCls}-status-processing`]: {
          overflow: "visible",
          color: token2.colorInfo,
          backgroundColor: token2.colorInfo,
          borderColor: "currentcolor",
          "&::after": {
            position: "absolute",
            top: 0,
            insetInlineStart: 0,
            width: "100%",
            height: "100%",
            borderWidth: badgeShadowSize,
            borderStyle: "solid",
            borderColor: "inherit",
            borderRadius: "50%",
            animationName: antStatusProcessing,
            animationDuration: token2.badgeProcessingDuration,
            animationIterationCount: "infinite",
            animationTimingFunction: "ease-in-out",
            content: '""'
          }
        },
        [`${componentCls}-status-default`]: {
          backgroundColor: token2.colorTextPlaceholder
        },
        [`${componentCls}-status-error`]: {
          backgroundColor: token2.colorError
        },
        [`${componentCls}-status-warning`]: {
          backgroundColor: token2.colorWarning
        },
        [`${componentCls}-status-text`]: {
          marginInlineStart: marginXS,
          color: token2.colorText,
          fontSize: token2.fontSize
        }
      }
    }), colorPreset), {
      [`${componentCls}-zoom-appear, ${componentCls}-zoom-enter`]: {
        animationName: antZoomBadgeIn,
        animationDuration: token2.motionDurationSlow,
        animationTimingFunction: token2.motionEaseOutBack,
        animationFillMode: "both"
      },
      [`${componentCls}-zoom-leave`]: {
        animationName: antZoomBadgeOut,
        animationDuration: token2.motionDurationSlow,
        animationTimingFunction: token2.motionEaseOutBack,
        animationFillMode: "both"
      },
      [`&${componentCls}-not-a-wrapper`]: {
        [`${componentCls}-zoom-appear, ${componentCls}-zoom-enter`]: {
          animationName: antNoWrapperZoomBadgeIn,
          animationDuration: token2.motionDurationSlow,
          animationTimingFunction: token2.motionEaseOutBack
        },
        [`${componentCls}-zoom-leave`]: {
          animationName: antNoWrapperZoomBadgeOut,
          animationDuration: token2.motionDurationSlow,
          animationTimingFunction: token2.motionEaseOutBack
        },
        [`&:not(${componentCls}-status)`]: {
          verticalAlign: "middle"
        },
        [`${numberPrefixCls}-custom-component, ${componentCls}-count`]: {
          transform: "none"
        },
        [`${numberPrefixCls}-custom-component, ${numberPrefixCls}`]: {
          position: "relative",
          top: "auto",
          display: "block",
          transformOrigin: "50% 50%"
        }
      },
      [numberPrefixCls]: {
        overflow: "hidden",
        transition: `all ${token2.motionDurationMid} ${token2.motionEaseOutBack}`,
        [`${numberPrefixCls}-only`]: {
          position: "relative",
          display: "inline-block",
          height: indicatorHeight,
          transition: `all ${token2.motionDurationSlow} ${token2.motionEaseOutBack}`,
          WebkitTransformStyle: "preserve-3d",
          WebkitBackfaceVisibility: "hidden",
          [`> p${numberPrefixCls}-only-unit`]: {
            height: indicatorHeight,
            margin: 0,
            WebkitTransformStyle: "preserve-3d",
            WebkitBackfaceVisibility: "hidden"
          }
        },
        [`${numberPrefixCls}-symbol`]: {
          verticalAlign: "top"
        }
      },
      // ====================== RTL =======================
      "&-rtl": {
        direction: "rtl",
        [`${componentCls}-count, ${componentCls}-dot, ${numberPrefixCls}-custom-component`]: {
          transform: "translate(-50%, -50%)"
        }
      }
    })
  };
}, "genSharedBadgeStyle"), prepareToken$2 = /* @__PURE__ */ __name((token2) => {
  const {
    fontHeight,
    lineWidth,
    marginXS,
    colorBorderBg
  } = token2, badgeFontHeight = fontHeight, badgeShadowSize = lineWidth, badgeTextColor = token2.colorTextLightSolid, badgeColor = token2.colorError, badgeColorHover = token2.colorErrorHover;
  return merge(token2, {
    badgeFontHeight,
    badgeShadowSize,
    badgeTextColor,
    badgeColor,
    badgeColorHover,
    badgeShadowColor: colorBorderBg,
    badgeProcessingDuration: "1.2s",
    badgeRibbonOffset: marginXS,
    // Follow token just by Design. Not related with token
    badgeRibbonCornerTransform: "scaleY(0.75)",
    badgeRibbonCornerFilter: "brightness(75%)"
  });
}, "prepareToken$2"), prepareComponentToken$i = /* @__PURE__ */ __name((token2) => {
  const {
    fontSize,
    lineHeight,
    fontSizeSM,
    lineWidth
  } = token2;
  return {
    indicatorZIndex: "auto",
    indicatorHeight: Math.round(fontSize * lineHeight) - 2 * lineWidth,
    indicatorHeightSM: fontSize,
    dotSize: fontSizeSM / 2,
    textFontSize: fontSizeSM,
    textFontSizeSM: fontSizeSM,
    textFontWeight: "normal",
    statusSize: fontSizeSM / 2
  };
}, "prepareComponentToken$i"), useStyle$n = genStyleHooks("Badge", (token2) => {
  const badgeToken = prepareToken$2(token2);
  return genSharedBadgeStyle(badgeToken);
}, prepareComponentToken$i), genRibbonStyle = /* @__PURE__ */ __name((token2) => {
  const {
    antCls,
    badgeFontHeight,
    marginXS,
    badgeRibbonOffset,
    calc
  } = token2, ribbonPrefixCls = `${antCls}-ribbon`, ribbonWrapperPrefixCls = `${antCls}-ribbon-wrapper`, statusRibbonPreset = genPresetColor(token2, (colorKey, _ref) => {
    let {
      darkColor
    } = _ref;
    return {
      [`&${ribbonPrefixCls}-color-${colorKey}`]: {
        background: darkColor,
        color: darkColor
      }
    };
  });
  return {
    [ribbonWrapperPrefixCls]: {
      position: "relative"
    },
    [ribbonPrefixCls]: Object.assign(Object.assign(Object.assign(Object.assign({}, resetComponent(token2)), {
      position: "absolute",
      top: marginXS,
      padding: `0 ${unit$1(token2.paddingXS)}`,
      color: token2.colorPrimary,
      lineHeight: unit$1(badgeFontHeight),
      whiteSpace: "nowrap",
      backgroundColor: token2.colorPrimary,
      borderRadius: token2.borderRadiusSM,
      [`${ribbonPrefixCls}-text`]: {
        color: token2.badgeTextColor
      },
      [`${ribbonPrefixCls}-corner`]: {
        position: "absolute",
        top: "100%",
        width: badgeRibbonOffset,
        height: badgeRibbonOffset,
        color: "currentcolor",
        border: `${unit$1(calc(badgeRibbonOffset).div(2).equal())} solid`,
        transform: token2.badgeRibbonCornerTransform,
        transformOrigin: "top",
        filter: token2.badgeRibbonCornerFilter
      }
    }), statusRibbonPreset), {
      [`&${ribbonPrefixCls}-placement-end`]: {
        insetInlineEnd: calc(badgeRibbonOffset).mul(-1).equal(),
        borderEndEndRadius: 0,
        [`${ribbonPrefixCls}-corner`]: {
          insetInlineEnd: 0,
          borderInlineEndColor: "transparent",
          borderBlockEndColor: "transparent"
        }
      },
      [`&${ribbonPrefixCls}-placement-start`]: {
        insetInlineStart: calc(badgeRibbonOffset).mul(-1).equal(),
        borderEndStartRadius: 0,
        [`${ribbonPrefixCls}-corner`]: {
          insetInlineStart: 0,
          borderBlockEndColor: "transparent",
          borderInlineStartColor: "transparent"
        }
      },
      // ====================== RTL =======================
      "&-rtl": {
        direction: "rtl"
      }
    })
  };
}, "genRibbonStyle"), useStyle$m = genStyleHooks(["Badge", "Ribbon"], (token2) => {
  const badgeToken = prepareToken$2(token2);
  return genRibbonStyle(badgeToken);
}, prepareComponentToken$i), Ribbon = /* @__PURE__ */ __name((props) => {
  const {
    className,
    prefixCls: customizePrefixCls,
    style: style2,
    color,
    children,
    text,
    placement = "end",
    rootClassName
  } = props, {
    getPrefixCls,
    direction
  } = React.useContext(ConfigContext), prefixCls = getPrefixCls("ribbon", customizePrefixCls), wrapperCls = `${prefixCls}-wrapper`, [wrapCSSVar, hashId, cssVarCls] = useStyle$m(prefixCls, wrapperCls), colorInPreset = isPresetColor(color, !1), ribbonCls = cn(prefixCls, `${prefixCls}-placement-${placement}`, {
    [`${prefixCls}-rtl`]: direction === "rtl",
    [`${prefixCls}-color-${color}`]: colorInPreset
  }, className), colorStyle = {}, cornerColorStyle = {};
  return color && !colorInPreset && (colorStyle.background = color, cornerColorStyle.color = color), wrapCSSVar(/* @__PURE__ */ React.createElement("div", {
    className: cn(wrapperCls, rootClassName, hashId, cssVarCls)
  }, children, /* @__PURE__ */ React.createElement("div", {
    className: cn(ribbonCls, hashId),
    style: Object.assign(Object.assign({}, colorStyle), style2)
  }, /* @__PURE__ */ React.createElement("span", {
    className: `${prefixCls}-text`
  }, text), /* @__PURE__ */ React.createElement("div", {
    className: `${prefixCls}-corner`,
    style: cornerColorStyle
  }))));
}, "Ribbon");
process.env.NODE_ENV !== "production" && (Ribbon.displayName = "Ribbon");
const UnitNumber = /* @__PURE__ */ __name((props) => {
  const {
    prefixCls,
    value,
    current,
    offset: offset2 = 0
  } = props;
  let style2;
  return offset2 && (style2 = {
    position: "absolute",
    top: `${offset2}00%`,
    left: 0
  }), /* @__PURE__ */ React.createElement("span", {
    style: style2,
    className: cn(`${prefixCls}-only-unit`, {
      current
    })
  }, value);
}, "UnitNumber");
function getOffset$2(start, end, unit2) {
  let index2 = start, offset2 = 0;
  for (; (index2 + 10) % 10 !== end; )
    index2 += unit2, offset2 += unit2;
  return offset2;
}
__name(getOffset$2, "getOffset$2");
const SingleNumber = /* @__PURE__ */ __name((props) => {
  const {
    prefixCls,
    count: originCount,
    value: originValue
  } = props, value = Number(originValue), count = Math.abs(originCount), [prevValue, setPrevValue] = React.useState(value), [prevCount, setPrevCount] = React.useState(count), onTransitionEnd = /* @__PURE__ */ __name(() => {
    setPrevValue(value), setPrevCount(count);
  }, "onTransitionEnd");
  React.useEffect(() => {
    const timer = setTimeout(onTransitionEnd, 1e3);
    return () => clearTimeout(timer);
  }, [value]);
  let unitNodes, offsetStyle;
  if (prevValue === value || Number.isNaN(value) || Number.isNaN(prevValue))
    unitNodes = [/* @__PURE__ */ React.createElement(UnitNumber, Object.assign({}, props, {
      key: value,
      current: !0
    }))], offsetStyle = {
      transition: "none"
    };
  else {
    unitNodes = [];
    const end = value + 10, unitNumberList = [];
    for (let index2 = value; index2 <= end; index2 += 1)
      unitNumberList.push(index2);
    const unit2 = prevCount < count ? 1 : -1, prevIndex = unitNumberList.findIndex((n2) => n2 % 10 === prevValue);
    unitNodes = (unit2 < 0 ? unitNumberList.slice(0, prevIndex + 1) : unitNumberList.slice(prevIndex)).map((n2, index2) => {
      const singleUnit = n2 % 10;
      return /* @__PURE__ */ React.createElement(UnitNumber, Object.assign({}, props, {
        key: n2,
        value: singleUnit,
        offset: unit2 < 0 ? index2 - prevIndex : index2,
        current: index2 === prevIndex
      }));
    }), offsetStyle = {
      transform: `translateY(${-getOffset$2(prevValue, value, unit2)}00%)`
    };
  }
  return /* @__PURE__ */ React.createElement("span", {
    className: `${prefixCls}-only`,
    style: offsetStyle,
    onTransitionEnd
  }, unitNodes);
}, "SingleNumber");
var __rest$L = function(s, e2) {
  var t2 = {};
  for (var p in s) Object.prototype.hasOwnProperty.call(s, p) && e2.indexOf(p) < 0 && (t2[p] = s[p]);
  if (s != null && typeof Object.getOwnPropertySymbols == "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++)
    e2.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]) && (t2[p[i]] = s[p[i]]);
  return t2;
};
const ScrollNumber = /* @__PURE__ */ React.forwardRef((props, ref) => {
  const {
    prefixCls: customizePrefixCls,
    count,
    className,
    motionClassName,
    style: style2,
    title: title2,
    show,
    component: Component2 = "sup",
    children
  } = props, restProps = __rest$L(props, ["prefixCls", "count", "className", "motionClassName", "style", "title", "show", "component", "children"]), {
    getPrefixCls
  } = React.useContext(ConfigContext), prefixCls = getPrefixCls("scroll-number", customizePrefixCls), newProps = Object.assign(Object.assign({}, restProps), {
    "data-show": show,
    style: style2,
    className: cn(prefixCls, className, motionClassName),
    title: title2
  });
  let numberNodes = count;
  if (count && Number(count) % 1 === 0) {
    const numberList = String(count).split("");
    numberNodes = /* @__PURE__ */ React.createElement("bdi", null, numberList.map((num, i) => /* @__PURE__ */ React.createElement(SingleNumber, {
      prefixCls,
      count: Number(count),
      value: num,
      // eslint-disable-next-line react/no-array-index-key
      key: numberList.length - i
    })));
  }
  return style2 != null && style2.borderColor && (newProps.style = Object.assign(Object.assign({}, style2), {
    boxShadow: `0 0 0 1px ${style2.borderColor} inset`
  })), children ? cloneElement(children, (oriProps) => ({
    className: cn(`${prefixCls}-custom-component`, oriProps == null ? void 0 : oriProps.className, motionClassName)
  })) : /* @__PURE__ */ React.createElement(Component2, Object.assign({}, newProps, {
    ref
  }), numberNodes);
});
var __rest$K = function(s, e2) {
  var t2 = {};
  for (var p in s) Object.prototype.hasOwnProperty.call(s, p) && e2.indexOf(p) < 0 && (t2[p] = s[p]);
  if (s != null && typeof Object.getOwnPropertySymbols == "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++)
    e2.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]) && (t2[p[i]] = s[p[i]]);
  return t2;
};
const InternalBadge = /* @__PURE__ */ React.forwardRef((props, ref) => {
  var _a, _b, _c, _d, _e;
  const {
    prefixCls: customizePrefixCls,
    scrollNumberPrefixCls: customizeScrollNumberPrefixCls,
    children,
    status,
    text,
    color,
    count = null,
    overflowCount = 99,
    dot = !1,
    size = "default",
    title: title2,
    offset: offset2,
    style: style2,
    className,
    rootClassName,
    classNames,
    styles: styles2,
    showZero = !1
  } = props, restProps = __rest$K(props, ["prefixCls", "scrollNumberPrefixCls", "children", "status", "text", "color", "count", "overflowCount", "dot", "size", "title", "offset", "style", "className", "rootClassName", "classNames", "styles", "showZero"]), {
    getPrefixCls,
    direction,
    badge
  } = React.useContext(ConfigContext), prefixCls = getPrefixCls("badge", customizePrefixCls), [wrapCSSVar, hashId, cssVarCls] = useStyle$n(prefixCls), numberedDisplayCount = count > overflowCount ? `${overflowCount}+` : count, isZero = numberedDisplayCount === "0" || numberedDisplayCount === 0, ignoreCount = count === null || isZero && !showZero, hasStatus = (status != null || color != null) && ignoreCount, showAsDot = dot && !isZero, mergedCount = showAsDot ? "" : numberedDisplayCount, isHidden = useMemo$1(() => (mergedCount == null || mergedCount === "" || isZero && !showZero) && !showAsDot, [mergedCount, isZero, showZero, showAsDot]), countRef = useRef(count);
  isHidden || (countRef.current = count);
  const livingCount = countRef.current, displayCountRef = useRef(mergedCount);
  isHidden || (displayCountRef.current = mergedCount);
  const displayCount = displayCountRef.current, isDotRef = useRef(showAsDot);
  isHidden || (isDotRef.current = showAsDot);
  const mergedStyle = useMemo$1(() => {
    if (!offset2)
      return Object.assign(Object.assign({}, badge == null ? void 0 : badge.style), style2);
    const offsetStyle = {
      marginTop: offset2[1]
    };
    return direction === "rtl" ? offsetStyle.left = parseInt(offset2[0], 10) : offsetStyle.right = -parseInt(offset2[0], 10), Object.assign(Object.assign(Object.assign({}, offsetStyle), badge == null ? void 0 : badge.style), style2);
  }, [direction, offset2, style2, badge == null ? void 0 : badge.style]), titleNode = title2 ?? (typeof livingCount == "string" || typeof livingCount == "number" ? livingCount : void 0), statusTextNode = isHidden || !text ? null : /* @__PURE__ */ React.createElement("span", {
    className: `${prefixCls}-status-text`
  }, text), displayNode = !livingCount || typeof livingCount != "object" ? void 0 : cloneElement(livingCount, (oriProps) => ({
    style: Object.assign(Object.assign({}, mergedStyle), oriProps.style)
  })), isInternalColor = isPresetColor(color, !1), statusCls = cn(classNames == null ? void 0 : classNames.indicator, (_a = badge == null ? void 0 : badge.classNames) === null || _a === void 0 ? void 0 : _a.indicator, {
    [`${prefixCls}-status-dot`]: hasStatus,
    [`${prefixCls}-status-${status}`]: !!status,
    [`${prefixCls}-color-${color}`]: isInternalColor
  }), statusStyle = {};
  color && !isInternalColor && (statusStyle.color = color, statusStyle.background = color);
  const badgeClassName = cn(prefixCls, {
    [`${prefixCls}-status`]: hasStatus,
    [`${prefixCls}-not-a-wrapper`]: !children,
    [`${prefixCls}-rtl`]: direction === "rtl"
  }, className, rootClassName, badge == null ? void 0 : badge.className, (_b = badge == null ? void 0 : badge.classNames) === null || _b === void 0 ? void 0 : _b.root, classNames == null ? void 0 : classNames.root, hashId, cssVarCls);
  if (!children && hasStatus) {
    const statusTextColor = mergedStyle.color;
    return wrapCSSVar(/* @__PURE__ */ React.createElement("span", Object.assign({}, restProps, {
      className: badgeClassName,
      style: Object.assign(Object.assign(Object.assign({}, styles2 == null ? void 0 : styles2.root), (_c = badge == null ? void 0 : badge.styles) === null || _c === void 0 ? void 0 : _c.root), mergedStyle)
    }), /* @__PURE__ */ React.createElement("span", {
      className: statusCls,
      style: Object.assign(Object.assign(Object.assign({}, styles2 == null ? void 0 : styles2.indicator), (_d = badge == null ? void 0 : badge.styles) === null || _d === void 0 ? void 0 : _d.indicator), statusStyle)
    }), text && /* @__PURE__ */ React.createElement("span", {
      style: {
        color: statusTextColor
      },
      className: `${prefixCls}-status-text`
    }, text)));
  }
  return wrapCSSVar(/* @__PURE__ */ React.createElement("span", Object.assign({
    ref
  }, restProps, {
    className: badgeClassName,
    style: Object.assign(Object.assign({}, (_e = badge == null ? void 0 : badge.styles) === null || _e === void 0 ? void 0 : _e.root), styles2 == null ? void 0 : styles2.root)
  }), children, /* @__PURE__ */ React.createElement(CSSMotion, {
    visible: !isHidden,
    motionName: `${prefixCls}-zoom`,
    motionAppear: !1,
    motionDeadline: 1e3
  }, (_ref) => {
    let {
      className: motionClassName
    } = _ref;
    var _a2, _b2;
    const scrollNumberPrefixCls = getPrefixCls("scroll-number", customizeScrollNumberPrefixCls), isDot = isDotRef.current, scrollNumberCls = cn(classNames == null ? void 0 : classNames.indicator, (_a2 = badge == null ? void 0 : badge.classNames) === null || _a2 === void 0 ? void 0 : _a2.indicator, {
      [`${prefixCls}-dot`]: isDot,
      [`${prefixCls}-count`]: !isDot,
      [`${prefixCls}-count-sm`]: size === "small",
      [`${prefixCls}-multiple-words`]: !isDot && displayCount && displayCount.toString().length > 1,
      [`${prefixCls}-status-${status}`]: !!status,
      [`${prefixCls}-color-${color}`]: isInternalColor
    });
    let scrollNumberStyle = Object.assign(Object.assign(Object.assign({}, styles2 == null ? void 0 : styles2.indicator), (_b2 = badge == null ? void 0 : badge.styles) === null || _b2 === void 0 ? void 0 : _b2.indicator), mergedStyle);
    return color && !isInternalColor && (scrollNumberStyle = scrollNumberStyle || {}, scrollNumberStyle.background = color), /* @__PURE__ */ React.createElement(ScrollNumber, {
      prefixCls: scrollNumberPrefixCls,
      show: !isHidden,
      motionClassName,
      className: scrollNumberCls,
      count: displayCount,
      title: titleNode,
      style: scrollNumberStyle,
      key: "scrollNumber"
    }, displayNode);
  }), statusTextNode));
}), Badge$1 = InternalBadge;
Badge$1.Ribbon = Ribbon;
process.env.NODE_ENV !== "production" && (Badge$1.displayName = "Badge");
var ESC$1 = KeyCode.ESC, TAB = KeyCode.TAB;
function useAccessibility$1(_ref) {
  var visible = _ref.visible, triggerRef = _ref.triggerRef, onVisibleChange = _ref.onVisibleChange, autoFocus = _ref.autoFocus, overlayRef = _ref.overlayRef, focusMenuRef = React.useRef(!1), handleCloseMenuAndReturnFocus = /* @__PURE__ */ __name(function() {
    if (visible) {
      var _triggerRef$current, _triggerRef$current$f;
      (_triggerRef$current = triggerRef.current) === null || _triggerRef$current === void 0 || (_triggerRef$current$f = _triggerRef$current.focus) === null || _triggerRef$current$f === void 0 || _triggerRef$current$f.call(_triggerRef$current), onVisibleChange == null || onVisibleChange(!1);
    }
  }, "handleCloseMenuAndReturnFocus"), focusMenu = /* @__PURE__ */ __name(function() {
    var _overlayRef$current;
    return (_overlayRef$current = overlayRef.current) !== null && _overlayRef$current !== void 0 && _overlayRef$current.focus ? (overlayRef.current.focus(), focusMenuRef.current = !0, !0) : !1;
  }, "focusMenu"), handleKeyDown = /* @__PURE__ */ __name(function(event) {
    switch (event.keyCode) {
      case ESC$1:
        handleCloseMenuAndReturnFocus();
        break;
      case TAB: {
        var focusResult = !1;
        focusMenuRef.current || (focusResult = focusMenu()), focusResult ? event.preventDefault() : handleCloseMenuAndReturnFocus();
        break;
      }
    }
  }, "handleKeyDown");
  React.useEffect(function() {
    return visible ? (window.addEventListener("keydown", handleKeyDown), autoFocus && wrapperRaf(focusMenu, 3), function() {
      window.removeEventListener("keydown", handleKeyDown), focusMenuRef.current = !1;
    }) : function() {
      focusMenuRef.current = !1;
    };
  }, [visible]);
}
__name(useAccessibility$1, "useAccessibility$1");
var Overlay = /* @__PURE__ */ forwardRef(function(props, ref) {
  var overlay2 = props.overlay, arrow = props.arrow, prefixCls = props.prefixCls, overlayNode = useMemo$1(function() {
    var overlayElement;
    return typeof overlay2 == "function" ? overlayElement = overlay2() : overlayElement = overlay2, overlayElement;
  }, [overlay2]), composedRef = composeRef(ref, getNodeRef(overlayNode));
  return /* @__PURE__ */ React__default.createElement(React__default.Fragment, null, arrow && /* @__PURE__ */ React__default.createElement("div", {
    className: "".concat(prefixCls, "-arrow")
  }), /* @__PURE__ */ React__default.cloneElement(overlayNode, {
    ref: supportRef(overlayNode) ? composedRef : void 0
  }));
}), autoAdjustOverflow$1 = {
  adjustX: 1,
  adjustY: 1
}, targetOffset = [0, 0], placements$1 = {
  topLeft: {
    points: ["bl", "tl"],
    overflow: autoAdjustOverflow$1,
    offset: [0, -4],
    targetOffset
  },
  top: {
    points: ["bc", "tc"],
    overflow: autoAdjustOverflow$1,
    offset: [0, -4],
    targetOffset
  },
  topRight: {
    points: ["br", "tr"],
    overflow: autoAdjustOverflow$1,
    offset: [0, -4],
    targetOffset
  },
  bottomLeft: {
    points: ["tl", "bl"],
    overflow: autoAdjustOverflow$1,
    offset: [0, 4],
    targetOffset
  },
  bottom: {
    points: ["tc", "bc"],
    overflow: autoAdjustOverflow$1,
    offset: [0, 4],
    targetOffset
  },
  bottomRight: {
    points: ["tr", "br"],
    overflow: autoAdjustOverflow$1,
    offset: [0, 4],
    targetOffset
  }
}, _excluded$y = ["arrow", "prefixCls", "transitionName", "animation", "align", "placement", "placements", "getPopupContainer", "showAction", "hideAction", "overlayClassName", "overlayStyle", "visible", "trigger", "autoFocus", "overlay", "children", "onVisibleChange"];
function Dropdown$2(props, ref) {
  var _children$props, _props$arrow = props.arrow, arrow = _props$arrow === void 0 ? !1 : _props$arrow, _props$prefixCls = props.prefixCls, prefixCls = _props$prefixCls === void 0 ? "rc-dropdown" : _props$prefixCls, transitionName = props.transitionName, animation = props.animation, align = props.align, _props$placement = props.placement, placement = _props$placement === void 0 ? "bottomLeft" : _props$placement, _props$placements = props.placements, placements2 = _props$placements === void 0 ? placements$1 : _props$placements, getPopupContainer = props.getPopupContainer, showAction = props.showAction, hideAction = props.hideAction, overlayClassName = props.overlayClassName, overlayStyle = props.overlayStyle, visible = props.visible, _props$trigger = props.trigger, trigger = _props$trigger === void 0 ? ["hover"] : _props$trigger, autoFocus = props.autoFocus, overlay2 = props.overlay, children = props.children, onVisibleChange = props.onVisibleChange, otherProps = _objectWithoutProperties(props, _excluded$y), _React$useState = React__default.useState(), _React$useState2 = _slicedToArray(_React$useState, 2), triggerVisible = _React$useState2[0], setTriggerVisible = _React$useState2[1], mergedVisible = "visible" in props ? visible : triggerVisible, triggerRef = React__default.useRef(null), overlayRef = React__default.useRef(null), childRef = React__default.useRef(null);
  React__default.useImperativeHandle(ref, function() {
    return triggerRef.current;
  });
  var handleVisibleChange = /* @__PURE__ */ __name(function(newVisible) {
    setTriggerVisible(newVisible), onVisibleChange == null || onVisibleChange(newVisible);
  }, "handleVisibleChange");
  useAccessibility$1({
    visible: mergedVisible,
    triggerRef: childRef,
    onVisibleChange: handleVisibleChange,
    autoFocus,
    overlayRef
  });
  var onClick = /* @__PURE__ */ __name(function(e2) {
    var onOverlayClick = props.onOverlayClick;
    setTriggerVisible(!1), onOverlayClick && onOverlayClick(e2);
  }, "onClick"), getMenuElement = /* @__PURE__ */ __name(function() {
    return /* @__PURE__ */ React__default.createElement(Overlay, {
      ref: overlayRef,
      overlay: overlay2,
      prefixCls,
      arrow
    });
  }, "getMenuElement"), getMenuElementOrLambda = /* @__PURE__ */ __name(function() {
    return typeof overlay2 == "function" ? getMenuElement : getMenuElement();
  }, "getMenuElementOrLambda"), getMinOverlayWidthMatchTrigger = /* @__PURE__ */ __name(function() {
    var minOverlayWidthMatchTrigger = props.minOverlayWidthMatchTrigger, alignPoint = props.alignPoint;
    return "minOverlayWidthMatchTrigger" in props ? minOverlayWidthMatchTrigger : !alignPoint;
  }, "getMinOverlayWidthMatchTrigger"), getOpenClassName = /* @__PURE__ */ __name(function() {
    var openClassName = props.openClassName;
    return openClassName !== void 0 ? openClassName : "".concat(prefixCls, "-open");
  }, "getOpenClassName"), childrenNode = /* @__PURE__ */ React__default.cloneElement(children, {
    className: cn((_children$props = children.props) === null || _children$props === void 0 ? void 0 : _children$props.className, mergedVisible && getOpenClassName()),
    ref: supportRef(children) ? composeRef(childRef, getNodeRef(children)) : void 0
  }), triggerHideAction = hideAction;
  return !triggerHideAction && trigger.indexOf("contextMenu") !== -1 && (triggerHideAction = ["click"]), /* @__PURE__ */ React__default.createElement(Trigger, _extends({
    builtinPlacements: placements2
  }, otherProps, {
    prefixCls,
    ref: triggerRef,
    popupClassName: cn(overlayClassName, _defineProperty$2({}, "".concat(prefixCls, "-show-arrow"), arrow)),
    popupStyle: overlayStyle,
    action: trigger,
    showAction,
    hideAction: triggerHideAction,
    popupPlacement: placement,
    popupAlign: align,
    popupTransitionName: transitionName,
    popupAnimation: animation,
    popupVisible: mergedVisible,
    stretch: getMinOverlayWidthMatchTrigger() ? "minWidth" : "",
    popup: getMenuElementOrLambda(),
    onPopupVisibleChange: handleVisibleChange,
    onPopupClick: onClick,
    getPopupContainer
  }), childrenNode);
}
__name(Dropdown$2, "Dropdown$2");
const Dropdown$3 = /* @__PURE__ */ React__default.forwardRef(Dropdown$2), isPrimitive = /* @__PURE__ */ __name((value) => typeof value != "object" && typeof value != "function" || value === null, "isPrimitive");
var IdContext = /* @__PURE__ */ React.createContext(null);
function getMenuId(uuid2, eventKey) {
  return uuid2 === void 0 ? null : "".concat(uuid2, "-").concat(eventKey);
}
__name(getMenuId, "getMenuId");
function useMenuId(eventKey) {
  var id2 = React.useContext(IdContext);
  return getMenuId(id2, eventKey);
}
__name(useMenuId, "useMenuId");
var _excluded$x = ["children", "locked"], MenuContext$1 = /* @__PURE__ */ React.createContext(null);
function mergeProps(origin, target) {
  var clone = _objectSpread2$1({}, origin);
  return Object.keys(target).forEach(function(key) {
    var value = target[key];
    value !== void 0 && (clone[key] = value);
  }), clone;
}
__name(mergeProps, "mergeProps");
function InheritableContextProvider(_ref) {
  var children = _ref.children, locked = _ref.locked, restProps = _objectWithoutProperties(_ref, _excluded$x), context = React.useContext(MenuContext$1), inheritableContext = useMemo(function() {
    return mergeProps(context, restProps);
  }, [context, restProps], function(prev2, next2) {
    return !locked && (prev2[0] !== next2[0] || !isEqual(prev2[1], next2[1], !0));
  });
  return /* @__PURE__ */ React.createElement(MenuContext$1.Provider, {
    value: inheritableContext
  }, children);
}
__name(InheritableContextProvider, "InheritableContextProvider");
var EmptyList = [], PathRegisterContext = /* @__PURE__ */ React.createContext(null);
function useMeasure() {
  return React.useContext(PathRegisterContext);
}
__name(useMeasure, "useMeasure");
var PathTrackerContext = /* @__PURE__ */ React.createContext(EmptyList);
function useFullPath(eventKey) {
  var parentKeyPath = React.useContext(PathTrackerContext);
  return React.useMemo(function() {
    return eventKey !== void 0 ? [].concat(_toConsumableArray(parentKeyPath), [eventKey]) : parentKeyPath;
  }, [parentKeyPath, eventKey]);
}
__name(useFullPath, "useFullPath");
var PathUserContext = /* @__PURE__ */ React.createContext(null), PrivateContext = /* @__PURE__ */ React.createContext({});
function focusable(node2) {
  var includePositive = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1;
  if (isVisible(node2)) {
    var nodeName = node2.nodeName.toLowerCase(), isFocusableElement = (
      // Focusable element
      ["input", "select", "textarea", "button"].includes(nodeName) || // Editable element
      node2.isContentEditable || // Anchor with href element
      nodeName === "a" && !!node2.getAttribute("href")
    ), tabIndexAttr = node2.getAttribute("tabindex"), tabIndexNum = Number(tabIndexAttr), tabIndex = null;
    return tabIndexAttr && !Number.isNaN(tabIndexNum) ? tabIndex = tabIndexNum : isFocusableElement && tabIndex === null && (tabIndex = 0), isFocusableElement && node2.disabled && (tabIndex = null), tabIndex !== null && (tabIndex >= 0 || includePositive && tabIndex < 0);
  }
  return !1;
}
__name(focusable, "focusable");
function getFocusNodeList(node2) {
  var includePositive = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1, res = _toConsumableArray(node2.querySelectorAll("*")).filter(function(child) {
    return focusable(child, includePositive);
  });
  return focusable(node2, includePositive) && res.unshift(node2), res;
}
__name(getFocusNodeList, "getFocusNodeList");
var LEFT = KeyCode.LEFT, RIGHT = KeyCode.RIGHT, UP = KeyCode.UP, DOWN = KeyCode.DOWN, ENTER = KeyCode.ENTER, ESC = KeyCode.ESC, HOME = KeyCode.HOME, END = KeyCode.END, ArrowKeys = [UP, DOWN, LEFT, RIGHT];
function getOffset$1(mode, isRootLevel, isRtl, which) {
  var _offsets, prev2 = "prev", next2 = "next", children = "children", parent = "parent";
  if (mode === "inline" && which === ENTER)
    return {
      inlineTrigger: !0
    };
  var inline2 = _defineProperty$2(_defineProperty$2({}, UP, prev2), DOWN, next2), horizontal = _defineProperty$2(_defineProperty$2(_defineProperty$2(_defineProperty$2({}, LEFT, isRtl ? next2 : prev2), RIGHT, isRtl ? prev2 : next2), DOWN, children), ENTER, children), vertical = _defineProperty$2(_defineProperty$2(_defineProperty$2(_defineProperty$2(_defineProperty$2(_defineProperty$2({}, UP, prev2), DOWN, next2), ENTER, children), ESC, parent), LEFT, isRtl ? children : parent), RIGHT, isRtl ? parent : children), offsets = {
    inline: inline2,
    horizontal,
    vertical,
    inlineSub: inline2,
    horizontalSub: vertical,
    verticalSub: vertical
  }, type4 = (_offsets = offsets["".concat(mode).concat(isRootLevel ? "" : "Sub")]) === null || _offsets === void 0 ? void 0 : _offsets[which];
  switch (type4) {
    case prev2:
      return {
        offset: -1,
        sibling: !0
      };
    case next2:
      return {
        offset: 1,
        sibling: !0
      };
    case parent:
      return {
        offset: -1,
        sibling: !1
      };
    case children:
      return {
        offset: 1,
        sibling: !1
      };
    default:
      return null;
  }
}
__name(getOffset$1, "getOffset$1");
function findContainerUL(element) {
  for (var current = element; current; ) {
    if (current.getAttribute("data-menu-list"))
      return current;
    current = current.parentElement;
  }
  return null;
}
__name(findContainerUL, "findContainerUL");
function getFocusElement(activeElement, elements) {
  for (var current = activeElement || document.activeElement; current; ) {
    if (elements.has(current))
      return current;
    current = current.parentElement;
  }
  return null;
}
__name(getFocusElement, "getFocusElement");
function getFocusableElements(container2, elements) {
  var list = getFocusNodeList(container2, !0);
  return list.filter(function(ele) {
    return elements.has(ele);
  });
}
__name(getFocusableElements, "getFocusableElements");
function getNextFocusElement(parentQueryContainer, elements, focusMenuElement) {
  var offset2 = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 1;
  if (!parentQueryContainer)
    return null;
  var sameLevelFocusableMenuElementList = getFocusableElements(parentQueryContainer, elements), count = sameLevelFocusableMenuElementList.length, focusIndex = sameLevelFocusableMenuElementList.findIndex(function(ele) {
    return focusMenuElement === ele;
  });
  return offset2 < 0 ? focusIndex === -1 ? focusIndex = count - 1 : focusIndex -= 1 : offset2 > 0 && (focusIndex += 1), focusIndex = (focusIndex + count) % count, sameLevelFocusableMenuElementList[focusIndex];
}
__name(getNextFocusElement, "getNextFocusElement");
var refreshElements = /* @__PURE__ */ __name(function(keys2, id2) {
  var elements = /* @__PURE__ */ new Set(), key2element = /* @__PURE__ */ new Map(), element2key = /* @__PURE__ */ new Map();
  return keys2.forEach(function(key) {
    var element = document.querySelector("[data-menu-id='".concat(getMenuId(id2, key), "']"));
    element && (elements.add(element), element2key.set(element, key), key2element.set(key, element));
  }), {
    elements,
    key2element,
    element2key
  };
}, "refreshElements");
function useAccessibility(mode, activeKey, isRtl, id2, containerRef, getKeys, getKeyPath, triggerActiveKey, triggerAccessibilityOpen, originOnKeyDown) {
  var rafRef = React.useRef(), activeRef = React.useRef();
  activeRef.current = activeKey;
  var cleanRaf = /* @__PURE__ */ __name(function() {
    wrapperRaf.cancel(rafRef.current);
  }, "cleanRaf");
  return React.useEffect(function() {
    return function() {
      cleanRaf();
    };
  }, []), function(e2) {
    var which = e2.which;
    if ([].concat(ArrowKeys, [ENTER, ESC, HOME, END]).includes(which)) {
      var keys2 = getKeys(), refreshedElements = refreshElements(keys2, id2), _refreshedElements = refreshedElements, elements = _refreshedElements.elements, key2element = _refreshedElements.key2element, element2key = _refreshedElements.element2key, activeElement = key2element.get(activeKey), focusMenuElement = getFocusElement(activeElement, elements), focusMenuKey = element2key.get(focusMenuElement), offsetObj = getOffset$1(mode, getKeyPath(focusMenuKey, !0).length === 1, isRtl, which);
      if (!offsetObj && which !== HOME && which !== END)
        return;
      (ArrowKeys.includes(which) || [HOME, END].includes(which)) && e2.preventDefault();
      var tryFocus = /* @__PURE__ */ __name(function(menuElement) {
        if (menuElement) {
          var focusTargetElement = menuElement, link = menuElement.querySelector("a");
          link != null && link.getAttribute("href") && (focusTargetElement = link);
          var targetKey = element2key.get(menuElement);
          triggerActiveKey(targetKey), cleanRaf(), rafRef.current = wrapperRaf(function() {
            activeRef.current === targetKey && focusTargetElement.focus();
          });
        }
      }, "tryFocus");
      if ([HOME, END].includes(which) || offsetObj.sibling || !focusMenuElement) {
        var parentQueryContainer;
        !focusMenuElement || mode === "inline" ? parentQueryContainer = containerRef.current : parentQueryContainer = findContainerUL(focusMenuElement);
        var targetElement, focusableElements = getFocusableElements(parentQueryContainer, elements);
        which === HOME ? targetElement = focusableElements[0] : which === END ? targetElement = focusableElements[focusableElements.length - 1] : targetElement = getNextFocusElement(parentQueryContainer, elements, focusMenuElement, offsetObj.offset), tryFocus(targetElement);
      } else if (offsetObj.inlineTrigger)
        triggerAccessibilityOpen(focusMenuKey);
      else if (offsetObj.offset > 0)
        triggerAccessibilityOpen(focusMenuKey, !0), cleanRaf(), rafRef.current = wrapperRaf(function() {
          refreshedElements = refreshElements(keys2, id2);
          var controlId = focusMenuElement.getAttribute("aria-controls"), subQueryContainer = document.getElementById(controlId), targetElement2 = getNextFocusElement(subQueryContainer, refreshedElements.elements);
          tryFocus(targetElement2);
        }, 5);
      else if (offsetObj.offset < 0) {
        var keyPath = getKeyPath(focusMenuKey, !0), parentKey = keyPath[keyPath.length - 2], parentMenuElement = key2element.get(parentKey);
        triggerAccessibilityOpen(parentKey, !1), tryFocus(parentMenuElement);
      }
    }
    originOnKeyDown == null || originOnKeyDown(e2);
  };
}
__name(useAccessibility, "useAccessibility");
function nextSlice(callback) {
  Promise.resolve().then(callback);
}
__name(nextSlice, "nextSlice");
var PATH_SPLIT = "__RC_UTIL_PATH_SPLIT__", getPathStr = /* @__PURE__ */ __name(function(keyPath) {
  return keyPath.join(PATH_SPLIT);
}, "getPathStr"), getPathKeys = /* @__PURE__ */ __name(function(keyPathStr) {
  return keyPathStr.split(PATH_SPLIT);
}, "getPathKeys"), OVERFLOW_KEY = "rc-menu-more";
function useKeyRecords() {
  var _React$useState = React.useState({}), _React$useState2 = _slicedToArray(_React$useState, 2), internalForceUpdate = _React$useState2[1], key2pathRef = useRef(/* @__PURE__ */ new Map()), path2keyRef = useRef(/* @__PURE__ */ new Map()), _React$useState3 = React.useState([]), _React$useState4 = _slicedToArray(_React$useState3, 2), overflowKeys = _React$useState4[0], setOverflowKeys = _React$useState4[1], updateRef = useRef(0), destroyRef = useRef(!1), forceUpdate = /* @__PURE__ */ __name(function() {
    destroyRef.current || internalForceUpdate({});
  }, "forceUpdate"), registerPath = useCallback(function(key, keyPath) {
    process.env.NODE_ENV !== "production" && warningOnce(!key2pathRef.current.has(key), "Duplicated key '".concat(key, "' used in Menu by path [").concat(keyPath.join(" > "), "]"));
    var connectedPath = getPathStr(keyPath);
    path2keyRef.current.set(connectedPath, key), key2pathRef.current.set(key, connectedPath), updateRef.current += 1;
    var id2 = updateRef.current;
    nextSlice(function() {
      id2 === updateRef.current && forceUpdate();
    });
  }, []), unregisterPath = useCallback(function(key, keyPath) {
    var connectedPath = getPathStr(keyPath);
    path2keyRef.current.delete(connectedPath), key2pathRef.current.delete(key);
  }, []), refreshOverflowKeys = useCallback(function(keys2) {
    setOverflowKeys(keys2);
  }, []), getKeyPath = useCallback(function(eventKey, includeOverflow) {
    var fullPath = key2pathRef.current.get(eventKey) || "", keys2 = getPathKeys(fullPath);
    return includeOverflow && overflowKeys.includes(keys2[0]) && keys2.unshift(OVERFLOW_KEY), keys2;
  }, [overflowKeys]), isSubPathKey = useCallback(function(pathKeys, eventKey) {
    return pathKeys.filter(function(item) {
      return item !== void 0;
    }).some(function(pathKey2) {
      var pathKeyList = getKeyPath(pathKey2, !0);
      return pathKeyList.includes(eventKey);
    });
  }, [getKeyPath]), getKeys = /* @__PURE__ */ __name(function() {
    var keys2 = _toConsumableArray(key2pathRef.current.keys());
    return overflowKeys.length && keys2.push(OVERFLOW_KEY), keys2;
  }, "getKeys"), getSubPathKeys = useCallback(function(key) {
    var connectedPath = "".concat(key2pathRef.current.get(key)).concat(PATH_SPLIT), pathKeys = /* @__PURE__ */ new Set();
    return _toConsumableArray(path2keyRef.current.keys()).forEach(function(pathKey2) {
      pathKey2.startsWith(connectedPath) && pathKeys.add(path2keyRef.current.get(pathKey2));
    }), pathKeys;
  }, []);
  return React.useEffect(function() {
    return function() {
      destroyRef.current = !0;
    };
  }, []), {
    // Register
    registerPath,
    unregisterPath,
    refreshOverflowKeys,
    // Util
    isSubPathKey,
    getKeyPath,
    getKeys,
    getSubPathKeys
  };
}
__name(useKeyRecords, "useKeyRecords");
function useMemoCallback(func) {
  var funRef = React.useRef(func);
  funRef.current = func;
  var callback = React.useCallback(function() {
    for (var _funRef$current, _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++)
      args[_key] = arguments[_key];
    return (_funRef$current = funRef.current) === null || _funRef$current === void 0 ? void 0 : _funRef$current.call.apply(_funRef$current, [funRef].concat(args));
  }, []);
  return func ? callback : void 0;
}
__name(useMemoCallback, "useMemoCallback");
var uniquePrefix = Math.random().toFixed(5).toString().slice(2), internalId = 0;
function useUUID(id2) {
  var _useMergedState = useMergedState(id2, {
    value: id2
  }), _useMergedState2 = _slicedToArray(_useMergedState, 2), uuid2 = _useMergedState2[0], setUUID = _useMergedState2[1];
  return React.useEffect(function() {
    internalId += 1;
    var newId = process.env.NODE_ENV === "test" ? "test" : "".concat(uniquePrefix, "-").concat(internalId);
    setUUID("rc-menu-uuid-".concat(newId));
  }, []), uuid2;
}
__name(useUUID, "useUUID");
function useActive(eventKey, disabled, onMouseEnter, onMouseLeave) {
  var _React$useContext = React.useContext(MenuContext$1), activeKey = _React$useContext.activeKey, onActive = _React$useContext.onActive, onInactive = _React$useContext.onInactive, ret = {
    active: activeKey === eventKey
  };
  return disabled || (ret.onMouseEnter = function(domEvent) {
    onMouseEnter == null || onMouseEnter({
      key: eventKey,
      domEvent
    }), onActive(eventKey);
  }, ret.onMouseLeave = function(domEvent) {
    onMouseLeave == null || onMouseLeave({
      key: eventKey,
      domEvent
    }), onInactive(eventKey);
  }), ret;
}
__name(useActive, "useActive");
function useDirectionStyle(level) {
  var _React$useContext = React.useContext(MenuContext$1), mode = _React$useContext.mode, rtl = _React$useContext.rtl, inlineIndent = _React$useContext.inlineIndent;
  if (mode !== "inline")
    return null;
  var len = level;
  return rtl ? {
    paddingRight: len * inlineIndent
  } : {
    paddingLeft: len * inlineIndent
  };
}
__name(useDirectionStyle, "useDirectionStyle");
function Icon$2(_ref) {
  var icon = _ref.icon, props = _ref.props, children = _ref.children, iconNode;
  return icon === null || icon === !1 ? null : (typeof icon == "function" ? iconNode = /* @__PURE__ */ React.createElement(icon, _objectSpread2$1({}, props)) : typeof icon != "boolean" && (iconNode = icon), iconNode || children || null);
}
__name(Icon$2, "Icon$2");
var _excluded$w = ["item"];
function warnItemProp(_ref) {
  var item = _ref.item, restInfo = _objectWithoutProperties(_ref, _excluded$w);
  return Object.defineProperty(restInfo, "item", {
    get: /* @__PURE__ */ __name(function() {
      return warningOnce(!1, "`info.item` is deprecated since we will move to function component that not provides React Node instance in future."), item;
    }, "get")
  }), restInfo;
}
__name(warnItemProp, "warnItemProp");
var _excluded$v = ["title", "attribute", "elementRef"], _excluded2$6 = ["style", "className", "eventKey", "warnKey", "disabled", "itemIcon", "children", "role", "onMouseEnter", "onMouseLeave", "onClick", "onKeyDown", "onFocus"], _excluded3$1 = ["active"], LegacyMenuItem = /* @__PURE__ */ function(_React$Component) {
  _inherits(LegacyMenuItem2, _React$Component);
  var _super = _createSuper(LegacyMenuItem2);
  function LegacyMenuItem2() {
    return _classCallCheck$1(this, LegacyMenuItem2), _super.apply(this, arguments);
  }
  return __name(LegacyMenuItem2, "LegacyMenuItem"), _createClass$1(LegacyMenuItem2, [{
    key: "render",
    value: /* @__PURE__ */ __name(function() {
      var _this$props = this.props, title2 = _this$props.title, attribute = _this$props.attribute, elementRef = _this$props.elementRef, restProps = _objectWithoutProperties(_this$props, _excluded$v), passedProps = omit(restProps, ["eventKey", "popupClassName", "popupOffset", "onTitleClick"]);
      return warningOnce(!attribute, "`attribute` of Menu.Item is deprecated. Please pass attribute directly."), /* @__PURE__ */ React.createElement(ForwardOverflow.Item, _extends({}, attribute, {
        title: typeof title2 == "string" ? title2 : void 0
      }, passedProps, {
        ref: elementRef
      }));
    }, "render")
  }]), LegacyMenuItem2;
}(React.Component), InternalMenuItem = /* @__PURE__ */ React.forwardRef(function(props, ref) {
  var style2 = props.style, className = props.className, eventKey = props.eventKey, warnKey = props.warnKey, disabled = props.disabled, itemIcon = props.itemIcon, children = props.children, role = props.role, onMouseEnter = props.onMouseEnter, onMouseLeave = props.onMouseLeave, onClick = props.onClick, onKeyDown2 = props.onKeyDown, onFocus = props.onFocus, restProps = _objectWithoutProperties(props, _excluded2$6), domDataId = useMenuId(eventKey), _React$useContext = React.useContext(MenuContext$1), prefixCls = _React$useContext.prefixCls, onItemClick = _React$useContext.onItemClick, contextDisabled = _React$useContext.disabled, overflowDisabled = _React$useContext.overflowDisabled, contextItemIcon = _React$useContext.itemIcon, selectedKeys = _React$useContext.selectedKeys, onActive = _React$useContext.onActive, _React$useContext2 = React.useContext(PrivateContext), _internalRenderMenuItem = _React$useContext2._internalRenderMenuItem, itemCls = "".concat(prefixCls, "-item"), legacyMenuItemRef = React.useRef(), elementRef = React.useRef(), mergedDisabled = contextDisabled || disabled, mergedEleRef = useComposeRef(ref, elementRef), connectedKeys = useFullPath(eventKey);
  process.env.NODE_ENV !== "production" && warnKey && warningOnce(!1, "MenuItem should not leave undefined `key`.");
  var getEventInfo = /* @__PURE__ */ __name(function(e2) {
    return {
      key: eventKey,
      // Note: For legacy code is reversed which not like other antd component
      keyPath: _toConsumableArray(connectedKeys).reverse(),
      item: legacyMenuItemRef.current,
      domEvent: e2
    };
  }, "getEventInfo"), mergedItemIcon = itemIcon || contextItemIcon, _useActive = useActive(eventKey, mergedDisabled, onMouseEnter, onMouseLeave), active = _useActive.active, activeProps = _objectWithoutProperties(_useActive, _excluded3$1), selected = selectedKeys.includes(eventKey), directionStyle = useDirectionStyle(connectedKeys.length), onInternalClick = /* @__PURE__ */ __name(function(e2) {
    if (!mergedDisabled) {
      var info = getEventInfo(e2);
      onClick == null || onClick(warnItemProp(info)), onItemClick(info);
    }
  }, "onInternalClick"), onInternalKeyDown = /* @__PURE__ */ __name(function(e2) {
    if (onKeyDown2 == null || onKeyDown2(e2), e2.which === KeyCode.ENTER) {
      var info = getEventInfo(e2);
      onClick == null || onClick(warnItemProp(info)), onItemClick(info);
    }
  }, "onInternalKeyDown"), onInternalFocus = /* @__PURE__ */ __name(function(e2) {
    onActive(eventKey), onFocus == null || onFocus(e2);
  }, "onInternalFocus"), optionRoleProps = {};
  props.role === "option" && (optionRoleProps["aria-selected"] = selected);
  var renderNode = /* @__PURE__ */ React.createElement(LegacyMenuItem, _extends({
    ref: legacyMenuItemRef,
    elementRef: mergedEleRef,
    role: role === null ? "none" : role || "menuitem",
    tabIndex: disabled ? null : -1,
    "data-menu-id": overflowDisabled && domDataId ? null : domDataId
  }, omit(restProps, ["extra"]), activeProps, optionRoleProps, {
    component: "li",
    "aria-disabled": disabled,
    style: _objectSpread2$1(_objectSpread2$1({}, directionStyle), style2),
    className: cn(itemCls, _defineProperty$2(_defineProperty$2(_defineProperty$2({}, "".concat(itemCls, "-active"), active), "".concat(itemCls, "-selected"), selected), "".concat(itemCls, "-disabled"), mergedDisabled), className),
    onClick: onInternalClick,
    onKeyDown: onInternalKeyDown,
    onFocus: onInternalFocus
  }), children, /* @__PURE__ */ React.createElement(Icon$2, {
    props: _objectSpread2$1(_objectSpread2$1({}, props), {}, {
      isSelected: selected
    }),
    icon: mergedItemIcon
  }));
  return _internalRenderMenuItem && (renderNode = _internalRenderMenuItem(renderNode, props, {
    selected
  })), renderNode;
});
function MenuItem$1(props, ref) {
  var eventKey = props.eventKey, measure = useMeasure(), connectedKeyPath = useFullPath(eventKey);
  return React.useEffect(function() {
    if (measure)
      return measure.registerPath(eventKey, connectedKeyPath), function() {
        measure.unregisterPath(eventKey, connectedKeyPath);
      };
  }, [connectedKeyPath]), measure ? null : /* @__PURE__ */ React.createElement(InternalMenuItem, _extends({}, props, {
    ref
  }));
}
__name(MenuItem$1, "MenuItem$1");
const MenuItem$2 = /* @__PURE__ */ React.forwardRef(MenuItem$1);
var _excluded$u = ["className", "children"], InternalSubMenuList = /* @__PURE__ */ __name(function(_ref, ref) {
  var className = _ref.className, children = _ref.children, restProps = _objectWithoutProperties(_ref, _excluded$u), _React$useContext = React.useContext(MenuContext$1), prefixCls = _React$useContext.prefixCls, mode = _React$useContext.mode, rtl = _React$useContext.rtl;
  return /* @__PURE__ */ React.createElement("ul", _extends({
    className: cn(prefixCls, rtl && "".concat(prefixCls, "-rtl"), "".concat(prefixCls, "-sub"), "".concat(prefixCls, "-").concat(mode === "inline" ? "inline" : "vertical"), className),
    role: "menu"
  }, restProps, {
    "data-menu-list": !0,
    ref
  }), children);
}, "InternalSubMenuList"), SubMenuList = /* @__PURE__ */ React.forwardRef(InternalSubMenuList);
SubMenuList.displayName = "SubMenuList";
function parseChildren(children, keyPath) {
  return toArray$7(children).map(function(child, index2) {
    if (/* @__PURE__ */ React.isValidElement(child)) {
      var _eventKey, _child$props, key = child.key, eventKey = (_eventKey = (_child$props = child.props) === null || _child$props === void 0 ? void 0 : _child$props.eventKey) !== null && _eventKey !== void 0 ? _eventKey : key, emptyKey = eventKey == null;
      emptyKey && (eventKey = "tmp_key-".concat([].concat(_toConsumableArray(keyPath), [index2]).join("-")));
      var cloneProps = {
        key: eventKey,
        eventKey
      };
      return process.env.NODE_ENV !== "production" && emptyKey && (cloneProps.warnKey = !0), /* @__PURE__ */ React.cloneElement(child, cloneProps);
    }
    return child;
  });
}
__name(parseChildren, "parseChildren");
var autoAdjustOverflow = {
  adjustX: 1,
  adjustY: 1
}, placements = {
  topLeft: {
    points: ["bl", "tl"],
    overflow: autoAdjustOverflow
  },
  topRight: {
    points: ["br", "tr"],
    overflow: autoAdjustOverflow
  },
  bottomLeft: {
    points: ["tl", "bl"],
    overflow: autoAdjustOverflow
  },
  bottomRight: {
    points: ["tr", "br"],
    overflow: autoAdjustOverflow
  },
  leftTop: {
    points: ["tr", "tl"],
    overflow: autoAdjustOverflow
  },
  leftBottom: {
    points: ["br", "bl"],
    overflow: autoAdjustOverflow
  },
  rightTop: {
    points: ["tl", "tr"],
    overflow: autoAdjustOverflow
  },
  rightBottom: {
    points: ["bl", "br"],
    overflow: autoAdjustOverflow
  }
}, placementsRtl = {
  topLeft: {
    points: ["bl", "tl"],
    overflow: autoAdjustOverflow
  },
  topRight: {
    points: ["br", "tr"],
    overflow: autoAdjustOverflow
  },
  bottomLeft: {
    points: ["tl", "bl"],
    overflow: autoAdjustOverflow
  },
  bottomRight: {
    points: ["tr", "br"],
    overflow: autoAdjustOverflow
  },
  rightTop: {
    points: ["tr", "tl"],
    overflow: autoAdjustOverflow
  },
  rightBottom: {
    points: ["br", "bl"],
    overflow: autoAdjustOverflow
  },
  leftTop: {
    points: ["tl", "tr"],
    overflow: autoAdjustOverflow
  },
  leftBottom: {
    points: ["bl", "br"],
    overflow: autoAdjustOverflow
  }
};
function getMotion(mode, motion2, defaultMotions) {
  if (motion2)
    return motion2;
  if (defaultMotions)
    return defaultMotions[mode] || defaultMotions.other;
}
__name(getMotion, "getMotion");
var popupPlacementMap = {
  horizontal: "bottomLeft",
  vertical: "rightTop",
  "vertical-left": "rightTop",
  "vertical-right": "leftTop"
};
function PopupTrigger(_ref) {
  var prefixCls = _ref.prefixCls, visible = _ref.visible, children = _ref.children, popup = _ref.popup, popupStyle = _ref.popupStyle, popupClassName = _ref.popupClassName, popupOffset = _ref.popupOffset, disabled = _ref.disabled, mode = _ref.mode, onVisibleChange = _ref.onVisibleChange, _React$useContext = React.useContext(MenuContext$1), getPopupContainer = _React$useContext.getPopupContainer, rtl = _React$useContext.rtl, subMenuOpenDelay = _React$useContext.subMenuOpenDelay, subMenuCloseDelay = _React$useContext.subMenuCloseDelay, builtinPlacements = _React$useContext.builtinPlacements, triggerSubMenuAction = _React$useContext.triggerSubMenuAction, forceSubMenuRender = _React$useContext.forceSubMenuRender, rootClassName = _React$useContext.rootClassName, motion2 = _React$useContext.motion, defaultMotions = _React$useContext.defaultMotions, _React$useState = React.useState(!1), _React$useState2 = _slicedToArray(_React$useState, 2), innerVisible = _React$useState2[0], setInnerVisible = _React$useState2[1], placement = _objectSpread2$1(rtl ? _objectSpread2$1({}, placementsRtl) : _objectSpread2$1({}, placements), builtinPlacements), popupPlacement = popupPlacementMap[mode], targetMotion = getMotion(mode, motion2, defaultMotions), targetMotionRef = React.useRef(targetMotion);
  mode !== "inline" && (targetMotionRef.current = targetMotion);
  var mergedMotion = _objectSpread2$1(_objectSpread2$1({}, targetMotionRef.current), {}, {
    leavedClassName: "".concat(prefixCls, "-hidden"),
    removeOnLeave: !1,
    motionAppear: !0
  }), visibleRef = React.useRef();
  return React.useEffect(function() {
    return visibleRef.current = wrapperRaf(function() {
      setInnerVisible(visible);
    }), function() {
      wrapperRaf.cancel(visibleRef.current);
    };
  }, [visible]), /* @__PURE__ */ React.createElement(Trigger, {
    prefixCls,
    popupClassName: cn("".concat(prefixCls, "-popup"), _defineProperty$2({}, "".concat(prefixCls, "-rtl"), rtl), popupClassName, rootClassName),
    stretch: mode === "horizontal" ? "minWidth" : null,
    getPopupContainer,
    builtinPlacements: placement,
    popupPlacement,
    popupVisible: innerVisible,
    popup,
    popupStyle,
    popupAlign: popupOffset && {
      offset: popupOffset
    },
    action: disabled ? [] : [triggerSubMenuAction],
    mouseEnterDelay: subMenuOpenDelay,
    mouseLeaveDelay: subMenuCloseDelay,
    onPopupVisibleChange: onVisibleChange,
    forceRender: forceSubMenuRender,
    popupMotion: mergedMotion,
    fresh: !0
  }, children);
}
__name(PopupTrigger, "PopupTrigger");
function InlineSubMenuList(_ref) {
  var id2 = _ref.id, open = _ref.open, keyPath = _ref.keyPath, children = _ref.children, fixedMode = "inline", _React$useContext = React.useContext(MenuContext$1), prefixCls = _React$useContext.prefixCls, forceSubMenuRender = _React$useContext.forceSubMenuRender, motion2 = _React$useContext.motion, defaultMotions = _React$useContext.defaultMotions, mode = _React$useContext.mode, sameModeRef = React.useRef(!1);
  sameModeRef.current = mode === fixedMode;
  var _React$useState = React.useState(!sameModeRef.current), _React$useState2 = _slicedToArray(_React$useState, 2), destroy = _React$useState2[0], setDestroy = _React$useState2[1], mergedOpen = sameModeRef.current ? open : !1;
  React.useEffect(function() {
    sameModeRef.current && setDestroy(!1);
  }, [mode]);
  var mergedMotion = _objectSpread2$1({}, getMotion(fixedMode, motion2, defaultMotions));
  keyPath.length > 1 && (mergedMotion.motionAppear = !1);
  var originOnVisibleChanged = mergedMotion.onVisibleChanged;
  return mergedMotion.onVisibleChanged = function(newVisible) {
    return !sameModeRef.current && !newVisible && setDestroy(!0), originOnVisibleChanged == null ? void 0 : originOnVisibleChanged(newVisible);
  }, destroy ? null : /* @__PURE__ */ React.createElement(InheritableContextProvider, {
    mode: fixedMode,
    locked: !sameModeRef.current
  }, /* @__PURE__ */ React.createElement(CSSMotion, _extends({
    visible: mergedOpen
  }, mergedMotion, {
    forceRender: forceSubMenuRender,
    removeOnLeave: !1,
    leavedClassName: "".concat(prefixCls, "-hidden")
  }), function(_ref2) {
    var motionClassName = _ref2.className, motionStyle = _ref2.style;
    return /* @__PURE__ */ React.createElement(SubMenuList, {
      id: id2,
      className: motionClassName,
      style: motionStyle
    }, children);
  }));
}
__name(InlineSubMenuList, "InlineSubMenuList");
var _excluded$t = ["style", "className", "title", "eventKey", "warnKey", "disabled", "internalPopupClose", "children", "itemIcon", "expandIcon", "popupClassName", "popupOffset", "popupStyle", "onClick", "onMouseEnter", "onMouseLeave", "onTitleClick", "onTitleMouseEnter", "onTitleMouseLeave"], _excluded2$5 = ["active"], InternalSubMenu = /* @__PURE__ */ React.forwardRef(function(props, ref) {
  var style2 = props.style, className = props.className, title2 = props.title, eventKey = props.eventKey, warnKey = props.warnKey, disabled = props.disabled, internalPopupClose = props.internalPopupClose, children = props.children, itemIcon = props.itemIcon, expandIcon = props.expandIcon, popupClassName = props.popupClassName, popupOffset = props.popupOffset, popupStyle = props.popupStyle, onClick = props.onClick, onMouseEnter = props.onMouseEnter, onMouseLeave = props.onMouseLeave, onTitleClick = props.onTitleClick, onTitleMouseEnter = props.onTitleMouseEnter, onTitleMouseLeave = props.onTitleMouseLeave, restProps = _objectWithoutProperties(props, _excluded$t), domDataId = useMenuId(eventKey), _React$useContext = React.useContext(MenuContext$1), prefixCls = _React$useContext.prefixCls, mode = _React$useContext.mode, openKeys = _React$useContext.openKeys, contextDisabled = _React$useContext.disabled, overflowDisabled = _React$useContext.overflowDisabled, activeKey = _React$useContext.activeKey, selectedKeys = _React$useContext.selectedKeys, contextItemIcon = _React$useContext.itemIcon, contextExpandIcon = _React$useContext.expandIcon, onItemClick = _React$useContext.onItemClick, onOpenChange = _React$useContext.onOpenChange, onActive = _React$useContext.onActive, _React$useContext2 = React.useContext(PrivateContext), _internalRenderSubMenuItem = _React$useContext2._internalRenderSubMenuItem, _React$useContext3 = React.useContext(PathUserContext), isSubPathKey = _React$useContext3.isSubPathKey, connectedPath = useFullPath(), subMenuPrefixCls = "".concat(prefixCls, "-submenu"), mergedDisabled = contextDisabled || disabled, elementRef = React.useRef(), popupRef = React.useRef();
  process.env.NODE_ENV !== "production" && warnKey && warningOnce(!1, "SubMenu should not leave undefined `key`.");
  var mergedItemIcon = itemIcon ?? contextItemIcon, mergedExpandIcon = expandIcon ?? contextExpandIcon, originOpen = openKeys.includes(eventKey), open = !overflowDisabled && originOpen, childrenSelected = isSubPathKey(selectedKeys, eventKey), _useActive = useActive(eventKey, mergedDisabled, onTitleMouseEnter, onTitleMouseLeave), active = _useActive.active, activeProps = _objectWithoutProperties(_useActive, _excluded2$5), _React$useState = React.useState(!1), _React$useState2 = _slicedToArray(_React$useState, 2), childrenActive = _React$useState2[0], setChildrenActive = _React$useState2[1], triggerChildrenActive = /* @__PURE__ */ __name(function(newActive) {
    mergedDisabled || setChildrenActive(newActive);
  }, "triggerChildrenActive"), onInternalMouseEnter = /* @__PURE__ */ __name(function(domEvent) {
    triggerChildrenActive(!0), onMouseEnter == null || onMouseEnter({
      key: eventKey,
      domEvent
    });
  }, "onInternalMouseEnter"), onInternalMouseLeave = /* @__PURE__ */ __name(function(domEvent) {
    triggerChildrenActive(!1), onMouseLeave == null || onMouseLeave({
      key: eventKey,
      domEvent
    });
  }, "onInternalMouseLeave"), mergedActive = React.useMemo(function() {
    return active || (mode !== "inline" ? childrenActive || isSubPathKey([activeKey], eventKey) : !1);
  }, [mode, active, activeKey, childrenActive, eventKey, isSubPathKey]), directionStyle = useDirectionStyle(connectedPath.length), onInternalTitleClick = /* @__PURE__ */ __name(function(e2) {
    mergedDisabled || (onTitleClick == null || onTitleClick({
      key: eventKey,
      domEvent: e2
    }), mode === "inline" && onOpenChange(eventKey, !originOpen));
  }, "onInternalTitleClick"), onMergedItemClick = useMemoCallback(function(info) {
    onClick == null || onClick(warnItemProp(info)), onItemClick(info);
  }), onPopupVisibleChange = /* @__PURE__ */ __name(function(newVisible) {
    mode !== "inline" && onOpenChange(eventKey, newVisible);
  }, "onPopupVisibleChange"), onInternalFocus = /* @__PURE__ */ __name(function() {
    onActive(eventKey);
  }, "onInternalFocus"), popupId = domDataId && "".concat(domDataId, "-popup"), titleNode = /* @__PURE__ */ React.createElement("div", _extends({
    role: "menuitem",
    style: directionStyle,
    className: "".concat(subMenuPrefixCls, "-title"),
    tabIndex: mergedDisabled ? null : -1,
    ref: elementRef,
    title: typeof title2 == "string" ? title2 : null,
    "data-menu-id": overflowDisabled && domDataId ? null : domDataId,
    "aria-expanded": open,
    "aria-haspopup": !0,
    "aria-controls": popupId,
    "aria-disabled": mergedDisabled,
    onClick: onInternalTitleClick,
    onFocus: onInternalFocus
  }, activeProps), title2, /* @__PURE__ */ React.createElement(Icon$2, {
    icon: mode !== "horizontal" ? mergedExpandIcon : void 0,
    props: _objectSpread2$1(_objectSpread2$1({}, props), {}, {
      isOpen: open,
      // [Legacy] Not sure why need this mark
      isSubMenu: !0
    })
  }, /* @__PURE__ */ React.createElement("i", {
    className: "".concat(subMenuPrefixCls, "-arrow")
  }))), triggerModeRef = React.useRef(mode);
  if (mode !== "inline" && connectedPath.length > 1 ? triggerModeRef.current = "vertical" : triggerModeRef.current = mode, !overflowDisabled) {
    var triggerMode = triggerModeRef.current;
    titleNode = /* @__PURE__ */ React.createElement(PopupTrigger, {
      mode: triggerMode,
      prefixCls: subMenuPrefixCls,
      visible: !internalPopupClose && open && mode !== "inline",
      popupClassName,
      popupOffset,
      popupStyle,
      popup: /* @__PURE__ */ React.createElement(
        InheritableContextProvider,
        {
          mode: triggerMode === "horizontal" ? "vertical" : triggerMode
        },
        /* @__PURE__ */ React.createElement(SubMenuList, {
          id: popupId,
          ref: popupRef
        }, children)
      ),
      disabled: mergedDisabled,
      onVisibleChange: onPopupVisibleChange
    }, titleNode);
  }
  var listNode = /* @__PURE__ */ React.createElement(ForwardOverflow.Item, _extends({
    ref,
    role: "none"
  }, restProps, {
    component: "li",
    style: style2,
    className: cn(subMenuPrefixCls, "".concat(subMenuPrefixCls, "-").concat(mode), className, _defineProperty$2(_defineProperty$2(_defineProperty$2(_defineProperty$2({}, "".concat(subMenuPrefixCls, "-open"), open), "".concat(subMenuPrefixCls, "-active"), mergedActive), "".concat(subMenuPrefixCls, "-selected"), childrenSelected), "".concat(subMenuPrefixCls, "-disabled"), mergedDisabled)),
    onMouseEnter: onInternalMouseEnter,
    onMouseLeave: onInternalMouseLeave
  }), titleNode, !overflowDisabled && /* @__PURE__ */ React.createElement(InlineSubMenuList, {
    id: popupId,
    open,
    keyPath: connectedPath
  }, children));
  return _internalRenderSubMenuItem && (listNode = _internalRenderSubMenuItem(listNode, props, {
    selected: childrenSelected,
    active: mergedActive,
    open,
    disabled: mergedDisabled
  })), /* @__PURE__ */ React.createElement(InheritableContextProvider, {
    onItemClick: onMergedItemClick,
    mode: mode === "horizontal" ? "vertical" : mode,
    itemIcon: mergedItemIcon,
    expandIcon: mergedExpandIcon
  }, listNode);
}), SubMenu$1 = /* @__PURE__ */ React.forwardRef(function(props, ref) {
  var eventKey = props.eventKey, children = props.children, connectedKeyPath = useFullPath(eventKey), childList = parseChildren(children, connectedKeyPath), measure = useMeasure();
  React.useEffect(function() {
    if (measure)
      return measure.registerPath(eventKey, connectedKeyPath), function() {
        measure.unregisterPath(eventKey, connectedKeyPath);
      };
  }, [connectedKeyPath]);
  var renderNode;
  return measure ? renderNode = childList : renderNode = /* @__PURE__ */ React.createElement(InternalSubMenu, _extends({
    ref
  }, props), childList), /* @__PURE__ */ React.createElement(PathTrackerContext.Provider, {
    value: connectedKeyPath
  }, renderNode);
});
process.env.NODE_ENV !== "production" && (SubMenu$1.displayName = "SubMenu");
function Divider(_ref) {
  var className = _ref.className, style2 = _ref.style, _React$useContext = React.useContext(MenuContext$1), prefixCls = _React$useContext.prefixCls, measure = useMeasure();
  return measure ? null : /* @__PURE__ */ React.createElement("li", {
    role: "separator",
    className: cn("".concat(prefixCls, "-item-divider"), className),
    style: style2
  });
}
__name(Divider, "Divider");
var _excluded$s = ["className", "title", "eventKey", "children"], InternalMenuItemGroup = /* @__PURE__ */ React.forwardRef(function(props, ref) {
  var className = props.className, title2 = props.title;
  props.eventKey;
  var children = props.children, restProps = _objectWithoutProperties(props, _excluded$s), _React$useContext = React.useContext(MenuContext$1), prefixCls = _React$useContext.prefixCls, groupPrefixCls = "".concat(prefixCls, "-item-group");
  return /* @__PURE__ */ React.createElement("li", _extends({
    ref,
    role: "presentation"
  }, restProps, {
    onClick: /* @__PURE__ */ __name(function(e2) {
      return e2.stopPropagation();
    }, "onClick"),
    className: cn(groupPrefixCls, className)
  }), /* @__PURE__ */ React.createElement("div", {
    role: "presentation",
    className: "".concat(groupPrefixCls, "-title"),
    title: typeof title2 == "string" ? title2 : void 0
  }, title2), /* @__PURE__ */ React.createElement("ul", {
    role: "group",
    className: "".concat(groupPrefixCls, "-list")
  }, children));
}), MenuItemGroup = /* @__PURE__ */ React.forwardRef(function(props, ref) {
  var eventKey = props.eventKey, children = props.children, connectedKeyPath = useFullPath(eventKey), childList = parseChildren(children, connectedKeyPath), measure = useMeasure();
  return measure ? childList : /* @__PURE__ */ React.createElement(InternalMenuItemGroup, _extends({
    ref
  }, omit(props, ["warnKey"])), childList);
});
process.env.NODE_ENV !== "production" && (MenuItemGroup.displayName = "MenuItemGroup");
var _excluded$r = ["label", "children", "key", "type", "extra"];
function convertItemsToNodes(list, components2, prefixCls) {
  var MergedMenuItem = components2.item, MergedMenuItemGroup = components2.group, MergedSubMenu = components2.submenu, MergedDivider = components2.divider;
  return (list || []).map(function(opt, index2) {
    if (opt && _typeof$4(opt) === "object") {
      var _ref = opt, label2 = _ref.label, children = _ref.children, key = _ref.key, type4 = _ref.type, extra = _ref.extra, restProps = _objectWithoutProperties(_ref, _excluded$r), mergedKey = key ?? "tmp-".concat(index2);
      return children || type4 === "group" ? type4 === "group" ? /* @__PURE__ */ React.createElement(MergedMenuItemGroup, _extends({
        key: mergedKey
      }, restProps, {
        title: label2
      }), convertItemsToNodes(children, components2, prefixCls)) : /* @__PURE__ */ React.createElement(MergedSubMenu, _extends({
        key: mergedKey
      }, restProps, {
        title: label2
      }), convertItemsToNodes(children, components2, prefixCls)) : type4 === "divider" ? /* @__PURE__ */ React.createElement(MergedDivider, _extends({
        key: mergedKey
      }, restProps)) : /* @__PURE__ */ React.createElement(MergedMenuItem, _extends({
        key: mergedKey
      }, restProps, {
        extra
      }), label2, (!!extra || extra === 0) && /* @__PURE__ */ React.createElement("span", {
        className: "".concat(prefixCls, "-item-extra")
      }, extra));
    }
    return null;
  }).filter(function(opt) {
    return opt;
  });
}
__name(convertItemsToNodes, "convertItemsToNodes");
function parseItems(children, items, keyPath, components2, prefixCls) {
  var childNodes = children, mergedComponents = _objectSpread2$1({
    divider: Divider,
    item: MenuItem$2,
    group: MenuItemGroup,
    submenu: SubMenu$1
  }, components2);
  return items && (childNodes = convertItemsToNodes(items, mergedComponents, prefixCls)), parseChildren(childNodes, keyPath);
}
__name(parseItems, "parseItems");
var _excluded$q = ["prefixCls", "rootClassName", "style", "className", "tabIndex", "items", "children", "direction", "id", "mode", "inlineCollapsed", "disabled", "disabledOverflow", "subMenuOpenDelay", "subMenuCloseDelay", "forceSubMenuRender", "defaultOpenKeys", "openKeys", "activeKey", "defaultActiveFirst", "selectable", "multiple", "defaultSelectedKeys", "selectedKeys", "onSelect", "onDeselect", "inlineIndent", "motion", "defaultMotions", "triggerSubMenuAction", "builtinPlacements", "itemIcon", "expandIcon", "overflowedIndicator", "overflowedIndicatorPopupClassName", "getPopupContainer", "onClick", "onOpenChange", "onKeyDown", "openAnimation", "openTransitionName", "_internalRenderMenuItem", "_internalRenderSubMenuItem", "_internalComponents"], EMPTY_LIST$4 = [], Menu$1 = /* @__PURE__ */ React.forwardRef(function(props, ref) {
  var _childList$, _ref = props, _ref$prefixCls = _ref.prefixCls, prefixCls = _ref$prefixCls === void 0 ? "rc-menu" : _ref$prefixCls, rootClassName = _ref.rootClassName, style2 = _ref.style, className = _ref.className, _ref$tabIndex = _ref.tabIndex, tabIndex = _ref$tabIndex === void 0 ? 0 : _ref$tabIndex, items = _ref.items, children = _ref.children, direction = _ref.direction, id2 = _ref.id, _ref$mode = _ref.mode, mode = _ref$mode === void 0 ? "vertical" : _ref$mode, inlineCollapsed = _ref.inlineCollapsed, disabled = _ref.disabled, disabledOverflow = _ref.disabledOverflow, _ref$subMenuOpenDelay = _ref.subMenuOpenDelay, subMenuOpenDelay = _ref$subMenuOpenDelay === void 0 ? 0.1 : _ref$subMenuOpenDelay, _ref$subMenuCloseDela = _ref.subMenuCloseDelay, subMenuCloseDelay = _ref$subMenuCloseDela === void 0 ? 0.1 : _ref$subMenuCloseDela, forceSubMenuRender = _ref.forceSubMenuRender, defaultOpenKeys = _ref.defaultOpenKeys, openKeys = _ref.openKeys, activeKey = _ref.activeKey, defaultActiveFirst = _ref.defaultActiveFirst, _ref$selectable = _ref.selectable, selectable = _ref$selectable === void 0 ? !0 : _ref$selectable, _ref$multiple = _ref.multiple, multiple = _ref$multiple === void 0 ? !1 : _ref$multiple, defaultSelectedKeys = _ref.defaultSelectedKeys, selectedKeys = _ref.selectedKeys, onSelect = _ref.onSelect, onDeselect = _ref.onDeselect, _ref$inlineIndent = _ref.inlineIndent, inlineIndent = _ref$inlineIndent === void 0 ? 24 : _ref$inlineIndent, motion2 = _ref.motion, defaultMotions = _ref.defaultMotions, _ref$triggerSubMenuAc = _ref.triggerSubMenuAction, triggerSubMenuAction = _ref$triggerSubMenuAc === void 0 ? "hover" : _ref$triggerSubMenuAc, builtinPlacements = _ref.builtinPlacements, itemIcon = _ref.itemIcon, expandIcon = _ref.expandIcon, _ref$overflowedIndica = _ref.overflowedIndicator, overflowedIndicator = _ref$overflowedIndica === void 0 ? "..." : _ref$overflowedIndica, overflowedIndicatorPopupClassName = _ref.overflowedIndicatorPopupClassName, getPopupContainer = _ref.getPopupContainer, onClick = _ref.onClick, onOpenChange = _ref.onOpenChange, onKeyDown2 = _ref.onKeyDown, openAnimation = _ref.openAnimation, openTransitionName = _ref.openTransitionName, _internalRenderMenuItem = _ref._internalRenderMenuItem, _internalRenderSubMenuItem = _ref._internalRenderSubMenuItem, _internalComponents = _ref._internalComponents, restProps = _objectWithoutProperties(_ref, _excluded$q), _React$useMemo = React.useMemo(function() {
    return [parseItems(children, items, EMPTY_LIST$4, _internalComponents, prefixCls), parseItems(children, items, EMPTY_LIST$4, {}, prefixCls)];
  }, [children, items, _internalComponents]), _React$useMemo2 = _slicedToArray(_React$useMemo, 2), childList = _React$useMemo2[0], measureChildList = _React$useMemo2[1], _React$useState = React.useState(!1), _React$useState2 = _slicedToArray(_React$useState, 2), mounted = _React$useState2[0], setMounted = _React$useState2[1], containerRef = React.useRef(), uuid2 = useUUID(id2), isRtl = direction === "rtl";
  process.env.NODE_ENV !== "production" && warningOnce(!openAnimation && !openTransitionName, "`openAnimation` and `openTransitionName` is removed. Please use `motion` or `defaultMotion` instead.");
  var _useMergedState = useMergedState(defaultOpenKeys, {
    value: openKeys,
    postState: /* @__PURE__ */ __name(function(keys2) {
      return keys2 || EMPTY_LIST$4;
    }, "postState")
  }), _useMergedState2 = _slicedToArray(_useMergedState, 2), mergedOpenKeys = _useMergedState2[0], setMergedOpenKeys = _useMergedState2[1], triggerOpenKeys = /* @__PURE__ */ __name(function(keys2) {
    var forceFlush = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1;
    function doUpdate() {
      setMergedOpenKeys(keys2), onOpenChange == null || onOpenChange(keys2);
    }
    __name(doUpdate, "doUpdate"), forceFlush ? flushSync(doUpdate) : doUpdate();
  }, "triggerOpenKeys"), _React$useState3 = React.useState(mergedOpenKeys), _React$useState4 = _slicedToArray(_React$useState3, 2), inlineCacheOpenKeys = _React$useState4[0], setInlineCacheOpenKeys = _React$useState4[1], mountRef = React.useRef(!1), _React$useMemo3 = React.useMemo(function() {
    return (mode === "inline" || mode === "vertical") && inlineCollapsed ? ["vertical", inlineCollapsed] : [mode, !1];
  }, [mode, inlineCollapsed]), _React$useMemo4 = _slicedToArray(_React$useMemo3, 2), mergedMode = _React$useMemo4[0], mergedInlineCollapsed = _React$useMemo4[1], isInlineMode = mergedMode === "inline", _React$useState5 = React.useState(mergedMode), _React$useState6 = _slicedToArray(_React$useState5, 2), internalMode = _React$useState6[0], setInternalMode = _React$useState6[1], _React$useState7 = React.useState(mergedInlineCollapsed), _React$useState8 = _slicedToArray(_React$useState7, 2), internalInlineCollapsed = _React$useState8[0], setInternalInlineCollapsed = _React$useState8[1];
  React.useEffect(function() {
    setInternalMode(mergedMode), setInternalInlineCollapsed(mergedInlineCollapsed), mountRef.current && (isInlineMode ? setMergedOpenKeys(inlineCacheOpenKeys) : triggerOpenKeys(EMPTY_LIST$4));
  }, [mergedMode, mergedInlineCollapsed]);
  var _React$useState9 = React.useState(0), _React$useState10 = _slicedToArray(_React$useState9, 2), lastVisibleIndex = _React$useState10[0], setLastVisibleIndex = _React$useState10[1], allVisible = lastVisibleIndex >= childList.length - 1 || internalMode !== "horizontal" || disabledOverflow;
  React.useEffect(function() {
    isInlineMode && setInlineCacheOpenKeys(mergedOpenKeys);
  }, [mergedOpenKeys]), React.useEffect(function() {
    return mountRef.current = !0, function() {
      mountRef.current = !1;
    };
  }, []);
  var _useKeyRecords = useKeyRecords(), registerPath = _useKeyRecords.registerPath, unregisterPath = _useKeyRecords.unregisterPath, refreshOverflowKeys = _useKeyRecords.refreshOverflowKeys, isSubPathKey = _useKeyRecords.isSubPathKey, getKeyPath = _useKeyRecords.getKeyPath, getKeys = _useKeyRecords.getKeys, getSubPathKeys = _useKeyRecords.getSubPathKeys, registerPathContext = React.useMemo(function() {
    return {
      registerPath,
      unregisterPath
    };
  }, [registerPath, unregisterPath]), pathUserContext = React.useMemo(function() {
    return {
      isSubPathKey
    };
  }, [isSubPathKey]);
  React.useEffect(function() {
    refreshOverflowKeys(allVisible ? EMPTY_LIST$4 : childList.slice(lastVisibleIndex + 1).map(function(child) {
      return child.key;
    }));
  }, [lastVisibleIndex, allVisible]);
  var _useMergedState3 = useMergedState(activeKey || defaultActiveFirst && ((_childList$ = childList[0]) === null || _childList$ === void 0 ? void 0 : _childList$.key), {
    value: activeKey
  }), _useMergedState4 = _slicedToArray(_useMergedState3, 2), mergedActiveKey = _useMergedState4[0], setMergedActiveKey = _useMergedState4[1], onActive = useMemoCallback(function(key) {
    setMergedActiveKey(key);
  }), onInactive = useMemoCallback(function() {
    setMergedActiveKey(void 0);
  });
  useImperativeHandle(ref, function() {
    return {
      list: containerRef.current,
      focus: /* @__PURE__ */ __name(function(options) {
        var _childList$find, keys2 = getKeys(), _refreshElements = refreshElements(keys2, uuid2), elements = _refreshElements.elements, key2element = _refreshElements.key2element, element2key = _refreshElements.element2key, focusableElements = getFocusableElements(containerRef.current, elements), shouldFocusKey = mergedActiveKey ?? (focusableElements[0] ? element2key.get(focusableElements[0]) : (_childList$find = childList.find(function(node2) {
          return !node2.props.disabled;
        })) === null || _childList$find === void 0 ? void 0 : _childList$find.key), elementToFocus = key2element.get(shouldFocusKey);
        if (shouldFocusKey && elementToFocus) {
          var _elementToFocus$focus;
          elementToFocus == null || (_elementToFocus$focus = elementToFocus.focus) === null || _elementToFocus$focus === void 0 || _elementToFocus$focus.call(elementToFocus, options);
        }
      }, "focus")
    };
  });
  var _useMergedState5 = useMergedState(defaultSelectedKeys || [], {
    value: selectedKeys,
    // Legacy convert key to array
    postState: /* @__PURE__ */ __name(function(keys2) {
      return Array.isArray(keys2) ? keys2 : keys2 == null ? EMPTY_LIST$4 : [keys2];
    }, "postState")
  }), _useMergedState6 = _slicedToArray(_useMergedState5, 2), mergedSelectKeys = _useMergedState6[0], setMergedSelectKeys = _useMergedState6[1], triggerSelection = /* @__PURE__ */ __name(function(info) {
    if (selectable) {
      var targetKey = info.key, exist = mergedSelectKeys.includes(targetKey), newSelectKeys;
      multiple ? exist ? newSelectKeys = mergedSelectKeys.filter(function(key) {
        return key !== targetKey;
      }) : newSelectKeys = [].concat(_toConsumableArray(mergedSelectKeys), [targetKey]) : newSelectKeys = [targetKey], setMergedSelectKeys(newSelectKeys);
      var selectInfo = _objectSpread2$1(_objectSpread2$1({}, info), {}, {
        selectedKeys: newSelectKeys
      });
      exist ? onDeselect == null || onDeselect(selectInfo) : onSelect == null || onSelect(selectInfo);
    }
    !multiple && mergedOpenKeys.length && internalMode !== "inline" && triggerOpenKeys(EMPTY_LIST$4);
  }, "triggerSelection"), onInternalClick = useMemoCallback(function(info) {
    onClick == null || onClick(warnItemProp(info)), triggerSelection(info);
  }), onInternalOpenChange = useMemoCallback(function(key, open) {
    var newOpenKeys = mergedOpenKeys.filter(function(k) {
      return k !== key;
    });
    if (open)
      newOpenKeys.push(key);
    else if (internalMode !== "inline") {
      var subPathKeys = getSubPathKeys(key);
      newOpenKeys = newOpenKeys.filter(function(k) {
        return !subPathKeys.has(k);
      });
    }
    isEqual(mergedOpenKeys, newOpenKeys, !0) || triggerOpenKeys(newOpenKeys, !0);
  }), triggerAccessibilityOpen = /* @__PURE__ */ __name(function(key, open) {
    var nextOpen = open ?? !mergedOpenKeys.includes(key);
    onInternalOpenChange(key, nextOpen);
  }, "triggerAccessibilityOpen"), onInternalKeyDown = useAccessibility(internalMode, mergedActiveKey, isRtl, uuid2, containerRef, getKeys, getKeyPath, setMergedActiveKey, triggerAccessibilityOpen, onKeyDown2);
  React.useEffect(function() {
    setMounted(!0);
  }, []);
  var privateContext = React.useMemo(function() {
    return {
      _internalRenderMenuItem,
      _internalRenderSubMenuItem
    };
  }, [_internalRenderMenuItem, _internalRenderSubMenuItem]), wrappedChildList = internalMode !== "horizontal" || disabledOverflow ? childList : (
    // Need wrap for overflow dropdown that do not response for open
    childList.map(function(child, index2) {
      return (
        // Always wrap provider to avoid sub node re-mount
        /* @__PURE__ */ React.createElement(InheritableContextProvider, {
          key: child.key,
          overflowDisabled: index2 > lastVisibleIndex
        }, child)
      );
    })
  ), container2 = /* @__PURE__ */ React.createElement(ForwardOverflow, _extends({
    id: id2,
    ref: containerRef,
    prefixCls: "".concat(prefixCls, "-overflow"),
    component: "ul",
    itemComponent: MenuItem$2,
    className: cn(prefixCls, "".concat(prefixCls, "-root"), "".concat(prefixCls, "-").concat(internalMode), className, _defineProperty$2(_defineProperty$2({}, "".concat(prefixCls, "-inline-collapsed"), internalInlineCollapsed), "".concat(prefixCls, "-rtl"), isRtl), rootClassName),
    dir: direction,
    style: style2,
    role: "menu",
    tabIndex,
    data: wrappedChildList,
    renderRawItem: /* @__PURE__ */ __name(function(node2) {
      return node2;
    }, "renderRawItem"),
    renderRawRest: /* @__PURE__ */ __name(function(omitItems) {
      var len = omitItems.length, originOmitItems = len ? childList.slice(-len) : null;
      return /* @__PURE__ */ React.createElement(SubMenu$1, {
        eventKey: OVERFLOW_KEY,
        title: overflowedIndicator,
        disabled: allVisible,
        internalPopupClose: len === 0,
        popupClassName: overflowedIndicatorPopupClassName
      }, originOmitItems);
    }, "renderRawRest"),
    maxCount: internalMode !== "horizontal" || disabledOverflow ? ForwardOverflow.INVALIDATE : ForwardOverflow.RESPONSIVE,
    ssr: "full",
    "data-menu-list": !0,
    onVisibleChange: /* @__PURE__ */ __name(function(newLastIndex) {
      setLastVisibleIndex(newLastIndex);
    }, "onVisibleChange"),
    onKeyDown: onInternalKeyDown
  }, restProps));
  return /* @__PURE__ */ React.createElement(PrivateContext.Provider, {
    value: privateContext
  }, /* @__PURE__ */ React.createElement(IdContext.Provider, {
    value: uuid2
  }, /* @__PURE__ */ React.createElement(InheritableContextProvider, {
    prefixCls,
    rootClassName,
    mode: internalMode,
    openKeys: mergedOpenKeys,
    rtl: isRtl,
    disabled,
    motion: mounted ? motion2 : null,
    defaultMotions: mounted ? defaultMotions : null,
    activeKey: mergedActiveKey,
    onActive,
    onInactive,
    selectedKeys: mergedSelectKeys,
    inlineIndent,
    subMenuOpenDelay,
    subMenuCloseDelay,
    forceSubMenuRender,
    builtinPlacements,
    triggerSubMenuAction,
    getPopupContainer,
    itemIcon,
    expandIcon,
    onItemClick: onInternalClick,
    onOpenChange: onInternalOpenChange
  }, /* @__PURE__ */ React.createElement(PathUserContext.Provider, {
    value: pathUserContext
  }, container2), /* @__PURE__ */ React.createElement("div", {
    style: {
      display: "none"
    },
    "aria-hidden": !0
  }, /* @__PURE__ */ React.createElement(PathRegisterContext.Provider, {
    value: registerPathContext
  }, measureChildList)))));
}), ExportMenu = Menu$1;
ExportMenu.Item = MenuItem$2;
ExportMenu.SubMenu = SubMenu$1;
ExportMenu.ItemGroup = MenuItemGroup;
ExportMenu.Divider = Divider;
var BarsOutlined$1 = { icon: { tag: "svg", attrs: { viewBox: "0 0 1024 1024", focusable: "false" }, children: [{ tag: "path", attrs: { d: "M912 192H328c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h584c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zm0 284H328c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h584c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zm0 284H328c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h584c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zM104 228a56 56 0 10112 0 56 56 0 10-112 0zm0 284a56 56 0 10112 0 56 56 0 10-112 0zm0 284a56 56 0 10112 0 56 56 0 10-112 0z" } }] }, name: "bars", theme: "outlined" }, BarsOutlined = /* @__PURE__ */ __name(function(props, ref) {
  return /* @__PURE__ */ React.createElement(Icon$3, _extends({}, props, {
    ref,
    icon: BarsOutlined$1
  }));
}, "BarsOutlined"), RefIcon$u = /* @__PURE__ */ React.forwardRef(BarsOutlined);
process.env.NODE_ENV !== "production" && (RefIcon$u.displayName = "BarsOutlined");
var LeftOutlined$1 = { icon: { tag: "svg", attrs: { viewBox: "64 64 896 896", focusable: "false" }, children: [{ tag: "path", attrs: { d: "M724 218.3V141c0-6.7-7.7-10.4-12.9-6.3L260.3 486.8a31.86 31.86 0 000 50.3l450.8 352.1c5.3 4.1 12.9.4 12.9-6.3v-77.3c0-4.9-2.3-9.6-6.1-12.6l-360-281 360-281.1c3.8-3 6.1-7.7 6.1-12.6z" } }] }, name: "left", theme: "outlined" }, LeftOutlined = /* @__PURE__ */ __name(function(props, ref) {
  return /* @__PURE__ */ React.createElement(Icon$3, _extends({}, props, {
    ref,
    icon: LeftOutlined$1
  }));
}, "LeftOutlined"), RefIcon$t = /* @__PURE__ */ React.forwardRef(LeftOutlined);
process.env.NODE_ENV !== "production" && (RefIcon$t.displayName = "LeftOutlined");
const isNumeric = /* @__PURE__ */ __name((value) => !isNaN(parseFloat(value)) && isFinite(value), "isNumeric"), LayoutContext = /* @__PURE__ */ React.createContext({
  siderHook: {
    addSider: /* @__PURE__ */ __name(() => null, "addSider"),
    removeSider: /* @__PURE__ */ __name(() => null, "removeSider")
  }
}), genLayoutStyle = /* @__PURE__ */ __name((token2) => {
  const {
    antCls,
    // .ant
    componentCls,
    // .ant-layout
    colorText,
    footerBg,
    headerHeight,
    headerPadding,
    headerColor,
    footerPadding,
    fontSize,
    bodyBg,
    headerBg
  } = token2;
  return {
    [componentCls]: {
      display: "flex",
      flex: "auto",
      flexDirection: "column",
      /* fix firefox can't set height smaller than content on flex item */
      minHeight: 0,
      background: bodyBg,
      "&, *": {
        boxSizing: "border-box"
      },
      [`&${componentCls}-has-sider`]: {
        flexDirection: "row",
        [`> ${componentCls}, > ${componentCls}-content`]: {
          // https://segmentfault.com/a/1190000019498300
          width: 0
        }
      },
      [`${componentCls}-header, &${componentCls}-footer`]: {
        flex: "0 0 auto"
      },
      // RTL
      "&-rtl": {
        direction: "rtl"
      }
    },
    // ==================== Header ====================
    [`${componentCls}-header`]: {
      height: headerHeight,
      padding: headerPadding,
      color: headerColor,
      lineHeight: unit$1(headerHeight),
      background: headerBg,
      // Other components/menu/style/index.less line:686
      // Integration with header element so menu items have the same height
      [`${antCls}-menu`]: {
        lineHeight: "inherit"
      }
    },
    // ==================== Footer ====================
    [`${componentCls}-footer`]: {
      padding: footerPadding,
      color: colorText,
      fontSize,
      background: footerBg
    },
    // =================== Content ====================
    [`${componentCls}-content`]: {
      flex: "auto",
      color: colorText,
      // fix firefox can't set height smaller than content on flex item
      minHeight: 0
    }
  };
}, "genLayoutStyle"), prepareComponentToken$h = /* @__PURE__ */ __name((token2) => {
  const {
    colorBgLayout,
    controlHeight,
    controlHeightLG,
    colorText,
    controlHeightSM,
    marginXXS,
    colorTextLightSolid,
    colorBgContainer
  } = token2, paddingInline = controlHeightLG * 1.25;
  return {
    // Deprecated
    colorBgHeader: "#001529",
    colorBgBody: colorBgLayout,
    colorBgTrigger: "#002140",
    bodyBg: colorBgLayout,
    headerBg: "#001529",
    headerHeight: controlHeight * 2,
    headerPadding: `0 ${paddingInline}px`,
    headerColor: colorText,
    footerPadding: `${controlHeightSM}px ${paddingInline}px`,
    footerBg: colorBgLayout,
    siderBg: "#001529",
    triggerHeight: controlHeightLG + marginXXS * 2,
    triggerBg: "#002140",
    triggerColor: colorTextLightSolid,
    zeroTriggerWidth: controlHeightLG,
    zeroTriggerHeight: controlHeightLG,
    lightSiderBg: colorBgContainer,
    lightTriggerBg: colorBgContainer,
    lightTriggerColor: colorText
  };
}, "prepareComponentToken$h"), DEPRECATED_TOKENS = [["colorBgBody", "bodyBg"], ["colorBgHeader", "headerBg"], ["colorBgTrigger", "triggerBg"]], useStyle$l = genStyleHooks("Layout", (token2) => [genLayoutStyle(token2)], prepareComponentToken$h, {
  deprecatedTokens: DEPRECATED_TOKENS
}), genSiderStyle = /* @__PURE__ */ __name((token2) => {
  const {
    componentCls,
    siderBg,
    motionDurationMid,
    motionDurationSlow,
    antCls,
    triggerHeight,
    triggerColor,
    triggerBg,
    headerHeight,
    zeroTriggerWidth,
    zeroTriggerHeight,
    borderRadius,
    lightSiderBg,
    lightTriggerColor,
    lightTriggerBg,
    bodyBg
  } = token2;
  return {
    [componentCls]: {
      position: "relative",
      // fix firefox can't set width smaller than content on flex item
      minWidth: 0,
      background: siderBg,
      transition: `all ${motionDurationMid}, background 0s`,
      "&-has-trigger": {
        paddingBottom: triggerHeight
      },
      "&-right": {
        order: 1
      },
      [`${componentCls}-children`]: {
        height: "100%",
        // Hack for fixing margin collapse bug
        // https://github.com/ant-design/ant-design/issues/7967
        // solution from https://stackoverflow.com/a/33132624/3040605
        marginTop: -0.1,
        paddingTop: 0.1,
        [`${antCls}-menu${antCls}-menu-inline-collapsed`]: {
          width: "auto"
        }
      },
      [`${componentCls}-trigger`]: {
        position: "fixed",
        bottom: 0,
        zIndex: 1,
        height: triggerHeight,
        color: triggerColor,
        lineHeight: unit$1(triggerHeight),
        textAlign: "center",
        background: triggerBg,
        cursor: "pointer",
        transition: `all ${motionDurationMid}`
      },
      [`${antCls}-layout &-zero-width`]: {
        "> *": {
          overflow: "hidden"
        },
        "&-trigger": {
          position: "absolute",
          top: headerHeight,
          insetInlineEnd: token2.calc(zeroTriggerWidth).mul(-1).equal(),
          zIndex: 1,
          width: zeroTriggerWidth,
          height: zeroTriggerHeight,
          color: triggerColor,
          fontSize: token2.fontSizeXL,
          display: "flex",
          alignItems: "center",
          justifyContent: "center",
          background: siderBg,
          borderStartStartRadius: 0,
          borderStartEndRadius: borderRadius,
          borderEndEndRadius: borderRadius,
          borderEndStartRadius: 0,
          cursor: "pointer",
          transition: `background ${motionDurationSlow} ease`,
          "&::after": {
            position: "absolute",
            inset: 0,
            background: "transparent",
            transition: `all ${motionDurationSlow}`,
            content: '""'
          },
          "&:hover::after": {
            background: "rgba(255, 255, 255, 0.2)"
          },
          "&-right": {
            insetInlineStart: token2.calc(zeroTriggerWidth).mul(-1).equal(),
            borderStartStartRadius: borderRadius,
            borderStartEndRadius: 0,
            borderEndEndRadius: 0,
            borderEndStartRadius: borderRadius
          }
        }
      },
      // Light
      "&-light": {
        background: lightSiderBg,
        [`${componentCls}-trigger`]: {
          color: lightTriggerColor,
          background: lightTriggerBg
        },
        [`${componentCls}-zero-width-trigger`]: {
          color: lightTriggerColor,
          background: lightTriggerBg,
          border: `1px solid ${bodyBg}`,
          // Safe to modify to any other color
          borderInlineStart: 0
        }
      }
    }
  };
}, "genSiderStyle"), useStyle$k = genStyleHooks(["Layout", "Sider"], (token2) => [genSiderStyle(token2)], prepareComponentToken$h, {
  deprecatedTokens: DEPRECATED_TOKENS
});
var __rest$J = function(s, e2) {
  var t2 = {};
  for (var p in s) Object.prototype.hasOwnProperty.call(s, p) && e2.indexOf(p) < 0 && (t2[p] = s[p]);
  if (s != null && typeof Object.getOwnPropertySymbols == "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++)
    e2.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]) && (t2[p[i]] = s[p[i]]);
  return t2;
};
const dimensionMaxMap = {
  xs: "479.98px",
  sm: "575.98px",
  md: "767.98px",
  lg: "991.98px",
  xl: "1199.98px",
  xxl: "1599.98px"
}, SiderContext = /* @__PURE__ */ React.createContext({}), generateId = /* @__PURE__ */ (() => {
  let i = 0;
  return function() {
    let prefix = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "";
    return i += 1, `${prefix}${i}`;
  };
})(), Sider = /* @__PURE__ */ React.forwardRef((props, ref) => {
  const {
    prefixCls: customizePrefixCls,
    className,
    trigger,
    children,
    defaultCollapsed = !1,
    theme: theme2 = "dark",
    style: style2 = {},
    collapsible = !1,
    reverseArrow = !1,
    width = 200,
    collapsedWidth = 80,
    zeroWidthTriggerStyle,
    breakpoint,
    onCollapse,
    onBreakpoint
  } = props, otherProps = __rest$J(props, ["prefixCls", "className", "trigger", "children", "defaultCollapsed", "theme", "style", "collapsible", "reverseArrow", "width", "collapsedWidth", "zeroWidthTriggerStyle", "breakpoint", "onCollapse", "onBreakpoint"]), {
    siderHook
  } = useContext$1(LayoutContext), [collapsed, setCollapsed] = useState("collapsed" in props ? props.collapsed : defaultCollapsed), [below, setBelow] = useState(!1);
  useEffect(() => {
    "collapsed" in props && setCollapsed(props.collapsed);
  }, [props.collapsed]);
  const handleSetCollapsed = /* @__PURE__ */ __name((value, type4) => {
    "collapsed" in props || setCollapsed(value), onCollapse == null || onCollapse(value, type4);
  }, "handleSetCollapsed"), {
    getPrefixCls
  } = useContext$1(ConfigContext), prefixCls = getPrefixCls("layout-sider", customizePrefixCls), [wrapCSSVar, hashId, cssVarCls] = useStyle$k(prefixCls), responsiveHandlerRef = useRef(null);
  responsiveHandlerRef.current = (mql) => {
    setBelow(mql.matches), onBreakpoint == null || onBreakpoint(mql.matches), collapsed !== mql.matches && handleSetCollapsed(mql.matches, "responsive");
  }, useEffect(() => {
    function responsiveHandler(mql2) {
      return responsiveHandlerRef.current(mql2);
    }
    __name(responsiveHandler, "responsiveHandler");
    let mql;
    if (typeof window < "u") {
      const {
        matchMedia
      } = window;
      if (matchMedia && breakpoint && breakpoint in dimensionMaxMap) {
        mql = matchMedia(`screen and (max-width: ${dimensionMaxMap[breakpoint]})`);
        try {
          mql.addEventListener("change", responsiveHandler);
        } catch {
          mql.addListener(responsiveHandler);
        }
        responsiveHandler(mql);
      }
    }
    return () => {
      try {
        mql == null || mql.removeEventListener("change", responsiveHandler);
      } catch {
        mql == null || mql.removeListener(responsiveHandler);
      }
    };
  }, [breakpoint]), useEffect(() => {
    const uniqueId = generateId("ant-sider-");
    return siderHook.addSider(uniqueId), () => siderHook.removeSider(uniqueId);
  }, []);
  const toggle = /* @__PURE__ */ __name(() => {
    handleSetCollapsed(!collapsed, "clickTrigger");
  }, "toggle"), renderSider = /* @__PURE__ */ __name(() => {
    const divProps = omit(otherProps, ["collapsed"]), rawWidth = collapsed ? collapsedWidth : width, siderWidth = isNumeric(rawWidth) ? `${rawWidth}px` : String(rawWidth), zeroWidthTrigger = parseFloat(String(collapsedWidth || 0)) === 0 ? /* @__PURE__ */ React.createElement("span", {
      onClick: toggle,
      className: cn(`${prefixCls}-zero-width-trigger`, `${prefixCls}-zero-width-trigger-${reverseArrow ? "right" : "left"}`),
      style: zeroWidthTriggerStyle
    }, trigger || /* @__PURE__ */ React.createElement(RefIcon$u, null)) : null, defaultTrigger = {
      expanded: reverseArrow ? /* @__PURE__ */ React.createElement(RefIcon$y, null) : /* @__PURE__ */ React.createElement(RefIcon$t, null),
      collapsed: reverseArrow ? /* @__PURE__ */ React.createElement(RefIcon$t, null) : /* @__PURE__ */ React.createElement(RefIcon$y, null)
    }[collapsed ? "collapsed" : "expanded"], triggerDom = trigger !== null ? zeroWidthTrigger || /* @__PURE__ */ React.createElement("div", {
      className: `${prefixCls}-trigger`,
      onClick: toggle,
      style: {
        width: siderWidth
      }
    }, trigger || defaultTrigger) : null, divStyle = Object.assign(Object.assign({}, style2), {
      flex: `0 0 ${siderWidth}`,
      maxWidth: siderWidth,
      minWidth: siderWidth,
      width: siderWidth
    }), siderCls = cn(prefixCls, `${prefixCls}-${theme2}`, {
      [`${prefixCls}-collapsed`]: !!collapsed,
      [`${prefixCls}-has-trigger`]: collapsible && trigger !== null && !zeroWidthTrigger,
      [`${prefixCls}-below`]: !!below,
      [`${prefixCls}-zero-width`]: parseFloat(siderWidth) === 0
    }, className, hashId, cssVarCls);
    return /* @__PURE__ */ React.createElement("aside", Object.assign({
      className: siderCls
    }, divProps, {
      style: divStyle,
      ref
    }), /* @__PURE__ */ React.createElement("div", {
      className: `${prefixCls}-children`
    }, children), collapsible || below && zeroWidthTrigger ? triggerDom : null);
  }, "renderSider"), contextValue = React.useMemo(() => ({
    siderCollapsed: collapsed
  }), [collapsed]);
  return wrapCSSVar(/* @__PURE__ */ React.createElement(SiderContext.Provider, {
    value: contextValue
  }, renderSider()));
});
process.env.NODE_ENV !== "production" && (Sider.displayName = "Sider");
var EllipsisOutlined$1 = { icon: { tag: "svg", attrs: { viewBox: "64 64 896 896", focusable: "false" }, children: [{ tag: "path", attrs: { d: "M176 511a56 56 0 10112 0 56 56 0 10-112 0zm280 0a56 56 0 10112 0 56 56 0 10-112 0zm280 0a56 56 0 10112 0 56 56 0 10-112 0z" } }] }, name: "ellipsis", theme: "outlined" }, EllipsisOutlined = /* @__PURE__ */ __name(function(props, ref) {
  return /* @__PURE__ */ React.createElement(Icon$3, _extends({}, props, {
    ref,
    icon: EllipsisOutlined$1
  }));
}, "EllipsisOutlined"), RefIcon$s = /* @__PURE__ */ React.forwardRef(EllipsisOutlined);
process.env.NODE_ENV !== "production" && (RefIcon$s.displayName = "EllipsisOutlined");
const MenuContext = /* @__PURE__ */ createContext$1({
  prefixCls: "",
  firstLevel: !0,
  inlineCollapsed: !1
});
var __rest$I = function(s, e2) {
  var t2 = {};
  for (var p in s) Object.prototype.hasOwnProperty.call(s, p) && e2.indexOf(p) < 0 && (t2[p] = s[p]);
  if (s != null && typeof Object.getOwnPropertySymbols == "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++)
    e2.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]) && (t2[p[i]] = s[p[i]]);
  return t2;
};
const MenuDivider = /* @__PURE__ */ __name((props) => {
  const {
    prefixCls: customizePrefixCls,
    className,
    dashed
  } = props, restProps = __rest$I(props, ["prefixCls", "className", "dashed"]), {
    getPrefixCls
  } = React.useContext(ConfigContext), prefixCls = getPrefixCls("menu", customizePrefixCls), classString = cn({
    [`${prefixCls}-item-divider-dashed`]: !!dashed
  }, className);
  return /* @__PURE__ */ React.createElement(Divider, Object.assign({
    className: classString
  }, restProps));
}, "MenuDivider"), MenuItem = /* @__PURE__ */ __name((props) => {
  var _a;
  const {
    className,
    children,
    icon,
    title: title2,
    danger,
    extra
  } = props, {
    prefixCls,
    firstLevel,
    direction,
    disableMenuItemTitleTooltip,
    inlineCollapsed: isInlineCollapsed
  } = React.useContext(MenuContext), renderItemChildren = /* @__PURE__ */ __name((inlineCollapsed) => {
    const label2 = children == null ? void 0 : children[0], wrapNode = /* @__PURE__ */ React.createElement("span", {
      className: cn(`${prefixCls}-title-content`, {
        [`${prefixCls}-title-content-with-extra`]: !!extra || extra === 0
      })
    }, children);
    return (!icon || /* @__PURE__ */ React.isValidElement(children) && children.type === "span") && children && inlineCollapsed && firstLevel && typeof label2 == "string" ? /* @__PURE__ */ React.createElement("div", {
      className: `${prefixCls}-inline-collapsed-noicon`
    }, label2.charAt(0)) : wrapNode;
  }, "renderItemChildren"), {
    siderCollapsed
  } = React.useContext(SiderContext);
  let tooltipTitle = title2;
  typeof title2 > "u" ? tooltipTitle = firstLevel ? children : "" : title2 === !1 && (tooltipTitle = "");
  const tooltipProps = {
    title: tooltipTitle
  };
  !siderCollapsed && !isInlineCollapsed && (tooltipProps.title = null, tooltipProps.open = !1);
  const childrenLength = toArray$7(children).length;
  let returnNode = /* @__PURE__ */ React.createElement(MenuItem$2, Object.assign({}, omit(props, ["title", "icon", "danger"]), {
    className: cn({
      [`${prefixCls}-item-danger`]: danger,
      [`${prefixCls}-item-only-child`]: (icon ? childrenLength + 1 : childrenLength) === 1
    }, className),
    title: typeof title2 == "string" ? title2 : void 0
  }), cloneElement(icon, {
    className: cn(/* @__PURE__ */ React.isValidElement(icon) ? (_a = icon.props) === null || _a === void 0 ? void 0 : _a.className : "", `${prefixCls}-item-icon`)
  }), renderItemChildren(isInlineCollapsed));
  return disableMenuItemTitleTooltip || (returnNode = /* @__PURE__ */ React.createElement(Tooltip$1, Object.assign({}, tooltipProps, {
    placement: direction === "rtl" ? "left" : "right",
    overlayClassName: `${prefixCls}-inline-collapsed-tooltip`
  }), returnNode)), returnNode;
}, "MenuItem");
var __rest$H = function(s, e2) {
  var t2 = {};
  for (var p in s) Object.prototype.hasOwnProperty.call(s, p) && e2.indexOf(p) < 0 && (t2[p] = s[p]);
  if (s != null && typeof Object.getOwnPropertySymbols == "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++)
    e2.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]) && (t2[p[i]] = s[p[i]]);
  return t2;
};
const OverrideContext = /* @__PURE__ */ React.createContext(null), OverrideProvider = /* @__PURE__ */ React.forwardRef((props, ref) => {
  const {
    children
  } = props, restProps = __rest$H(props, ["children"]), override = React.useContext(OverrideContext), context = React.useMemo(() => Object.assign(Object.assign({}, override), restProps), [
    override,
    restProps.prefixCls,
    // restProps.expandIcon, Not mark as deps since this is a ReactNode
    restProps.mode,
    restProps.selectable,
    restProps.rootClassName
    // restProps.validator, Not mark as deps since this is a function
  ]), canRef = supportNodeRef(children), mergedRef = useComposeRef(ref, canRef ? getNodeRef(children) : null);
  return /* @__PURE__ */ React.createElement(OverrideContext.Provider, {
    value: context
  }, /* @__PURE__ */ React.createElement(ContextIsolator, {
    space: !0
  }, canRef ? /* @__PURE__ */ React.cloneElement(children, {
    ref: mergedRef
  }) : children));
}), getHorizontalStyle = /* @__PURE__ */ __name((token2) => {
  const {
    componentCls,
    motionDurationSlow,
    horizontalLineHeight,
    colorSplit,
    lineWidth,
    lineType,
    itemPaddingInline
  } = token2;
  return {
    [`${componentCls}-horizontal`]: {
      lineHeight: horizontalLineHeight,
      border: 0,
      borderBottom: `${unit$1(lineWidth)} ${lineType} ${colorSplit}`,
      boxShadow: "none",
      "&::after": {
        display: "block",
        clear: "both",
        height: 0,
        content: '"\\20"'
      },
      // ======================= Item =======================
      [`${componentCls}-item, ${componentCls}-submenu`]: {
        position: "relative",
        display: "inline-block",
        verticalAlign: "bottom",
        paddingInline: itemPaddingInline
      },
      [`> ${componentCls}-item:hover,
        > ${componentCls}-item-active,
        > ${componentCls}-submenu ${componentCls}-submenu-title:hover`]: {
        backgroundColor: "transparent"
      },
      [`${componentCls}-item, ${componentCls}-submenu-title`]: {
        transition: [`border-color ${motionDurationSlow}`, `background ${motionDurationSlow}`].join(",")
      },
      // ===================== Sub Menu =====================
      [`${componentCls}-submenu-arrow`]: {
        display: "none"
      }
    }
  };
}, "getHorizontalStyle"), getRTLStyle = /* @__PURE__ */ __name((_ref) => {
  let {
    componentCls,
    menuArrowOffset,
    calc
  } = _ref;
  return {
    [`${componentCls}-rtl`]: {
      direction: "rtl"
    },
    [`${componentCls}-submenu-rtl`]: {
      transformOrigin: "100% 0"
    },
    // Vertical Arrow
    [`${componentCls}-rtl${componentCls}-vertical,
    ${componentCls}-submenu-rtl ${componentCls}-vertical`]: {
      [`${componentCls}-submenu-arrow`]: {
        "&::before": {
          transform: `rotate(-45deg) translateY(${unit$1(calc(menuArrowOffset).mul(-1).equal())})`
        },
        "&::after": {
          transform: `rotate(45deg) translateY(${unit$1(menuArrowOffset)})`
        }
      }
    }
  };
}, "getRTLStyle"), accessibilityFocus = /* @__PURE__ */ __name((token2) => Object.assign({}, genFocusOutline(token2)), "accessibilityFocus"), getThemeStyle = /* @__PURE__ */ __name((token2, themeSuffix) => {
  const {
    componentCls,
    itemColor,
    itemSelectedColor,
    groupTitleColor,
    itemBg,
    subMenuItemBg,
    itemSelectedBg,
    activeBarHeight,
    activeBarWidth,
    activeBarBorderWidth,
    motionDurationSlow,
    motionEaseInOut,
    motionEaseOut,
    itemPaddingInline,
    motionDurationMid,
    itemHoverColor,
    lineType,
    colorSplit,
    // Disabled
    itemDisabledColor,
    // Danger
    dangerItemColor,
    dangerItemHoverColor,
    dangerItemSelectedColor,
    dangerItemActiveBg,
    dangerItemSelectedBg,
    // Bg
    popupBg,
    itemHoverBg,
    itemActiveBg,
    menuSubMenuBg,
    // Horizontal
    horizontalItemSelectedColor,
    horizontalItemSelectedBg,
    horizontalItemBorderRadius,
    horizontalItemHoverBg
  } = token2;
  return {
    [`${componentCls}-${themeSuffix}, ${componentCls}-${themeSuffix} > ${componentCls}`]: {
      color: itemColor,
      background: itemBg,
      [`&${componentCls}-root:focus-visible`]: Object.assign({}, accessibilityFocus(token2)),
      // ======================== Item ========================
      [`${componentCls}-item`]: {
        "&-group-title, &-extra": {
          color: groupTitleColor
        }
      },
      [`${componentCls}-submenu-selected`]: {
        [`> ${componentCls}-submenu-title`]: {
          color: itemSelectedColor
        }
      },
      [`${componentCls}-item, ${componentCls}-submenu-title`]: {
        color: itemColor,
        [`&:not(${componentCls}-item-disabled):focus-visible`]: Object.assign({}, accessibilityFocus(token2))
      },
      // Disabled
      [`${componentCls}-item-disabled, ${componentCls}-submenu-disabled`]: {
        color: `${itemDisabledColor} !important`
      },
      // Hover
      [`${componentCls}-item:not(${componentCls}-item-selected):not(${componentCls}-submenu-selected)`]: {
        [`&:hover, > ${componentCls}-submenu-title:hover`]: {
          color: itemHoverColor
        }
      },
      [`&:not(${componentCls}-horizontal)`]: {
        [`${componentCls}-item:not(${componentCls}-item-selected)`]: {
          "&:hover": {
            backgroundColor: itemHoverBg
          },
          "&:active": {
            backgroundColor: itemActiveBg
          }
        },
        [`${componentCls}-submenu-title`]: {
          "&:hover": {
            backgroundColor: itemHoverBg
          },
          "&:active": {
            backgroundColor: itemActiveBg
          }
        }
      },
      // Danger - only Item has
      [`${componentCls}-item-danger`]: {
        color: dangerItemColor,
        [`&${componentCls}-item:hover`]: {
          [`&:not(${componentCls}-item-selected):not(${componentCls}-submenu-selected)`]: {
            color: dangerItemHoverColor
          }
        },
        [`&${componentCls}-item:active`]: {
          background: dangerItemActiveBg
        }
      },
      [`${componentCls}-item a`]: {
        "&, &:hover": {
          color: "inherit"
        }
      },
      [`${componentCls}-item-selected`]: {
        color: itemSelectedColor,
        // Danger
        [`&${componentCls}-item-danger`]: {
          color: dangerItemSelectedColor
        },
        "a, a:hover": {
          color: "inherit"
        }
      },
      [`& ${componentCls}-item-selected`]: {
        backgroundColor: itemSelectedBg,
        // Danger
        [`&${componentCls}-item-danger`]: {
          backgroundColor: dangerItemSelectedBg
        }
      },
      [`&${componentCls}-submenu > ${componentCls}`]: {
        backgroundColor: menuSubMenuBg
      },
      // ===== 设置浮层的颜色 =======
      // ！dark 模式会被popupBg 会被rest 为 darkPopupBg
      [`&${componentCls}-popup > ${componentCls}`]: {
        backgroundColor: popupBg
      },
      [`&${componentCls}-submenu-popup > ${componentCls}`]: {
        backgroundColor: popupBg
      },
      // ===== 设置浮层的颜色 end =======
      // ====================== Horizontal ======================
      [`&${componentCls}-horizontal`]: Object.assign(Object.assign({}, themeSuffix === "dark" ? {
        borderBottom: 0
      } : {}), {
        [`> ${componentCls}-item, > ${componentCls}-submenu`]: {
          top: activeBarBorderWidth,
          marginTop: token2.calc(activeBarBorderWidth).mul(-1).equal(),
          marginBottom: 0,
          borderRadius: horizontalItemBorderRadius,
          "&::after": {
            position: "absolute",
            insetInline: itemPaddingInline,
            bottom: 0,
            borderBottom: `${unit$1(activeBarHeight)} solid transparent`,
            transition: `border-color ${motionDurationSlow} ${motionEaseInOut}`,
            content: '""'
          },
          "&:hover, &-active, &-open": {
            background: horizontalItemHoverBg,
            "&::after": {
              borderBottomWidth: activeBarHeight,
              borderBottomColor: horizontalItemSelectedColor
            }
          },
          "&-selected": {
            color: horizontalItemSelectedColor,
            backgroundColor: horizontalItemSelectedBg,
            "&:hover": {
              backgroundColor: horizontalItemSelectedBg
            },
            "&::after": {
              borderBottomWidth: activeBarHeight,
              borderBottomColor: horizontalItemSelectedColor
            }
          }
        }
      }),
      // ================== Inline & Vertical ===================
      //
      [`&${componentCls}-root`]: {
        [`&${componentCls}-inline, &${componentCls}-vertical`]: {
          borderInlineEnd: `${unit$1(activeBarBorderWidth)} ${lineType} ${colorSplit}`
        }
      },
      // ======================== Inline ========================
      [`&${componentCls}-inline`]: {
        // Sub
        [`${componentCls}-sub${componentCls}-inline`]: {
          background: subMenuItemBg
        },
        [`${componentCls}-item`]: {
          position: "relative",
          "&::after": {
            position: "absolute",
            insetBlock: 0,
            insetInlineEnd: 0,
            borderInlineEnd: `${unit$1(activeBarWidth)} solid ${itemSelectedColor}`,
            transform: "scaleY(0.0001)",
            opacity: 0,
            transition: [`transform ${motionDurationMid} ${motionEaseOut}`, `opacity ${motionDurationMid} ${motionEaseOut}`].join(","),
            content: '""'
          },
          // Danger
          [`&${componentCls}-item-danger`]: {
            "&::after": {
              borderInlineEndColor: dangerItemSelectedColor
            }
          }
        },
        [`${componentCls}-selected, ${componentCls}-item-selected`]: {
          "&::after": {
            transform: "scaleY(1)",
            opacity: 1,
            transition: [`transform ${motionDurationMid} ${motionEaseInOut}`, `opacity ${motionDurationMid} ${motionEaseInOut}`].join(",")
          }
        }
      }
    }
  };
}, "getThemeStyle"), getVerticalInlineStyle = /* @__PURE__ */ __name((token2) => {
  const {
    componentCls,
    itemHeight,
    itemMarginInline,
    padding,
    menuArrowSize,
    marginXS,
    itemMarginBlock,
    itemWidth,
    itemPaddingInline
  } = token2, paddingWithArrow = token2.calc(menuArrowSize).add(padding).add(marginXS).equal();
  return {
    [`${componentCls}-item`]: {
      position: "relative",
      overflow: "hidden"
    },
    [`${componentCls}-item, ${componentCls}-submenu-title`]: {
      height: itemHeight,
      lineHeight: unit$1(itemHeight),
      paddingInline: itemPaddingInline,
      overflow: "hidden",
      textOverflow: "ellipsis",
      marginInline: itemMarginInline,
      marginBlock: itemMarginBlock,
      width: itemWidth
    },
    [`> ${componentCls}-item,
            > ${componentCls}-submenu > ${componentCls}-submenu-title`]: {
      height: itemHeight,
      lineHeight: unit$1(itemHeight)
    },
    [`${componentCls}-item-group-list ${componentCls}-submenu-title,
            ${componentCls}-submenu-title`]: {
      paddingInlineEnd: paddingWithArrow
    }
  };
}, "getVerticalInlineStyle"), getVerticalStyle = /* @__PURE__ */ __name((token2) => {
  const {
    componentCls,
    iconCls,
    itemHeight,
    colorTextLightSolid,
    dropdownWidth,
    controlHeightLG,
    motionEaseOut,
    paddingXL,
    itemMarginInline,
    fontSizeLG,
    motionDurationFast,
    motionDurationSlow,
    paddingXS,
    boxShadowSecondary,
    collapsedWidth,
    collapsedIconSize
  } = token2, inlineItemStyle = {
    height: itemHeight,
    lineHeight: unit$1(itemHeight),
    listStylePosition: "inside",
    listStyleType: "disc"
  };
  return [
    {
      [componentCls]: {
        "&-inline, &-vertical": Object.assign({
          [`&${componentCls}-root`]: {
            boxShadow: "none"
          }
        }, getVerticalInlineStyle(token2))
      },
      [`${componentCls}-submenu-popup`]: {
        [`${componentCls}-vertical`]: Object.assign(Object.assign({}, getVerticalInlineStyle(token2)), {
          boxShadow: boxShadowSecondary
        })
      }
    },
    // Vertical only
    {
      [`${componentCls}-submenu-popup ${componentCls}-vertical${componentCls}-sub`]: {
        minWidth: dropdownWidth,
        maxHeight: `calc(100vh - ${unit$1(token2.calc(controlHeightLG).mul(2.5).equal())})`,
        padding: "0",
        overflow: "hidden",
        borderInlineEnd: 0,
        // https://github.com/ant-design/ant-design/issues/22244
        // https://github.com/ant-design/ant-design/issues/26812
        "&:not([class*='-active'])": {
          overflowX: "hidden",
          overflowY: "auto"
        }
      }
    },
    // Inline Only
    {
      [`${componentCls}-inline`]: {
        width: "100%",
        // Motion enhance for first level
        [`&${componentCls}-root`]: {
          [`${componentCls}-item, ${componentCls}-submenu-title`]: {
            display: "flex",
            alignItems: "center",
            transition: [`border-color ${motionDurationSlow}`, `background ${motionDurationSlow}`, `padding ${motionDurationFast} ${motionEaseOut}`].join(","),
            [`> ${componentCls}-title-content`]: {
              flex: "auto",
              minWidth: 0,
              overflow: "hidden",
              textOverflow: "ellipsis"
            },
            "> *": {
              flex: "none"
            }
          }
        },
        // >>>>> Sub
        [`${componentCls}-sub${componentCls}-inline`]: {
          padding: 0,
          border: 0,
          borderRadius: 0,
          boxShadow: "none",
          [`& > ${componentCls}-submenu > ${componentCls}-submenu-title`]: inlineItemStyle,
          [`& ${componentCls}-item-group-title`]: {
            paddingInlineStart: paddingXL
          }
        },
        // >>>>> Item
        [`${componentCls}-item`]: inlineItemStyle
      }
    },
    // Inline Collapse Only
    {
      [`${componentCls}-inline-collapsed`]: {
        width: collapsedWidth,
        [`&${componentCls}-root`]: {
          [`${componentCls}-item, ${componentCls}-submenu ${componentCls}-submenu-title`]: {
            [`> ${componentCls}-inline-collapsed-noicon`]: {
              fontSize: fontSizeLG,
              textAlign: "center"
            }
          }
        },
        [`> ${componentCls}-item,
          > ${componentCls}-item-group > ${componentCls}-item-group-list > ${componentCls}-item,
          > ${componentCls}-item-group > ${componentCls}-item-group-list > ${componentCls}-submenu > ${componentCls}-submenu-title,
          > ${componentCls}-submenu > ${componentCls}-submenu-title`]: {
          insetInlineStart: 0,
          paddingInline: `calc(50% - ${unit$1(token2.calc(collapsedIconSize).div(2).equal())} - ${unit$1(itemMarginInline)})`,
          textOverflow: "clip",
          [`
            ${componentCls}-submenu-arrow,
            ${componentCls}-submenu-expand-icon
          `]: {
            opacity: 0
          },
          [`${componentCls}-item-icon, ${iconCls}`]: {
            margin: 0,
            fontSize: collapsedIconSize,
            lineHeight: unit$1(itemHeight),
            "+ span": {
              display: "inline-block",
              opacity: 0
            }
          }
        },
        [`${componentCls}-item-icon, ${iconCls}`]: {
          display: "inline-block"
        },
        "&-tooltip": {
          pointerEvents: "none",
          [`${componentCls}-item-icon, ${iconCls}`]: {
            display: "none"
          },
          "a, a:hover": {
            color: colorTextLightSolid
          }
        },
        [`${componentCls}-item-group-title`]: Object.assign(Object.assign({}, textEllipsis), {
          paddingInline: paddingXS
        })
      }
    }
  ];
}, "getVerticalStyle"), genMenuItemStyle = /* @__PURE__ */ __name((token2) => {
  const {
    componentCls,
    motionDurationSlow,
    motionDurationMid,
    motionEaseInOut,
    motionEaseOut,
    iconCls,
    iconSize,
    iconMarginInlineEnd
  } = token2;
  return {
    // >>>>> Item
    [`${componentCls}-item, ${componentCls}-submenu-title`]: {
      position: "relative",
      display: "block",
      margin: 0,
      whiteSpace: "nowrap",
      cursor: "pointer",
      transition: [`border-color ${motionDurationSlow}`, `background ${motionDurationSlow}`, `padding calc(${motionDurationSlow} + 0.1s) ${motionEaseInOut}`].join(","),
      [`${componentCls}-item-icon, ${iconCls}`]: {
        minWidth: iconSize,
        fontSize: iconSize,
        transition: [`font-size ${motionDurationMid} ${motionEaseOut}`, `margin ${motionDurationSlow} ${motionEaseInOut}`, `color ${motionDurationSlow}`].join(","),
        "+ span": {
          marginInlineStart: iconMarginInlineEnd,
          opacity: 1,
          transition: [`opacity ${motionDurationSlow} ${motionEaseInOut}`, `margin ${motionDurationSlow}`, `color ${motionDurationSlow}`].join(",")
        }
      },
      [`${componentCls}-item-icon`]: Object.assign({}, resetIcon()),
      [`&${componentCls}-item-only-child`]: {
        [`> ${iconCls}, > ${componentCls}-item-icon`]: {
          marginInlineEnd: 0
        }
      }
    },
    // Disabled state sets text to gray and nukes hover/tab effects
    [`${componentCls}-item-disabled, ${componentCls}-submenu-disabled`]: {
      background: "none !important",
      cursor: "not-allowed",
      "&::after": {
        borderColor: "transparent !important"
      },
      a: {
        color: "inherit !important"
      },
      [`> ${componentCls}-submenu-title`]: {
        color: "inherit !important",
        cursor: "not-allowed"
      }
    }
  };
}, "genMenuItemStyle"), genSubMenuArrowStyle = /* @__PURE__ */ __name((token2) => {
  const {
    componentCls,
    motionDurationSlow,
    motionEaseInOut,
    borderRadius,
    menuArrowSize,
    menuArrowOffset
  } = token2;
  return {
    [`${componentCls}-submenu`]: {
      "&-expand-icon, &-arrow": {
        position: "absolute",
        top: "50%",
        insetInlineEnd: token2.margin,
        width: menuArrowSize,
        color: "currentcolor",
        transform: "translateY(-50%)",
        transition: `transform ${motionDurationSlow} ${motionEaseInOut}, opacity ${motionDurationSlow}`
      },
      "&-arrow": {
        // →
        "&::before, &::after": {
          position: "absolute",
          width: token2.calc(menuArrowSize).mul(0.6).equal(),
          height: token2.calc(menuArrowSize).mul(0.15).equal(),
          backgroundColor: "currentcolor",
          borderRadius,
          transition: [`background ${motionDurationSlow} ${motionEaseInOut}`, `transform ${motionDurationSlow} ${motionEaseInOut}`, `top ${motionDurationSlow} ${motionEaseInOut}`, `color ${motionDurationSlow} ${motionEaseInOut}`].join(","),
          content: '""'
        },
        "&::before": {
          transform: `rotate(45deg) translateY(${unit$1(token2.calc(menuArrowOffset).mul(-1).equal())})`
        },
        "&::after": {
          transform: `rotate(-45deg) translateY(${unit$1(menuArrowOffset)})`
        }
      }
    }
  };
}, "genSubMenuArrowStyle"), getBaseStyle = /* @__PURE__ */ __name((token2) => {
  const {
    antCls,
    componentCls,
    fontSize,
    motionDurationSlow,
    motionDurationMid,
    motionEaseInOut,
    paddingXS,
    padding,
    colorSplit,
    lineWidth,
    zIndexPopup,
    borderRadiusLG,
    subMenuItemBorderRadius,
    menuArrowSize,
    menuArrowOffset,
    lineType,
    groupTitleLineHeight,
    groupTitleFontSize
  } = token2;
  return [
    // Misc
    {
      "": {
        [componentCls]: Object.assign(Object.assign({}, clearFix()), {
          // Hidden
          "&-hidden": {
            display: "none"
          }
        })
      },
      [`${componentCls}-submenu-hidden`]: {
        display: "none"
      }
    },
    {
      [componentCls]: Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, resetComponent(token2)), clearFix()), {
        marginBottom: 0,
        paddingInlineStart: 0,
        // Override default ul/ol
        fontSize,
        lineHeight: 0,
        listStyle: "none",
        outline: "none",
        // Magic cubic here but smooth transition
        transition: `width ${motionDurationSlow} cubic-bezier(0.2, 0, 0, 1) 0s`,
        "ul, ol": {
          margin: 0,
          padding: 0,
          listStyle: "none"
        },
        // Overflow ellipsis
        "&-overflow": {
          display: "flex",
          [`${componentCls}-item`]: {
            flex: "none"
          }
        },
        [`${componentCls}-item, ${componentCls}-submenu, ${componentCls}-submenu-title`]: {
          borderRadius: token2.itemBorderRadius
        },
        [`${componentCls}-item-group-title`]: {
          padding: `${unit$1(paddingXS)} ${unit$1(padding)}`,
          fontSize: groupTitleFontSize,
          lineHeight: groupTitleLineHeight,
          transition: `all ${motionDurationSlow}`
        },
        [`&-horizontal ${componentCls}-submenu`]: {
          transition: [`border-color ${motionDurationSlow} ${motionEaseInOut}`, `background ${motionDurationSlow} ${motionEaseInOut}`].join(",")
        },
        [`${componentCls}-submenu, ${componentCls}-submenu-inline`]: {
          transition: [`border-color ${motionDurationSlow} ${motionEaseInOut}`, `background ${motionDurationSlow} ${motionEaseInOut}`, `padding ${motionDurationMid} ${motionEaseInOut}`].join(",")
        },
        [`${componentCls}-submenu ${componentCls}-sub`]: {
          cursor: "initial",
          transition: [`background ${motionDurationSlow} ${motionEaseInOut}`, `padding ${motionDurationSlow} ${motionEaseInOut}`].join(",")
        },
        [`${componentCls}-title-content`]: {
          transition: `color ${motionDurationSlow}`,
          "&-with-extra": {
            display: "inline-flex",
            alignItems: "center",
            width: "100%"
          },
          // https://github.com/ant-design/ant-design/issues/41143
          [`> ${antCls}-typography-ellipsis-single-line`]: {
            display: "inline",
            verticalAlign: "unset"
          },
          [`${componentCls}-item-extra`]: {
            marginInlineStart: "auto",
            paddingInlineStart: token2.padding,
            fontSize: token2.fontSizeSM
          }
        },
        [`${componentCls}-item a`]: {
          "&::before": {
            position: "absolute",
            inset: 0,
            backgroundColor: "transparent",
            content: '""'
          }
        },
        // Removed a Badge related style seems it's safe
        // https://github.com/ant-design/ant-design/issues/19809
        // >>>>> Divider
        [`${componentCls}-item-divider`]: {
          overflow: "hidden",
          lineHeight: 0,
          borderColor: colorSplit,
          borderStyle: lineType,
          borderWidth: 0,
          borderTopWidth: lineWidth,
          marginBlock: lineWidth,
          padding: 0,
          "&-dashed": {
            borderStyle: "dashed"
          }
        }
      }), genMenuItemStyle(token2)), {
        [`${componentCls}-item-group`]: {
          [`${componentCls}-item-group-list`]: {
            margin: 0,
            padding: 0,
            [`${componentCls}-item, ${componentCls}-submenu-title`]: {
              paddingInline: `${unit$1(token2.calc(fontSize).mul(2).equal())} ${unit$1(padding)}`
            }
          }
        },
        // ======================= Sub Menu =======================
        "&-submenu": {
          "&-popup": {
            position: "absolute",
            zIndex: zIndexPopup,
            borderRadius: borderRadiusLG,
            boxShadow: "none",
            transformOrigin: "0 0",
            [`&${componentCls}-submenu`]: {
              background: "transparent"
            },
            // https://github.com/ant-design/ant-design/issues/13955
            "&::before": {
              position: "absolute",
              inset: 0,
              zIndex: -1,
              width: "100%",
              height: "100%",
              opacity: 0,
              content: '""'
            },
            [`> ${componentCls}`]: Object.assign(Object.assign(Object.assign({
              borderRadius: borderRadiusLG
            }, genMenuItemStyle(token2)), genSubMenuArrowStyle(token2)), {
              [`${componentCls}-item, ${componentCls}-submenu > ${componentCls}-submenu-title`]: {
                borderRadius: subMenuItemBorderRadius
              },
              [`${componentCls}-submenu-title::after`]: {
                transition: `transform ${motionDurationSlow} ${motionEaseInOut}`
              }
            })
          },
          "\n          &-placement-leftTop,\n          &-placement-bottomRight,\n          ": {
            transformOrigin: "100% 0"
          },
          "\n          &-placement-leftBottom,\n          &-placement-topRight,\n          ": {
            transformOrigin: "100% 100%"
          },
          "\n          &-placement-rightBottom,\n          &-placement-topLeft,\n          ": {
            transformOrigin: "0 100%"
          },
          "\n          &-placement-bottomLeft,\n          &-placement-rightTop,\n          ": {
            transformOrigin: "0 0"
          },
          "\n          &-placement-leftTop,\n          &-placement-leftBottom\n          ": {
            paddingInlineEnd: token2.paddingXS
          },
          "\n          &-placement-rightTop,\n          &-placement-rightBottom\n          ": {
            paddingInlineStart: token2.paddingXS
          },
          "\n          &-placement-topRight,\n          &-placement-topLeft\n          ": {
            paddingBottom: token2.paddingXS
          },
          "\n          &-placement-bottomRight,\n          &-placement-bottomLeft\n          ": {
            paddingTop: token2.paddingXS
          }
        }
      }), genSubMenuArrowStyle(token2)), {
        [`&-inline-collapsed ${componentCls}-submenu-arrow,
        &-inline ${componentCls}-submenu-arrow`]: {
          // ↓
          "&::before": {
            transform: `rotate(-45deg) translateX(${unit$1(menuArrowOffset)})`
          },
          "&::after": {
            transform: `rotate(45deg) translateX(${unit$1(token2.calc(menuArrowOffset).mul(-1).equal())})`
          }
        },
        [`${componentCls}-submenu-open${componentCls}-submenu-inline > ${componentCls}-submenu-title > ${componentCls}-submenu-arrow`]: {
          // ↑
          transform: `translateY(${unit$1(token2.calc(menuArrowSize).mul(0.2).mul(-1).equal())})`,
          "&::after": {
            transform: `rotate(-45deg) translateX(${unit$1(token2.calc(menuArrowOffset).mul(-1).equal())})`
          },
          "&::before": {
            transform: `rotate(45deg) translateX(${unit$1(menuArrowOffset)})`
          }
        }
      })
    },
    // Integration with header element so menu items have the same height
    {
      [`${antCls}-layout-header`]: {
        [componentCls]: {
          lineHeight: "inherit"
        }
      }
    }
  ];
}, "getBaseStyle"), prepareComponentToken$g = /* @__PURE__ */ __name((token2) => {
  var _a, _b, _c;
  const {
    colorPrimary,
    colorError,
    colorTextDisabled,
    colorErrorBg,
    colorText,
    colorTextDescription,
    colorBgContainer,
    colorFillAlter,
    colorFillContent,
    lineWidth,
    lineWidthBold,
    controlItemBgActive,
    colorBgTextHover,
    controlHeightLG,
    lineHeight,
    colorBgElevated,
    marginXXS,
    padding,
    fontSize,
    controlHeightSM,
    fontSizeLG,
    colorTextLightSolid,
    colorErrorHover
  } = token2, activeBarWidth = (_a = token2.activeBarWidth) !== null && _a !== void 0 ? _a : 0, activeBarBorderWidth = (_b = token2.activeBarBorderWidth) !== null && _b !== void 0 ? _b : lineWidth, itemMarginInline = (_c = token2.itemMarginInline) !== null && _c !== void 0 ? _c : token2.marginXXS, colorTextDark = new TinyColor(colorTextLightSolid).setAlpha(0.65).toRgbString();
  return {
    dropdownWidth: 160,
    zIndexPopup: token2.zIndexPopupBase + 50,
    radiusItem: token2.borderRadiusLG,
    itemBorderRadius: token2.borderRadiusLG,
    radiusSubMenuItem: token2.borderRadiusSM,
    subMenuItemBorderRadius: token2.borderRadiusSM,
    colorItemText: colorText,
    itemColor: colorText,
    colorItemTextHover: colorText,
    itemHoverColor: colorText,
    colorItemTextHoverHorizontal: colorPrimary,
    horizontalItemHoverColor: colorPrimary,
    colorGroupTitle: colorTextDescription,
    groupTitleColor: colorTextDescription,
    colorItemTextSelected: colorPrimary,
    itemSelectedColor: colorPrimary,
    colorItemTextSelectedHorizontal: colorPrimary,
    horizontalItemSelectedColor: colorPrimary,
    colorItemBg: colorBgContainer,
    itemBg: colorBgContainer,
    colorItemBgHover: colorBgTextHover,
    itemHoverBg: colorBgTextHover,
    colorItemBgActive: colorFillContent,
    itemActiveBg: controlItemBgActive,
    colorSubItemBg: colorFillAlter,
    subMenuItemBg: colorFillAlter,
    colorItemBgSelected: controlItemBgActive,
    itemSelectedBg: controlItemBgActive,
    colorItemBgSelectedHorizontal: "transparent",
    horizontalItemSelectedBg: "transparent",
    colorActiveBarWidth: 0,
    activeBarWidth,
    colorActiveBarHeight: lineWidthBold,
    activeBarHeight: lineWidthBold,
    colorActiveBarBorderSize: lineWidth,
    activeBarBorderWidth,
    // Disabled
    colorItemTextDisabled: colorTextDisabled,
    itemDisabledColor: colorTextDisabled,
    // Danger
    colorDangerItemText: colorError,
    dangerItemColor: colorError,
    colorDangerItemTextHover: colorError,
    dangerItemHoverColor: colorError,
    colorDangerItemTextSelected: colorError,
    dangerItemSelectedColor: colorError,
    colorDangerItemBgActive: colorErrorBg,
    dangerItemActiveBg: colorErrorBg,
    colorDangerItemBgSelected: colorErrorBg,
    dangerItemSelectedBg: colorErrorBg,
    itemMarginInline,
    horizontalItemBorderRadius: 0,
    horizontalItemHoverBg: "transparent",
    itemHeight: controlHeightLG,
    groupTitleLineHeight: lineHeight,
    collapsedWidth: controlHeightLG * 2,
    popupBg: colorBgElevated,
    itemMarginBlock: marginXXS,
    itemPaddingInline: padding,
    horizontalLineHeight: `${controlHeightLG * 1.15}px`,
    iconSize: fontSize,
    iconMarginInlineEnd: controlHeightSM - fontSize,
    collapsedIconSize: fontSizeLG,
    groupTitleFontSize: fontSize,
    // Disabled
    darkItemDisabledColor: new TinyColor(colorTextLightSolid).setAlpha(0.25).toRgbString(),
    // Dark
    darkItemColor: colorTextDark,
    darkDangerItemColor: colorError,
    darkItemBg: "#001529",
    darkPopupBg: "#001529",
    darkSubMenuItemBg: "#000c17",
    darkItemSelectedColor: colorTextLightSolid,
    darkItemSelectedBg: colorPrimary,
    darkDangerItemSelectedBg: colorError,
    darkItemHoverBg: "transparent",
    darkGroupTitleColor: colorTextDark,
    darkItemHoverColor: colorTextLightSolid,
    darkDangerItemHoverColor: colorErrorHover,
    darkDangerItemSelectedColor: colorTextLightSolid,
    darkDangerItemActiveBg: colorError,
    // internal
    itemWidth: activeBarWidth ? `calc(100% + ${activeBarBorderWidth}px)` : `calc(100% - ${itemMarginInline * 2}px)`
  };
}, "prepareComponentToken$g"), useStyle$j = /* @__PURE__ */ __name(function(prefixCls) {
  let rootCls = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : prefixCls, injectStyle = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !0;
  return genStyleHooks("Menu", (token2) => {
    const {
      colorBgElevated,
      controlHeightLG,
      fontSize,
      darkItemColor,
      darkDangerItemColor,
      darkItemBg,
      darkSubMenuItemBg,
      darkItemSelectedColor,
      darkItemSelectedBg,
      darkDangerItemSelectedBg,
      darkItemHoverBg,
      darkGroupTitleColor,
      darkItemHoverColor,
      darkItemDisabledColor,
      darkDangerItemHoverColor,
      darkDangerItemSelectedColor,
      darkDangerItemActiveBg,
      popupBg,
      darkPopupBg
    } = token2, menuArrowSize = token2.calc(fontSize).div(7).mul(5).equal(), menuToken = merge(token2, {
      menuArrowSize,
      menuHorizontalHeight: token2.calc(controlHeightLG).mul(1.15).equal(),
      menuArrowOffset: token2.calc(menuArrowSize).mul(0.25).equal(),
      menuSubMenuBg: colorBgElevated,
      calc: token2.calc,
      popupBg
    }), menuDarkToken = merge(menuToken, {
      itemColor: darkItemColor,
      itemHoverColor: darkItemHoverColor,
      groupTitleColor: darkGroupTitleColor,
      itemSelectedColor: darkItemSelectedColor,
      itemBg: darkItemBg,
      popupBg: darkPopupBg,
      subMenuItemBg: darkSubMenuItemBg,
      itemActiveBg: "transparent",
      itemSelectedBg: darkItemSelectedBg,
      activeBarHeight: 0,
      activeBarBorderWidth: 0,
      itemHoverBg: darkItemHoverBg,
      // Disabled
      itemDisabledColor: darkItemDisabledColor,
      // Danger
      dangerItemColor: darkDangerItemColor,
      dangerItemHoverColor: darkDangerItemHoverColor,
      dangerItemSelectedColor: darkDangerItemSelectedColor,
      dangerItemActiveBg: darkDangerItemActiveBg,
      dangerItemSelectedBg: darkDangerItemSelectedBg,
      menuSubMenuBg: darkSubMenuItemBg,
      // Horizontal
      horizontalItemSelectedColor: darkItemSelectedColor,
      horizontalItemSelectedBg: darkItemSelectedBg
    });
    return [
      // Basic
      getBaseStyle(menuToken),
      // Horizontal
      getHorizontalStyle(menuToken),
      // Hard code for some light style
      // Vertical
      getVerticalStyle(menuToken),
      // Hard code for some light style
      // Theme
      getThemeStyle(menuToken, "light"),
      getThemeStyle(menuDarkToken, "dark"),
      // RTL
      getRTLStyle(menuToken),
      // Motion
      genCollapseMotion(menuToken),
      initSlideMotion(menuToken, "slide-up"),
      initSlideMotion(menuToken, "slide-down"),
      initZoomMotion(menuToken, "zoom-big")
    ];
  }, prepareComponentToken$g, {
    deprecatedTokens: [["colorGroupTitle", "groupTitleColor"], ["radiusItem", "itemBorderRadius"], ["radiusSubMenuItem", "subMenuItemBorderRadius"], ["colorItemText", "itemColor"], ["colorItemTextHover", "itemHoverColor"], ["colorItemTextHoverHorizontal", "horizontalItemHoverColor"], ["colorItemTextSelected", "itemSelectedColor"], ["colorItemTextSelectedHorizontal", "horizontalItemSelectedColor"], ["colorItemTextDisabled", "itemDisabledColor"], ["colorDangerItemText", "dangerItemColor"], ["colorDangerItemTextHover", "dangerItemHoverColor"], ["colorDangerItemTextSelected", "dangerItemSelectedColor"], ["colorDangerItemBgActive", "dangerItemActiveBg"], ["colorDangerItemBgSelected", "dangerItemSelectedBg"], ["colorItemBg", "itemBg"], ["colorItemBgHover", "itemHoverBg"], ["colorSubItemBg", "subMenuItemBg"], ["colorItemBgActive", "itemActiveBg"], ["colorItemBgSelectedHorizontal", "horizontalItemSelectedBg"], ["colorActiveBarWidth", "activeBarWidth"], ["colorActiveBarHeight", "activeBarHeight"], ["colorActiveBarBorderSize", "activeBarBorderWidth"], ["colorItemBgSelected", "itemSelectedBg"]],
    // Dropdown will handle menu style self. We do not need to handle this.
    injectStyle,
    unitless: {
      groupTitleLineHeight: !0
    }
  })(prefixCls, rootCls);
}, "useStyle$j"), SubMenu = /* @__PURE__ */ __name((props) => {
  var _a;
  const {
    popupClassName,
    icon,
    title: title2,
    theme: customTheme
  } = props, context = React.useContext(MenuContext), {
    prefixCls,
    inlineCollapsed,
    theme: contextTheme
  } = context, parentPath = useFullPath();
  let titleNode;
  if (!icon)
    titleNode = inlineCollapsed && !parentPath.length && title2 && typeof title2 == "string" ? /* @__PURE__ */ React.createElement("div", {
      className: `${prefixCls}-inline-collapsed-noicon`
    }, title2.charAt(0)) : /* @__PURE__ */ React.createElement("span", {
      className: `${prefixCls}-title-content`
    }, title2);
  else {
    const titleIsSpan = /* @__PURE__ */ React.isValidElement(title2) && title2.type === "span";
    titleNode = /* @__PURE__ */ React.createElement(React.Fragment, null, cloneElement(icon, {
      className: cn(/* @__PURE__ */ React.isValidElement(icon) ? (_a = icon.props) === null || _a === void 0 ? void 0 : _a.className : "", `${prefixCls}-item-icon`)
    }), titleIsSpan ? title2 : /* @__PURE__ */ React.createElement("span", {
      className: `${prefixCls}-title-content`
    }, title2));
  }
  const contextValue = React.useMemo(() => Object.assign(Object.assign({}, context), {
    firstLevel: !1
  }), [context]), [zIndex] = useZIndex("Menu");
  return /* @__PURE__ */ React.createElement(MenuContext.Provider, {
    value: contextValue
  }, /* @__PURE__ */ React.createElement(SubMenu$1, Object.assign({}, omit(props, ["icon"]), {
    title: titleNode,
    popupClassName: cn(prefixCls, popupClassName, `${prefixCls}-${customTheme || contextTheme}`),
    popupStyle: Object.assign({
      zIndex
    }, props.popupStyle)
  })));
}, "SubMenu");
var __rest$G = function(s, e2) {
  var t2 = {};
  for (var p in s) Object.prototype.hasOwnProperty.call(s, p) && e2.indexOf(p) < 0 && (t2[p] = s[p]);
  if (s != null && typeof Object.getOwnPropertySymbols == "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++)
    e2.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]) && (t2[p[i]] = s[p[i]]);
  return t2;
};
function isEmptyIcon(icon) {
  return icon === null || icon === !1;
}
__name(isEmptyIcon, "isEmptyIcon");
const MENU_COMPONENTS = {
  item: MenuItem,
  submenu: SubMenu,
  divider: MenuDivider
}, InternalMenu = /* @__PURE__ */ forwardRef((props, ref) => {
  var _a;
  const override = React.useContext(OverrideContext), overrideObj = override || {}, {
    getPrefixCls,
    getPopupContainer,
    direction,
    menu
  } = React.useContext(ConfigContext), rootPrefixCls = getPrefixCls(), {
    prefixCls: customizePrefixCls,
    className,
    style: style2,
    theme: theme2 = "light",
    expandIcon,
    _internalDisableMenuItemTitleTooltip,
    inlineCollapsed,
    siderCollapsed,
    rootClassName,
    mode,
    selectable,
    onClick,
    overflowedIndicatorPopupClassName
  } = props, restProps = __rest$G(props, ["prefixCls", "className", "style", "theme", "expandIcon", "_internalDisableMenuItemTitleTooltip", "inlineCollapsed", "siderCollapsed", "rootClassName", "mode", "selectable", "onClick", "overflowedIndicatorPopupClassName"]), passedProps = omit(restProps, ["collapsedWidth"]);
  if (process.env.NODE_ENV !== "production") {
    const warning3 = devUseWarning("Menu");
    process.env.NODE_ENV !== "production" && warning3(!("inlineCollapsed" in props && mode !== "inline"), "usage", "`inlineCollapsed` should only be used when `mode` is inline."), warning3.deprecated("items" in props && !props.children, "children", "items");
  }
  (_a = overrideObj.validator) === null || _a === void 0 || _a.call(overrideObj, {
    mode
  });
  const onItemClick = useEvent(function() {
    var _a2;
    onClick == null || onClick.apply(void 0, arguments), (_a2 = overrideObj.onClick) === null || _a2 === void 0 || _a2.call(overrideObj);
  }), mergedMode = overrideObj.mode || mode, mergedSelectable = selectable ?? overrideObj.selectable, mergedInlineCollapsed = inlineCollapsed ?? siderCollapsed, defaultMotions = {
    horizontal: {
      motionName: `${rootPrefixCls}-slide-up`
    },
    inline: initCollapseMotion(rootPrefixCls),
    other: {
      motionName: `${rootPrefixCls}-zoom-big`
    }
  }, prefixCls = getPrefixCls("menu", customizePrefixCls || overrideObj.prefixCls), rootCls = useCSSVarCls(prefixCls), [wrapCSSVar, hashId, cssVarCls] = useStyle$j(prefixCls, rootCls, !override), menuClassName = cn(`${prefixCls}-${theme2}`, menu == null ? void 0 : menu.className, className), mergedExpandIcon = React.useMemo(() => {
    var _a2, _b;
    if (typeof expandIcon == "function" || isEmptyIcon(expandIcon))
      return expandIcon || null;
    if (typeof overrideObj.expandIcon == "function" || isEmptyIcon(overrideObj.expandIcon))
      return overrideObj.expandIcon || null;
    if (typeof (menu == null ? void 0 : menu.expandIcon) == "function" || isEmptyIcon(menu == null ? void 0 : menu.expandIcon))
      return (menu == null ? void 0 : menu.expandIcon) || null;
    const mergedIcon = (_a2 = expandIcon ?? (overrideObj == null ? void 0 : overrideObj.expandIcon)) !== null && _a2 !== void 0 ? _a2 : menu == null ? void 0 : menu.expandIcon;
    return cloneElement(mergedIcon, {
      className: cn(`${prefixCls}-submenu-expand-icon`, /* @__PURE__ */ React.isValidElement(mergedIcon) ? (_b = mergedIcon.props) === null || _b === void 0 ? void 0 : _b.className : void 0)
    });
  }, [expandIcon, overrideObj == null ? void 0 : overrideObj.expandIcon, menu == null ? void 0 : menu.expandIcon, prefixCls]), contextValue = React.useMemo(() => ({
    prefixCls,
    inlineCollapsed: mergedInlineCollapsed || !1,
    direction,
    firstLevel: !0,
    theme: theme2,
    mode: mergedMode,
    disableMenuItemTitleTooltip: _internalDisableMenuItemTitleTooltip
  }), [prefixCls, mergedInlineCollapsed, direction, _internalDisableMenuItemTitleTooltip, theme2]);
  return wrapCSSVar(/* @__PURE__ */ React.createElement(OverrideContext.Provider, {
    value: null
  }, /* @__PURE__ */ React.createElement(MenuContext.Provider, {
    value: contextValue
  }, /* @__PURE__ */ React.createElement(ExportMenu, Object.assign({
    getPopupContainer,
    overflowedIndicator: /* @__PURE__ */ React.createElement(RefIcon$s, null),
    overflowedIndicatorPopupClassName: cn(prefixCls, `${prefixCls}-${theme2}`, overflowedIndicatorPopupClassName),
    mode: mergedMode,
    selectable: mergedSelectable,
    onClick: onItemClick
  }, passedProps, {
    inlineCollapsed: mergedInlineCollapsed,
    style: Object.assign(Object.assign({}, menu == null ? void 0 : menu.style), style2),
    className: menuClassName,
    prefixCls,
    direction,
    defaultMotions,
    expandIcon: mergedExpandIcon,
    ref,
    rootClassName: cn(rootClassName, hashId, overrideObj.rootClassName, cssVarCls, rootCls),
    _internalComponents: MENU_COMPONENTS
  })))));
}), Menu = /* @__PURE__ */ forwardRef((props, ref) => {
  const menuRef = useRef(null), context = React.useContext(SiderContext);
  return useImperativeHandle(ref, () => ({
    menu: menuRef.current,
    focus: /* @__PURE__ */ __name((options) => {
      var _a;
      (_a = menuRef.current) === null || _a === void 0 || _a.focus(options);
    }, "focus")
  })), /* @__PURE__ */ React.createElement(InternalMenu, Object.assign({
    ref: menuRef
  }, props, context));
});
Menu.Item = MenuItem;
Menu.SubMenu = SubMenu;
Menu.Divider = MenuDivider;
Menu.ItemGroup = MenuItemGroup;
process.env.NODE_ENV !== "production" && (Menu.displayName = "Menu");
const genStatusStyle = /* @__PURE__ */ __name((token2) => {
  const {
    componentCls,
    menuCls,
    colorError,
    colorTextLightSolid
  } = token2, itemCls = `${menuCls}-item`;
  return {
    [`${componentCls}, ${componentCls}-menu-submenu`]: {
      [`${menuCls} ${itemCls}`]: {
        [`&${itemCls}-danger:not(${itemCls}-disabled)`]: {
          color: colorError,
          "&:hover": {
            color: colorTextLightSolid,
            backgroundColor: colorError
          }
        }
      }
    }
  };
}, "genStatusStyle"), genBaseStyle$3 = /* @__PURE__ */ __name((token2) => {
  const {
    componentCls,
    menuCls,
    zIndexPopup,
    dropdownArrowDistance,
    sizePopupArrow,
    antCls,
    iconCls,
    motionDurationMid,
    paddingBlock,
    fontSize,
    dropdownEdgeChildPadding,
    colorTextDisabled,
    fontSizeIcon,
    controlPaddingHorizontal,
    colorBgElevated
  } = token2;
  return [
    {
      [componentCls]: {
        position: "absolute",
        top: -9999,
        left: {
          _skip_check_: !0,
          value: -9999
        },
        zIndex: zIndexPopup,
        display: "block",
        // A placeholder out of dropdown visible range to avoid close when user moving
        "&::before": {
          position: "absolute",
          insetBlock: token2.calc(sizePopupArrow).div(2).sub(dropdownArrowDistance).equal(),
          // insetInlineStart: -7, // FIXME: Seems not work for hidden element
          zIndex: -9999,
          opacity: 1e-4,
          content: '""'
        },
        // Makes vertical dropdowns have a scrollbar once they become taller than the viewport.
        "&-menu-vertical": {
          maxHeight: "100vh",
          overflowY: "auto"
        },
        [`&-trigger${antCls}-btn`]: {
          [`& > ${iconCls}-down, & > ${antCls}-btn-icon > ${iconCls}-down`]: {
            fontSize: fontSizeIcon
          }
        },
        [`${componentCls}-wrap`]: {
          position: "relative",
          [`${antCls}-btn > ${iconCls}-down`]: {
            fontSize: fontSizeIcon
          },
          [`${iconCls}-down::before`]: {
            transition: `transform ${motionDurationMid}`
          }
        },
        [`${componentCls}-wrap-open`]: {
          [`${iconCls}-down::before`]: {
            transform: "rotate(180deg)"
          }
        },
        "\n        &-hidden,\n        &-menu-hidden,\n        &-menu-submenu-hidden\n      ": {
          display: "none"
        },
        // =============================================================
        // ==                         Motion                          ==
        // =============================================================
        // When position is not enough for dropdown, the placement will revert.
        // We will handle this with revert motion name.
        [`&${antCls}-slide-down-enter${antCls}-slide-down-enter-active${componentCls}-placement-bottomLeft,
          &${antCls}-slide-down-appear${antCls}-slide-down-appear-active${componentCls}-placement-bottomLeft,
          &${antCls}-slide-down-enter${antCls}-slide-down-enter-active${componentCls}-placement-bottom,
          &${antCls}-slide-down-appear${antCls}-slide-down-appear-active${componentCls}-placement-bottom,
          &${antCls}-slide-down-enter${antCls}-slide-down-enter-active${componentCls}-placement-bottomRight,
          &${antCls}-slide-down-appear${antCls}-slide-down-appear-active${componentCls}-placement-bottomRight`]: {
          animationName: slideUpIn
        },
        [`&${antCls}-slide-up-enter${antCls}-slide-up-enter-active${componentCls}-placement-topLeft,
          &${antCls}-slide-up-appear${antCls}-slide-up-appear-active${componentCls}-placement-topLeft,
          &${antCls}-slide-up-enter${antCls}-slide-up-enter-active${componentCls}-placement-top,
          &${antCls}-slide-up-appear${antCls}-slide-up-appear-active${componentCls}-placement-top,
          &${antCls}-slide-up-enter${antCls}-slide-up-enter-active${componentCls}-placement-topRight,
          &${antCls}-slide-up-appear${antCls}-slide-up-appear-active${componentCls}-placement-topRight`]: {
          animationName: slideDownIn
        },
        [`&${antCls}-slide-down-leave${antCls}-slide-down-leave-active${componentCls}-placement-bottomLeft,
          &${antCls}-slide-down-leave${antCls}-slide-down-leave-active${componentCls}-placement-bottom,
          &${antCls}-slide-down-leave${antCls}-slide-down-leave-active${componentCls}-placement-bottomRight`]: {
          animationName: slideUpOut
        },
        [`&${antCls}-slide-up-leave${antCls}-slide-up-leave-active${componentCls}-placement-topLeft,
          &${antCls}-slide-up-leave${antCls}-slide-up-leave-active${componentCls}-placement-top,
          &${antCls}-slide-up-leave${antCls}-slide-up-leave-active${componentCls}-placement-topRight`]: {
          animationName: slideDownOut
        }
      }
    },
    // =============================================================
    // ==                        Arrow style                      ==
    // =============================================================
    getArrowStyle(token2, colorBgElevated, {
      arrowPlacement: {
        top: !0,
        bottom: !0
      }
    }),
    {
      // =============================================================
      // ==                          Menu                           ==
      // =============================================================
      [`${componentCls} ${menuCls}`]: {
        position: "relative",
        margin: 0
      },
      [`${menuCls}-submenu-popup`]: {
        position: "absolute",
        zIndex: zIndexPopup,
        background: "transparent",
        boxShadow: "none",
        transformOrigin: "0 0",
        "ul, li": {
          listStyle: "none",
          margin: 0
        }
      },
      [`${componentCls}, ${componentCls}-menu-submenu`]: Object.assign(Object.assign({}, resetComponent(token2)), {
        [menuCls]: Object.assign(Object.assign({
          padding: dropdownEdgeChildPadding,
          listStyleType: "none",
          backgroundColor: colorBgElevated,
          backgroundClip: "padding-box",
          borderRadius: token2.borderRadiusLG,
          outline: "none",
          boxShadow: token2.boxShadowSecondary
        }, genFocusStyle(token2)), {
          "&:empty": {
            padding: 0,
            boxShadow: "none"
          },
          [`${menuCls}-item-group-title`]: {
            padding: `${unit$1(paddingBlock)} ${unit$1(controlPaddingHorizontal)}`,
            color: token2.colorTextDescription,
            transition: `all ${motionDurationMid}`
          },
          // ======================= Item Content =======================
          [`${menuCls}-item`]: {
            position: "relative",
            display: "flex",
            alignItems: "center"
          },
          [`${menuCls}-item-icon`]: {
            minWidth: fontSize,
            marginInlineEnd: token2.marginXS,
            fontSize: token2.fontSizeSM
          },
          [`${menuCls}-title-content`]: {
            flex: "auto",
            "&-with-extra": {
              display: "inline-flex",
              alignItems: "center",
              width: "100%"
            },
            "> a": {
              color: "inherit",
              transition: `all ${motionDurationMid}`,
              "&:hover": {
                color: "inherit"
              },
              "&::after": {
                position: "absolute",
                inset: 0,
                content: '""'
              }
            },
            [`${menuCls}-item-extra`]: {
              paddingInlineStart: token2.padding,
              marginInlineStart: "auto",
              fontSize: token2.fontSizeSM,
              color: token2.colorTextDescription
            }
          },
          // =========================== Item ===========================
          [`${menuCls}-item, ${menuCls}-submenu-title`]: Object.assign(Object.assign({
            display: "flex",
            margin: 0,
            padding: `${unit$1(paddingBlock)} ${unit$1(controlPaddingHorizontal)}`,
            color: token2.colorText,
            fontWeight: "normal",
            fontSize,
            lineHeight: token2.lineHeight,
            cursor: "pointer",
            transition: `all ${motionDurationMid}`,
            borderRadius: token2.borderRadiusSM,
            "&:hover, &-active": {
              backgroundColor: token2.controlItemBgHover
            }
          }, genFocusStyle(token2)), {
            "&-selected": {
              color: token2.colorPrimary,
              backgroundColor: token2.controlItemBgActive,
              "&:hover, &-active": {
                backgroundColor: token2.controlItemBgActiveHover
              }
            },
            "&-disabled": {
              color: colorTextDisabled,
              cursor: "not-allowed",
              "&:hover": {
                color: colorTextDisabled,
                backgroundColor: colorBgElevated,
                cursor: "not-allowed"
              },
              a: {
                pointerEvents: "none"
              }
            },
            "&-divider": {
              height: 1,
              // By design
              margin: `${unit$1(token2.marginXXS)} 0`,
              overflow: "hidden",
              lineHeight: 0,
              backgroundColor: token2.colorSplit
            },
            [`${componentCls}-menu-submenu-expand-icon`]: {
              position: "absolute",
              insetInlineEnd: token2.paddingXS,
              [`${componentCls}-menu-submenu-arrow-icon`]: {
                marginInlineEnd: "0 !important",
                color: token2.colorTextDescription,
                fontSize: fontSizeIcon,
                fontStyle: "normal"
              }
            }
          }),
          [`${menuCls}-item-group-list`]: {
            margin: `0 ${unit$1(token2.marginXS)}`,
            padding: 0,
            listStyle: "none"
          },
          [`${menuCls}-submenu-title`]: {
            paddingInlineEnd: token2.calc(controlPaddingHorizontal).add(token2.fontSizeSM).equal()
          },
          [`${menuCls}-submenu-vertical`]: {
            position: "relative"
          },
          [`${menuCls}-submenu${menuCls}-submenu-disabled ${componentCls}-menu-submenu-title`]: {
            [`&, ${componentCls}-menu-submenu-arrow-icon`]: {
              color: colorTextDisabled,
              backgroundColor: colorBgElevated,
              cursor: "not-allowed"
            }
          },
          // https://github.com/ant-design/ant-design/issues/19264
          [`${menuCls}-submenu-selected ${componentCls}-menu-submenu-title`]: {
            color: token2.colorPrimary
          }
        })
      })
    },
    // Follow code may reuse in other components
    [initSlideMotion(token2, "slide-up"), initSlideMotion(token2, "slide-down"), initMoveMotion(token2, "move-up"), initMoveMotion(token2, "move-down"), initZoomMotion(token2, "zoom-big")]
  ];
}, "genBaseStyle$3"), prepareComponentToken$f = /* @__PURE__ */ __name((token2) => Object.assign(Object.assign({
  zIndexPopup: token2.zIndexPopupBase + 50,
  paddingBlock: (token2.controlHeight - token2.fontSize * token2.lineHeight) / 2
}, getArrowOffsetToken({
  contentRadius: token2.borderRadiusLG,
  limitVerticalRadius: !0
})), getArrowToken(token2)), "prepareComponentToken$f"), useStyle$i = genStyleHooks("Dropdown", (token2) => {
  const {
    marginXXS,
    sizePopupArrow,
    paddingXXS,
    componentCls
  } = token2, dropdownToken = merge(token2, {
    menuCls: `${componentCls}-menu`,
    dropdownArrowDistance: token2.calc(sizePopupArrow).div(2).add(marginXXS).equal(),
    dropdownEdgeChildPadding: paddingXXS
  });
  return [genBaseStyle$3(dropdownToken), genStatusStyle(dropdownToken)];
}, prepareComponentToken$f, {
  resetStyle: !1
}), Dropdown$1 = /* @__PURE__ */ __name((props) => {
  var _a;
  const {
    menu,
    arrow,
    prefixCls: customizePrefixCls,
    children,
    trigger,
    disabled,
    dropdownRender,
    getPopupContainer,
    overlayClassName,
    rootClassName,
    overlayStyle,
    open,
    onOpenChange,
    // Deprecated
    visible,
    onVisibleChange,
    mouseEnterDelay = 0.15,
    mouseLeaveDelay = 0.1,
    autoAdjustOverflow: autoAdjustOverflow2 = !0,
    placement = "",
    overlay: overlay2,
    transitionName
  } = props, {
    getPopupContainer: getContextPopupContainer,
    getPrefixCls,
    direction,
    dropdown
  } = React.useContext(ConfigContext), warning3 = devUseWarning("Dropdown");
  process.env.NODE_ENV !== "production" && ([["visible", "open"], ["onVisibleChange", "onOpenChange"]].forEach((_ref) => {
    let [deprecatedName, newName] = _ref;
    warning3.deprecated(!(deprecatedName in props), deprecatedName, newName);
  }), warning3.deprecated(!("overlay" in props), "overlay", "menu"));
  const memoTransitionName = React.useMemo(() => {
    const rootPrefixCls = getPrefixCls();
    return transitionName !== void 0 ? transitionName : placement.includes("top") ? `${rootPrefixCls}-slide-down` : `${rootPrefixCls}-slide-up`;
  }, [getPrefixCls, placement, transitionName]), memoPlacement = React.useMemo(() => placement ? placement.includes("Center") ? placement.slice(0, placement.indexOf("Center")) : placement : direction === "rtl" ? "bottomRight" : "bottomLeft", [placement, direction]);
  if (process.env.NODE_ENV !== "production") {
    if (placement.includes("Center")) {
      const newPlacement = placement.slice(0, placement.indexOf("Center"));
      process.env.NODE_ENV !== "production" && warning3(!placement.includes("Center"), "deprecated", `You are using '${placement}' placement in Dropdown, which is deprecated. Try to use '${newPlacement}' instead.`);
    }
    [["visible", "open"], ["onVisibleChange", "onOpenChange"]].forEach((_ref2) => {
      let [deprecatedName, newName] = _ref2;
      warning3.deprecated(!(deprecatedName in props), deprecatedName, newName);
    });
  }
  const prefixCls = getPrefixCls("dropdown", customizePrefixCls), rootCls = useCSSVarCls(prefixCls), [wrapCSSVar, hashId, cssVarCls] = useStyle$i(prefixCls, rootCls), [, token2] = useToken(), child = React.Children.only(isPrimitive(children) ? /* @__PURE__ */ React.createElement("span", null, children) : children), dropdownTrigger = cloneElement(child, {
    className: cn(`${prefixCls}-trigger`, {
      [`${prefixCls}-rtl`]: direction === "rtl"
    }, child.props.className),
    disabled: (_a = child.props.disabled) !== null && _a !== void 0 ? _a : disabled
  }), triggerActions = disabled ? [] : trigger, alignPoint = !!(triggerActions != null && triggerActions.includes("contextMenu")), [mergedOpen, setOpen] = useMergedState(!1, {
    value: open ?? visible
  }), onInnerOpenChange = useEvent((nextOpen) => {
    onOpenChange == null || onOpenChange(nextOpen, {
      source: "trigger"
    }), onVisibleChange == null || onVisibleChange(nextOpen), setOpen(nextOpen);
  }), overlayClassNameCustomized = cn(overlayClassName, rootClassName, hashId, cssVarCls, rootCls, dropdown == null ? void 0 : dropdown.className, {
    [`${prefixCls}-rtl`]: direction === "rtl"
  }), builtinPlacements = getPlacements({
    arrowPointAtCenter: typeof arrow == "object" && arrow.pointAtCenter,
    autoAdjustOverflow: autoAdjustOverflow2,
    offset: token2.marginXXS,
    arrowWidth: arrow ? token2.sizePopupArrow : 0,
    borderRadius: token2.borderRadius
  }), onMenuClick = React.useCallback(() => {
    menu != null && menu.selectable && (menu != null && menu.multiple) || (onOpenChange == null || onOpenChange(!1, {
      source: "menu"
    }), setOpen(!1));
  }, [menu == null ? void 0 : menu.selectable, menu == null ? void 0 : menu.multiple]), renderOverlay = /* @__PURE__ */ __name(() => {
    let overlayNode;
    return menu != null && menu.items ? overlayNode = /* @__PURE__ */ React.createElement(Menu, Object.assign({}, menu)) : typeof overlay2 == "function" ? overlayNode = overlay2() : overlayNode = overlay2, dropdownRender && (overlayNode = dropdownRender(overlayNode)), overlayNode = React.Children.only(typeof overlayNode == "string" ? /* @__PURE__ */ React.createElement("span", null, overlayNode) : overlayNode), /* @__PURE__ */ React.createElement(OverrideProvider, {
      prefixCls: `${prefixCls}-menu`,
      rootClassName: cn(cssVarCls, rootCls),
      expandIcon: /* @__PURE__ */ React.createElement("span", {
        className: `${prefixCls}-menu-submenu-arrow`
      }, /* @__PURE__ */ React.createElement(RefIcon$y, {
        className: `${prefixCls}-menu-submenu-arrow-icon`
      })),
      mode: "vertical",
      selectable: !1,
      onClick: onMenuClick,
      validator: /* @__PURE__ */ __name((_ref3) => {
        let {
          mode
        } = _ref3;
        process.env.NODE_ENV !== "production" && warning3(!mode || mode === "vertical", "usage", `mode="${mode}" is not supported for Dropdown's Menu.`);
      }, "validator")
    }, overlayNode);
  }, "renderOverlay"), [zIndex, contextZIndex] = useZIndex("Dropdown", overlayStyle == null ? void 0 : overlayStyle.zIndex);
  let renderNode = /* @__PURE__ */ React.createElement(Dropdown$3, Object.assign({
    alignPoint
  }, omit(props, ["rootClassName"]), {
    mouseEnterDelay,
    mouseLeaveDelay,
    visible: mergedOpen,
    builtinPlacements,
    arrow: !!arrow,
    overlayClassName: overlayClassNameCustomized,
    prefixCls,
    getPopupContainer: getPopupContainer || getContextPopupContainer,
    transitionName: memoTransitionName,
    trigger: triggerActions,
    overlay: renderOverlay,
    placement: memoPlacement,
    onVisibleChange: onInnerOpenChange,
    overlayStyle: Object.assign(Object.assign(Object.assign({}, dropdown == null ? void 0 : dropdown.style), overlayStyle), {
      zIndex
    })
  }), dropdownTrigger);
  return zIndex && (renderNode = /* @__PURE__ */ React.createElement(zIndexContext.Provider, {
    value: contextZIndex
  }, renderNode)), wrapCSSVar(renderNode);
}, "Dropdown$1");
function postPureProps(props) {
  return Object.assign(Object.assign({}, props), {
    align: {
      overflow: {
        adjustX: !1,
        adjustY: !1
      }
    }
  });
}
__name(postPureProps, "postPureProps");
const PurePanel$2 = genPurePanel(Dropdown$1, "dropdown", (prefixCls) => prefixCls, postPureProps), WrapPurePanel = /* @__PURE__ */ __name((props) => /* @__PURE__ */ React.createElement(PurePanel$2, Object.assign({}, props), /* @__PURE__ */ React.createElement("span", null)), "WrapPurePanel");
Dropdown$1._InternalPanelDoNotUseOrYouWillBeFired = WrapPurePanel;
process.env.NODE_ENV !== "production" && (Dropdown$1.displayName = "Dropdown");
var dayjs_min = { exports: {} }, hasRequiredDayjs_min;
function requireDayjs_min() {
  return hasRequiredDayjs_min || (hasRequiredDayjs_min = 1, function(module2, exports) {
    (function(t2, e2) {
      module2.exports = e2();
    })(commonjsGlobal, function() {
      var t2 = 1e3, e2 = 6e4, n2 = 36e5, r2 = "millisecond", i = "second", s = "minute", u = "hour", a = "day", o2 = "week", c = "month", f = "quarter", h = "year", d = "date", l2 = "Invalid Date", $ = /^(\d{4})[-/]?(\d{1,2})?[-/]?(\d{0,2})[Tt\s]*(\d{1,2})?:?(\d{1,2})?:?(\d{1,2})?[.:]?(\d+)?$/, y = /\[([^\]]+)]|Y{1,4}|M{1,4}|D{1,2}|d{1,4}|H{1,2}|h{1,2}|a|A|m{1,2}|s{1,2}|Z{1,2}|SSS/g, M = { name: "en", weekdays: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"), months: "January_February_March_April_May_June_July_August_September_October_November_December".split("_"), ordinal: /* @__PURE__ */ __name(function(t3) {
        var e3 = ["th", "st", "nd", "rd"], n3 = t3 % 100;
        return "[" + t3 + (e3[(n3 - 20) % 10] || e3[n3] || e3[0]) + "]";
      }, "ordinal") }, m2 = /* @__PURE__ */ __name(function(t3, e3, n3) {
        var r3 = String(t3);
        return !r3 || r3.length >= e3 ? t3 : "" + Array(e3 + 1 - r3.length).join(n3) + t3;
      }, "m"), v = { s: m2, z: /* @__PURE__ */ __name(function(t3) {
        var e3 = -t3.utcOffset(), n3 = Math.abs(e3), r3 = Math.floor(n3 / 60), i2 = n3 % 60;
        return (e3 <= 0 ? "+" : "-") + m2(r3, 2, "0") + ":" + m2(i2, 2, "0");
      }, "z"), m: /* @__PURE__ */ __name(function t3(e3, n3) {
        if (e3.date() < n3.date()) return -t3(n3, e3);
        var r3 = 12 * (n3.year() - e3.year()) + (n3.month() - e3.month()), i2 = e3.clone().add(r3, c), s2 = n3 - i2 < 0, u2 = e3.clone().add(r3 + (s2 ? -1 : 1), c);
        return +(-(r3 + (n3 - i2) / (s2 ? i2 - u2 : u2 - i2)) || 0);
      }, "t"), a: /* @__PURE__ */ __name(function(t3) {
        return t3 < 0 ? Math.ceil(t3) || 0 : Math.floor(t3);
      }, "a"), p: /* @__PURE__ */ __name(function(t3) {
        return { M: c, y: h, w: o2, d: a, D: d, h: u, m: s, s: i, ms: r2, Q: f }[t3] || String(t3 || "").toLowerCase().replace(/s$/, "");
      }, "p"), u: /* @__PURE__ */ __name(function(t3) {
        return t3 === void 0;
      }, "u") }, g = "en", D = {};
      D[g] = M;
      var p = "$isDayjsObject", S = /* @__PURE__ */ __name(function(t3) {
        return t3 instanceof _2 || !(!t3 || !t3[p]);
      }, "S"), w = /* @__PURE__ */ __name(function t3(e3, n3, r3) {
        var i2;
        if (!e3) return g;
        if (typeof e3 == "string") {
          var s2 = e3.toLowerCase();
          D[s2] && (i2 = s2), n3 && (D[s2] = n3, i2 = s2);
          var u2 = e3.split("-");
          if (!i2 && u2.length > 1) return t3(u2[0]);
        } else {
          var a2 = e3.name;
          D[a2] = e3, i2 = a2;
        }
        return !r3 && i2 && (g = i2), i2 || !r3 && g;
      }, "t"), O = /* @__PURE__ */ __name(function(t3, e3) {
        if (S(t3)) return t3.clone();
        var n3 = typeof e3 == "object" ? e3 : {};
        return n3.date = t3, n3.args = arguments, new _2(n3);
      }, "O"), b = v;
      b.l = w, b.i = S, b.w = function(t3, e3) {
        return O(t3, { locale: e3.$L, utc: e3.$u, x: e3.$x, $offset: e3.$offset });
      };
      var _2 = function() {
        function M2(t3) {
          this.$L = w(t3.locale, null, !0), this.parse(t3), this.$x = this.$x || t3.x || {}, this[p] = !0;
        }
        __name(M2, "M");
        var m3 = M2.prototype;
        return m3.parse = function(t3) {
          this.$d = function(t4) {
            var e3 = t4.date, n3 = t4.utc;
            if (e3 === null) return /* @__PURE__ */ new Date(NaN);
            if (b.u(e3)) return /* @__PURE__ */ new Date();
            if (e3 instanceof Date) return new Date(e3);
            if (typeof e3 == "string" && !/Z$/i.test(e3)) {
              var r3 = e3.match($);
              if (r3) {
                var i2 = r3[2] - 1 || 0, s2 = (r3[7] || "0").substring(0, 3);
                return n3 ? new Date(Date.UTC(r3[1], i2, r3[3] || 1, r3[4] || 0, r3[5] || 0, r3[6] || 0, s2)) : new Date(r3[1], i2, r3[3] || 1, r3[4] || 0, r3[5] || 0, r3[6] || 0, s2);
              }
            }
            return new Date(e3);
          }(t3), this.init();
        }, m3.init = function() {
          var t3 = this.$d;
          this.$y = t3.getFullYear(), this.$M = t3.getMonth(), this.$D = t3.getDate(), this.$W = t3.getDay(), this.$H = t3.getHours(), this.$m = t3.getMinutes(), this.$s = t3.getSeconds(), this.$ms = t3.getMilliseconds();
        }, m3.$utils = function() {
          return b;
        }, m3.isValid = function() {
          return this.$d.toString() !== l2;
        }, m3.isSame = function(t3, e3) {
          var n3 = O(t3);
          return this.startOf(e3) <= n3 && n3 <= this.endOf(e3);
        }, m3.isAfter = function(t3, e3) {
          return O(t3) < this.startOf(e3);
        }, m3.isBefore = function(t3, e3) {
          return this.endOf(e3) < O(t3);
        }, m3.$g = function(t3, e3, n3) {
          return b.u(t3) ? this[e3] : this.set(n3, t3);
        }, m3.unix = function() {
          return Math.floor(this.valueOf() / 1e3);
        }, m3.valueOf = function() {
          return this.$d.getTime();
        }, m3.startOf = function(t3, e3) {
          var n3 = this, r3 = !!b.u(e3) || e3, f2 = b.p(t3), l3 = /* @__PURE__ */ __name(function(t4, e4) {
            var i2 = b.w(n3.$u ? Date.UTC(n3.$y, e4, t4) : new Date(n3.$y, e4, t4), n3);
            return r3 ? i2 : i2.endOf(a);
          }, "l"), $2 = /* @__PURE__ */ __name(function(t4, e4) {
            return b.w(n3.toDate()[t4].apply(n3.toDate("s"), (r3 ? [0, 0, 0, 0] : [23, 59, 59, 999]).slice(e4)), n3);
          }, "$"), y2 = this.$W, M3 = this.$M, m4 = this.$D, v2 = "set" + (this.$u ? "UTC" : "");
          switch (f2) {
            case h:
              return r3 ? l3(1, 0) : l3(31, 11);
            case c:
              return r3 ? l3(1, M3) : l3(0, M3 + 1);
            case o2:
              var g2 = this.$locale().weekStart || 0, D2 = (y2 < g2 ? y2 + 7 : y2) - g2;
              return l3(r3 ? m4 - D2 : m4 + (6 - D2), M3);
            case a:
            case d:
              return $2(v2 + "Hours", 0);
            case u:
              return $2(v2 + "Minutes", 1);
            case s:
              return $2(v2 + "Seconds", 2);
            case i:
              return $2(v2 + "Milliseconds", 3);
            default:
              return this.clone();
          }
        }, m3.endOf = function(t3) {
          return this.startOf(t3, !1);
        }, m3.$set = function(t3, e3) {
          var n3, o3 = b.p(t3), f2 = "set" + (this.$u ? "UTC" : ""), l3 = (n3 = {}, n3[a] = f2 + "Date", n3[d] = f2 + "Date", n3[c] = f2 + "Month", n3[h] = f2 + "FullYear", n3[u] = f2 + "Hours", n3[s] = f2 + "Minutes", n3[i] = f2 + "Seconds", n3[r2] = f2 + "Milliseconds", n3)[o3], $2 = o3 === a ? this.$D + (e3 - this.$W) : e3;
          if (o3 === c || o3 === h) {
            var y2 = this.clone().set(d, 1);
            y2.$d[l3]($2), y2.init(), this.$d = y2.set(d, Math.min(this.$D, y2.daysInMonth())).$d;
          } else l3 && this.$d[l3]($2);
          return this.init(), this;
        }, m3.set = function(t3, e3) {
          return this.clone().$set(t3, e3);
        }, m3.get = function(t3) {
          return this[b.p(t3)]();
        }, m3.add = function(r3, f2) {
          var d2, l3 = this;
          r3 = Number(r3);
          var $2 = b.p(f2), y2 = /* @__PURE__ */ __name(function(t3) {
            var e3 = O(l3);
            return b.w(e3.date(e3.date() + Math.round(t3 * r3)), l3);
          }, "y");
          if ($2 === c) return this.set(c, this.$M + r3);
          if ($2 === h) return this.set(h, this.$y + r3);
          if ($2 === a) return y2(1);
          if ($2 === o2) return y2(7);
          var M3 = (d2 = {}, d2[s] = e2, d2[u] = n2, d2[i] = t2, d2)[$2] || 1, m4 = this.$d.getTime() + r3 * M3;
          return b.w(m4, this);
        }, m3.subtract = function(t3, e3) {
          return this.add(-1 * t3, e3);
        }, m3.format = function(t3) {
          var e3 = this, n3 = this.$locale();
          if (!this.isValid()) return n3.invalidDate || l2;
          var r3 = t3 || "YYYY-MM-DDTHH:mm:ssZ", i2 = b.z(this), s2 = this.$H, u2 = this.$m, a2 = this.$M, o3 = n3.weekdays, c2 = n3.months, f2 = n3.meridiem, h2 = /* @__PURE__ */ __name(function(t4, n4, i3, s3) {
            return t4 && (t4[n4] || t4(e3, r3)) || i3[n4].slice(0, s3);
          }, "h"), d2 = /* @__PURE__ */ __name(function(t4) {
            return b.s(s2 % 12 || 12, t4, "0");
          }, "d"), $2 = f2 || function(t4, e4, n4) {
            var r4 = t4 < 12 ? "AM" : "PM";
            return n4 ? r4.toLowerCase() : r4;
          };
          return r3.replace(y, function(t4, r4) {
            return r4 || function(t5) {
              switch (t5) {
                case "YY":
                  return String(e3.$y).slice(-2);
                case "YYYY":
                  return b.s(e3.$y, 4, "0");
                case "M":
                  return a2 + 1;
                case "MM":
                  return b.s(a2 + 1, 2, "0");
                case "MMM":
                  return h2(n3.monthsShort, a2, c2, 3);
                case "MMMM":
                  return h2(c2, a2);
                case "D":
                  return e3.$D;
                case "DD":
                  return b.s(e3.$D, 2, "0");
                case "d":
                  return String(e3.$W);
                case "dd":
                  return h2(n3.weekdaysMin, e3.$W, o3, 2);
                case "ddd":
                  return h2(n3.weekdaysShort, e3.$W, o3, 3);
                case "dddd":
                  return o3[e3.$W];
                case "H":
                  return String(s2);
                case "HH":
                  return b.s(s2, 2, "0");
                case "h":
                  return d2(1);
                case "hh":
                  return d2(2);
                case "a":
                  return $2(s2, u2, !0);
                case "A":
                  return $2(s2, u2, !1);
                case "m":
                  return String(u2);
                case "mm":
                  return b.s(u2, 2, "0");
                case "s":
                  return String(e3.$s);
                case "ss":
                  return b.s(e3.$s, 2, "0");
                case "SSS":
                  return b.s(e3.$ms, 3, "0");
                case "Z":
                  return i2;
              }
              return null;
            }(t4) || i2.replace(":", "");
          });
        }, m3.utcOffset = function() {
          return 15 * -Math.round(this.$d.getTimezoneOffset() / 15);
        }, m3.diff = function(r3, d2, l3) {
          var $2, y2 = this, M3 = b.p(d2), m4 = O(r3), v2 = (m4.utcOffset() - this.utcOffset()) * e2, g2 = this - m4, D2 = /* @__PURE__ */ __name(function() {
            return b.m(y2, m4);
          }, "D");
          switch (M3) {
            case h:
              $2 = D2() / 12;
              break;
            case c:
              $2 = D2();
              break;
            case f:
              $2 = D2() / 3;
              break;
            case o2:
              $2 = (g2 - v2) / 6048e5;
              break;
            case a:
              $2 = (g2 - v2) / 864e5;
              break;
            case u:
              $2 = g2 / n2;
              break;
            case s:
              $2 = g2 / e2;
              break;
            case i:
              $2 = g2 / t2;
              break;
            default:
              $2 = g2;
          }
          return l3 ? $2 : b.a($2);
        }, m3.daysInMonth = function() {
          return this.endOf(c).$D;
        }, m3.$locale = function() {
          return D[this.$L];
        }, m3.locale = function(t3, e3) {
          if (!t3) return this.$L;
          var n3 = this.clone(), r3 = w(t3, e3, !0);
          return r3 && (n3.$L = r3), n3;
        }, m3.clone = function() {
          return b.w(this.$d, this);
        }, m3.toDate = function() {
          return new Date(this.valueOf());
        }, m3.toJSON = function() {
          return this.isValid() ? this.toISOString() : null;
        }, m3.toISOString = function() {
          return this.$d.toISOString();
        }, m3.toString = function() {
          return this.$d.toUTCString();
        }, M2;
      }(), k = _2.prototype;
      return O.prototype = k, [["$ms", r2], ["$s", i], ["$m", s], ["$H", u], ["$W", a], ["$M", c], ["$y", h], ["$D", d]].forEach(function(t3) {
        k[t3[1]] = function(e3) {
          return this.$g(e3, t3[0], t3[1]);
        };
      }), O.extend = function(t3, e3) {
        return t3.$i || (t3(e3, _2, O), t3.$i = !0), O;
      }, O.locale = w, O.isDayjs = S, O.unix = function(t3) {
        return O(1e3 * t3);
      }, O.en = D[g], O.Ls = D, O.p = {}, O;
    });
  }(dayjs_min)), dayjs_min.exports;
}
__name(requireDayjs_min, "requireDayjs_min");
var dayjs_minExports = requireDayjs_min();
const dayjs = /* @__PURE__ */ getDefaultExportFromCjs(dayjs_minExports);
var weekday$1 = { exports: {} };
(function(module2, exports) {
  (function(e2, t2) {
    module2.exports = t2();
  })(commonjsGlobal, function() {
    return function(e2, t2) {
      t2.prototype.weekday = function(e3) {
        var t3 = this.$locale().weekStart || 0, i = this.$W, n2 = (i < t3 ? i + 7 : i) - t3;
        return this.$utils().u(e3) ? n2 : this.subtract(n2, "day").add(e3, "day");
      };
    };
  });
})(weekday$1);
var weekdayExports = weekday$1.exports;
const weekday = /* @__PURE__ */ getDefaultExportFromCjs(weekdayExports);
var localeData$1 = { exports: {} };
(function(module2, exports) {
  (function(n2, e2) {
    module2.exports = e2();
  })(commonjsGlobal, function() {
    return function(n2, e2, t2) {
      var r2 = e2.prototype, o2 = /* @__PURE__ */ __name(function(n3) {
        return n3 && (n3.indexOf ? n3 : n3.s);
      }, "o"), u = /* @__PURE__ */ __name(function(n3, e3, t3, r3, u2) {
        var i2 = n3.name ? n3 : n3.$locale(), a2 = o2(i2[e3]), s2 = o2(i2[t3]), f = a2 || s2.map(function(n4) {
          return n4.slice(0, r3);
        });
        if (!u2) return f;
        var d = i2.weekStart;
        return f.map(function(n4, e4) {
          return f[(e4 + (d || 0)) % 7];
        });
      }, "u"), i = /* @__PURE__ */ __name(function() {
        return t2.Ls[t2.locale()];
      }, "i"), a = /* @__PURE__ */ __name(function(n3, e3) {
        return n3.formats[e3] || function(n4) {
          return n4.replace(/(\[[^\]]+])|(MMMM|MM|DD|dddd)/g, function(n5, e4, t3) {
            return e4 || t3.slice(1);
          });
        }(n3.formats[e3.toUpperCase()]);
      }, "a"), s = /* @__PURE__ */ __name(function() {
        var n3 = this;
        return { months: /* @__PURE__ */ __name(function(e3) {
          return e3 ? e3.format("MMMM") : u(n3, "months");
        }, "months"), monthsShort: /* @__PURE__ */ __name(function(e3) {
          return e3 ? e3.format("MMM") : u(n3, "monthsShort", "months", 3);
        }, "monthsShort"), firstDayOfWeek: /* @__PURE__ */ __name(function() {
          return n3.$locale().weekStart || 0;
        }, "firstDayOfWeek"), weekdays: /* @__PURE__ */ __name(function(e3) {
          return e3 ? e3.format("dddd") : u(n3, "weekdays");
        }, "weekdays"), weekdaysMin: /* @__PURE__ */ __name(function(e3) {
          return e3 ? e3.format("dd") : u(n3, "weekdaysMin", "weekdays", 2);
        }, "weekdaysMin"), weekdaysShort: /* @__PURE__ */ __name(function(e3) {
          return e3 ? e3.format("ddd") : u(n3, "weekdaysShort", "weekdays", 3);
        }, "weekdaysShort"), longDateFormat: /* @__PURE__ */ __name(function(e3) {
          return a(n3.$locale(), e3);
        }, "longDateFormat"), meridiem: this.$locale().meridiem, ordinal: this.$locale().ordinal };
      }, "s");
      r2.localeData = function() {
        return s.bind(this)();
      }, t2.localeData = function() {
        var n3 = i();
        return { firstDayOfWeek: /* @__PURE__ */ __name(function() {
          return n3.weekStart || 0;
        }, "firstDayOfWeek"), weekdays: /* @__PURE__ */ __name(function() {
          return t2.weekdays();
        }, "weekdays"), weekdaysShort: /* @__PURE__ */ __name(function() {
          return t2.weekdaysShort();
        }, "weekdaysShort"), weekdaysMin: /* @__PURE__ */ __name(function() {
          return t2.weekdaysMin();
        }, "weekdaysMin"), months: /* @__PURE__ */ __name(function() {
          return t2.months();
        }, "months"), monthsShort: /* @__PURE__ */ __name(function() {
          return t2.monthsShort();
        }, "monthsShort"), longDateFormat: /* @__PURE__ */ __name(function(e3) {
          return a(n3, e3);
        }, "longDateFormat"), meridiem: n3.meridiem, ordinal: n3.ordinal };
      }, t2.months = function() {
        return u(i(), "months");
      }, t2.monthsShort = function() {
        return u(i(), "monthsShort", "months", 3);
      }, t2.weekdays = function(n3) {
        return u(i(), "weekdays", null, null, n3);
      }, t2.weekdaysShort = function(n3) {
        return u(i(), "weekdaysShort", "weekdays", 3, n3);
      }, t2.weekdaysMin = function(n3) {
        return u(i(), "weekdaysMin", "weekdays", 2, n3);
      };
    };
  });
})(localeData$1);
var localeDataExports = localeData$1.exports;
const localeData = /* @__PURE__ */ getDefaultExportFromCjs(localeDataExports);
var weekOfYear$1 = { exports: {} };
(function(module2, exports) {
  (function(e2, t2) {
    module2.exports = t2();
  })(commonjsGlobal, function() {
    var e2 = "week", t2 = "year";
    return function(i, n2, r2) {
      var f = n2.prototype;
      f.week = function(i2) {
        if (i2 === void 0 && (i2 = null), i2 !== null) return this.add(7 * (i2 - this.week()), "day");
        var n3 = this.$locale().yearStart || 1;
        if (this.month() === 11 && this.date() > 25) {
          var f2 = r2(this).startOf(t2).add(1, t2).date(n3), s = r2(this).endOf(e2);
          if (f2.isBefore(s)) return 1;
        }
        var a = r2(this).startOf(t2).date(n3).startOf(e2).subtract(1, "millisecond"), o2 = this.diff(a, e2, !0);
        return o2 < 0 ? r2(this).startOf("week").week() : Math.ceil(o2);
      }, f.weeks = function(e3) {
        return e3 === void 0 && (e3 = null), this.week(e3);
      };
    };
  });
})(weekOfYear$1);
var weekOfYearExports = weekOfYear$1.exports;
const weekOfYear = /* @__PURE__ */ getDefaultExportFromCjs(weekOfYearExports);
var weekYear$1 = { exports: {} };
(function(module2, exports) {
  (function(e2, t2) {
    module2.exports = t2();
  })(commonjsGlobal, function() {
    return function(e2, t2) {
      t2.prototype.weekYear = function() {
        var e3 = this.month(), t3 = this.week(), n2 = this.year();
        return t3 === 1 && e3 === 11 ? n2 + 1 : e3 === 0 && t3 >= 52 ? n2 - 1 : n2;
      };
    };
  });
})(weekYear$1);
var weekYearExports = weekYear$1.exports;
const weekYear = /* @__PURE__ */ getDefaultExportFromCjs(weekYearExports);
var advancedFormat$1 = { exports: {} };
(function(module2, exports) {
  (function(e2, t2) {
    module2.exports = t2();
  })(commonjsGlobal, function() {
    return function(e2, t2) {
      var r2 = t2.prototype, n2 = r2.format;
      r2.format = function(e3) {
        var t3 = this, r3 = this.$locale();
        if (!this.isValid()) return n2.bind(this)(e3);
        var s = this.$utils(), a = (e3 || "YYYY-MM-DDTHH:mm:ssZ").replace(/\[([^\]]+)]|Q|wo|ww|w|WW|W|zzz|z|gggg|GGGG|Do|X|x|k{1,2}|S/g, function(e4) {
          switch (e4) {
            case "Q":
              return Math.ceil((t3.$M + 1) / 3);
            case "Do":
              return r3.ordinal(t3.$D);
            case "gggg":
              return t3.weekYear();
            case "GGGG":
              return t3.isoWeekYear();
            case "wo":
              return r3.ordinal(t3.week(), "W");
            case "w":
            case "ww":
              return s.s(t3.week(), e4 === "w" ? 1 : 2, "0");
            case "W":
            case "WW":
              return s.s(t3.isoWeek(), e4 === "W" ? 1 : 2, "0");
            case "k":
            case "kk":
              return s.s(String(t3.$H === 0 ? 24 : t3.$H), e4 === "k" ? 1 : 2, "0");
            case "X":
              return Math.floor(t3.$d.getTime() / 1e3);
            case "x":
              return t3.$d.getTime();
            case "z":
              return "[" + t3.offsetName() + "]";
            case "zzz":
              return "[" + t3.offsetName("long") + "]";
            default:
              return e4;
          }
        });
        return n2.bind(this)(a);
      };
    };
  });
})(advancedFormat$1);
var advancedFormatExports = advancedFormat$1.exports;
const advancedFormat = /* @__PURE__ */ getDefaultExportFromCjs(advancedFormatExports);
var customParseFormat$1 = { exports: {} };
(function(module2, exports) {
  (function(e2, t2) {
    module2.exports = t2();
  })(commonjsGlobal, function() {
    var e2 = { LTS: "h:mm:ss A", LT: "h:mm A", L: "MM/DD/YYYY", LL: "MMMM D, YYYY", LLL: "MMMM D, YYYY h:mm A", LLLL: "dddd, MMMM D, YYYY h:mm A" }, t2 = /(\[[^[]*\])|([-_:/.,()\s]+)|(A|a|Q|YYYY|YY?|ww?|MM?M?M?|Do|DD?|hh?|HH?|mm?|ss?|S{1,3}|z|ZZ?)/g, n2 = /\d/, r2 = /\d\d/, i = /\d\d?/, o2 = /\d*[^-_:/,()\s\d]+/, s = {}, a = /* @__PURE__ */ __name(function(e3) {
      return (e3 = +e3) + (e3 > 68 ? 1900 : 2e3);
    }, "a"), f = /* @__PURE__ */ __name(function(e3) {
      return function(t3) {
        this[e3] = +t3;
      };
    }, "f"), h = [/[+-]\d\d:?(\d\d)?|Z/, function(e3) {
      (this.zone || (this.zone = {})).offset = function(e4) {
        if (!e4 || e4 === "Z") return 0;
        var t3 = e4.match(/([+-]|\d\d)/g), n3 = 60 * t3[1] + (+t3[2] || 0);
        return n3 === 0 ? 0 : t3[0] === "+" ? -n3 : n3;
      }(e3);
    }], u = /* @__PURE__ */ __name(function(e3) {
      var t3 = s[e3];
      return t3 && (t3.indexOf ? t3 : t3.s.concat(t3.f));
    }, "u"), d = /* @__PURE__ */ __name(function(e3, t3) {
      var n3, r3 = s.meridiem;
      if (r3) {
        for (var i2 = 1; i2 <= 24; i2 += 1) if (e3.indexOf(r3(i2, 0, t3)) > -1) {
          n3 = i2 > 12;
          break;
        }
      } else n3 = e3 === (t3 ? "pm" : "PM");
      return n3;
    }, "d"), c = { A: [o2, function(e3) {
      this.afternoon = d(e3, !1);
    }], a: [o2, function(e3) {
      this.afternoon = d(e3, !0);
    }], Q: [n2, function(e3) {
      this.month = 3 * (e3 - 1) + 1;
    }], S: [n2, function(e3) {
      this.milliseconds = 100 * +e3;
    }], SS: [r2, function(e3) {
      this.milliseconds = 10 * +e3;
    }], SSS: [/\d{3}/, function(e3) {
      this.milliseconds = +e3;
    }], s: [i, f("seconds")], ss: [i, f("seconds")], m: [i, f("minutes")], mm: [i, f("minutes")], H: [i, f("hours")], h: [i, f("hours")], HH: [i, f("hours")], hh: [i, f("hours")], D: [i, f("day")], DD: [r2, f("day")], Do: [o2, function(e3) {
      var t3 = s.ordinal, n3 = e3.match(/\d+/);
      if (this.day = n3[0], t3) for (var r3 = 1; r3 <= 31; r3 += 1) t3(r3).replace(/\[|\]/g, "") === e3 && (this.day = r3);
    }], w: [i, f("week")], ww: [r2, f("week")], M: [i, f("month")], MM: [r2, f("month")], MMM: [o2, function(e3) {
      var t3 = u("months"), n3 = (u("monthsShort") || t3.map(function(e4) {
        return e4.slice(0, 3);
      })).indexOf(e3) + 1;
      if (n3 < 1) throw new Error();
      this.month = n3 % 12 || n3;
    }], MMMM: [o2, function(e3) {
      var t3 = u("months").indexOf(e3) + 1;
      if (t3 < 1) throw new Error();
      this.month = t3 % 12 || t3;
    }], Y: [/[+-]?\d+/, f("year")], YY: [r2, function(e3) {
      this.year = a(e3);
    }], YYYY: [/\d{4}/, f("year")], Z: h, ZZ: h };
    function l2(n3) {
      var r3, i2;
      r3 = n3, i2 = s && s.formats;
      for (var o3 = (n3 = r3.replace(/(\[[^\]]+])|(LTS?|l{1,4}|L{1,4})/g, function(t3, n4, r4) {
        var o4 = r4 && r4.toUpperCase();
        return n4 || i2[r4] || e2[r4] || i2[o4].replace(/(\[[^\]]+])|(MMMM|MM|DD|dddd)/g, function(e3, t4, n5) {
          return t4 || n5.slice(1);
        });
      })).match(t2), a2 = o3.length, f2 = 0; f2 < a2; f2 += 1) {
        var h2 = o3[f2], u2 = c[h2], d2 = u2 && u2[0], l3 = u2 && u2[1];
        o3[f2] = l3 ? { regex: d2, parser: l3 } : h2.replace(/^\[|\]$/g, "");
      }
      return function(e3) {
        for (var t3 = {}, n4 = 0, r4 = 0; n4 < a2; n4 += 1) {
          var i3 = o3[n4];
          if (typeof i3 == "string") r4 += i3.length;
          else {
            var s2 = i3.regex, f3 = i3.parser, h3 = e3.slice(r4), u3 = s2.exec(h3)[0];
            f3.call(t3, u3), e3 = e3.replace(u3, "");
          }
        }
        return function(e4) {
          var t4 = e4.afternoon;
          if (t4 !== void 0) {
            var n5 = e4.hours;
            t4 ? n5 < 12 && (e4.hours += 12) : n5 === 12 && (e4.hours = 0), delete e4.afternoon;
          }
        }(t3), t3;
      };
    }
    return __name(l2, "l"), function(e3, t3, n3) {
      n3.p.customParseFormat = !0, e3 && e3.parseTwoDigitYear && (a = e3.parseTwoDigitYear);
      var r3 = t3.prototype, i2 = r3.parse;
      r3.parse = function(e4) {
        var t4 = e4.date, r4 = e4.utc, o3 = e4.args;
        this.$u = r4;
        var a2 = o3[1];
        if (typeof a2 == "string") {
          var f2 = o3[2] === !0, h2 = o3[3] === !0, u2 = f2 || h2, d2 = o3[2];
          h2 && (d2 = o3[2]), s = this.$locale(), !f2 && d2 && (s = n3.Ls[d2]), this.$d = function(e5, t5, n4, r5) {
            try {
              if (["x", "X"].indexOf(t5) > -1) return new Date((t5 === "X" ? 1e3 : 1) * e5);
              var i3 = l2(t5)(e5), o4 = i3.year, s2 = i3.month, a3 = i3.day, f3 = i3.hours, h3 = i3.minutes, u3 = i3.seconds, d3 = i3.milliseconds, c3 = i3.zone, m3 = i3.week, M2 = /* @__PURE__ */ new Date(), Y = a3 || (o4 || s2 ? 1 : M2.getDate()), p = o4 || M2.getFullYear(), v = 0;
              o4 && !s2 || (v = s2 > 0 ? s2 - 1 : M2.getMonth());
              var D, w = f3 || 0, g = h3 || 0, y = u3 || 0, L = d3 || 0;
              return c3 ? new Date(Date.UTC(p, v, Y, w, g, y, L + 60 * c3.offset * 1e3)) : n4 ? new Date(Date.UTC(p, v, Y, w, g, y, L)) : (D = new Date(p, v, Y, w, g, y, L), m3 && (D = r5(D).week(m3).toDate()), D);
            } catch {
              return /* @__PURE__ */ new Date("");
            }
          }(t4, a2, r4, n3), this.init(), d2 && d2 !== !0 && (this.$L = this.locale(d2).$L), u2 && t4 != this.format(a2) && (this.$d = /* @__PURE__ */ new Date("")), s = {};
        } else if (a2 instanceof Array) for (var c2 = a2.length, m2 = 1; m2 <= c2; m2 += 1) {
          o3[1] = a2[m2 - 1];
          var M = n3.apply(this, o3);
          if (M.isValid()) {
            this.$d = M.$d, this.$L = M.$L, this.init();
            break;
          }
          m2 === c2 && (this.$d = /* @__PURE__ */ new Date(""));
        }
        else i2.call(this, e4);
      };
    };
  });
})(customParseFormat$1);
var customParseFormatExports = customParseFormat$1.exports;
const customParseFormat = /* @__PURE__ */ getDefaultExportFromCjs(customParseFormatExports);
dayjs.extend(customParseFormat);
dayjs.extend(advancedFormat);
dayjs.extend(weekday);
dayjs.extend(localeData);
dayjs.extend(weekOfYear);
dayjs.extend(weekYear);
dayjs.extend(function(o2, c) {
  var proto = c.prototype, oldFormat = proto.format;
  proto.format = /* @__PURE__ */ __name(function(formatStr) {
    var str = (formatStr || "").replace("Wo", "wo");
    return oldFormat.bind(this)(str);
  }, "f");
});
var localeMap = {
  // ar_EG:
  // az_AZ:
  // bg_BG:
  bn_BD: "bn-bd",
  by_BY: "be",
  // ca_ES:
  // cs_CZ:
  // da_DK:
  // de_DE:
  // el_GR:
  en_GB: "en-gb",
  en_US: "en",
  // es_ES:
  // et_EE:
  // fa_IR:
  // fi_FI:
  fr_BE: "fr",
  // todo: dayjs has no fr_BE locale, use fr at present
  fr_CA: "fr-ca",
  // fr_FR:
  // ga_IE:
  // gl_ES:
  // he_IL:
  // hi_IN:
  // hr_HR:
  // hu_HU:
  hy_AM: "hy-am",
  // id_ID:
  // is_IS:
  // it_IT:
  // ja_JP:
  // ka_GE:
  // kk_KZ:
  // km_KH:
  kmr_IQ: "ku",
  // kn_IN:
  // ko_KR:
  // ku_IQ: // previous ku in antd
  // lt_LT:
  // lv_LV:
  // mk_MK:
  // ml_IN:
  // mn_MN:
  // ms_MY:
  // nb_NO:
  // ne_NP:
  nl_BE: "nl-be",
  // nl_NL:
  // pl_PL:
  pt_BR: "pt-br",
  // pt_PT:
  // ro_RO:
  // ru_RU:
  // sk_SK:
  // sl_SI:
  // sr_RS:
  // sv_SE:
  // ta_IN:
  // th_TH:
  // tr_TR:
  // uk_UA:
  // ur_PK:
  // vi_VN:
  zh_CN: "zh-cn",
  zh_HK: "zh-hk",
  zh_TW: "zh-tw"
}, parseLocale = /* @__PURE__ */ __name(function(locale2) {
  var mapLocale = localeMap[locale2];
  return mapLocale || locale2.split("_")[0];
}, "parseLocale"), generateConfig = {
  // get
  getNow: /* @__PURE__ */ __name(function() {
    var now2 = dayjs();
    return typeof now2.tz == "function" ? now2.tz() : now2;
  }, "getNow"),
  getFixedDate: /* @__PURE__ */ __name(function(string3) {
    return dayjs(string3, ["YYYY-M-DD", "YYYY-MM-DD"]);
  }, "getFixedDate"),
  getEndDate: /* @__PURE__ */ __name(function(date4) {
    return date4.endOf("month");
  }, "getEndDate"),
  getWeekDay: /* @__PURE__ */ __name(function(date4) {
    var clone = date4.locale("en");
    return clone.weekday() + clone.localeData().firstDayOfWeek();
  }, "getWeekDay"),
  getYear: /* @__PURE__ */ __name(function(date4) {
    return date4.year();
  }, "getYear"),
  getMonth: /* @__PURE__ */ __name(function(date4) {
    return date4.month();
  }, "getMonth"),
  getDate: /* @__PURE__ */ __name(function(date4) {
    return date4.date();
  }, "getDate"),
  getHour: /* @__PURE__ */ __name(function(date4) {
    return date4.hour();
  }, "getHour"),
  getMinute: /* @__PURE__ */ __name(function(date4) {
    return date4.minute();
  }, "getMinute"),
  getSecond: /* @__PURE__ */ __name(function(date4) {
    return date4.second();
  }, "getSecond"),
  getMillisecond: /* @__PURE__ */ __name(function(date4) {
    return date4.millisecond();
  }, "getMillisecond"),
  // set
  addYear: /* @__PURE__ */ __name(function(date4, diff) {
    return date4.add(diff, "year");
  }, "addYear"),
  addMonth: /* @__PURE__ */ __name(function(date4, diff) {
    return date4.add(diff, "month");
  }, "addMonth"),
  addDate: /* @__PURE__ */ __name(function(date4, diff) {
    return date4.add(diff, "day");
  }, "addDate"),
  setYear: /* @__PURE__ */ __name(function(date4, year) {
    return date4.year(year);
  }, "setYear"),
  setMonth: /* @__PURE__ */ __name(function(date4, month) {
    return date4.month(month);
  }, "setMonth"),
  setDate: /* @__PURE__ */ __name(function(date4, num) {
    return date4.date(num);
  }, "setDate"),
  setHour: /* @__PURE__ */ __name(function(date4, hour) {
    return date4.hour(hour);
  }, "setHour"),
  setMinute: /* @__PURE__ */ __name(function(date4, minute) {
    return date4.minute(minute);
  }, "setMinute"),
  setSecond: /* @__PURE__ */ __name(function(date4, second) {
    return date4.second(second);
  }, "setSecond"),
  setMillisecond: /* @__PURE__ */ __name(function(date4, milliseconds) {
    return date4.millisecond(milliseconds);
  }, "setMillisecond"),
  // Compare
  isAfter: /* @__PURE__ */ __name(function(date1, date22) {
    return date1.isAfter(date22);
  }, "isAfter"),
  isValidate: /* @__PURE__ */ __name(function(date4) {
    return date4.isValid();
  }, "isValidate"),
  locale: {
    getWeekFirstDay: /* @__PURE__ */ __name(function(locale2) {
      return dayjs().locale(parseLocale(locale2)).localeData().firstDayOfWeek();
    }, "getWeekFirstDay"),
    getWeekFirstDate: /* @__PURE__ */ __name(function(locale2, date4) {
      return date4.locale(parseLocale(locale2)).weekday(0);
    }, "getWeekFirstDate"),
    getWeek: /* @__PURE__ */ __name(function(locale2, date4) {
      return date4.locale(parseLocale(locale2)).week();
    }, "getWeek"),
    getShortWeekDays: /* @__PURE__ */ __name(function(locale2) {
      return dayjs().locale(parseLocale(locale2)).localeData().weekdaysMin();
    }, "getShortWeekDays"),
    getShortMonths: /* @__PURE__ */ __name(function(locale2) {
      return dayjs().locale(parseLocale(locale2)).localeData().monthsShort();
    }, "getShortMonths"),
    format: /* @__PURE__ */ __name(function(locale2, date4, _format) {
      return date4.locale(parseLocale(locale2)).format(_format);
    }, "format"),
    parse: /* @__PURE__ */ __name(function(locale2, text, formats) {
      for (var localeStr = parseLocale(locale2), i = 0; i < formats.length; i += 1) {
        var format3 = formats[i], formatText = text;
        if (format3.includes("wo") || format3.includes("Wo")) {
          for (var year = formatText.split("-")[0], weekStr = formatText.split("-")[1], firstWeek = dayjs(year, "YYYY").startOf("year").locale(localeStr), j = 0; j <= 52; j += 1) {
            var nextWeek = firstWeek.add(j, "week");
            if (nextWeek.format("Wo") === weekStr)
              return nextWeek;
          }
          return null;
        }
        var date4 = dayjs(formatText, format3, !0).locale(localeStr);
        if (date4.isValid())
          return date4;
      }
      return null;
    }, "parse")
  }
};
function getRealPlacement(placement, rtl) {
  return placement !== void 0 ? placement : rtl ? "bottomRight" : "bottomLeft";
}
__name(getRealPlacement, "getRealPlacement");
function getoffsetUnit(placement, rtl) {
  var realPlacement = getRealPlacement(placement, rtl), placementRight = realPlacement == null ? void 0 : realPlacement.toLowerCase().endsWith("right"), offsetUnit = placementRight ? "insetInlineEnd" : "insetInlineStart";
  return rtl && (offsetUnit = ["insetInlineStart", "insetInlineEnd"].find(function(unit2) {
    return unit2 !== offsetUnit;
  })), offsetUnit;
}
__name(getoffsetUnit, "getoffsetUnit");
var PickerContext = /* @__PURE__ */ React.createContext(null), BUILT_IN_PLACEMENTS = {
  bottomLeft: {
    points: ["tl", "bl"],
    offset: [0, 4],
    overflow: {
      adjustX: 1,
      adjustY: 1
    }
  },
  bottomRight: {
    points: ["tr", "br"],
    offset: [0, 4],
    overflow: {
      adjustX: 1,
      adjustY: 1
    }
  },
  topLeft: {
    points: ["bl", "tl"],
    offset: [0, -4],
    overflow: {
      adjustX: 0,
      adjustY: 1
    }
  },
  topRight: {
    points: ["br", "tr"],
    offset: [0, -4],
    overflow: {
      adjustX: 0,
      adjustY: 1
    }
  }
};
function PickerTrigger(_ref) {
  var popupElement = _ref.popupElement, popupStyle = _ref.popupStyle, popupClassName = _ref.popupClassName, popupAlign = _ref.popupAlign, transitionName = _ref.transitionName, getPopupContainer = _ref.getPopupContainer, children = _ref.children, range3 = _ref.range, placement = _ref.placement, _ref$builtinPlacement = _ref.builtinPlacements, builtinPlacements = _ref$builtinPlacement === void 0 ? BUILT_IN_PLACEMENTS : _ref$builtinPlacement, direction = _ref.direction, visible = _ref.visible, onClose = _ref.onClose, _React$useContext = React.useContext(PickerContext), prefixCls = _React$useContext.prefixCls, dropdownPrefixCls = "".concat(prefixCls, "-dropdown"), realPlacement = getRealPlacement(placement, direction === "rtl");
  return /* @__PURE__ */ React.createElement(Trigger, {
    showAction: [],
    hideAction: ["click"],
    popupPlacement: realPlacement,
    builtinPlacements,
    prefixCls: dropdownPrefixCls,
    popupTransitionName: transitionName,
    popup: popupElement,
    popupAlign,
    popupVisible: visible,
    popupClassName: cn(popupClassName, _defineProperty$2(_defineProperty$2({}, "".concat(dropdownPrefixCls, "-range"), range3), "".concat(dropdownPrefixCls, "-rtl"), direction === "rtl")),
    popupStyle,
    stretch: "minWidth",
    getPopupContainer,
    onPopupVisibleChange: /* @__PURE__ */ __name(function(nextVisible) {
      nextVisible || onClose();
    }, "onPopupVisibleChange")
  }, children);
}
__name(PickerTrigger, "PickerTrigger");
function leftPad(str, length2) {
  for (var fill = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "0", current = String(str); current.length < length2; )
    current = "".concat(fill).concat(current);
  return current;
}
__name(leftPad, "leftPad");
function toArray$3(val) {
  return val == null ? [] : Array.isArray(val) ? val : [val];
}
__name(toArray$3, "toArray$3");
function fillIndex(ori, index2, value) {
  var clone = _toConsumableArray(ori);
  return clone[index2] = value, clone;
}
__name(fillIndex, "fillIndex");
function pickProps(props, keys2) {
  var clone = {}, mergedKeys = keys2 || Object.keys(props);
  return mergedKeys.forEach(function(key) {
    props[key] !== void 0 && (clone[key] = props[key]);
  }), clone;
}
__name(pickProps, "pickProps");
function getRowFormat(picker, locale2, format3) {
  if (format3)
    return format3;
  switch (picker) {
    case "time":
      return locale2.fieldTimeFormat;
    case "datetime":
      return locale2.fieldDateTimeFormat;
    case "month":
      return locale2.fieldMonthFormat;
    case "year":
      return locale2.fieldYearFormat;
    case "quarter":
      return locale2.fieldQuarterFormat;
    case "week":
      return locale2.fieldWeekFormat;
    default:
      return locale2.fieldDateFormat;
  }
}
__name(getRowFormat, "getRowFormat");
function getFromDate(calendarValues, activeIndexList, activeIndex) {
  var mergedActiveIndex = activeIndex !== void 0 ? activeIndex : activeIndexList[activeIndexList.length - 1], firstValuedIndex = activeIndexList.find(function(index2) {
    return calendarValues[index2];
  });
  return mergedActiveIndex !== firstValuedIndex ? calendarValues[firstValuedIndex] : void 0;
}
__name(getFromDate, "getFromDate");
function pickTriggerProps(props) {
  return pickProps(props, ["placement", "builtinPlacements", "popupAlign", "getPopupContainer", "transitionName", "direction"]);
}
__name(pickTriggerProps, "pickTriggerProps");
function useCellRender$1(cellRender, dateRender, monthCellRender, range3) {
  process.env.NODE_ENV !== "production" && (warningOnce(!dateRender, "'dateRender' is deprecated. Please use 'cellRender' instead."), warningOnce(!monthCellRender, "'monthCellRender' is deprecated. Please use 'cellRender' instead."));
  var mergedCellRender = React.useMemo(function() {
    return cellRender || function(current, info) {
      var date4 = current;
      return dateRender && info.type === "date" ? dateRender(date4, info.today) : monthCellRender && info.type === "month" ? monthCellRender(date4, info.locale) : info.originNode;
    };
  }, [cellRender, monthCellRender, dateRender]), onInternalCellRender = React.useCallback(function(date4, info) {
    return mergedCellRender(date4, _objectSpread2$1(_objectSpread2$1({}, info), {}, {
      range: range3
    }));
  }, [mergedCellRender, range3]);
  return onInternalCellRender;
}
__name(useCellRender$1, "useCellRender$1");
function useFieldsInvalidate(calendarValue, isInvalidateDate) {
  var allowEmpty = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : [], _React$useState = React.useState([!1, !1]), _React$useState2 = _slicedToArray(_React$useState, 2), fieldsInvalidates = _React$useState2[0], setFieldsInvalidates = _React$useState2[1], onSelectorInvalid = /* @__PURE__ */ __name(function(invalid, index2) {
    setFieldsInvalidates(function(ori) {
      return fillIndex(ori, index2, invalid);
    });
  }, "onSelectorInvalid"), submitInvalidates = React.useMemo(function() {
    return fieldsInvalidates.map(function(invalid, index2) {
      if (invalid)
        return !0;
      var current = calendarValue[index2];
      return current ? !!(!allowEmpty[index2] && !current || current && isInvalidateDate(current, {
        activeIndex: index2
      })) : !1;
    });
  }, [calendarValue, fieldsInvalidates, isInvalidateDate, allowEmpty]);
  return [submitInvalidates, onSelectorInvalid];
}
__name(useFieldsInvalidate, "useFieldsInvalidate");
function fillTimeFormat(showHour, showMinute, showSecond, showMillisecond, showMeridiem) {
  var timeFormat = "", cells = [];
  return showHour && cells.push(showMeridiem ? "hh" : "HH"), showMinute && cells.push("mm"), showSecond && cells.push("ss"), timeFormat = cells.join(":"), showMillisecond && (timeFormat += ".SSS"), showMeridiem && (timeFormat += " A"), timeFormat;
}
__name(fillTimeFormat, "fillTimeFormat");
function fillLocale(locale2, showHour, showMinute, showSecond, showMillisecond, use12Hours) {
  var fieldDateTimeFormat = locale2.fieldDateTimeFormat, fieldDateFormat = locale2.fieldDateFormat, fieldTimeFormat = locale2.fieldTimeFormat, fieldMonthFormat = locale2.fieldMonthFormat, fieldYearFormat = locale2.fieldYearFormat, fieldWeekFormat = locale2.fieldWeekFormat, fieldQuarterFormat = locale2.fieldQuarterFormat, yearFormat = locale2.yearFormat, cellYearFormat = locale2.cellYearFormat, cellQuarterFormat = locale2.cellQuarterFormat, dayFormat = locale2.dayFormat, cellDateFormat = locale2.cellDateFormat, timeFormat = fillTimeFormat(showHour, showMinute, showSecond, showMillisecond, use12Hours);
  return _objectSpread2$1(_objectSpread2$1({}, locale2), {}, {
    fieldDateTimeFormat: fieldDateTimeFormat || "YYYY-MM-DD ".concat(timeFormat),
    fieldDateFormat: fieldDateFormat || "YYYY-MM-DD",
    fieldTimeFormat: fieldTimeFormat || timeFormat,
    fieldMonthFormat: fieldMonthFormat || "YYYY-MM",
    fieldYearFormat: fieldYearFormat || "YYYY",
    fieldWeekFormat: fieldWeekFormat || "gggg-wo",
    fieldQuarterFormat: fieldQuarterFormat || "YYYY-[Q]Q",
    yearFormat: yearFormat || "YYYY",
    cellYearFormat: cellYearFormat || "YYYY",
    cellQuarterFormat: cellQuarterFormat || "[Q]Q",
    cellDateFormat: cellDateFormat || dayFormat || "D"
  });
}
__name(fillLocale, "fillLocale");
function useLocale(locale2, showProps) {
  var showHour = showProps.showHour, showMinute = showProps.showMinute, showSecond = showProps.showSecond, showMillisecond = showProps.showMillisecond, use12Hours = showProps.use12Hours;
  return React__default.useMemo(function() {
    return fillLocale(locale2, showHour, showMinute, showSecond, showMillisecond, use12Hours);
  }, [locale2, showHour, showMinute, showSecond, showMillisecond, use12Hours]);
}
__name(useLocale, "useLocale");
function checkShow(format3, keywords, show) {
  return show ?? keywords.some(function(keyword) {
    return format3.includes(keyword);
  });
}
__name(checkShow, "checkShow");
var showTimeKeys = [
  // 'format',
  "showNow",
  "showHour",
  "showMinute",
  "showSecond",
  "showMillisecond",
  "use12Hours",
  "hourStep",
  "minuteStep",
  "secondStep",
  "millisecondStep",
  "hideDisabledOptions",
  "defaultValue",
  "disabledHours",
  "disabledMinutes",
  "disabledSeconds",
  "disabledMilliseconds",
  "disabledTime",
  "changeOnScroll",
  "defaultOpenValue"
];
function pickTimeProps(props) {
  var timeProps = pickProps(props, showTimeKeys), format3 = props.format, picker = props.picker, propFormat = null;
  return format3 && (propFormat = format3, Array.isArray(propFormat) && (propFormat = propFormat[0]), propFormat = _typeof$4(propFormat) === "object" ? propFormat.format : propFormat), picker === "time" && (timeProps.format = propFormat), [timeProps, propFormat];
}
__name(pickTimeProps, "pickTimeProps");
function isStringFormat(format3) {
  return format3 && typeof format3 == "string";
}
__name(isStringFormat, "isStringFormat");
function existShowConfig(showHour, showMinute, showSecond, showMillisecond) {
  return [showHour, showMinute, showSecond, showMillisecond].some(function(show) {
    return show !== void 0;
  });
}
__name(existShowConfig, "existShowConfig");
function fillShowConfig(hasShowConfig, showHour, showMinute, showSecond, showMillisecond) {
  var parsedShowHour = showHour, parsedShowMinute = showMinute, parsedShowSecond = showSecond;
  if (!hasShowConfig && !parsedShowHour && !parsedShowMinute && !parsedShowSecond && !showMillisecond)
    parsedShowHour = !0, parsedShowMinute = !0, parsedShowSecond = !0;
  else if (hasShowConfig) {
    var _parsedShowHour, _parsedShowMinute, _parsedShowSecond, existFalse = [parsedShowHour, parsedShowMinute, parsedShowSecond].some(function(show) {
      return show === !1;
    }), existTrue = [parsedShowHour, parsedShowMinute, parsedShowSecond].some(function(show) {
      return show === !0;
    }), defaultShow = existFalse ? !0 : !existTrue;
    parsedShowHour = (_parsedShowHour = parsedShowHour) !== null && _parsedShowHour !== void 0 ? _parsedShowHour : defaultShow, parsedShowMinute = (_parsedShowMinute = parsedShowMinute) !== null && _parsedShowMinute !== void 0 ? _parsedShowMinute : defaultShow, parsedShowSecond = (_parsedShowSecond = parsedShowSecond) !== null && _parsedShowSecond !== void 0 ? _parsedShowSecond : defaultShow;
  }
  return [parsedShowHour, parsedShowMinute, parsedShowSecond, showMillisecond];
}
__name(fillShowConfig, "fillShowConfig");
function getTimeProps(componentProps) {
  var showTime = componentProps.showTime, _pickTimeProps = pickTimeProps(componentProps), _pickTimeProps2 = _slicedToArray(_pickTimeProps, 2), pickedProps = _pickTimeProps2[0], propFormat = _pickTimeProps2[1], showTimeConfig = showTime && _typeof$4(showTime) === "object" ? showTime : {}, timeConfig = _objectSpread2$1(_objectSpread2$1({
    defaultOpenValue: showTimeConfig.defaultOpenValue || showTimeConfig.defaultValue
  }, pickedProps), showTimeConfig), showMillisecond = timeConfig.showMillisecond, showHour = timeConfig.showHour, showMinute = timeConfig.showMinute, showSecond = timeConfig.showSecond, hasShowConfig = existShowConfig(showHour, showMinute, showSecond, showMillisecond), _fillShowConfig = fillShowConfig(hasShowConfig, showHour, showMinute, showSecond, showMillisecond), _fillShowConfig2 = _slicedToArray(_fillShowConfig, 3);
  return showHour = _fillShowConfig2[0], showMinute = _fillShowConfig2[1], showSecond = _fillShowConfig2[2], [timeConfig, _objectSpread2$1(_objectSpread2$1({}, timeConfig), {}, {
    showHour,
    showMinute,
    showSecond,
    showMillisecond
  }), timeConfig.format, propFormat];
}
__name(getTimeProps, "getTimeProps");
function fillShowTimeConfig(picker, showTimeFormat, propFormat, timeConfig, locale2) {
  var isTimePicker = picker === "time";
  if (picker === "datetime" || isTimePicker) {
    for (var pickedProps = timeConfig, defaultLocaleFormat = getRowFormat(picker, locale2, null), baselineFormat = defaultLocaleFormat, formatList = [showTimeFormat, propFormat], i = 0; i < formatList.length; i += 1) {
      var format3 = toArray$3(formatList[i])[0];
      if (isStringFormat(format3)) {
        baselineFormat = format3;
        break;
      }
    }
    var showHour = pickedProps.showHour, showMinute = pickedProps.showMinute, showSecond = pickedProps.showSecond, showMillisecond = pickedProps.showMillisecond, use12Hours = pickedProps.use12Hours, showMeridiem = checkShow(baselineFormat, ["a", "A", "LT", "LLL", "LTS"], use12Hours), hasShowConfig = existShowConfig(showHour, showMinute, showSecond, showMillisecond);
    hasShowConfig || (showHour = checkShow(baselineFormat, ["H", "h", "k", "LT", "LLL"]), showMinute = checkShow(baselineFormat, ["m", "LT", "LLL"]), showSecond = checkShow(baselineFormat, ["s", "LTS"]), showMillisecond = checkShow(baselineFormat, ["SSS"]));
    var _fillShowConfig3 = fillShowConfig(hasShowConfig, showHour, showMinute, showSecond, showMillisecond), _fillShowConfig4 = _slicedToArray(_fillShowConfig3, 3);
    showHour = _fillShowConfig4[0], showMinute = _fillShowConfig4[1], showSecond = _fillShowConfig4[2];
    var timeFormat = showTimeFormat || fillTimeFormat(showHour, showMinute, showSecond, showMillisecond, showMeridiem);
    return _objectSpread2$1(_objectSpread2$1({}, pickedProps), {}, {
      // Format
      format: timeFormat,
      // Show Config
      showHour,
      showMinute,
      showSecond,
      showMillisecond,
      use12Hours: showMeridiem
    });
  }
  return null;
}
__name(fillShowTimeConfig, "fillShowTimeConfig");
function fillClearIcon(prefixCls, allowClear, clearIcon) {
  if (process.env.NODE_ENV !== "production" && clearIcon && warningOnce(!1, "`clearIcon` will be removed in future. Please use `allowClear` instead."), allowClear === !1)
    return null;
  var config = allowClear && _typeof$4(allowClear) === "object" ? allowClear : {};
  return config.clearIcon || clearIcon || /* @__PURE__ */ React.createElement("span", {
    className: "".concat(prefixCls, "-clear-btn")
  });
}
__name(fillClearIcon, "fillClearIcon");
var WEEK_DAY_COUNT = 7;
function nullableCompare(value1, value2, oriCompareFn) {
  return !value1 && !value2 || value1 === value2 ? !0 : !value1 || !value2 ? !1 : oriCompareFn();
}
__name(nullableCompare, "nullableCompare");
function isSameDecade(generateConfig2, decade1, decade2) {
  return nullableCompare(decade1, decade2, function() {
    var num1 = Math.floor(generateConfig2.getYear(decade1) / 10), num2 = Math.floor(generateConfig2.getYear(decade2) / 10);
    return num1 === num2;
  });
}
__name(isSameDecade, "isSameDecade");
function isSameYear(generateConfig2, year1, year2) {
  return nullableCompare(year1, year2, function() {
    return generateConfig2.getYear(year1) === generateConfig2.getYear(year2);
  });
}
__name(isSameYear, "isSameYear");
function getQuarter(generateConfig2, date4) {
  var quota = Math.floor(generateConfig2.getMonth(date4) / 3);
  return quota + 1;
}
__name(getQuarter, "getQuarter");
function isSameQuarter(generateConfig2, quarter1, quarter2) {
  return nullableCompare(quarter1, quarter2, function() {
    return isSameYear(generateConfig2, quarter1, quarter2) && getQuarter(generateConfig2, quarter1) === getQuarter(generateConfig2, quarter2);
  });
}
__name(isSameQuarter, "isSameQuarter");
function isSameMonth(generateConfig2, month1, month2) {
  return nullableCompare(month1, month2, function() {
    return isSameYear(generateConfig2, month1, month2) && generateConfig2.getMonth(month1) === generateConfig2.getMonth(month2);
  });
}
__name(isSameMonth, "isSameMonth");
function isSameDate(generateConfig2, date1, date22) {
  return nullableCompare(date1, date22, function() {
    return isSameYear(generateConfig2, date1, date22) && isSameMonth(generateConfig2, date1, date22) && generateConfig2.getDate(date1) === generateConfig2.getDate(date22);
  });
}
__name(isSameDate, "isSameDate");
function isSameTime(generateConfig2, time1, time2) {
  return nullableCompare(time1, time2, function() {
    return generateConfig2.getHour(time1) === generateConfig2.getHour(time2) && generateConfig2.getMinute(time1) === generateConfig2.getMinute(time2) && generateConfig2.getSecond(time1) === generateConfig2.getSecond(time2);
  });
}
__name(isSameTime, "isSameTime");
function isSameTimestamp(generateConfig2, time1, time2) {
  return nullableCompare(time1, time2, function() {
    return isSameDate(generateConfig2, time1, time2) && isSameTime(generateConfig2, time1, time2) && generateConfig2.getMillisecond(time1) === generateConfig2.getMillisecond(time2);
  });
}
__name(isSameTimestamp, "isSameTimestamp");
function isSameWeek(generateConfig2, locale2, date1, date22) {
  return nullableCompare(date1, date22, function() {
    var weekStartDate1 = generateConfig2.locale.getWeekFirstDate(locale2, date1), weekStartDate2 = generateConfig2.locale.getWeekFirstDate(locale2, date22);
    return isSameYear(generateConfig2, weekStartDate1, weekStartDate2) && generateConfig2.locale.getWeek(locale2, date1) === generateConfig2.locale.getWeek(locale2, date22);
  });
}
__name(isSameWeek, "isSameWeek");
function isSame(generateConfig2, locale2, source, target, type4) {
  switch (type4) {
    case "date":
      return isSameDate(generateConfig2, source, target);
    case "week":
      return isSameWeek(generateConfig2, locale2.locale, source, target);
    case "month":
      return isSameMonth(generateConfig2, source, target);
    case "quarter":
      return isSameQuarter(generateConfig2, source, target);
    case "year":
      return isSameYear(generateConfig2, source, target);
    case "decade":
      return isSameDecade(generateConfig2, source, target);
    case "time":
      return isSameTime(generateConfig2, source, target);
    default:
      return isSameTimestamp(generateConfig2, source, target);
  }
}
__name(isSame, "isSame");
function isInRange(generateConfig2, startDate, endDate, current) {
  return !startDate || !endDate || !current ? !1 : generateConfig2.isAfter(current, startDate) && generateConfig2.isAfter(endDate, current);
}
__name(isInRange, "isInRange");
function isSameOrAfter(generateConfig2, locale2, date1, date22, type4) {
  return isSame(generateConfig2, locale2, date1, date22, type4) ? !0 : generateConfig2.isAfter(date1, date22);
}
__name(isSameOrAfter, "isSameOrAfter");
function getWeekStartDate(locale2, generateConfig2, value) {
  var weekFirstDay = generateConfig2.locale.getWeekFirstDay(locale2), monthStartDate = generateConfig2.setDate(value, 1), startDateWeekDay = generateConfig2.getWeekDay(monthStartDate), alignStartDate = generateConfig2.addDate(monthStartDate, weekFirstDay - startDateWeekDay);
  return generateConfig2.getMonth(alignStartDate) === generateConfig2.getMonth(value) && generateConfig2.getDate(alignStartDate) > 1 && (alignStartDate = generateConfig2.addDate(alignStartDate, -7)), alignStartDate;
}
__name(getWeekStartDate, "getWeekStartDate");
function formatValue(value, _ref) {
  var generateConfig2 = _ref.generateConfig, locale2 = _ref.locale, format3 = _ref.format;
  return value ? typeof format3 == "function" ? format3(value) : generateConfig2.locale.format(locale2.locale, value, format3) : "";
}
__name(formatValue, "formatValue");
function fillTime(generateConfig2, date4, time) {
  var tmpDate = date4, getFn = ["getHour", "getMinute", "getSecond", "getMillisecond"], setFn = ["setHour", "setMinute", "setSecond", "setMillisecond"];
  return setFn.forEach(function(fn, index2) {
    time ? tmpDate = generateConfig2[fn](tmpDate, generateConfig2[getFn[index2]](time)) : tmpDate = generateConfig2[fn](tmpDate, 0);
  }), tmpDate;
}
__name(fillTime, "fillTime");
function useDisabledBoundary(generateConfig2, locale2, disabledDate, minDate, maxDate) {
  var mergedDisabledDate = useEvent(function(date4, info) {
    return !!(disabledDate && disabledDate(date4, info) || minDate && generateConfig2.isAfter(minDate, date4) && !isSame(generateConfig2, locale2, minDate, date4, info.type) || maxDate && generateConfig2.isAfter(date4, maxDate) && !isSame(generateConfig2, locale2, maxDate, date4, info.type));
  });
  return mergedDisabledDate;
}
__name(useDisabledBoundary, "useDisabledBoundary");
function useFieldFormat(picker, locale2, format3) {
  return React.useMemo(function() {
    var rawFormat = getRowFormat(picker, locale2, format3), formatList = toArray$3(rawFormat), firstFormat = formatList[0], maskFormat = _typeof$4(firstFormat) === "object" && firstFormat.type === "mask" ? firstFormat.format : null;
    return [
      // Format list
      formatList.map(function(config) {
        return typeof config == "string" || typeof config == "function" ? config : config.format;
      }),
      // Mask Format
      maskFormat
    ];
  }, [picker, locale2, format3]);
}
__name(useFieldFormat, "useFieldFormat");
function useInputReadOnly(formatList, inputReadOnly, multiple) {
  return typeof formatList[0] == "function" || multiple ? !0 : inputReadOnly;
}
__name(useInputReadOnly, "useInputReadOnly");
function useInvalidate(generateConfig2, picker, disabledDate, showTime) {
  var isInvalidate = useEvent(function(date4, info) {
    var outsideInfo = _objectSpread2$1({
      type: picker
    }, info);
    if (delete outsideInfo.activeIndex, // Date object is invalid
    !generateConfig2.isValidate(date4) || // Date is disabled by `disabledDate`
    disabledDate && disabledDate(date4, outsideInfo))
      return !0;
    if ((picker === "date" || picker === "time") && showTime) {
      var _showTime$disabledTim, range3 = info && info.activeIndex === 1 ? "end" : "start", _ref = ((_showTime$disabledTim = showTime.disabledTime) === null || _showTime$disabledTim === void 0 ? void 0 : _showTime$disabledTim.call(showTime, date4, range3, {
        from: outsideInfo.from
      })) || {}, disabledHours = _ref.disabledHours, disabledMinutes = _ref.disabledMinutes, disabledSeconds = _ref.disabledSeconds, disabledMilliseconds = _ref.disabledMilliseconds, legacyDisabledHours = showTime.disabledHours, legacyDisabledMinutes = showTime.disabledMinutes, legacyDisabledSeconds = showTime.disabledSeconds, mergedDisabledHours = disabledHours || legacyDisabledHours, mergedDisabledMinutes = disabledMinutes || legacyDisabledMinutes, mergedDisabledSeconds = disabledSeconds || legacyDisabledSeconds, hour = generateConfig2.getHour(date4), minute = generateConfig2.getMinute(date4), second = generateConfig2.getSecond(date4), millisecond = generateConfig2.getMillisecond(date4);
      if (mergedDisabledHours && mergedDisabledHours().includes(hour) || mergedDisabledMinutes && mergedDisabledMinutes(hour).includes(minute) || mergedDisabledSeconds && mergedDisabledSeconds(hour, minute).includes(second) || disabledMilliseconds && disabledMilliseconds(hour, minute, second).includes(millisecond))
        return !0;
    }
    return !1;
  });
  return isInvalidate;
}
__name(useInvalidate, "useInvalidate");
function useList(value) {
  var fillMode = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1, values = React.useMemo(function() {
    var list = value && toArray$3(value);
    return fillMode && list && (list[1] = list[1] || list[0]), list;
  }, [value, fillMode]);
  return values;
}
__name(useList, "useList");
function useFilledProps(props, updater) {
  var generateConfig2 = props.generateConfig, locale2 = props.locale, _props$picker = props.picker, picker = _props$picker === void 0 ? "date" : _props$picker, _props$prefixCls = props.prefixCls, prefixCls = _props$prefixCls === void 0 ? "rc-picker" : _props$prefixCls, _props$styles = props.styles, styles2 = _props$styles === void 0 ? {} : _props$styles, _props$classNames = props.classNames, classNames = _props$classNames === void 0 ? {} : _props$classNames, _props$order = props.order, order2 = _props$order === void 0 ? !0 : _props$order, _props$components = props.components, components2 = _props$components === void 0 ? {} : _props$components, inputRender = props.inputRender, allowClear = props.allowClear, clearIcon = props.clearIcon, needConfirm = props.needConfirm, multiple = props.multiple, format3 = props.format, inputReadOnly = props.inputReadOnly, disabledDate = props.disabledDate, minDate = props.minDate, maxDate = props.maxDate, showTime = props.showTime, value = props.value, defaultValue = props.defaultValue, pickerValue = props.pickerValue, defaultPickerValue = props.defaultPickerValue, values = useList(value), defaultValues = useList(defaultValue), pickerValues = useList(pickerValue), defaultPickerValues = useList(defaultPickerValue), internalPicker = picker === "date" && showTime ? "datetime" : picker, multipleInteractivePicker = internalPicker === "time" || internalPicker === "datetime", complexPicker = multipleInteractivePicker || multiple, mergedNeedConfirm = needConfirm ?? multipleInteractivePicker, _getTimeProps = getTimeProps(props), _getTimeProps2 = _slicedToArray(_getTimeProps, 4), timeProps = _getTimeProps2[0], localeTimeProps = _getTimeProps2[1], showTimeFormat = _getTimeProps2[2], propFormat = _getTimeProps2[3], mergedLocale = useLocale(locale2, localeTimeProps), mergedShowTime = React.useMemo(function() {
    return fillShowTimeConfig(internalPicker, showTimeFormat, propFormat, timeProps, mergedLocale);
  }, [internalPicker, showTimeFormat, propFormat, timeProps, mergedLocale]);
  process.env.NODE_ENV !== "production" && picker === "time" && ["disabledHours", "disabledMinutes", "disabledSeconds"].some(function(key) {
    return props[key];
  }) && warningOnce(!1, "'disabledHours', 'disabledMinutes', 'disabledSeconds' will be removed in the next major version, please use 'disabledTime' instead.");
  var filledProps = React.useMemo(function() {
    return _objectSpread2$1(_objectSpread2$1({}, props), {}, {
      prefixCls,
      locale: mergedLocale,
      picker,
      styles: styles2,
      classNames,
      order: order2,
      components: _objectSpread2$1({
        input: inputRender
      }, components2),
      clearIcon: fillClearIcon(prefixCls, allowClear, clearIcon),
      showTime: mergedShowTime,
      value: values,
      defaultValue: defaultValues,
      pickerValue: pickerValues,
      defaultPickerValue: defaultPickerValues
    }, updater == null ? void 0 : updater());
  }, [props]), _useFieldFormat = useFieldFormat(internalPicker, mergedLocale, format3), _useFieldFormat2 = _slicedToArray(_useFieldFormat, 2), formatList = _useFieldFormat2[0], maskFormat = _useFieldFormat2[1], mergedInputReadOnly = useInputReadOnly(formatList, inputReadOnly, multiple), disabledBoundaryDate = useDisabledBoundary(generateConfig2, locale2, disabledDate, minDate, maxDate), isInvalidateDate = useInvalidate(generateConfig2, picker, disabledBoundaryDate, mergedShowTime), mergedProps = React.useMemo(function() {
    return _objectSpread2$1(_objectSpread2$1({}, filledProps), {}, {
      needConfirm: mergedNeedConfirm,
      inputReadOnly: mergedInputReadOnly,
      disabledDate: disabledBoundaryDate
    });
  }, [filledProps, mergedNeedConfirm, mergedInputReadOnly, disabledBoundaryDate]);
  return [mergedProps, internalPicker, complexPicker, formatList, maskFormat, isInvalidateDate];
}
__name(useFilledProps, "useFilledProps");
function useDelayState(value, defaultValue, onChange) {
  var _useMergedState = useMergedState(defaultValue, {
    value
  }), _useMergedState2 = _slicedToArray(_useMergedState, 2), state = _useMergedState2[0], setState = _useMergedState2[1], nextValueRef = React__default.useRef(value), rafRef = React__default.useRef(), cancelRaf = /* @__PURE__ */ __name(function() {
    wrapperRaf.cancel(rafRef.current);
  }, "cancelRaf"), doUpdate = useEvent(function() {
    setState(nextValueRef.current), onChange && state !== nextValueRef.current && onChange(nextValueRef.current);
  }), updateValue = useEvent(function(next2, immediately) {
    cancelRaf(), nextValueRef.current = next2, next2 || immediately ? doUpdate() : rafRef.current = wrapperRaf(doUpdate);
  });
  return React__default.useEffect(function() {
    return cancelRaf;
  }, []), [state, updateValue];
}
__name(useDelayState, "useDelayState");
function useOpen(open, defaultOpen) {
  var disabledList = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : [], onOpenChange = arguments.length > 3 ? arguments[3] : void 0, mergedOpen = disabledList.every(function(disabled) {
    return disabled;
  }) ? !1 : open, _useDelayState = useDelayState(mergedOpen, defaultOpen || !1, onOpenChange), _useDelayState2 = _slicedToArray(_useDelayState, 2), rafOpen = _useDelayState2[0], setRafOpen = _useDelayState2[1];
  function setOpen(next2) {
    var config = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    (!config.inherit || rafOpen) && setRafOpen(next2, config.force);
  }
  return __name(setOpen, "setOpen"), [rafOpen, setOpen];
}
__name(useOpen, "useOpen");
function usePickerRef(ref) {
  var selectorRef = React.useRef();
  return React.useImperativeHandle(ref, function() {
    var _selectorRef$current;
    return {
      nativeElement: (_selectorRef$current = selectorRef.current) === null || _selectorRef$current === void 0 ? void 0 : _selectorRef$current.nativeElement,
      focus: /* @__PURE__ */ __name(function(options) {
        var _selectorRef$current2;
        (_selectorRef$current2 = selectorRef.current) === null || _selectorRef$current2 === void 0 || _selectorRef$current2.focus(options);
      }, "focus"),
      blur: /* @__PURE__ */ __name(function() {
        var _selectorRef$current3;
        (_selectorRef$current3 = selectorRef.current) === null || _selectorRef$current3 === void 0 || _selectorRef$current3.blur();
      }, "blur")
    };
  }), selectorRef;
}
__name(usePickerRef, "usePickerRef");
function usePresets(presets, legacyRanges) {
  return React.useMemo(function() {
    return presets || (legacyRanges ? (warningOnce(!1, "`ranges` is deprecated. Please use `presets` instead."), Object.entries(legacyRanges).map(function(_ref) {
      var _ref2 = _slicedToArray(_ref, 2), label2 = _ref2[0], value = _ref2[1];
      return {
        label: label2,
        value
      };
    })) : []);
  }, [presets, legacyRanges]);
}
__name(usePresets, "usePresets");
function useLockEffect(condition, callback) {
  var delayFrames = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1, callbackRef = React.useRef(callback);
  callbackRef.current = callback, useLayoutUpdateEffect(function() {
    if (condition)
      callbackRef.current(condition);
    else {
      var id2 = wrapperRaf(function() {
        callbackRef.current(condition);
      }, delayFrames);
      return function() {
        wrapperRaf.cancel(id2);
      };
    }
  }, [condition]);
}
__name(useLockEffect, "useLockEffect");
function useRangeActive(disabled) {
  var empty2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [], mergedOpen = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !1, _React$useState = React.useState(0), _React$useState2 = _slicedToArray(_React$useState, 2), activeIndex = _React$useState2[0], setActiveIndex = _React$useState2[1], _React$useState3 = React.useState(!1), _React$useState4 = _slicedToArray(_React$useState3, 2), focused = _React$useState4[0], setFocused = _React$useState4[1], activeListRef = React.useRef([]), lastOperationRef = React.useRef(null), triggerFocus2 = /* @__PURE__ */ __name(function(nextFocus) {
    setFocused(nextFocus);
  }, "triggerFocus"), lastOperation = /* @__PURE__ */ __name(function(type4) {
    return type4 && (lastOperationRef.current = type4), lastOperationRef.current;
  }, "lastOperation"), nextActiveIndex = /* @__PURE__ */ __name(function(nextValue) {
    var list = activeListRef.current, filledActiveSet = new Set(list.filter(function(index2) {
      return nextValue[index2] || empty2[index2];
    })), nextIndex = list[list.length - 1] === 0 ? 1 : 0;
    return filledActiveSet.size >= 2 || disabled[nextIndex] ? null : nextIndex;
  }, "nextActiveIndex");
  return useLockEffect(focused || mergedOpen, function() {
    focused || (activeListRef.current = []);
  }), React.useEffect(function() {
    focused && activeListRef.current.push(activeIndex);
  }, [focused, activeIndex]), [focused, triggerFocus2, lastOperation, activeIndex, setActiveIndex, nextActiveIndex, activeListRef.current];
}
__name(useRangeActive, "useRangeActive");
function useRangeDisabledDate(values, disabled, activeIndexList, generateConfig2, locale2, disabledDate) {
  var activeIndex = activeIndexList[activeIndexList.length - 1], rangeDisabledDate = /* @__PURE__ */ __name(function(date4, info) {
    var _values = _slicedToArray(values, 2), start = _values[0], end = _values[1], mergedInfo = _objectSpread2$1(_objectSpread2$1({}, info), {}, {
      from: getFromDate(values, activeIndexList)
    });
    return activeIndex === 1 && disabled[0] && start && // Same date isOK
    !isSame(generateConfig2, locale2, start, date4, mergedInfo.type) && // Before start date
    generateConfig2.isAfter(start, date4) || activeIndex === 0 && disabled[1] && end && // Same date isOK
    !isSame(generateConfig2, locale2, end, date4, mergedInfo.type) && // After end date
    generateConfig2.isAfter(date4, end) ? !0 : disabledDate == null ? void 0 : disabledDate(date4, mergedInfo);
  }, "rangeDisabledDate");
  return rangeDisabledDate;
}
__name(useRangeDisabledDate, "useRangeDisabledDate");
function offsetPanelDate(generateConfig2, picker, date4, offset2) {
  switch (picker) {
    case "date":
    case "week":
      return generateConfig2.addMonth(date4, offset2);
    case "month":
    case "quarter":
      return generateConfig2.addYear(date4, offset2);
    case "year":
      return generateConfig2.addYear(date4, offset2 * 10);
    case "decade":
      return generateConfig2.addYear(date4, offset2 * 100);
    default:
      return date4;
  }
}
__name(offsetPanelDate, "offsetPanelDate");
var EMPTY_LIST$3 = [];
function useRangePickerValue(generateConfig2, locale2, calendarValue, modes, open, activeIndex, pickerMode, multiplePanel) {
  var defaultPickerValue = arguments.length > 8 && arguments[8] !== void 0 ? arguments[8] : EMPTY_LIST$3, pickerValue = arguments.length > 9 && arguments[9] !== void 0 ? arguments[9] : EMPTY_LIST$3, timeDefaultValue = arguments.length > 10 && arguments[10] !== void 0 ? arguments[10] : EMPTY_LIST$3, onPickerValueChange = arguments.length > 11 ? arguments[11] : void 0, minDate = arguments.length > 12 ? arguments[12] : void 0, maxDate = arguments.length > 13 ? arguments[13] : void 0, isTimePicker = pickerMode === "time", mergedActiveIndex = activeIndex || 0, getDefaultPickerValue = /* @__PURE__ */ __name(function(index2) {
    var now2 = generateConfig2.getNow();
    return isTimePicker && (now2 = fillTime(generateConfig2, now2)), defaultPickerValue[index2] || calendarValue[index2] || now2;
  }, "getDefaultPickerValue"), _pickerValue = _slicedToArray(pickerValue, 2), startPickerValue = _pickerValue[0], endPickerValue = _pickerValue[1], _useMergedState = useMergedState(function() {
    return getDefaultPickerValue(0);
  }, {
    value: startPickerValue
  }), _useMergedState2 = _slicedToArray(_useMergedState, 2), mergedStartPickerValue = _useMergedState2[0], setStartPickerValue = _useMergedState2[1], _useMergedState3 = useMergedState(function() {
    return getDefaultPickerValue(1);
  }, {
    value: endPickerValue
  }), _useMergedState4 = _slicedToArray(_useMergedState3, 2), mergedEndPickerValue = _useMergedState4[0], setEndPickerValue = _useMergedState4[1], currentPickerValue = React.useMemo(function() {
    var current = [mergedStartPickerValue, mergedEndPickerValue][mergedActiveIndex];
    return isTimePicker ? current : fillTime(generateConfig2, current, timeDefaultValue[mergedActiveIndex]);
  }, [isTimePicker, mergedStartPickerValue, mergedEndPickerValue, mergedActiveIndex, generateConfig2, timeDefaultValue]), setCurrentPickerValue = /* @__PURE__ */ __name(function(nextPickerValue) {
    var source = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "panel", updater = [setStartPickerValue, setEndPickerValue][mergedActiveIndex];
    updater(nextPickerValue);
    var clone = [mergedStartPickerValue, mergedEndPickerValue];
    clone[mergedActiveIndex] = nextPickerValue, onPickerValueChange && (!isSame(generateConfig2, locale2, mergedStartPickerValue, clone[0], pickerMode) || !isSame(generateConfig2, locale2, mergedEndPickerValue, clone[1], pickerMode)) && onPickerValueChange(clone, {
      source,
      range: mergedActiveIndex === 1 ? "end" : "start",
      mode: modes
    });
  }, "setCurrentPickerValue"), getEndDatePickerValue = /* @__PURE__ */ __name(function(startDate, endDate) {
    if (multiplePanel) {
      var SAME_CHECKER = {
        date: "month",
        week: "month",
        month: "year",
        quarter: "year"
      }, mode = SAME_CHECKER[pickerMode];
      if (mode && !isSame(generateConfig2, locale2, startDate, endDate, mode))
        return offsetPanelDate(generateConfig2, pickerMode, endDate, -1);
      if (pickerMode === "year" && startDate) {
        var srcYear = Math.floor(generateConfig2.getYear(startDate) / 10), tgtYear = Math.floor(generateConfig2.getYear(endDate) / 10);
        if (srcYear !== tgtYear)
          return offsetPanelDate(generateConfig2, pickerMode, endDate, -1);
      }
    }
    return endDate;
  }, "getEndDatePickerValue"), prevActiveIndexRef = React.useRef(null);
  return useLayoutEffect$1(function() {
    if (open && !defaultPickerValue[mergedActiveIndex]) {
      var nextPickerValue = isTimePicker ? null : generateConfig2.getNow();
      if (prevActiveIndexRef.current !== null && prevActiveIndexRef.current !== mergedActiveIndex ? nextPickerValue = [mergedStartPickerValue, mergedEndPickerValue][mergedActiveIndex ^ 1] : calendarValue[mergedActiveIndex] ? nextPickerValue = mergedActiveIndex === 0 ? calendarValue[0] : getEndDatePickerValue(calendarValue[0], calendarValue[1]) : calendarValue[mergedActiveIndex ^ 1] && (nextPickerValue = calendarValue[mergedActiveIndex ^ 1]), nextPickerValue) {
        minDate && generateConfig2.isAfter(minDate, nextPickerValue) && (nextPickerValue = minDate);
        var offsetPickerValue = multiplePanel ? offsetPanelDate(generateConfig2, pickerMode, nextPickerValue, 1) : nextPickerValue;
        maxDate && generateConfig2.isAfter(offsetPickerValue, maxDate) && (nextPickerValue = multiplePanel ? offsetPanelDate(generateConfig2, pickerMode, maxDate, -1) : maxDate), setCurrentPickerValue(nextPickerValue, "reset");
      }
    }
  }, [open, mergedActiveIndex, calendarValue[mergedActiveIndex]]), React.useEffect(function() {
    open ? prevActiveIndexRef.current = mergedActiveIndex : prevActiveIndexRef.current = null;
  }, [open, mergedActiveIndex]), useLayoutEffect$1(function() {
    open && defaultPickerValue && defaultPickerValue[mergedActiveIndex] && setCurrentPickerValue(defaultPickerValue[mergedActiveIndex], "reset");
  }, [open, mergedActiveIndex]), [currentPickerValue, setCurrentPickerValue];
}
__name(useRangePickerValue, "useRangePickerValue");
function useSyncState$2(defaultValue, controlledValue) {
  var valueRef = React.useRef(defaultValue), _React$useState = React.useState({}), _React$useState2 = _slicedToArray(_React$useState, 2), forceUpdate = _React$useState2[1], getter = /* @__PURE__ */ __name(function(useControlledValueFirst) {
    return useControlledValueFirst && controlledValue !== void 0 ? controlledValue : valueRef.current;
  }, "getter"), setter = /* @__PURE__ */ __name(function(nextValue) {
    valueRef.current = nextValue, forceUpdate({});
  }, "setter");
  return [getter, setter, getter(!0)];
}
__name(useSyncState$2, "useSyncState$2");
var EMPTY_VALUE = [];
function useUtil(generateConfig2, locale2, formatList) {
  var getDateTexts = /* @__PURE__ */ __name(function(dates) {
    return dates.map(function(date4) {
      return formatValue(date4, {
        generateConfig: generateConfig2,
        locale: locale2,
        format: formatList[0]
      });
    });
  }, "getDateTexts"), isSameDates = /* @__PURE__ */ __name(function(source, target) {
    for (var maxLen = Math.max(source.length, target.length), diffIndex = -1, i = 0; i < maxLen; i += 1) {
      var prev2 = source[i] || null, next2 = target[i] || null;
      if (prev2 !== next2 && !isSameTimestamp(generateConfig2, prev2, next2)) {
        diffIndex = i;
        break;
      }
    }
    return [diffIndex < 0, diffIndex !== 0];
  }, "isSameDates");
  return [getDateTexts, isSameDates];
}
__name(useUtil, "useUtil");
function orderDates(dates, generateConfig2) {
  return _toConsumableArray(dates).sort(function(a, b) {
    return generateConfig2.isAfter(a, b) ? 1 : -1;
  });
}
__name(orderDates, "orderDates");
function useCalendarValue(mergedValue) {
  var _useSyncState = useSyncState$2(mergedValue), _useSyncState2 = _slicedToArray(_useSyncState, 2), calendarValue = _useSyncState2[0], setCalendarValue = _useSyncState2[1], syncWithValue = useEvent(function() {
    setCalendarValue(mergedValue);
  });
  return React.useEffect(function() {
    syncWithValue();
  }, [mergedValue]), [calendarValue, setCalendarValue];
}
__name(useCalendarValue, "useCalendarValue");
function useInnerValue(generateConfig2, locale2, formatList, rangeValue, order2, defaultValue, value, onCalendarChange, onOk) {
  var _useMergedState = useMergedState(defaultValue, {
    value
  }), _useMergedState2 = _slicedToArray(_useMergedState, 2), innerValue = _useMergedState2[0], setInnerValue = _useMergedState2[1], mergedValue = innerValue || EMPTY_VALUE, _useCalendarValue = useCalendarValue(mergedValue), _useCalendarValue2 = _slicedToArray(_useCalendarValue, 2), calendarValue = _useCalendarValue2[0], setCalendarValue = _useCalendarValue2[1], _useUtil = useUtil(generateConfig2, locale2, formatList), _useUtil2 = _slicedToArray(_useUtil, 2), getDateTexts = _useUtil2[0], isSameDates = _useUtil2[1], triggerCalendarChange = useEvent(function(nextCalendarValues) {
    var clone = _toConsumableArray(nextCalendarValues);
    if (rangeValue)
      for (var i = 0; i < 2; i += 1)
        clone[i] = clone[i] || null;
    else order2 && (clone = orderDates(clone.filter(function(date4) {
      return date4;
    }), generateConfig2));
    var _isSameDates = isSameDates(calendarValue(), clone), _isSameDates2 = _slicedToArray(_isSameDates, 2), isSameMergedDates = _isSameDates2[0], isSameStart = _isSameDates2[1];
    if (!isSameMergedDates && (setCalendarValue(clone), onCalendarChange)) {
      var cellTexts = getDateTexts(clone);
      onCalendarChange(clone, cellTexts, {
        range: isSameStart ? "end" : "start"
      });
    }
  }), triggerOk = /* @__PURE__ */ __name(function() {
    onOk && onOk(calendarValue());
  }, "triggerOk");
  return [mergedValue, setInnerValue, calendarValue, triggerCalendarChange, triggerOk];
}
__name(useInnerValue, "useInnerValue");
function useRangeValue(info, mergedValue, setInnerValue, getCalendarValue, triggerCalendarChange, disabled, formatList, focused, open, isInvalidateDate) {
  var generateConfig2 = info.generateConfig, locale2 = info.locale, picker = info.picker, onChange = info.onChange, allowEmpty = info.allowEmpty, order2 = info.order, orderOnChange = disabled.some(function(d) {
    return d;
  }) ? !1 : order2, _useUtil3 = useUtil(generateConfig2, locale2, formatList), _useUtil4 = _slicedToArray(_useUtil3, 2), getDateTexts = _useUtil4[0], isSameDates = _useUtil4[1], _useSyncState3 = useSyncState$2(mergedValue), _useSyncState4 = _slicedToArray(_useSyncState3, 2), submitValue = _useSyncState4[0], setSubmitValue = _useSyncState4[1], syncWithValue = useEvent(function() {
    setSubmitValue(mergedValue);
  });
  React.useEffect(function() {
    syncWithValue();
  }, [mergedValue]);
  var triggerSubmit = useEvent(function(nextValue) {
    var isNullValue = nextValue === null, clone = _toConsumableArray(nextValue || submitValue());
    if (isNullValue)
      for (var maxLen = Math.max(disabled.length, clone.length), i = 0; i < maxLen; i += 1)
        disabled[i] || (clone[i] = null);
    orderOnChange && clone[0] && clone[1] && (clone = orderDates(clone, generateConfig2)), triggerCalendarChange(clone);
    var _clone = clone, _clone2 = _slicedToArray(_clone, 2), start = _clone2[0], end = _clone2[1], startEmpty = !start, endEmpty = !end, validateEmptyDateRange = allowEmpty ? (
      // Validate empty start
      (!startEmpty || allowEmpty[0]) && // Validate empty end
      (!endEmpty || allowEmpty[1])
    ) : !0, validateOrder = !order2 || startEmpty || endEmpty || isSame(generateConfig2, locale2, start, end, picker) || generateConfig2.isAfter(end, start), validateDates = (
      // Validate start
      (disabled[0] || !start || !isInvalidateDate(start, {
        activeIndex: 0
      })) && // Validate end
      (disabled[1] || !end || !isInvalidateDate(end, {
        from: start,
        activeIndex: 1
      }))
    ), allPassed = (
      // Null value is from clear button
      isNullValue || // Normal check
      validateEmptyDateRange && validateOrder && validateDates
    );
    if (allPassed) {
      setInnerValue(clone);
      var _isSameDates3 = isSameDates(clone, mergedValue), _isSameDates4 = _slicedToArray(_isSameDates3, 1), isSameMergedDates = _isSameDates4[0];
      onChange && !isSameMergedDates && onChange(
        // Return null directly if all date are empty
        isNullValue && clone.every(function(val) {
          return !val;
        }) ? null : clone,
        getDateTexts(clone)
      );
    }
    return allPassed;
  }), flushSubmit = useEvent(function(index2, needTriggerChange) {
    var nextSubmitValue = fillIndex(submitValue(), index2, getCalendarValue()[index2]);
    setSubmitValue(nextSubmitValue), needTriggerChange && triggerSubmit();
  }), interactiveFinished = !focused && !open;
  useLockEffect(!interactiveFinished, function() {
    interactiveFinished && (triggerSubmit(), triggerCalendarChange(mergedValue), syncWithValue());
  }, 2);
  function hasSubmitValue(index2) {
    return !!submitValue()[index2];
  }
  return __name(hasSubmitValue, "hasSubmitValue"), [flushSubmit, triggerSubmit, hasSubmitValue];
}
__name(useRangeValue, "useRangeValue");
function useShowNow(picker, mode, showNow, showToday, rangePicker) {
  return mode !== "date" && mode !== "time" ? !1 : showNow !== void 0 ? showNow : showToday !== void 0 ? showToday : !rangePicker && (picker === "date" || picker === "time");
}
__name(useShowNow, "useShowNow");
function findValidateTime(date4, getHourUnits, getMinuteUnits, getSecondUnits, getMillisecondUnits, generateConfig2) {
  var nextDate = date4;
  function alignValidate(getUnitValue3, setUnitValue, units) {
    var nextValue = generateConfig2[getUnitValue3](nextDate), nextUnit = units.find(function(unit2) {
      return unit2.value === nextValue;
    });
    if (!nextUnit || nextUnit.disabled) {
      var validateUnits = units.filter(function(unit2) {
        return !unit2.disabled;
      }), reverseEnabledUnits = _toConsumableArray(validateUnits).reverse(), validateUnit = reverseEnabledUnits.find(function(unit2) {
        return unit2.value <= nextValue;
      }) || validateUnits[0];
      validateUnit && (nextValue = validateUnit.value, nextDate = generateConfig2[setUnitValue](nextDate, nextValue));
    }
    return nextValue;
  }
  __name(alignValidate, "alignValidate");
  var nextHour = alignValidate("getHour", "setHour", getHourUnits()), nextMinute = alignValidate("getMinute", "setMinute", getMinuteUnits(nextHour)), nextSecond = alignValidate("getSecond", "setSecond", getSecondUnits(nextHour, nextMinute));
  return alignValidate("getMillisecond", "setMillisecond", getMillisecondUnits(nextHour, nextMinute, nextSecond)), nextDate;
}
__name(findValidateTime, "findValidateTime");
function emptyDisabled() {
  return [];
}
__name(emptyDisabled, "emptyDisabled");
function generateUnits(start, end) {
  for (var step = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1, hideDisabledOptions = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : !1, disabledUnits = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : [], pad = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : 2, units = [], integerStep = step >= 1 ? step | 0 : 1, i = start; i <= end; i += integerStep) {
    var disabled = disabledUnits.includes(i);
    (!disabled || !hideDisabledOptions) && units.push({
      label: leftPad(i, pad),
      value: i,
      disabled
    });
  }
  return units;
}
__name(generateUnits, "generateUnits");
function useTimeInfo(generateConfig2) {
  var props = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, date4 = arguments.length > 2 ? arguments[2] : void 0, _ref = props || {}, use12Hours = _ref.use12Hours, _ref$hourStep = _ref.hourStep, hourStep = _ref$hourStep === void 0 ? 1 : _ref$hourStep, _ref$minuteStep = _ref.minuteStep, minuteStep = _ref$minuteStep === void 0 ? 1 : _ref$minuteStep, _ref$secondStep = _ref.secondStep, secondStep = _ref$secondStep === void 0 ? 1 : _ref$secondStep, _ref$millisecondStep = _ref.millisecondStep, millisecondStep = _ref$millisecondStep === void 0 ? 100 : _ref$millisecondStep, hideDisabledOptions = _ref.hideDisabledOptions, disabledTime = _ref.disabledTime, disabledHours = _ref.disabledHours, disabledMinutes = _ref.disabledMinutes, disabledSeconds = _ref.disabledSeconds, mergedDate = React.useMemo(function() {
    return date4 || generateConfig2.getNow();
  }, [date4, generateConfig2]);
  if (process.env.NODE_ENV !== "production") {
    var isHourStepValid = 24 % hourStep === 0, isMinuteStepValid = 60 % minuteStep === 0, isSecondStepValid = 60 % secondStep === 0;
    warningOnce(isHourStepValid, "`hourStep` ".concat(hourStep, " is invalid. It should be a factor of 24.")), warningOnce(isMinuteStepValid, "`minuteStep` ".concat(minuteStep, " is invalid. It should be a factor of 60.")), warningOnce(isSecondStepValid, "`secondStep` ".concat(secondStep, " is invalid. It should be a factor of 60."));
  }
  var getDisabledTimes = React.useCallback(function(targetDate) {
    var disabledConfig = (disabledTime == null ? void 0 : disabledTime(targetDate)) || {};
    return [disabledConfig.disabledHours || disabledHours || emptyDisabled, disabledConfig.disabledMinutes || disabledMinutes || emptyDisabled, disabledConfig.disabledSeconds || disabledSeconds || emptyDisabled, disabledConfig.disabledMilliseconds || emptyDisabled];
  }, [disabledTime, disabledHours, disabledMinutes, disabledSeconds]), _React$useMemo = React.useMemo(function() {
    return getDisabledTimes(mergedDate);
  }, [mergedDate, getDisabledTimes]), _React$useMemo2 = _slicedToArray(_React$useMemo, 4), mergedDisabledHours = _React$useMemo2[0], mergedDisabledMinutes = _React$useMemo2[1], mergedDisabledSeconds = _React$useMemo2[2], mergedDisabledMilliseconds = _React$useMemo2[3], getAllUnits = React.useCallback(function(getDisabledHours, getDisabledMinutes, getDisabledSeconds, getDisabledMilliseconds) {
    var hours = generateUnits(0, 23, hourStep, hideDisabledOptions, getDisabledHours()), rowHourUnits2 = use12Hours ? hours.map(function(unit2) {
      return _objectSpread2$1(_objectSpread2$1({}, unit2), {}, {
        label: leftPad(unit2.value % 12 || 12, 2)
      });
    }) : hours, getMinuteUnits2 = /* @__PURE__ */ __name(function(nextHour) {
      return generateUnits(0, 59, minuteStep, hideDisabledOptions, getDisabledMinutes(nextHour));
    }, "getMinuteUnits"), getSecondUnits2 = /* @__PURE__ */ __name(function(nextHour, nextMinute) {
      return generateUnits(0, 59, secondStep, hideDisabledOptions, getDisabledSeconds(nextHour, nextMinute));
    }, "getSecondUnits"), getMillisecondUnits2 = /* @__PURE__ */ __name(function(nextHour, nextMinute, nextSecond) {
      return generateUnits(0, 999, millisecondStep, hideDisabledOptions, getDisabledMilliseconds(nextHour, nextMinute, nextSecond), 3);
    }, "getMillisecondUnits");
    return [rowHourUnits2, getMinuteUnits2, getSecondUnits2, getMillisecondUnits2];
  }, [hideDisabledOptions, hourStep, use12Hours, millisecondStep, minuteStep, secondStep]), _React$useMemo3 = React.useMemo(function() {
    return getAllUnits(mergedDisabledHours, mergedDisabledMinutes, mergedDisabledSeconds, mergedDisabledMilliseconds);
  }, [getAllUnits, mergedDisabledHours, mergedDisabledMinutes, mergedDisabledSeconds, mergedDisabledMilliseconds]), _React$useMemo4 = _slicedToArray(_React$useMemo3, 4), rowHourUnits = _React$useMemo4[0], getMinuteUnits = _React$useMemo4[1], getSecondUnits = _React$useMemo4[2], getMillisecondUnits = _React$useMemo4[3], getValidTime = /* @__PURE__ */ __name(function(nextTime, certainDate) {
    var getCheckHourUnits = /* @__PURE__ */ __name(function() {
      return rowHourUnits;
    }, "getCheckHourUnits"), getCheckMinuteUnits = getMinuteUnits, getCheckSecondUnits = getSecondUnits, getCheckMillisecondUnits = getMillisecondUnits;
    if (certainDate) {
      var _getDisabledTimes = getDisabledTimes(certainDate), _getDisabledTimes2 = _slicedToArray(_getDisabledTimes, 4), targetDisabledHours = _getDisabledTimes2[0], targetDisabledMinutes = _getDisabledTimes2[1], targetDisabledSeconds = _getDisabledTimes2[2], targetDisabledMilliseconds = _getDisabledTimes2[3], _getAllUnits = getAllUnits(targetDisabledHours, targetDisabledMinutes, targetDisabledSeconds, targetDisabledMilliseconds), _getAllUnits2 = _slicedToArray(_getAllUnits, 4), targetRowHourUnits = _getAllUnits2[0], targetGetMinuteUnits = _getAllUnits2[1], targetGetSecondUnits = _getAllUnits2[2], targetGetMillisecondUnits = _getAllUnits2[3];
      getCheckHourUnits = /* @__PURE__ */ __name(function() {
        return targetRowHourUnits;
      }, "getCheckHourUnits"), getCheckMinuteUnits = targetGetMinuteUnits, getCheckSecondUnits = targetGetSecondUnits, getCheckMillisecondUnits = targetGetMillisecondUnits;
    }
    var validateDate = findValidateTime(nextTime, getCheckHourUnits, getCheckMinuteUnits, getCheckSecondUnits, getCheckMillisecondUnits, generateConfig2);
    return validateDate;
  }, "getValidTime");
  return [
    // getValidTime
    getValidTime,
    // Units
    rowHourUnits,
    getMinuteUnits,
    getSecondUnits,
    getMillisecondUnits
  ];
}
__name(useTimeInfo, "useTimeInfo");
function Footer$3(props) {
  var mode = props.mode, internalMode = props.internalMode, renderExtraFooter = props.renderExtraFooter, showNow = props.showNow, showTime = props.showTime, onSubmit = props.onSubmit, onNow = props.onNow, invalid = props.invalid, needConfirm = props.needConfirm, generateConfig2 = props.generateConfig, disabledDate = props.disabledDate, _React$useContext = React.useContext(PickerContext), prefixCls = _React$useContext.prefixCls, locale2 = _React$useContext.locale, _React$useContext$but = _React$useContext.button, Button2 = _React$useContext$but === void 0 ? "button" : _React$useContext$but, now2 = generateConfig2.getNow(), _useTimeInfo = useTimeInfo(generateConfig2, showTime, now2), _useTimeInfo2 = _slicedToArray(_useTimeInfo, 1), getValidTime = _useTimeInfo2[0], extraNode = renderExtraFooter == null ? void 0 : renderExtraFooter(mode), nowDisabled = disabledDate(now2, {
    type: mode
  }), onInternalNow = /* @__PURE__ */ __name(function() {
    if (!nowDisabled) {
      var validateNow = getValidTime(now2);
      onNow(validateNow);
    }
  }, "onInternalNow"), nowPrefixCls = "".concat(prefixCls, "-now"), nowBtnPrefixCls = "".concat(nowPrefixCls, "-btn"), presetNode = showNow && /* @__PURE__ */ React.createElement("li", {
    className: nowPrefixCls
  }, /* @__PURE__ */ React.createElement("a", {
    className: cn(nowBtnPrefixCls, nowDisabled && "".concat(nowBtnPrefixCls, "-disabled")),
    "aria-disabled": nowDisabled,
    onClick: onInternalNow
  }, internalMode === "date" ? locale2.today : locale2.now)), okNode = needConfirm && /* @__PURE__ */ React.createElement("li", {
    className: "".concat(prefixCls, "-ok")
  }, /* @__PURE__ */ React.createElement(Button2, {
    disabled: invalid,
    onClick: onSubmit
  }, locale2.ok)), rangeNode = (presetNode || okNode) && /* @__PURE__ */ React.createElement("ul", {
    className: "".concat(prefixCls, "-ranges")
  }, presetNode, okNode);
  return !extraNode && !rangeNode ? null : /* @__PURE__ */ React.createElement("div", {
    className: "".concat(prefixCls, "-footer")
  }, extraNode && /* @__PURE__ */ React.createElement("div", {
    className: "".concat(prefixCls, "-footer-extra")
  }, extraNode), rangeNode);
}
__name(Footer$3, "Footer$3");
function useToggleDates(generateConfig2, locale2, panelMode) {
  function toggleDates(list, target) {
    var index2 = list.findIndex(function(date4) {
      return isSame(generateConfig2, locale2, date4, target, panelMode);
    });
    if (index2 === -1)
      return [].concat(_toConsumableArray(list), [target]);
    var sliceList = _toConsumableArray(list);
    return sliceList.splice(index2, 1), sliceList;
  }
  return __name(toggleDates, "toggleDates"), toggleDates;
}
__name(useToggleDates, "useToggleDates");
var PanelContext = /* @__PURE__ */ React.createContext(null);
function usePanelContext() {
  return React.useContext(PanelContext);
}
__name(usePanelContext, "usePanelContext");
function useInfo(props, panelType) {
  var prefixCls = props.prefixCls, generateConfig2 = props.generateConfig, locale2 = props.locale, disabledDate = props.disabledDate, minDate = props.minDate, maxDate = props.maxDate, cellRender = props.cellRender, hoverValue = props.hoverValue, hoverRangeValue = props.hoverRangeValue, onHover = props.onHover, values = props.values, pickerValue = props.pickerValue, onSelect = props.onSelect, prevIcon = props.prevIcon, nextIcon = props.nextIcon, superPrevIcon = props.superPrevIcon, superNextIcon = props.superNextIcon, now2 = generateConfig2.getNow(), info = {
    now: now2,
    values,
    pickerValue,
    prefixCls,
    disabledDate,
    minDate,
    maxDate,
    cellRender,
    hoverValue,
    hoverRangeValue,
    onHover,
    locale: locale2,
    generateConfig: generateConfig2,
    onSelect,
    panelType,
    // Icons
    prevIcon,
    nextIcon,
    superPrevIcon,
    superNextIcon
  };
  return [info, now2];
}
__name(useInfo, "useInfo");
var PickerHackContext = /* @__PURE__ */ React.createContext({});
process.env.NODE_ENV !== "production" && (PickerHackContext.displayName = "PickerHackContext");
function PanelBody(props) {
  for (var rowNum = props.rowNum, colNum = props.colNum, baseDate = props.baseDate, getCellDate = props.getCellDate, prefixColumn = props.prefixColumn, rowClassName = props.rowClassName, titleFormat = props.titleFormat, getCellText = props.getCellText, getCellClassName = props.getCellClassName, headerCells = props.headerCells, _props$cellSelection = props.cellSelection, cellSelection = _props$cellSelection === void 0 ? !0 : _props$cellSelection, disabledDate = props.disabledDate, _usePanelContext = usePanelContext(), prefixCls = _usePanelContext.prefixCls, type4 = _usePanelContext.panelType, now2 = _usePanelContext.now, contextDisabledDate = _usePanelContext.disabledDate, cellRender = _usePanelContext.cellRender, onHover = _usePanelContext.onHover, hoverValue = _usePanelContext.hoverValue, hoverRangeValue = _usePanelContext.hoverRangeValue, generateConfig2 = _usePanelContext.generateConfig, values = _usePanelContext.values, locale2 = _usePanelContext.locale, onSelect = _usePanelContext.onSelect, mergedDisabledDate = disabledDate || contextDisabledDate, cellPrefixCls = "".concat(prefixCls, "-cell"), _React$useContext = React.useContext(PickerHackContext), onCellDblClick = _React$useContext.onCellDblClick, matchValues = /* @__PURE__ */ __name(function(date4) {
    return values.some(function(singleValue) {
      return singleValue && isSame(generateConfig2, locale2, date4, singleValue, type4);
    });
  }, "matchValues"), rows = [], row = 0; row < rowNum; row += 1) {
    for (var rowNode = [], rowStartDate = void 0, _loop = /* @__PURE__ */ __name(function() {
      var offset2 = row * colNum + col, currentDate = getCellDate(baseDate, offset2), disabled = mergedDisabledDate == null ? void 0 : mergedDisabledDate(currentDate, {
        type: type4
      });
      col === 0 && (rowStartDate = currentDate, prefixColumn && rowNode.push(prefixColumn(rowStartDate)));
      var inRange = !1, rangeStart = !1, rangeEnd = !1;
      if (cellSelection && hoverRangeValue) {
        var _hoverRangeValue = _slicedToArray(hoverRangeValue, 2), hoverStart = _hoverRangeValue[0], hoverEnd = _hoverRangeValue[1];
        inRange = isInRange(generateConfig2, hoverStart, hoverEnd, currentDate), rangeStart = isSame(generateConfig2, locale2, currentDate, hoverStart, type4), rangeEnd = isSame(generateConfig2, locale2, currentDate, hoverEnd, type4);
      }
      var title2 = titleFormat ? formatValue(currentDate, {
        locale: locale2,
        format: titleFormat,
        generateConfig: generateConfig2
      }) : void 0, inner = /* @__PURE__ */ React.createElement("div", {
        className: "".concat(cellPrefixCls, "-inner")
      }, getCellText(currentDate));
      rowNode.push(/* @__PURE__ */ React.createElement("td", {
        key: col,
        title: title2,
        className: cn(cellPrefixCls, _objectSpread2$1(_defineProperty$2(_defineProperty$2(_defineProperty$2(_defineProperty$2(_defineProperty$2(_defineProperty$2({}, "".concat(cellPrefixCls, "-disabled"), disabled), "".concat(cellPrefixCls, "-hover"), (hoverValue || []).some(function(date4) {
          return isSame(generateConfig2, locale2, currentDate, date4, type4);
        })), "".concat(cellPrefixCls, "-in-range"), inRange && !rangeStart && !rangeEnd), "".concat(cellPrefixCls, "-range-start"), rangeStart), "".concat(cellPrefixCls, "-range-end"), rangeEnd), "".concat(prefixCls, "-cell-selected"), !hoverRangeValue && // WeekPicker use row instead
        type4 !== "week" && matchValues(currentDate)), getCellClassName(currentDate))),
        onClick: /* @__PURE__ */ __name(function() {
          disabled || onSelect(currentDate);
        }, "onClick"),
        onDoubleClick: /* @__PURE__ */ __name(function() {
          !disabled && onCellDblClick && onCellDblClick();
        }, "onDoubleClick"),
        onMouseEnter: /* @__PURE__ */ __name(function() {
          disabled || onHover == null || onHover(currentDate);
        }, "onMouseEnter"),
        onMouseLeave: /* @__PURE__ */ __name(function() {
          disabled || onHover == null || onHover(null);
        }, "onMouseLeave")
      }, cellRender ? cellRender(currentDate, {
        prefixCls,
        originNode: inner,
        today: now2,
        type: type4,
        locale: locale2
      }) : inner));
    }, "_loop"), col = 0; col < colNum; col += 1)
      _loop();
    rows.push(/* @__PURE__ */ React.createElement("tr", {
      key: row,
      className: rowClassName == null ? void 0 : rowClassName(rowStartDate)
    }, rowNode));
  }
  return /* @__PURE__ */ React.createElement("div", {
    className: "".concat(prefixCls, "-body")
  }, /* @__PURE__ */ React.createElement("table", {
    className: "".concat(prefixCls, "-content")
  }, headerCells && /* @__PURE__ */ React.createElement("thead", null, /* @__PURE__ */ React.createElement("tr", null, headerCells)), /* @__PURE__ */ React.createElement("tbody", null, rows)));
}
__name(PanelBody, "PanelBody");
var HIDDEN_STYLE$1 = {
  visibility: "hidden"
};
function PanelHeader(props) {
  var offset2 = props.offset, superOffset = props.superOffset, onChange = props.onChange, getStart = props.getStart, getEnd = props.getEnd, children = props.children, _usePanelContext = usePanelContext(), prefixCls = _usePanelContext.prefixCls, _usePanelContext$prev = _usePanelContext.prevIcon, prevIcon = _usePanelContext$prev === void 0 ? "‹" : _usePanelContext$prev, _usePanelContext$next = _usePanelContext.nextIcon, nextIcon = _usePanelContext$next === void 0 ? "›" : _usePanelContext$next, _usePanelContext$supe = _usePanelContext.superPrevIcon, superPrevIcon = _usePanelContext$supe === void 0 ? "«" : _usePanelContext$supe, _usePanelContext$supe2 = _usePanelContext.superNextIcon, superNextIcon = _usePanelContext$supe2 === void 0 ? "»" : _usePanelContext$supe2, minDate = _usePanelContext.minDate, maxDate = _usePanelContext.maxDate, generateConfig2 = _usePanelContext.generateConfig, locale2 = _usePanelContext.locale, pickerValue = _usePanelContext.pickerValue, type4 = _usePanelContext.panelType, headerPrefixCls = "".concat(prefixCls, "-header"), _React$useContext = React.useContext(PickerHackContext), hidePrev = _React$useContext.hidePrev, hideNext = _React$useContext.hideNext, hideHeader = _React$useContext.hideHeader, disabledOffsetPrev = React.useMemo(function() {
    if (!minDate || !offset2 || !getEnd)
      return !1;
    var prevPanelLimitDate = getEnd(offset2(-1, pickerValue));
    return !isSameOrAfter(generateConfig2, locale2, prevPanelLimitDate, minDate, type4);
  }, [minDate, offset2, pickerValue, getEnd, generateConfig2, locale2, type4]), disabledSuperOffsetPrev = React.useMemo(function() {
    if (!minDate || !superOffset || !getEnd)
      return !1;
    var prevPanelLimitDate = getEnd(superOffset(-1, pickerValue));
    return !isSameOrAfter(generateConfig2, locale2, prevPanelLimitDate, minDate, type4);
  }, [minDate, superOffset, pickerValue, getEnd, generateConfig2, locale2, type4]), disabledOffsetNext = React.useMemo(function() {
    if (!maxDate || !offset2 || !getStart)
      return !1;
    var nextPanelLimitDate = getStart(offset2(1, pickerValue));
    return !isSameOrAfter(generateConfig2, locale2, maxDate, nextPanelLimitDate, type4);
  }, [maxDate, offset2, pickerValue, getStart, generateConfig2, locale2, type4]), disabledSuperOffsetNext = React.useMemo(function() {
    if (!maxDate || !superOffset || !getStart)
      return !1;
    var nextPanelLimitDate = getStart(superOffset(1, pickerValue));
    return !isSameOrAfter(generateConfig2, locale2, maxDate, nextPanelLimitDate, type4);
  }, [maxDate, superOffset, pickerValue, getStart, generateConfig2, locale2, type4]), onOffset = /* @__PURE__ */ __name(function(distance) {
    offset2 && onChange(offset2(distance, pickerValue));
  }, "onOffset"), onSuperOffset = /* @__PURE__ */ __name(function(distance) {
    superOffset && onChange(superOffset(distance, pickerValue));
  }, "onSuperOffset");
  if (hideHeader)
    return null;
  var prevBtnCls = "".concat(headerPrefixCls, "-prev-btn"), nextBtnCls = "".concat(headerPrefixCls, "-next-btn"), superPrevBtnCls = "".concat(headerPrefixCls, "-super-prev-btn"), superNextBtnCls = "".concat(headerPrefixCls, "-super-next-btn");
  return /* @__PURE__ */ React.createElement("div", {
    className: headerPrefixCls
  }, superOffset && /* @__PURE__ */ React.createElement("button", {
    type: "button",
    "aria-label": "super-prev-year",
    onClick: /* @__PURE__ */ __name(function() {
      return onSuperOffset(-1);
    }, "onClick"),
    tabIndex: -1,
    className: cn(superPrevBtnCls, disabledSuperOffsetPrev && "".concat(superPrevBtnCls, "-disabled")),
    disabled: disabledSuperOffsetPrev,
    style: hidePrev ? HIDDEN_STYLE$1 : {}
  }, superPrevIcon), offset2 && /* @__PURE__ */ React.createElement("button", {
    type: "button",
    "aria-label": "prev-year",
    onClick: /* @__PURE__ */ __name(function() {
      return onOffset(-1);
    }, "onClick"),
    tabIndex: -1,
    className: cn(prevBtnCls, disabledOffsetPrev && "".concat(prevBtnCls, "-disabled")),
    disabled: disabledOffsetPrev,
    style: hidePrev ? HIDDEN_STYLE$1 : {}
  }, prevIcon), /* @__PURE__ */ React.createElement("div", {
    className: "".concat(headerPrefixCls, "-view")
  }, children), offset2 && /* @__PURE__ */ React.createElement("button", {
    type: "button",
    "aria-label": "next-year",
    onClick: /* @__PURE__ */ __name(function() {
      return onOffset(1);
    }, "onClick"),
    tabIndex: -1,
    className: cn(nextBtnCls, disabledOffsetNext && "".concat(nextBtnCls, "-disabled")),
    disabled: disabledOffsetNext,
    style: hideNext ? HIDDEN_STYLE$1 : {}
  }, nextIcon), superOffset && /* @__PURE__ */ React.createElement("button", {
    type: "button",
    "aria-label": "super-next-year",
    onClick: /* @__PURE__ */ __name(function() {
      return onSuperOffset(1);
    }, "onClick"),
    tabIndex: -1,
    className: cn(superNextBtnCls, disabledSuperOffsetNext && "".concat(superNextBtnCls, "-disabled")),
    disabled: disabledSuperOffsetNext,
    style: hideNext ? HIDDEN_STYLE$1 : {}
  }, superNextIcon));
}
__name(PanelHeader, "PanelHeader");
function DatePanel(props) {
  var prefixCls = props.prefixCls, _props$panelName = props.panelName, panelName = _props$panelName === void 0 ? "date" : _props$panelName, locale2 = props.locale, generateConfig2 = props.generateConfig, pickerValue = props.pickerValue, onPickerValueChange = props.onPickerValueChange, onModeChange = props.onModeChange, _props$mode = props.mode, mode = _props$mode === void 0 ? "date" : _props$mode, disabledDate = props.disabledDate, onSelect = props.onSelect, onHover = props.onHover, showWeek = props.showWeek, panelPrefixCls = "".concat(prefixCls, "-").concat(panelName, "-panel"), cellPrefixCls = "".concat(prefixCls, "-cell"), isWeek = mode === "week", _useInfo = useInfo(props, mode), _useInfo2 = _slicedToArray(_useInfo, 2), info = _useInfo2[0], now2 = _useInfo2[1], weekFirstDay = generateConfig2.locale.getWeekFirstDay(locale2.locale), monthStartDate = generateConfig2.setDate(pickerValue, 1), baseDate = getWeekStartDate(locale2.locale, generateConfig2, monthStartDate), month = generateConfig2.getMonth(pickerValue), showPrefixColumn = showWeek === void 0 ? isWeek : showWeek, prefixColumn = showPrefixColumn ? function(date4) {
    var disabled = disabledDate == null ? void 0 : disabledDate(date4, {
      type: "week"
    });
    return /* @__PURE__ */ React.createElement("td", {
      key: "week",
      className: cn(cellPrefixCls, "".concat(cellPrefixCls, "-week"), _defineProperty$2({}, "".concat(cellPrefixCls, "-disabled"), disabled)),
      onClick: /* @__PURE__ */ __name(function() {
        disabled || onSelect(date4);
      }, "onClick"),
      onMouseEnter: /* @__PURE__ */ __name(function() {
        disabled || onHover == null || onHover(date4);
      }, "onMouseEnter"),
      onMouseLeave: /* @__PURE__ */ __name(function() {
        disabled || onHover == null || onHover(null);
      }, "onMouseLeave")
    }, /* @__PURE__ */ React.createElement("div", {
      className: "".concat(cellPrefixCls, "-inner")
    }, generateConfig2.locale.getWeek(locale2.locale, date4)));
  } : null, headerCells = [], weekDaysLocale = locale2.shortWeekDays || (generateConfig2.locale.getShortWeekDays ? generateConfig2.locale.getShortWeekDays(locale2.locale) : []);
  prefixColumn && headerCells.push(/* @__PURE__ */ React.createElement("th", {
    key: "empty",
    "aria-label": "empty cell"
  }));
  for (var i = 0; i < WEEK_DAY_COUNT; i += 1)
    headerCells.push(/* @__PURE__ */ React.createElement("th", {
      key: i
    }, weekDaysLocale[(i + weekFirstDay) % WEEK_DAY_COUNT]));
  var getCellDate = /* @__PURE__ */ __name(function(date4, offset2) {
    return generateConfig2.addDate(date4, offset2);
  }, "getCellDate"), getCellText = /* @__PURE__ */ __name(function(date4) {
    return formatValue(date4, {
      locale: locale2,
      format: locale2.cellDateFormat,
      generateConfig: generateConfig2
    });
  }, "getCellText"), getCellClassName = /* @__PURE__ */ __name(function(date4) {
    var classObj = _defineProperty$2(_defineProperty$2({}, "".concat(prefixCls, "-cell-in-view"), isSameMonth(generateConfig2, date4, pickerValue)), "".concat(prefixCls, "-cell-today"), isSameDate(generateConfig2, date4, now2));
    return classObj;
  }, "getCellClassName"), monthsLocale = locale2.shortMonths || (generateConfig2.locale.getShortMonths ? generateConfig2.locale.getShortMonths(locale2.locale) : []), yearNode = /* @__PURE__ */ React.createElement("button", {
    type: "button",
    "aria-label": "year panel",
    key: "year",
    onClick: /* @__PURE__ */ __name(function() {
      onModeChange("year", pickerValue);
    }, "onClick"),
    tabIndex: -1,
    className: "".concat(prefixCls, "-year-btn")
  }, formatValue(pickerValue, {
    locale: locale2,
    format: locale2.yearFormat,
    generateConfig: generateConfig2
  })), monthNode = /* @__PURE__ */ React.createElement("button", {
    type: "button",
    "aria-label": "month panel",
    key: "month",
    onClick: /* @__PURE__ */ __name(function() {
      onModeChange("month", pickerValue);
    }, "onClick"),
    tabIndex: -1,
    className: "".concat(prefixCls, "-month-btn")
  }, locale2.monthFormat ? formatValue(pickerValue, {
    locale: locale2,
    format: locale2.monthFormat,
    generateConfig: generateConfig2
  }) : monthsLocale[month]), monthYearNodes = locale2.monthBeforeYear ? [monthNode, yearNode] : [yearNode, monthNode];
  return /* @__PURE__ */ React.createElement(PanelContext.Provider, {
    value: info
  }, /* @__PURE__ */ React.createElement("div", {
    className: cn(panelPrefixCls, showWeek && "".concat(panelPrefixCls, "-show-week"))
  }, /* @__PURE__ */ React.createElement(PanelHeader, {
    offset: /* @__PURE__ */ __name(function(distance) {
      return generateConfig2.addMonth(pickerValue, distance);
    }, "offset"),
    superOffset: /* @__PURE__ */ __name(function(distance) {
      return generateConfig2.addYear(pickerValue, distance);
    }, "superOffset"),
    onChange: onPickerValueChange,
    getStart: /* @__PURE__ */ __name(function(date4) {
      return generateConfig2.setDate(date4, 1);
    }, "getStart"),
    getEnd: /* @__PURE__ */ __name(function(date4) {
      var clone = generateConfig2.setDate(date4, 1);
      return clone = generateConfig2.addMonth(clone, 1), generateConfig2.addDate(clone, -1);
    }, "getEnd")
  }, monthYearNodes), /* @__PURE__ */ React.createElement(PanelBody, _extends({
    titleFormat: locale2.fieldDateFormat
  }, props, {
    colNum: WEEK_DAY_COUNT,
    rowNum: 6,
    baseDate,
    headerCells,
    getCellDate,
    getCellText,
    getCellClassName,
    prefixColumn,
    cellSelection: !isWeek
  }))));
}
__name(DatePanel, "DatePanel");
var SPEED_PTG = 1 / 3;
function useScrollTo(ulRef, value) {
  var scrollingRef = React.useRef(!1), scrollRafRef = React.useRef(null), scrollDistRef = React.useRef(null), isScrolling = /* @__PURE__ */ __name(function() {
    return scrollingRef.current;
  }, "isScrolling"), stopScroll = /* @__PURE__ */ __name(function() {
    wrapperRaf.cancel(scrollRafRef.current), scrollingRef.current = !1;
  }, "stopScroll"), scrollRafTimesRef = React.useRef(), startScroll = /* @__PURE__ */ __name(function() {
    var ul = ulRef.current;
    if (scrollDistRef.current = null, scrollRafTimesRef.current = 0, ul) {
      var targetLi = ul.querySelector('[data-value="'.concat(value, '"]')), firstLi = ul.querySelector("li"), doScroll = /* @__PURE__ */ __name(function doScroll2() {
        stopScroll(), scrollingRef.current = !0, scrollRafTimesRef.current += 1;
        var currentTop = ul.scrollTop, firstLiTop = firstLi.offsetTop, targetLiTop = targetLi.offsetTop, targetTop = targetLiTop - firstLiTop;
        if (targetLiTop === 0 && targetLi !== firstLi || !isVisible(ul)) {
          scrollRafTimesRef.current <= 5 && (scrollRafRef.current = wrapperRaf(doScroll2));
          return;
        }
        var nextTop = currentTop + (targetTop - currentTop) * SPEED_PTG, dist = Math.abs(targetTop - nextTop);
        if (scrollDistRef.current !== null && scrollDistRef.current < dist) {
          stopScroll();
          return;
        }
        if (scrollDistRef.current = dist, dist <= 1) {
          ul.scrollTop = targetTop, stopScroll();
          return;
        }
        ul.scrollTop = nextTop, scrollRafRef.current = wrapperRaf(doScroll2);
      }, "doScroll");
      targetLi && firstLi && doScroll();
    }
  }, "startScroll"), syncScroll = useEvent(startScroll);
  return [syncScroll, stopScroll, isScrolling];
}
__name(useScrollTo, "useScrollTo");
var SCROLL_DELAY = 300;
function TimeColumn(props) {
  var units = props.units, value = props.value, optionalValue = props.optionalValue, type4 = props.type, onChange = props.onChange, onHover = props.onHover, onDblClick = props.onDblClick, changeOnScroll = props.changeOnScroll, _usePanelContext = usePanelContext(), prefixCls = _usePanelContext.prefixCls, cellRender = _usePanelContext.cellRender, now2 = _usePanelContext.now, locale2 = _usePanelContext.locale, panelPrefixCls = "".concat(prefixCls, "-time-panel"), cellPrefixCls = "".concat(prefixCls, "-time-panel-cell"), ulRef = React.useRef(null), checkDelayRef = React.useRef(), clearDelayCheck = /* @__PURE__ */ __name(function() {
    clearTimeout(checkDelayRef.current);
  }, "clearDelayCheck"), _useScrollTo = useScrollTo(ulRef, value ?? optionalValue), _useScrollTo2 = _slicedToArray(_useScrollTo, 3), syncScroll = _useScrollTo2[0], stopScroll = _useScrollTo2[1], isScrolling = _useScrollTo2[2];
  useLayoutEffect$1(function() {
    return syncScroll(), clearDelayCheck(), function() {
      stopScroll(), clearDelayCheck();
    };
  }, [value, optionalValue, units]);
  var onInternalScroll = /* @__PURE__ */ __name(function(event) {
    clearDelayCheck();
    var target = event.target;
    !isScrolling() && changeOnScroll && (checkDelayRef.current = setTimeout(function() {
      var ul = ulRef.current, firstLiTop = ul.querySelector("li").offsetTop, liList = Array.from(ul.querySelectorAll("li")), liTopList = liList.map(function(li) {
        return li.offsetTop - firstLiTop;
      }), liDistList = liTopList.map(function(top, index2) {
        return units[index2].disabled ? Number.MAX_SAFE_INTEGER : Math.abs(top - target.scrollTop);
      }), minDist = Math.min.apply(Math, _toConsumableArray(liDistList)), minDistIndex = liDistList.findIndex(function(dist) {
        return dist === minDist;
      }), targetUnit = units[minDistIndex];
      targetUnit && !targetUnit.disabled && onChange(targetUnit.value);
    }, SCROLL_DELAY));
  }, "onInternalScroll"), columnPrefixCls = "".concat(panelPrefixCls, "-column");
  return /* @__PURE__ */ React.createElement("ul", {
    className: columnPrefixCls,
    ref: ulRef,
    "data-type": type4,
    onScroll: onInternalScroll
  }, units.map(function(_ref) {
    var label2 = _ref.label, unitValue = _ref.value, disabled = _ref.disabled, inner = /* @__PURE__ */ React.createElement("div", {
      className: "".concat(cellPrefixCls, "-inner")
    }, label2);
    return /* @__PURE__ */ React.createElement("li", {
      key: unitValue,
      className: cn(cellPrefixCls, _defineProperty$2(_defineProperty$2({}, "".concat(cellPrefixCls, "-selected"), value === unitValue), "".concat(cellPrefixCls, "-disabled"), disabled)),
      onClick: /* @__PURE__ */ __name(function() {
        disabled || onChange(unitValue);
      }, "onClick"),
      onDoubleClick: /* @__PURE__ */ __name(function() {
        !disabled && onDblClick && onDblClick();
      }, "onDoubleClick"),
      onMouseEnter: /* @__PURE__ */ __name(function() {
        onHover(unitValue);
      }, "onMouseEnter"),
      onMouseLeave: /* @__PURE__ */ __name(function() {
        onHover(null);
      }, "onMouseLeave"),
      "data-value": unitValue
    }, cellRender ? cellRender(unitValue, {
      prefixCls,
      originNode: inner,
      today: now2,
      type: "time",
      subType: type4,
      locale: locale2
    }) : inner);
  }));
}
__name(TimeColumn, "TimeColumn");
function isAM(hour) {
  return hour < 12;
}
__name(isAM, "isAM");
function TimePanelBody(props) {
  var showHour = props.showHour, showMinute = props.showMinute, showSecond = props.showSecond, showMillisecond = props.showMillisecond, showMeridiem = props.use12Hours, changeOnScroll = props.changeOnScroll, _usePanelContext = usePanelContext(), prefixCls = _usePanelContext.prefixCls, values = _usePanelContext.values, generateConfig2 = _usePanelContext.generateConfig, locale2 = _usePanelContext.locale, onSelect = _usePanelContext.onSelect, _usePanelContext$onHo = _usePanelContext.onHover, onHover = _usePanelContext$onHo === void 0 ? function() {
  } : _usePanelContext$onHo, pickerValue = _usePanelContext.pickerValue, value = (values == null ? void 0 : values[0]) || null, _React$useContext = React.useContext(PickerHackContext), onCellDblClick = _React$useContext.onCellDblClick, _useTimeInfo = useTimeInfo(generateConfig2, props, value), _useTimeInfo2 = _slicedToArray(_useTimeInfo, 5), getValidTime = _useTimeInfo2[0], rowHourUnits = _useTimeInfo2[1], getMinuteUnits = _useTimeInfo2[2], getSecondUnits = _useTimeInfo2[3], getMillisecondUnits = _useTimeInfo2[4], getUnitValue3 = /* @__PURE__ */ __name(function(func) {
    var valueUnitVal = value && generateConfig2[func](value), pickerUnitValue = pickerValue && generateConfig2[func](pickerValue);
    return [valueUnitVal, pickerUnitValue];
  }, "getUnitValue"), _getUnitValue = getUnitValue3("getHour"), _getUnitValue2 = _slicedToArray(_getUnitValue, 2), hour = _getUnitValue2[0], pickerHour = _getUnitValue2[1], _getUnitValue3 = getUnitValue3("getMinute"), _getUnitValue4 = _slicedToArray(_getUnitValue3, 2), minute = _getUnitValue4[0], pickerMinute = _getUnitValue4[1], _getUnitValue5 = getUnitValue3("getSecond"), _getUnitValue6 = _slicedToArray(_getUnitValue5, 2), second = _getUnitValue6[0], pickerSecond = _getUnitValue6[1], _getUnitValue7 = getUnitValue3("getMillisecond"), _getUnitValue8 = _slicedToArray(_getUnitValue7, 2), millisecond = _getUnitValue8[0], pickerMillisecond = _getUnitValue8[1], meridiem = hour === null ? null : isAM(hour) ? "am" : "pm", hourUnits = React.useMemo(function() {
    return showMeridiem ? isAM(hour) ? rowHourUnits.filter(function(h) {
      return isAM(h.value);
    }) : rowHourUnits.filter(function(h) {
      return !isAM(h.value);
    }) : rowHourUnits;
  }, [hour, rowHourUnits, showMeridiem]), getEnabled = /* @__PURE__ */ __name(function(units, val) {
    var _enabledUnits$, enabledUnits = units.filter(function(unit2) {
      return !unit2.disabled;
    });
    return val ?? // Fallback to enabled value
    (enabledUnits == null || (_enabledUnits$ = enabledUnits[0]) === null || _enabledUnits$ === void 0 ? void 0 : _enabledUnits$.value);
  }, "getEnabled"), validHour = getEnabled(rowHourUnits, hour), minuteUnits = React.useMemo(function() {
    return getMinuteUnits(validHour);
  }, [getMinuteUnits, validHour]), validMinute = getEnabled(minuteUnits, minute), secondUnits = React.useMemo(function() {
    return getSecondUnits(validHour, validMinute);
  }, [getSecondUnits, validHour, validMinute]), validSecond = getEnabled(secondUnits, second), millisecondUnits = React.useMemo(function() {
    return getMillisecondUnits(validHour, validMinute, validSecond);
  }, [getMillisecondUnits, validHour, validMinute, validSecond]), validMillisecond = getEnabled(millisecondUnits, millisecond), meridiemUnits = React.useMemo(function() {
    if (!showMeridiem)
      return [];
    var base = generateConfig2.getNow(), amDate = generateConfig2.setHour(base, 6), pmDate = generateConfig2.setHour(base, 18), formatMeridiem = /* @__PURE__ */ __name(function(date4, defaultLabel) {
      var cellMeridiemFormat = locale2.cellMeridiemFormat;
      return cellMeridiemFormat ? formatValue(date4, {
        generateConfig: generateConfig2,
        locale: locale2,
        format: cellMeridiemFormat
      }) : defaultLabel;
    }, "formatMeridiem");
    return [{
      label: formatMeridiem(amDate, "AM"),
      value: "am",
      disabled: rowHourUnits.every(function(h) {
        return h.disabled || !isAM(h.value);
      })
    }, {
      label: formatMeridiem(pmDate, "PM"),
      value: "pm",
      disabled: rowHourUnits.every(function(h) {
        return h.disabled || isAM(h.value);
      })
    }];
  }, [rowHourUnits, showMeridiem, generateConfig2, locale2]), triggerChange = /* @__PURE__ */ __name(function(nextDate) {
    var validateDate = getValidTime(nextDate);
    onSelect(validateDate);
  }, "triggerChange"), triggerDateTmpl = React.useMemo(function() {
    var tmpl = value || pickerValue || generateConfig2.getNow(), isNotNull = /* @__PURE__ */ __name(function(num) {
      return num != null;
    }, "isNotNull");
    return isNotNull(hour) ? (tmpl = generateConfig2.setHour(tmpl, hour), tmpl = generateConfig2.setMinute(tmpl, minute), tmpl = generateConfig2.setSecond(tmpl, second), tmpl = generateConfig2.setMillisecond(tmpl, millisecond)) : isNotNull(pickerHour) ? (tmpl = generateConfig2.setHour(tmpl, pickerHour), tmpl = generateConfig2.setMinute(tmpl, pickerMinute), tmpl = generateConfig2.setSecond(tmpl, pickerSecond), tmpl = generateConfig2.setMillisecond(tmpl, pickerMillisecond)) : isNotNull(validHour) && (tmpl = generateConfig2.setHour(tmpl, validHour), tmpl = generateConfig2.setMinute(tmpl, validMinute), tmpl = generateConfig2.setSecond(tmpl, validSecond), tmpl = generateConfig2.setMillisecond(tmpl, validMillisecond)), tmpl;
  }, [value, pickerValue, hour, minute, second, millisecond, validHour, validMinute, validSecond, validMillisecond, pickerHour, pickerMinute, pickerSecond, pickerMillisecond, generateConfig2]), fillColumnValue = /* @__PURE__ */ __name(function(val, func) {
    return val === null ? null : generateConfig2[func](triggerDateTmpl, val);
  }, "fillColumnValue"), getNextHourTime = /* @__PURE__ */ __name(function(val) {
    return fillColumnValue(val, "setHour");
  }, "getNextHourTime"), getNextMinuteTime = /* @__PURE__ */ __name(function(val) {
    return fillColumnValue(val, "setMinute");
  }, "getNextMinuteTime"), getNextSecondTime = /* @__PURE__ */ __name(function(val) {
    return fillColumnValue(val, "setSecond");
  }, "getNextSecondTime"), getNextMillisecondTime = /* @__PURE__ */ __name(function(val) {
    return fillColumnValue(val, "setMillisecond");
  }, "getNextMillisecondTime"), getMeridiemTime = /* @__PURE__ */ __name(function(val) {
    return val === null ? null : val === "am" && !isAM(hour) ? generateConfig2.setHour(triggerDateTmpl, hour - 12) : val === "pm" && isAM(hour) ? generateConfig2.setHour(triggerDateTmpl, hour + 12) : triggerDateTmpl;
  }, "getMeridiemTime"), onHourChange = /* @__PURE__ */ __name(function(val) {
    triggerChange(getNextHourTime(val));
  }, "onHourChange"), onMinuteChange = /* @__PURE__ */ __name(function(val) {
    triggerChange(getNextMinuteTime(val));
  }, "onMinuteChange"), onSecondChange = /* @__PURE__ */ __name(function(val) {
    triggerChange(getNextSecondTime(val));
  }, "onSecondChange"), onMillisecondChange = /* @__PURE__ */ __name(function(val) {
    triggerChange(getNextMillisecondTime(val));
  }, "onMillisecondChange"), onMeridiemChange = /* @__PURE__ */ __name(function(val) {
    triggerChange(getMeridiemTime(val));
  }, "onMeridiemChange"), onHourHover = /* @__PURE__ */ __name(function(val) {
    onHover(getNextHourTime(val));
  }, "onHourHover"), onMinuteHover = /* @__PURE__ */ __name(function(val) {
    onHover(getNextMinuteTime(val));
  }, "onMinuteHover"), onSecondHover = /* @__PURE__ */ __name(function(val) {
    onHover(getNextSecondTime(val));
  }, "onSecondHover"), onMillisecondHover = /* @__PURE__ */ __name(function(val) {
    onHover(getNextMillisecondTime(val));
  }, "onMillisecondHover"), onMeridiemHover = /* @__PURE__ */ __name(function(val) {
    onHover(getMeridiemTime(val));
  }, "onMeridiemHover"), sharedColumnProps = {
    onDblClick: onCellDblClick,
    changeOnScroll
  };
  return /* @__PURE__ */ React.createElement("div", {
    className: "".concat(prefixCls, "-content")
  }, showHour && /* @__PURE__ */ React.createElement(TimeColumn, _extends({
    units: hourUnits,
    value: hour,
    optionalValue: pickerHour,
    type: "hour",
    onChange: onHourChange,
    onHover: onHourHover
  }, sharedColumnProps)), showMinute && /* @__PURE__ */ React.createElement(TimeColumn, _extends({
    units: minuteUnits,
    value: minute,
    optionalValue: pickerMinute,
    type: "minute",
    onChange: onMinuteChange,
    onHover: onMinuteHover
  }, sharedColumnProps)), showSecond && /* @__PURE__ */ React.createElement(TimeColumn, _extends({
    units: secondUnits,
    value: second,
    optionalValue: pickerSecond,
    type: "second",
    onChange: onSecondChange,
    onHover: onSecondHover
  }, sharedColumnProps)), showMillisecond && /* @__PURE__ */ React.createElement(TimeColumn, _extends({
    units: millisecondUnits,
    value: millisecond,
    optionalValue: pickerMillisecond,
    type: "millisecond",
    onChange: onMillisecondChange,
    onHover: onMillisecondHover
  }, sharedColumnProps)), showMeridiem && /* @__PURE__ */ React.createElement(TimeColumn, _extends({
    units: meridiemUnits,
    value: meridiem,
    type: "meridiem",
    onChange: onMeridiemChange,
    onHover: onMeridiemHover
  }, sharedColumnProps)));
}
__name(TimePanelBody, "TimePanelBody");
function TimePanel(props) {
  var prefixCls = props.prefixCls, value = props.value, locale2 = props.locale, generateConfig2 = props.generateConfig, showTime = props.showTime, _ref = showTime || {}, format3 = _ref.format, panelPrefixCls = "".concat(prefixCls, "-time-panel"), _useInfo = useInfo(props, "time"), _useInfo2 = _slicedToArray(_useInfo, 1), info = _useInfo2[0];
  return /* @__PURE__ */ React.createElement(PanelContext.Provider, {
    value: info
  }, /* @__PURE__ */ React.createElement("div", {
    className: cn(panelPrefixCls)
  }, /* @__PURE__ */ React.createElement(PanelHeader, null, value ? formatValue(value, {
    locale: locale2,
    format: format3,
    generateConfig: generateConfig2
  }) : " "), /* @__PURE__ */ React.createElement(TimePanelBody, showTime)));
}
__name(TimePanel, "TimePanel");
function DateTimePanel(props) {
  var prefixCls = props.prefixCls, generateConfig2 = props.generateConfig, showTime = props.showTime, onSelect = props.onSelect, value = props.value, pickerValue = props.pickerValue, onHover = props.onHover, panelPrefixCls = "".concat(prefixCls, "-datetime-panel"), _useTimeInfo = useTimeInfo(generateConfig2, showTime), _useTimeInfo2 = _slicedToArray(_useTimeInfo, 1), getValidTime = _useTimeInfo2[0], mergeTime = /* @__PURE__ */ __name(function(date4) {
    return value ? fillTime(generateConfig2, date4, value) : fillTime(generateConfig2, date4, pickerValue);
  }, "mergeTime"), onDateHover = /* @__PURE__ */ __name(function(date4) {
    onHover == null || onHover(date4 && mergeTime(date4));
  }, "onDateHover"), onDateSelect = /* @__PURE__ */ __name(function(date4) {
    var cloneDate = mergeTime(date4);
    onSelect(getValidTime(cloneDate, cloneDate));
  }, "onDateSelect");
  return /* @__PURE__ */ React.createElement("div", {
    className: panelPrefixCls
  }, /* @__PURE__ */ React.createElement(DatePanel, _extends({}, props, {
    onSelect: onDateSelect,
    onHover: onDateHover
  })), /* @__PURE__ */ React.createElement(TimePanel, props));
}
__name(DateTimePanel, "DateTimePanel");
function DecadePanel(props) {
  var prefixCls = props.prefixCls, locale2 = props.locale, generateConfig2 = props.generateConfig, pickerValue = props.pickerValue, disabledDate = props.disabledDate, onPickerValueChange = props.onPickerValueChange, panelPrefixCls = "".concat(prefixCls, "-decade-panel"), _useInfo = useInfo(props, "decade"), _useInfo2 = _slicedToArray(_useInfo, 1), info = _useInfo2[0], getStartYear = /* @__PURE__ */ __name(function(date4) {
    var startYear = Math.floor(generateConfig2.getYear(date4) / 100) * 100;
    return generateConfig2.setYear(date4, startYear);
  }, "getStartYear"), getEndYear = /* @__PURE__ */ __name(function(date4) {
    var startYear = getStartYear(date4);
    return generateConfig2.addYear(startYear, 99);
  }, "getEndYear"), startYearDate = getStartYear(pickerValue), endYearDate = getEndYear(pickerValue), baseDate = generateConfig2.addYear(startYearDate, -10), getCellDate = /* @__PURE__ */ __name(function(date4, offset2) {
    return generateConfig2.addYear(date4, offset2 * 10);
  }, "getCellDate"), getCellText = /* @__PURE__ */ __name(function(date4) {
    var cellYearFormat = locale2.cellYearFormat, startYearStr = formatValue(date4, {
      locale: locale2,
      format: cellYearFormat,
      generateConfig: generateConfig2
    }), endYearStr = formatValue(generateConfig2.addYear(date4, 9), {
      locale: locale2,
      format: cellYearFormat,
      generateConfig: generateConfig2
    });
    return "".concat(startYearStr, "-").concat(endYearStr);
  }, "getCellText"), getCellClassName = /* @__PURE__ */ __name(function(date4) {
    return _defineProperty$2({}, "".concat(prefixCls, "-cell-in-view"), isSameDecade(generateConfig2, date4, startYearDate) || isSameDecade(generateConfig2, date4, endYearDate) || isInRange(generateConfig2, startYearDate, endYearDate, date4));
  }, "getCellClassName"), mergedDisabledDate = disabledDate ? function(currentDate, disabledInfo) {
    var baseStartDate = generateConfig2.setDate(currentDate, 1), baseStartMonth = generateConfig2.setMonth(baseStartDate, 0), baseStartYear = generateConfig2.setYear(baseStartMonth, Math.floor(generateConfig2.getYear(baseStartMonth) / 10) * 10), baseEndYear = generateConfig2.addYear(baseStartYear, 10), baseEndDate = generateConfig2.addDate(baseEndYear, -1);
    return disabledDate(baseStartYear, disabledInfo) && disabledDate(baseEndDate, disabledInfo);
  } : null, yearNode = "".concat(formatValue(startYearDate, {
    locale: locale2,
    format: locale2.yearFormat,
    generateConfig: generateConfig2
  }), "-").concat(formatValue(endYearDate, {
    locale: locale2,
    format: locale2.yearFormat,
    generateConfig: generateConfig2
  }));
  return /* @__PURE__ */ React.createElement(PanelContext.Provider, {
    value: info
  }, /* @__PURE__ */ React.createElement("div", {
    className: panelPrefixCls
  }, /* @__PURE__ */ React.createElement(PanelHeader, {
    superOffset: /* @__PURE__ */ __name(function(distance) {
      return generateConfig2.addYear(pickerValue, distance * 100);
    }, "superOffset"),
    onChange: onPickerValueChange,
    getStart: getStartYear,
    getEnd: getEndYear
  }, yearNode), /* @__PURE__ */ React.createElement(PanelBody, _extends({}, props, {
    disabledDate: mergedDisabledDate,
    colNum: 3,
    rowNum: 4,
    baseDate,
    getCellDate,
    getCellText,
    getCellClassName
  }))));
}
__name(DecadePanel, "DecadePanel");
function MonthPanel(props) {
  var prefixCls = props.prefixCls, locale2 = props.locale, generateConfig2 = props.generateConfig, pickerValue = props.pickerValue, disabledDate = props.disabledDate, onPickerValueChange = props.onPickerValueChange, onModeChange = props.onModeChange, panelPrefixCls = "".concat(prefixCls, "-month-panel"), _useInfo = useInfo(props, "month"), _useInfo2 = _slicedToArray(_useInfo, 1), info = _useInfo2[0], baseDate = generateConfig2.setMonth(pickerValue, 0), monthsLocale = locale2.shortMonths || (generateConfig2.locale.getShortMonths ? generateConfig2.locale.getShortMonths(locale2.locale) : []), getCellDate = /* @__PURE__ */ __name(function(date4, offset2) {
    return generateConfig2.addMonth(date4, offset2);
  }, "getCellDate"), getCellText = /* @__PURE__ */ __name(function(date4) {
    var month = generateConfig2.getMonth(date4);
    return locale2.monthFormat ? formatValue(date4, {
      locale: locale2,
      format: locale2.monthFormat,
      generateConfig: generateConfig2
    }) : monthsLocale[month];
  }, "getCellText"), getCellClassName = /* @__PURE__ */ __name(function() {
    return _defineProperty$2({}, "".concat(prefixCls, "-cell-in-view"), !0);
  }, "getCellClassName"), mergedDisabledDate = disabledDate ? function(currentDate, disabledInfo) {
    var startDate = generateConfig2.setDate(currentDate, 1), nextMonthStartDate = generateConfig2.setMonth(startDate, generateConfig2.getMonth(startDate) + 1), endDate = generateConfig2.addDate(nextMonthStartDate, -1);
    return disabledDate(startDate, disabledInfo) && disabledDate(endDate, disabledInfo);
  } : null, yearNode = /* @__PURE__ */ React.createElement("button", {
    type: "button",
    key: "year",
    "aria-label": "year panel",
    onClick: /* @__PURE__ */ __name(function() {
      onModeChange("year");
    }, "onClick"),
    tabIndex: -1,
    className: "".concat(prefixCls, "-year-btn")
  }, formatValue(pickerValue, {
    locale: locale2,
    format: locale2.yearFormat,
    generateConfig: generateConfig2
  }));
  return /* @__PURE__ */ React.createElement(PanelContext.Provider, {
    value: info
  }, /* @__PURE__ */ React.createElement("div", {
    className: panelPrefixCls
  }, /* @__PURE__ */ React.createElement(PanelHeader, {
    superOffset: /* @__PURE__ */ __name(function(distance) {
      return generateConfig2.addYear(pickerValue, distance);
    }, "superOffset"),
    onChange: onPickerValueChange,
    getStart: /* @__PURE__ */ __name(function(date4) {
      return generateConfig2.setMonth(date4, 0);
    }, "getStart"),
    getEnd: /* @__PURE__ */ __name(function(date4) {
      return generateConfig2.setMonth(date4, 11);
    }, "getEnd")
  }, yearNode), /* @__PURE__ */ React.createElement(PanelBody, _extends({}, props, {
    disabledDate: mergedDisabledDate,
    titleFormat: locale2.fieldMonthFormat,
    colNum: 3,
    rowNum: 4,
    baseDate,
    getCellDate,
    getCellText,
    getCellClassName
  }))));
}
__name(MonthPanel, "MonthPanel");
function QuarterPanel(props) {
  var prefixCls = props.prefixCls, locale2 = props.locale, generateConfig2 = props.generateConfig, pickerValue = props.pickerValue, onPickerValueChange = props.onPickerValueChange, onModeChange = props.onModeChange, panelPrefixCls = "".concat(prefixCls, "-quarter-panel"), _useInfo = useInfo(props, "quarter"), _useInfo2 = _slicedToArray(_useInfo, 1), info = _useInfo2[0], baseDate = generateConfig2.setMonth(pickerValue, 0), getCellDate = /* @__PURE__ */ __name(function(date4, offset2) {
    return generateConfig2.addMonth(date4, offset2 * 3);
  }, "getCellDate"), getCellText = /* @__PURE__ */ __name(function(date4) {
    return formatValue(date4, {
      locale: locale2,
      format: locale2.cellQuarterFormat,
      generateConfig: generateConfig2
    });
  }, "getCellText"), getCellClassName = /* @__PURE__ */ __name(function() {
    return _defineProperty$2({}, "".concat(prefixCls, "-cell-in-view"), !0);
  }, "getCellClassName"), yearNode = /* @__PURE__ */ React.createElement("button", {
    type: "button",
    key: "year",
    "aria-label": "year panel",
    onClick: /* @__PURE__ */ __name(function() {
      onModeChange("year");
    }, "onClick"),
    tabIndex: -1,
    className: "".concat(prefixCls, "-year-btn")
  }, formatValue(pickerValue, {
    locale: locale2,
    format: locale2.yearFormat,
    generateConfig: generateConfig2
  }));
  return /* @__PURE__ */ React.createElement(PanelContext.Provider, {
    value: info
  }, /* @__PURE__ */ React.createElement("div", {
    className: panelPrefixCls
  }, /* @__PURE__ */ React.createElement(PanelHeader, {
    superOffset: /* @__PURE__ */ __name(function(distance) {
      return generateConfig2.addYear(pickerValue, distance);
    }, "superOffset"),
    onChange: onPickerValueChange,
    getStart: /* @__PURE__ */ __name(function(date4) {
      return generateConfig2.setMonth(date4, 0);
    }, "getStart"),
    getEnd: /* @__PURE__ */ __name(function(date4) {
      return generateConfig2.setMonth(date4, 11);
    }, "getEnd")
  }, yearNode), /* @__PURE__ */ React.createElement(PanelBody, _extends({}, props, {
    titleFormat: locale2.fieldQuarterFormat,
    colNum: 4,
    rowNum: 1,
    baseDate,
    getCellDate,
    getCellText,
    getCellClassName
  }))));
}
__name(QuarterPanel, "QuarterPanel");
function WeekPanel(props) {
  var prefixCls = props.prefixCls, generateConfig2 = props.generateConfig, locale2 = props.locale, value = props.value, hoverValue = props.hoverValue, hoverRangeValue = props.hoverRangeValue, localeName = locale2.locale, rowPrefixCls = "".concat(prefixCls, "-week-panel-row"), rowClassName = /* @__PURE__ */ __name(function(currentDate) {
    var rangeCls = {};
    if (hoverRangeValue) {
      var _hoverRangeValue = _slicedToArray(hoverRangeValue, 2), rangeStart = _hoverRangeValue[0], rangeEnd = _hoverRangeValue[1], isRangeStart = isSameWeek(generateConfig2, localeName, rangeStart, currentDate), isRangeEnd = isSameWeek(generateConfig2, localeName, rangeEnd, currentDate);
      rangeCls["".concat(rowPrefixCls, "-range-start")] = isRangeStart, rangeCls["".concat(rowPrefixCls, "-range-end")] = isRangeEnd, rangeCls["".concat(rowPrefixCls, "-range-hover")] = !isRangeStart && !isRangeEnd && isInRange(generateConfig2, rangeStart, rangeEnd, currentDate);
    }
    return hoverValue && (rangeCls["".concat(rowPrefixCls, "-hover")] = hoverValue.some(function(date4) {
      return isSameWeek(generateConfig2, localeName, currentDate, date4);
    })), cn(
      rowPrefixCls,
      _defineProperty$2({}, "".concat(rowPrefixCls, "-selected"), !hoverRangeValue && isSameWeek(generateConfig2, localeName, value, currentDate)),
      // Patch for hover range
      rangeCls
    );
  }, "rowClassName");
  return /* @__PURE__ */ React.createElement(DatePanel, _extends({}, props, {
    mode: "week",
    panelName: "week",
    rowClassName
  }));
}
__name(WeekPanel, "WeekPanel");
function YearPanel(props) {
  var prefixCls = props.prefixCls, locale2 = props.locale, generateConfig2 = props.generateConfig, pickerValue = props.pickerValue, disabledDate = props.disabledDate, onPickerValueChange = props.onPickerValueChange, onModeChange = props.onModeChange, panelPrefixCls = "".concat(prefixCls, "-year-panel"), _useInfo = useInfo(props, "year"), _useInfo2 = _slicedToArray(_useInfo, 1), info = _useInfo2[0], getStartYear = /* @__PURE__ */ __name(function(date4) {
    var startYear = Math.floor(generateConfig2.getYear(date4) / 10) * 10;
    return generateConfig2.setYear(date4, startYear);
  }, "getStartYear"), getEndYear = /* @__PURE__ */ __name(function(date4) {
    var startYear = getStartYear(date4);
    return generateConfig2.addYear(startYear, 9);
  }, "getEndYear"), startYearDate = getStartYear(pickerValue), endYearDate = getEndYear(pickerValue), baseDate = generateConfig2.addYear(startYearDate, -1), getCellDate = /* @__PURE__ */ __name(function(date4, offset2) {
    return generateConfig2.addYear(date4, offset2);
  }, "getCellDate"), getCellText = /* @__PURE__ */ __name(function(date4) {
    return formatValue(date4, {
      locale: locale2,
      format: locale2.cellYearFormat,
      generateConfig: generateConfig2
    });
  }, "getCellText"), getCellClassName = /* @__PURE__ */ __name(function(date4) {
    return _defineProperty$2({}, "".concat(prefixCls, "-cell-in-view"), isSameYear(generateConfig2, date4, startYearDate) || isSameYear(generateConfig2, date4, endYearDate) || isInRange(generateConfig2, startYearDate, endYearDate, date4));
  }, "getCellClassName"), mergedDisabledDate = disabledDate ? function(currentDate, disabledInfo) {
    var startMonth = generateConfig2.setMonth(currentDate, 0), startDate = generateConfig2.setDate(startMonth, 1), endMonth = generateConfig2.addYear(startDate, 1), endDate = generateConfig2.addDate(endMonth, -1);
    return disabledDate(startDate, disabledInfo) && disabledDate(endDate, disabledInfo);
  } : null, yearNode = /* @__PURE__ */ React.createElement("button", {
    type: "button",
    key: "decade",
    "aria-label": "decade panel",
    onClick: /* @__PURE__ */ __name(function() {
      onModeChange("decade");
    }, "onClick"),
    tabIndex: -1,
    className: "".concat(prefixCls, "-decade-btn")
  }, formatValue(startYearDate, {
    locale: locale2,
    format: locale2.yearFormat,
    generateConfig: generateConfig2
  }), "-", formatValue(endYearDate, {
    locale: locale2,
    format: locale2.yearFormat,
    generateConfig: generateConfig2
  }));
  return /* @__PURE__ */ React.createElement(PanelContext.Provider, {
    value: info
  }, /* @__PURE__ */ React.createElement("div", {
    className: panelPrefixCls
  }, /* @__PURE__ */ React.createElement(PanelHeader, {
    superOffset: /* @__PURE__ */ __name(function(distance) {
      return generateConfig2.addYear(pickerValue, distance * 10);
    }, "superOffset"),
    onChange: onPickerValueChange,
    getStart: getStartYear,
    getEnd: getEndYear
  }, yearNode), /* @__PURE__ */ React.createElement(PanelBody, _extends({}, props, {
    disabledDate: mergedDisabledDate,
    titleFormat: locale2.fieldYearFormat,
    colNum: 3,
    rowNum: 4,
    baseDate,
    getCellDate,
    getCellText,
    getCellClassName
  }))));
}
__name(YearPanel, "YearPanel");
var DefaultComponents = {
  date: DatePanel,
  datetime: DateTimePanel,
  week: WeekPanel,
  month: MonthPanel,
  quarter: QuarterPanel,
  year: YearPanel,
  decade: DecadePanel,
  time: TimePanel
};
function PickerPanel(props, ref) {
  var _React$useContext, locale2 = props.locale, generateConfig2 = props.generateConfig, direction = props.direction, prefixCls = props.prefixCls, _props$tabIndex = props.tabIndex, tabIndex = _props$tabIndex === void 0 ? 0 : _props$tabIndex, multiple = props.multiple, defaultValue = props.defaultValue, value = props.value, onChange = props.onChange, onSelect = props.onSelect, defaultPickerValue = props.defaultPickerValue, pickerValue = props.pickerValue, onPickerValueChange = props.onPickerValueChange, mode = props.mode, onPanelChange = props.onPanelChange, _props$picker = props.picker, picker = _props$picker === void 0 ? "date" : _props$picker, showTime = props.showTime, hoverValue = props.hoverValue, hoverRangeValue = props.hoverRangeValue, cellRender = props.cellRender, dateRender = props.dateRender, monthCellRender = props.monthCellRender, _props$components = props.components, components2 = _props$components === void 0 ? {} : _props$components, hideHeader = props.hideHeader, mergedPrefixCls = ((_React$useContext = React.useContext(PickerContext)) === null || _React$useContext === void 0 ? void 0 : _React$useContext.prefixCls) || prefixCls || "rc-picker", rootRef = React.useRef();
  React.useImperativeHandle(ref, function() {
    return {
      nativeElement: rootRef.current
    };
  });
  var _getTimeProps = getTimeProps(props), _getTimeProps2 = _slicedToArray(_getTimeProps, 4), timeProps = _getTimeProps2[0], localeTimeProps = _getTimeProps2[1], showTimeFormat = _getTimeProps2[2], propFormat = _getTimeProps2[3], filledLocale = useLocale(locale2, localeTimeProps), internalPicker = picker === "date" && showTime ? "datetime" : picker, mergedShowTime = React.useMemo(function() {
    return fillShowTimeConfig(internalPicker, showTimeFormat, propFormat, timeProps, filledLocale);
  }, [internalPicker, showTimeFormat, propFormat, timeProps, filledLocale]), now2 = generateConfig2.getNow(), _useMergedState = useMergedState(picker, {
    value: mode,
    postState: /* @__PURE__ */ __name(function(val) {
      return val || "date";
    }, "postState")
  }), _useMergedState2 = _slicedToArray(_useMergedState, 2), mergedMode = _useMergedState2[0], setMergedMode = _useMergedState2[1], internalMode = mergedMode === "date" && mergedShowTime ? "datetime" : mergedMode, toggleDates = useToggleDates(generateConfig2, locale2, internalPicker), _useMergedState3 = useMergedState(defaultValue, {
    value
  }), _useMergedState4 = _slicedToArray(_useMergedState3, 2), innerValue = _useMergedState4[0], setMergedValue = _useMergedState4[1], mergedValue = React.useMemo(function() {
    var values = toArray$3(innerValue).filter(function(val) {
      return val;
    });
    return multiple ? values : values.slice(0, 1);
  }, [innerValue, multiple]), triggerChange = useEvent(function(nextValue) {
    setMergedValue(nextValue), onChange && (nextValue === null || mergedValue.length !== nextValue.length || mergedValue.some(function(ori, index2) {
      return !isSame(generateConfig2, locale2, ori, nextValue[index2], internalPicker);
    })) && (onChange == null || onChange(multiple ? nextValue : nextValue[0]));
  }), onInternalSelect = useEvent(function(newDate) {
    if (onSelect == null || onSelect(newDate), mergedMode === picker) {
      var nextValues = multiple ? toggleDates(mergedValue, newDate) : [newDate];
      triggerChange(nextValues);
    }
  }), _useMergedState5 = useMergedState(defaultPickerValue || mergedValue[0] || now2, {
    value: pickerValue
  }), _useMergedState6 = _slicedToArray(_useMergedState5, 2), mergedPickerValue = _useMergedState6[0], setInternalPickerValue = _useMergedState6[1];
  React.useEffect(function() {
    mergedValue[0] && !pickerValue && setInternalPickerValue(mergedValue[0]);
  }, [mergedValue[0]]);
  var triggerPanelChange = /* @__PURE__ */ __name(function(viewDate, nextMode) {
    onPanelChange == null || onPanelChange(viewDate || pickerValue, nextMode || mergedMode);
  }, "triggerPanelChange"), setPickerValue = /* @__PURE__ */ __name(function(nextPickerValue) {
    var triggerPanelEvent = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1;
    setInternalPickerValue(nextPickerValue), onPickerValueChange == null || onPickerValueChange(nextPickerValue), triggerPanelEvent && triggerPanelChange(nextPickerValue);
  }, "setPickerValue"), triggerModeChange = /* @__PURE__ */ __name(function(nextMode, viewDate) {
    setMergedMode(nextMode), viewDate && setPickerValue(viewDate), triggerPanelChange(viewDate, nextMode);
  }, "triggerModeChange"), onPanelValueSelect = /* @__PURE__ */ __name(function(nextValue) {
    if (onInternalSelect(nextValue), setPickerValue(nextValue), mergedMode !== picker) {
      var decadeYearQueue = ["decade", "year"], decadeYearMonthQueue = [].concat(decadeYearQueue, ["month"]), pickerQueue = {
        quarter: [].concat(decadeYearQueue, ["quarter"]),
        week: [].concat(_toConsumableArray(decadeYearMonthQueue), ["week"]),
        date: [].concat(_toConsumableArray(decadeYearMonthQueue), ["date"])
      }, queue = pickerQueue[picker] || decadeYearMonthQueue, index2 = queue.indexOf(mergedMode), nextMode = queue[index2 + 1];
      nextMode && triggerModeChange(nextMode, nextValue);
    }
  }, "onPanelValueSelect"), hoverRangeDate = React.useMemo(function() {
    var start, end;
    if (Array.isArray(hoverRangeValue)) {
      var _hoverRangeValue = _slicedToArray(hoverRangeValue, 2);
      start = _hoverRangeValue[0], end = _hoverRangeValue[1];
    } else
      start = hoverRangeValue;
    return !start && !end ? null : (start = start || end, end = end || start, generateConfig2.isAfter(start, end) ? [end, start] : [start, end]);
  }, [hoverRangeValue, generateConfig2]), onInternalCellRender = useCellRender$1(cellRender, dateRender, monthCellRender), PanelComponent = components2[internalMode] || DefaultComponents[internalMode] || DatePanel, parentHackContext = React.useContext(PickerHackContext), pickerPanelContext = React.useMemo(function() {
    return _objectSpread2$1(_objectSpread2$1({}, parentHackContext), {}, {
      hideHeader
    });
  }, [parentHackContext, hideHeader]);
  process.env.NODE_ENV !== "production" && warningOnce(!mergedValue || mergedValue.every(function(val) {
    return generateConfig2.isValidate(val);
  }), "Invalidate date pass to `value` or `defaultValue`.");
  var panelCls = "".concat(mergedPrefixCls, "-panel"), panelProps = pickProps(props, [
    // Week
    "showWeek",
    // Icons
    "prevIcon",
    "nextIcon",
    "superPrevIcon",
    "superNextIcon",
    // Disabled
    "disabledDate",
    "minDate",
    "maxDate",
    // Hover
    "onHover"
  ]);
  return /* @__PURE__ */ React.createElement(PickerHackContext.Provider, {
    value: pickerPanelContext
  }, /* @__PURE__ */ React.createElement("div", {
    ref: rootRef,
    tabIndex,
    className: cn(panelCls, _defineProperty$2({}, "".concat(panelCls, "-rtl"), direction === "rtl"))
  }, /* @__PURE__ */ React.createElement(PanelComponent, _extends({}, panelProps, {
    // Time
    showTime: mergedShowTime,
    prefixCls: mergedPrefixCls,
    locale: filledLocale,
    generateConfig: generateConfig2,
    onModeChange: triggerModeChange,
    pickerValue: mergedPickerValue,
    onPickerValueChange: /* @__PURE__ */ __name(function(nextPickerValue) {
      setPickerValue(nextPickerValue, !0);
    }, "onPickerValueChange"),
    value: mergedValue[0],
    onSelect: onPanelValueSelect,
    values: mergedValue,
    cellRender: onInternalCellRender,
    hoverRangeValue: hoverRangeDate,
    hoverValue
  }))));
}
__name(PickerPanel, "PickerPanel");
var RefPanelPicker = /* @__PURE__ */ React.memo(/* @__PURE__ */ React.forwardRef(PickerPanel));
process.env.NODE_ENV !== "production" && (RefPanelPicker.displayName = "PanelPicker");
function PopupPanel(props) {
  var picker = props.picker, multiplePanel = props.multiplePanel, pickerValue = props.pickerValue, onPickerValueChange = props.onPickerValueChange, needConfirm = props.needConfirm, onSubmit = props.onSubmit, range3 = props.range, hoverValue = props.hoverValue, _React$useContext = React.useContext(PickerContext), prefixCls = _React$useContext.prefixCls, generateConfig2 = _React$useContext.generateConfig, internalOffsetDate = React.useCallback(function(date4, offset2) {
    return offsetPanelDate(generateConfig2, picker, date4, offset2);
  }, [generateConfig2, picker]), nextPickerValue = React.useMemo(function() {
    return internalOffsetDate(pickerValue, 1);
  }, [pickerValue, internalOffsetDate]), onSecondPickerValueChange = /* @__PURE__ */ __name(function(nextDate) {
    onPickerValueChange(internalOffsetDate(nextDate, -1));
  }, "onSecondPickerValueChange"), sharedContext = {
    onCellDblClick: /* @__PURE__ */ __name(function() {
      needConfirm && onSubmit();
    }, "onCellDblClick")
  }, hideHeader = picker === "time", pickerProps = _objectSpread2$1(_objectSpread2$1({}, props), {}, {
    hoverValue: null,
    hoverRangeValue: null,
    hideHeader
  });
  return range3 ? pickerProps.hoverRangeValue = hoverValue : pickerProps.hoverValue = hoverValue, multiplePanel ? /* @__PURE__ */ React.createElement("div", {
    className: "".concat(prefixCls, "-panels")
  }, /* @__PURE__ */ React.createElement(PickerHackContext.Provider, {
    value: _objectSpread2$1(_objectSpread2$1({}, sharedContext), {}, {
      hideNext: !0
    })
  }, /* @__PURE__ */ React.createElement(RefPanelPicker, pickerProps)), /* @__PURE__ */ React.createElement(PickerHackContext.Provider, {
    value: _objectSpread2$1(_objectSpread2$1({}, sharedContext), {}, {
      hidePrev: !0
    })
  }, /* @__PURE__ */ React.createElement(RefPanelPicker, _extends({}, pickerProps, {
    pickerValue: nextPickerValue,
    onPickerValueChange: onSecondPickerValueChange
  })))) : /* @__PURE__ */ React.createElement(PickerHackContext.Provider, {
    value: _objectSpread2$1({}, sharedContext)
  }, /* @__PURE__ */ React.createElement(RefPanelPicker, pickerProps));
}
__name(PopupPanel, "PopupPanel");
function executeValue(value) {
  return typeof value == "function" ? value() : value;
}
__name(executeValue, "executeValue");
function PresetPanel(props) {
  var prefixCls = props.prefixCls, presets = props.presets, _onClick = props.onClick, onHover = props.onHover;
  return presets.length ? /* @__PURE__ */ React.createElement("div", {
    className: "".concat(prefixCls, "-presets")
  }, /* @__PURE__ */ React.createElement("ul", null, presets.map(function(_ref, index2) {
    var label2 = _ref.label, value = _ref.value;
    return /* @__PURE__ */ React.createElement("li", {
      key: index2,
      onClick: /* @__PURE__ */ __name(function() {
        _onClick(executeValue(value));
      }, "onClick"),
      onMouseEnter: /* @__PURE__ */ __name(function() {
        onHover(executeValue(value));
      }, "onMouseEnter"),
      onMouseLeave: /* @__PURE__ */ __name(function() {
        onHover(null);
      }, "onMouseLeave")
    }, label2);
  }))) : null;
}
__name(PresetPanel, "PresetPanel");
function Popup(props) {
  var panelRender = props.panelRender, internalMode = props.internalMode, picker = props.picker, showNow = props.showNow, range3 = props.range, multiple = props.multiple, _props$activeOffset = props.activeOffset, activeOffset = _props$activeOffset === void 0 ? 0 : _props$activeOffset, placement = props.placement, presets = props.presets, onPresetHover = props.onPresetHover, onPresetSubmit = props.onPresetSubmit, onFocus = props.onFocus, onBlur = props.onBlur, onPanelMouseDown = props.onPanelMouseDown, direction = props.direction, value = props.value, onSelect = props.onSelect, isInvalid = props.isInvalid, defaultOpenValue = props.defaultOpenValue, onOk = props.onOk, onSubmit = props.onSubmit, _React$useContext = React.useContext(PickerContext), prefixCls = _React$useContext.prefixCls, panelPrefixCls = "".concat(prefixCls, "-panel"), rtl = direction === "rtl", arrowRef = React.useRef(null), wrapperRef = React.useRef(null), _React$useState = React.useState(0), _React$useState2 = _slicedToArray(_React$useState, 2), containerWidth = _React$useState2[0], setContainerWidth = _React$useState2[1], _React$useState3 = React.useState(0), _React$useState4 = _slicedToArray(_React$useState3, 2), containerOffset = _React$useState4[0], setContainerOffset = _React$useState4[1], onResize2 = /* @__PURE__ */ __name(function(info) {
    info.offsetWidth && setContainerWidth(info.offsetWidth);
  }, "onResize");
  React.useEffect(function() {
    if (range3) {
      var _arrowRef$current, arrowWidth = ((_arrowRef$current = arrowRef.current) === null || _arrowRef$current === void 0 ? void 0 : _arrowRef$current.offsetWidth) || 0, maxOffset = containerWidth - arrowWidth;
      activeOffset <= maxOffset ? setContainerOffset(0) : setContainerOffset(activeOffset + arrowWidth - containerWidth);
    }
  }, [containerWidth, activeOffset, range3]);
  function filterEmpty(list) {
    return list.filter(function(item) {
      return item;
    });
  }
  __name(filterEmpty, "filterEmpty");
  var valueList = React.useMemo(function() {
    return filterEmpty(toArray$3(value));
  }, [value]), isTimePickerEmptyValue = picker === "time" && !valueList.length, footerSubmitValue = React.useMemo(function() {
    return isTimePickerEmptyValue ? filterEmpty([defaultOpenValue]) : valueList;
  }, [isTimePickerEmptyValue, valueList, defaultOpenValue]), popupPanelValue = isTimePickerEmptyValue ? defaultOpenValue : valueList, disableSubmit = React.useMemo(function() {
    return footerSubmitValue.length ? footerSubmitValue.some(function(val) {
      return isInvalid(val);
    }) : !0;
  }, [footerSubmitValue, isInvalid]), onFooterSubmit = /* @__PURE__ */ __name(function() {
    isTimePickerEmptyValue && onSelect(defaultOpenValue), onOk(), onSubmit();
  }, "onFooterSubmit"), mergedNodes = /* @__PURE__ */ React.createElement("div", {
    className: "".concat(prefixCls, "-panel-layout")
  }, /* @__PURE__ */ React.createElement(PresetPanel, {
    prefixCls,
    presets,
    onClick: onPresetSubmit,
    onHover: onPresetHover
  }), /* @__PURE__ */ React.createElement("div", null, /* @__PURE__ */ React.createElement(PopupPanel, _extends({}, props, {
    value: popupPanelValue
  })), /* @__PURE__ */ React.createElement(Footer$3, _extends({}, props, {
    showNow: multiple ? !1 : showNow,
    invalid: disableSubmit,
    onSubmit: onFooterSubmit
  }))));
  panelRender && (mergedNodes = panelRender(mergedNodes));
  var containerPrefixCls = "".concat(panelPrefixCls, "-container"), marginLeft = "marginLeft", marginRight = "marginRight", renderNode = /* @__PURE__ */ React.createElement("div", {
    onMouseDown: onPanelMouseDown,
    tabIndex: -1,
    className: cn(
      containerPrefixCls,
      // Used for Today Button style, safe to remove if no need
      "".concat(prefixCls, "-").concat(internalMode, "-panel-container")
    ),
    style: _defineProperty$2(_defineProperty$2({}, rtl ? marginRight : marginLeft, containerOffset), rtl ? marginLeft : marginRight, "auto"),
    onFocus,
    onBlur
  }, mergedNodes);
  if (range3) {
    var realPlacement = getRealPlacement(placement, rtl), offsetUnit = getoffsetUnit(realPlacement, rtl);
    renderNode = /* @__PURE__ */ React.createElement("div", {
      onMouseDown: onPanelMouseDown,
      ref: wrapperRef,
      className: cn("".concat(prefixCls, "-range-wrapper"), "".concat(prefixCls, "-").concat(picker, "-range-wrapper"))
    }, /* @__PURE__ */ React.createElement("div", {
      ref: arrowRef,
      className: "".concat(prefixCls, "-range-arrow"),
      style: _defineProperty$2({}, offsetUnit, activeOffset)
    }), /* @__PURE__ */ React.createElement(RefResizeObserver, {
      onResize: onResize2
    }, renderNode));
  }
  return renderNode;
}
__name(Popup, "Popup");
function useInputProps(props, postProps) {
  var format3 = props.format, maskFormat = props.maskFormat, generateConfig2 = props.generateConfig, locale2 = props.locale, preserveInvalidOnBlur = props.preserveInvalidOnBlur, inputReadOnly = props.inputReadOnly, required4 = props.required, ariaRequired = props["aria-required"], onSubmit = props.onSubmit, _onFocus = props.onFocus, _onBlur = props.onBlur, onInputChange = props.onInputChange, onInvalid = props.onInvalid, open = props.open, onOpenChange = props.onOpenChange, _onKeyDown = props.onKeyDown, _onChange = props.onChange, activeHelp = props.activeHelp, name = props.name, autoComplete = props.autoComplete, id2 = props.id, value = props.value, invalid = props.invalid, placeholder = props.placeholder, disabled = props.disabled, activeIndex = props.activeIndex, allHelp = props.allHelp, picker = props.picker, parseDate = /* @__PURE__ */ __name(function(str, formatStr) {
    var parsed = generateConfig2.locale.parse(locale2.locale, str, [formatStr]);
    return parsed && generateConfig2.isValidate(parsed) ? parsed : null;
  }, "parseDate"), firstFormat = format3[0], getText = React.useCallback(function(date4) {
    return formatValue(date4, {
      locale: locale2,
      format: firstFormat,
      generateConfig: generateConfig2
    });
  }, [locale2, generateConfig2, firstFormat]), valueTexts = React.useMemo(function() {
    return value.map(getText);
  }, [value, getText]), size = React.useMemo(function() {
    var defaultSize = picker === "time" ? 8 : 10, length2 = typeof firstFormat == "function" ? firstFormat(generateConfig2.getNow()).length : firstFormat.length;
    return Math.max(defaultSize, length2) + 2;
  }, [firstFormat, picker, generateConfig2]), _validateFormat = /* @__PURE__ */ __name(function(text) {
    for (var i = 0; i < format3.length; i += 1) {
      var singleFormat = format3[i];
      if (typeof singleFormat == "string") {
        var parsed = parseDate(text, singleFormat);
        if (parsed)
          return parsed;
      }
    }
    return !1;
  }, "validateFormat"), getInputProps = /* @__PURE__ */ __name(function(index2) {
    function getProp(propValue) {
      return index2 !== void 0 ? propValue[index2] : propValue;
    }
    __name(getProp, "getProp");
    var pickedAttrs = pickAttrs(props, {
      aria: !0,
      data: !0
    }), inputProps = _objectSpread2$1(_objectSpread2$1({}, pickedAttrs), {}, {
      // ============== Shared ==============
      format: maskFormat,
      validateFormat: /* @__PURE__ */ __name(function(text) {
        return !!_validateFormat(text);
      }, "validateFormat"),
      preserveInvalidOnBlur,
      readOnly: inputReadOnly,
      required: required4,
      "aria-required": ariaRequired,
      name,
      autoComplete,
      size,
      // ============= By Index =============
      id: getProp(id2),
      value: getProp(valueTexts) || "",
      invalid: getProp(invalid),
      placeholder: getProp(placeholder),
      active: activeIndex === index2,
      helped: allHelp || activeHelp && activeIndex === index2,
      disabled: getProp(disabled),
      onFocus: /* @__PURE__ */ __name(function(event) {
        _onFocus(event, index2);
      }, "onFocus"),
      onBlur: /* @__PURE__ */ __name(function(event) {
        _onBlur(event, index2);
      }, "onBlur"),
      onSubmit,
      // Get validate text value
      onChange: /* @__PURE__ */ __name(function(text) {
        onInputChange();
        var parsed = _validateFormat(text);
        if (parsed) {
          onInvalid(!1, index2), _onChange(parsed, index2);
          return;
        }
        onInvalid(!!text, index2);
      }, "onChange"),
      onHelp: /* @__PURE__ */ __name(function() {
        onOpenChange(!0, {
          index: index2
        });
      }, "onHelp"),
      onKeyDown: /* @__PURE__ */ __name(function(event) {
        var prevented = !1;
        if (_onKeyDown == null || _onKeyDown(event, function() {
          process.env.NODE_ENV !== "production" && warningOnce(!1, "`preventDefault` callback is deprecated. Please call `event.preventDefault` directly."), prevented = !0;
        }), !event.defaultPrevented && !prevented)
          switch (event.key) {
            case "Escape":
              onOpenChange(!1, {
                index: index2
              });
              break;
            case "Enter":
              open || onOpenChange(!0);
              break;
          }
      }, "onKeyDown")
    }, postProps == null ? void 0 : postProps({
      valueTexts
    }));
    return Object.keys(inputProps).forEach(function(key) {
      inputProps[key] === void 0 && delete inputProps[key];
    }), inputProps;
  }, "getInputProps");
  return [getInputProps, getText];
}
__name(useInputProps, "useInputProps");
var propNames = ["onMouseEnter", "onMouseLeave"];
function useRootProps(props) {
  return React.useMemo(function() {
    return pickProps(props, propNames);
  }, [props]);
}
__name(useRootProps, "useRootProps");
var _excluded$p = ["icon", "type"], _excluded2$4 = ["onClear"];
function Icon$1(props) {
  var icon = props.icon, type4 = props.type, restProps = _objectWithoutProperties(props, _excluded$p), _React$useContext = React.useContext(PickerContext), prefixCls = _React$useContext.prefixCls;
  return icon ? /* @__PURE__ */ React.createElement("span", _extends({
    className: "".concat(prefixCls, "-").concat(type4)
  }, restProps), icon) : null;
}
__name(Icon$1, "Icon$1");
function ClearIcon(_ref) {
  var onClear = _ref.onClear, restProps = _objectWithoutProperties(_ref, _excluded2$4);
  return /* @__PURE__ */ React.createElement(Icon$1, _extends({}, restProps, {
    type: "clear",
    role: "button",
    onMouseDown: /* @__PURE__ */ __name(function(e2) {
      e2.preventDefault();
    }, "onMouseDown"),
    onClick: /* @__PURE__ */ __name(function(e2) {
      e2.stopPropagation(), onClear();
    }, "onClick")
  }));
}
__name(ClearIcon, "ClearIcon");
var FORMAT_KEYS = ["YYYY", "MM", "DD", "HH", "mm", "ss", "SSS"], REPLACE_KEY = "顧", MaskFormat = /* @__PURE__ */ function() {
  function MaskFormat2(format3) {
    _classCallCheck$1(this, MaskFormat2), _defineProperty$2(this, "format", void 0), _defineProperty$2(this, "maskFormat", void 0), _defineProperty$2(this, "cells", void 0), _defineProperty$2(this, "maskCells", void 0), this.format = format3;
    var replaceKeys = FORMAT_KEYS.map(function(key) {
      return "(".concat(key, ")");
    }).join("|"), replaceReg = new RegExp(replaceKeys, "g");
    this.maskFormat = format3.replace(
      replaceReg,
      // Use Chinese character to avoid user use it in format
      function(key) {
        return REPLACE_KEY.repeat(key.length);
      }
    );
    var cellReg = new RegExp("(".concat(FORMAT_KEYS.join("|"), ")")), strCells = (format3.split(cellReg) || []).filter(function(str) {
      return str;
    }), offset2 = 0;
    this.cells = strCells.map(function(text) {
      var mask = FORMAT_KEYS.includes(text), start = offset2, end = offset2 + text.length;
      return offset2 = end, {
        text,
        mask,
        start,
        end
      };
    }), this.maskCells = this.cells.filter(function(cell) {
      return cell.mask;
    });
  }
  return __name(MaskFormat2, "MaskFormat"), _createClass$1(MaskFormat2, [{
    key: "getSelection",
    value: /* @__PURE__ */ __name(function(maskCellIndex) {
      var _ref = this.maskCells[maskCellIndex] || {}, start = _ref.start, end = _ref.end;
      return [start || 0, end || 0];
    }, "getSelection")
    /** Check given text match format */
  }, {
    key: "match",
    value: /* @__PURE__ */ __name(function(text) {
      for (var i = 0; i < this.maskFormat.length; i += 1) {
        var maskChar = this.maskFormat[i], textChar = text[i];
        if (!textChar || maskChar !== REPLACE_KEY && maskChar !== textChar)
          return !1;
      }
      return !0;
    }, "match")
    /** Get mask cell count */
  }, {
    key: "size",
    value: /* @__PURE__ */ __name(function() {
      return this.maskCells.length;
    }, "size")
  }, {
    key: "getMaskCellIndex",
    value: /* @__PURE__ */ __name(function(anchorIndex) {
      for (var closetDist = Number.MAX_SAFE_INTEGER, closetIndex = 0, i = 0; i < this.maskCells.length; i += 1) {
        var _this$maskCells$i = this.maskCells[i], start = _this$maskCells$i.start, end = _this$maskCells$i.end;
        if (anchorIndex >= start && anchorIndex <= end)
          return i;
        var dist = Math.min(Math.abs(anchorIndex - start), Math.abs(anchorIndex - end));
        dist < closetDist && (closetDist = dist, closetIndex = i);
      }
      return closetIndex;
    }, "getMaskCellIndex")
  }]), MaskFormat2;
}();
function getMaskRange(key) {
  var PresetRange = {
    YYYY: [0, 9999, (/* @__PURE__ */ new Date()).getFullYear()],
    MM: [1, 12],
    DD: [1, 31],
    HH: [0, 23],
    mm: [0, 59],
    ss: [0, 59],
    SSS: [0, 999]
  };
  return PresetRange[key];
}
__name(getMaskRange, "getMaskRange");
var _excluded$o = ["active", "showActiveCls", "suffixIcon", "format", "validateFormat", "onChange", "onInput", "helped", "onHelp", "onSubmit", "onKeyDown", "preserveInvalidOnBlur", "invalid", "clearIcon"], Input$4 = /* @__PURE__ */ React.forwardRef(function(props, ref) {
  var active = props.active, _props$showActiveCls = props.showActiveCls, showActiveCls = _props$showActiveCls === void 0 ? !0 : _props$showActiveCls, suffixIcon = props.suffixIcon, format3 = props.format, validateFormat = props.validateFormat, onChange = props.onChange;
  props.onInput;
  var helped = props.helped, onHelp = props.onHelp, onSubmit = props.onSubmit, onKeyDown2 = props.onKeyDown, _props$preserveInvali = props.preserveInvalidOnBlur, preserveInvalidOnBlur = _props$preserveInvali === void 0 ? !1 : _props$preserveInvali, invalid = props.invalid, clearIcon = props.clearIcon, restProps = _objectWithoutProperties(props, _excluded$o), value = props.value, onFocus = props.onFocus, onBlur = props.onBlur, onMouseUp = props.onMouseUp, _React$useContext = React.useContext(PickerContext), prefixCls = _React$useContext.prefixCls, _React$useContext$inp = _React$useContext.input, Component2 = _React$useContext$inp === void 0 ? "input" : _React$useContext$inp, inputPrefixCls = "".concat(prefixCls, "-input"), _React$useState = React.useState(!1), _React$useState2 = _slicedToArray(_React$useState, 2), focused = _React$useState2[0], setFocused = _React$useState2[1], _React$useState3 = React.useState(value), _React$useState4 = _slicedToArray(_React$useState3, 2), internalInputValue = _React$useState4[0], setInputValue = _React$useState4[1], _React$useState5 = React.useState(""), _React$useState6 = _slicedToArray(_React$useState5, 2), focusCellText = _React$useState6[0], setFocusCellText = _React$useState6[1], _React$useState7 = React.useState(null), _React$useState8 = _slicedToArray(_React$useState7, 2), focusCellIndex = _React$useState8[0], setFocusCellIndex = _React$useState8[1], _React$useState9 = React.useState(null), _React$useState10 = _slicedToArray(_React$useState9, 2), forceSelectionSyncMark = _React$useState10[0], forceSelectionSync = _React$useState10[1], inputValue = internalInputValue || "";
  React.useEffect(function() {
    setInputValue(value);
  }, [value]);
  var holderRef = React.useRef(), inputRef = React.useRef();
  React.useImperativeHandle(ref, function() {
    return {
      nativeElement: holderRef.current,
      inputElement: inputRef.current,
      focus: /* @__PURE__ */ __name(function(options) {
        inputRef.current.focus(options);
      }, "focus"),
      blur: /* @__PURE__ */ __name(function() {
        inputRef.current.blur();
      }, "blur")
    };
  });
  var maskFormat = React.useMemo(function() {
    return new MaskFormat(format3 || "");
  }, [format3]), _React$useMemo = React.useMemo(function() {
    return helped ? [0, 0] : maskFormat.getSelection(focusCellIndex);
  }, [maskFormat, focusCellIndex, helped]), _React$useMemo2 = _slicedToArray(_React$useMemo, 2), selectionStart = _React$useMemo2[0], selectionEnd = _React$useMemo2[1], onModify = /* @__PURE__ */ __name(function(text) {
    text && text !== format3 && text !== value && onHelp();
  }, "onModify"), triggerInputChange = useEvent(function(text) {
    validateFormat(text) && onChange(text), setInputValue(text), onModify(text);
  }), onInternalChange = /* @__PURE__ */ __name(function(event) {
    if (!format3) {
      var text = event.target.value;
      onModify(text), setInputValue(text), onChange(text);
    }
  }, "onInternalChange"), onFormatPaste = /* @__PURE__ */ __name(function(event) {
    var pasteText = event.clipboardData.getData("text");
    validateFormat(pasteText) && triggerInputChange(pasteText);
  }, "onFormatPaste"), mouseDownRef = React.useRef(!1), onFormatMouseDown = /* @__PURE__ */ __name(function() {
    mouseDownRef.current = !0;
  }, "onFormatMouseDown"), onFormatMouseUp = /* @__PURE__ */ __name(function(event) {
    var _ref = event.target, start = _ref.selectionStart, closeMaskIndex = maskFormat.getMaskCellIndex(start);
    setFocusCellIndex(closeMaskIndex), forceSelectionSync({}), onMouseUp == null || onMouseUp(event), mouseDownRef.current = !1;
  }, "onFormatMouseUp"), onFormatFocus = /* @__PURE__ */ __name(function(event) {
    setFocused(!0), setFocusCellIndex(0), setFocusCellText(""), onFocus(event);
  }, "onFormatFocus"), onSharedBlur = /* @__PURE__ */ __name(function(event) {
    onBlur(event);
  }, "onSharedBlur"), onFormatBlur = /* @__PURE__ */ __name(function(event) {
    setFocused(!1), onSharedBlur(event);
  }, "onFormatBlur");
  useLockEffect(active, function() {
    !active && !preserveInvalidOnBlur && setInputValue(value);
  });
  var onSharedKeyDown = /* @__PURE__ */ __name(function(event) {
    event.key === "Enter" && validateFormat(inputValue) && onSubmit(), onKeyDown2 == null || onKeyDown2(event);
  }, "onSharedKeyDown"), onFormatKeyDown = /* @__PURE__ */ __name(function(event) {
    onSharedKeyDown(event);
    var key = event.key, nextCellText = null, nextFillText = null, maskCellLen = selectionEnd - selectionStart, cellFormat = format3.slice(selectionStart, selectionEnd), offsetCellIndex = /* @__PURE__ */ __name(function(offset2) {
      setFocusCellIndex(function(idx) {
        var nextIndex = idx + offset2;
        return nextIndex = Math.max(nextIndex, 0), nextIndex = Math.min(nextIndex, maskFormat.size() - 1), nextIndex;
      });
    }, "offsetCellIndex"), offsetCellValue = /* @__PURE__ */ __name(function(offset2) {
      var _getMaskRange = getMaskRange(cellFormat), _getMaskRange2 = _slicedToArray(_getMaskRange, 3), rangeStart = _getMaskRange2[0], rangeEnd = _getMaskRange2[1], rangeDefault = _getMaskRange2[2], currentText = inputValue.slice(selectionStart, selectionEnd), currentTextNum = Number(currentText);
      if (isNaN(currentTextNum))
        return String(rangeDefault || (offset2 > 0 ? rangeStart : rangeEnd));
      var num = currentTextNum + offset2, range3 = rangeEnd - rangeStart + 1;
      return String(rangeStart + (range3 + num - rangeStart) % range3);
    }, "offsetCellValue");
    switch (key) {
      case "Backspace":
      case "Delete":
        nextCellText = "", nextFillText = cellFormat;
        break;
      case "ArrowLeft":
        nextCellText = "", offsetCellIndex(-1);
        break;
      case "ArrowRight":
        nextCellText = "", offsetCellIndex(1);
        break;
      case "ArrowUp":
        nextCellText = "", nextFillText = offsetCellValue(1);
        break;
      case "ArrowDown":
        nextCellText = "", nextFillText = offsetCellValue(-1);
        break;
      default:
        isNaN(Number(key)) || (nextCellText = focusCellText + key, nextFillText = nextCellText);
        break;
    }
    if (nextCellText !== null && (setFocusCellText(nextCellText), nextCellText.length >= maskCellLen && (offsetCellIndex(1), setFocusCellText(""))), nextFillText !== null) {
      var nextFocusValue = (
        // before
        inputValue.slice(0, selectionStart) + // replace
        leftPad(nextFillText, maskCellLen) + // after
        inputValue.slice(selectionEnd)
      );
      triggerInputChange(nextFocusValue.slice(0, format3.length));
    }
    forceSelectionSync({});
  }, "onFormatKeyDown"), rafRef = React.useRef();
  useLayoutEffect$1(function() {
    if (!(!focused || !format3 || mouseDownRef.current)) {
      if (!maskFormat.match(inputValue)) {
        triggerInputChange(format3);
        return;
      }
      return inputRef.current.setSelectionRange(selectionStart, selectionEnd), rafRef.current = wrapperRaf(function() {
        inputRef.current.setSelectionRange(selectionStart, selectionEnd);
      }), function() {
        wrapperRaf.cancel(rafRef.current);
      };
    }
  }, [maskFormat, format3, focused, inputValue, focusCellIndex, selectionStart, selectionEnd, forceSelectionSyncMark, triggerInputChange]);
  var inputProps = format3 ? {
    onFocus: onFormatFocus,
    onBlur: onFormatBlur,
    onKeyDown: onFormatKeyDown,
    onMouseDown: onFormatMouseDown,
    onMouseUp: onFormatMouseUp,
    onPaste: onFormatPaste
  } : {};
  return /* @__PURE__ */ React.createElement("div", {
    ref: holderRef,
    className: cn(inputPrefixCls, _defineProperty$2(_defineProperty$2({}, "".concat(inputPrefixCls, "-active"), active && showActiveCls), "".concat(inputPrefixCls, "-placeholder"), helped))
  }, /* @__PURE__ */ React.createElement(Component2, _extends({
    ref: inputRef,
    "aria-invalid": invalid,
    autoComplete: "off"
  }, restProps, {
    onKeyDown: onSharedKeyDown,
    onBlur: onSharedBlur
    // Replace with format
  }, inputProps, {
    // Value
    value: inputValue,
    onChange: onInternalChange
  })), /* @__PURE__ */ React.createElement(Icon$1, {
    type: "suffix",
    icon: suffixIcon
  }), clearIcon);
});
process.env.NODE_ENV !== "production" && (Input$4.displayName = "Input");
var _excluded$n = ["id", "prefix", "clearIcon", "suffixIcon", "separator", "activeIndex", "activeHelp", "allHelp", "focused", "onFocus", "onBlur", "onKeyDown", "locale", "generateConfig", "placeholder", "className", "style", "onClick", "onClear", "value", "onChange", "onSubmit", "onInputChange", "format", "maskFormat", "preserveInvalidOnBlur", "onInvalid", "disabled", "invalid", "inputReadOnly", "direction", "onOpenChange", "onActiveOffset", "placement", "onMouseDown", "required", "aria-required", "autoFocus", "tabIndex"], _excluded2$3 = ["index"], _excluded3 = ["insetInlineStart", "insetInlineEnd"];
function RangeSelector(props, ref) {
  var id2 = props.id, prefix = props.prefix, clearIcon = props.clearIcon, suffixIcon = props.suffixIcon, _props$separator = props.separator, separator = _props$separator === void 0 ? "~" : _props$separator, activeIndex = props.activeIndex;
  props.activeHelp, props.allHelp;
  var focused = props.focused;
  props.onFocus, props.onBlur, props.onKeyDown, props.locale, props.generateConfig;
  var placeholder = props.placeholder, className = props.className, style2 = props.style, onClick = props.onClick, onClear = props.onClear, value = props.value;
  props.onChange, props.onSubmit, props.onInputChange, props.format, props.maskFormat, props.preserveInvalidOnBlur, props.onInvalid;
  var disabled = props.disabled, invalid = props.invalid;
  props.inputReadOnly;
  var direction = props.direction;
  props.onOpenChange;
  var onActiveOffset = props.onActiveOffset, placement = props.placement, _onMouseDown = props.onMouseDown;
  props.required, props["aria-required"];
  var autoFocus = props.autoFocus, tabIndex = props.tabIndex, restProps = _objectWithoutProperties(props, _excluded$n), rtl = direction === "rtl", _React$useContext = React.useContext(PickerContext), prefixCls = _React$useContext.prefixCls, ids = React.useMemo(function() {
    if (typeof id2 == "string")
      return [id2];
    var mergedId = id2 || {};
    return [mergedId.start, mergedId.end];
  }, [id2]), rootRef = React.useRef(), inputStartRef = React.useRef(), inputEndRef = React.useRef(), getInput = /* @__PURE__ */ __name(function(index2) {
    var _index;
    return (_index = [inputStartRef, inputEndRef][index2]) === null || _index === void 0 ? void 0 : _index.current;
  }, "getInput");
  React.useImperativeHandle(ref, function() {
    return {
      nativeElement: rootRef.current,
      focus: /* @__PURE__ */ __name(function(options) {
        if (_typeof$4(options) === "object") {
          var _getInput, _ref = options || {}, _ref$index = _ref.index, _index2 = _ref$index === void 0 ? 0 : _ref$index, rest = _objectWithoutProperties(_ref, _excluded2$3);
          (_getInput = getInput(_index2)) === null || _getInput === void 0 || _getInput.focus(rest);
        } else {
          var _getInput2;
          (_getInput2 = getInput(options ?? 0)) === null || _getInput2 === void 0 || _getInput2.focus();
        }
      }, "focus"),
      blur: /* @__PURE__ */ __name(function() {
        var _getInput3, _getInput4;
        (_getInput3 = getInput(0)) === null || _getInput3 === void 0 || _getInput3.blur(), (_getInput4 = getInput(1)) === null || _getInput4 === void 0 || _getInput4.blur();
      }, "blur")
    };
  });
  var rootProps = useRootProps(restProps), mergedPlaceholder = React.useMemo(function() {
    return Array.isArray(placeholder) ? placeholder : [placeholder, placeholder];
  }, [placeholder]), _useInputProps = useInputProps(_objectSpread2$1(_objectSpread2$1({}, props), {}, {
    id: ids,
    placeholder: mergedPlaceholder
  })), _useInputProps2 = _slicedToArray(_useInputProps, 1), getInputProps = _useInputProps2[0], realPlacement = getRealPlacement(placement, rtl), offsetUnit = getoffsetUnit(realPlacement, rtl), placementRight = realPlacement == null ? void 0 : realPlacement.toLowerCase().endsWith("right"), _React$useState = React.useState({
    position: "absolute",
    width: 0
  }), _React$useState2 = _slicedToArray(_React$useState, 2), activeBarStyle = _React$useState2[0], setActiveBarStyle = _React$useState2[1], syncActiveOffset = useEvent(function() {
    var input = getInput(activeIndex);
    if (input) {
      var _input$nativeElement = input.nativeElement, offsetWidth = _input$nativeElement.offsetWidth, offsetLeft = _input$nativeElement.offsetLeft, offsetParent = _input$nativeElement.offsetParent, parentWidth = (offsetParent == null ? void 0 : offsetParent.offsetWidth) || 0, activeOffset = placementRight ? parentWidth - offsetWidth - offsetLeft : offsetLeft;
      setActiveBarStyle(function(_ref2) {
        _ref2.insetInlineStart, _ref2.insetInlineEnd;
        var rest = _objectWithoutProperties(_ref2, _excluded3);
        return _objectSpread2$1(_objectSpread2$1({}, rest), {}, _defineProperty$2({
          width: offsetWidth
        }, offsetUnit, activeOffset));
      }), onActiveOffset(activeOffset);
    }
  });
  React.useEffect(function() {
    syncActiveOffset();
  }, [activeIndex]);
  var showClear = clearIcon && (value[0] && !disabled[0] || value[1] && !disabled[1]), startAutoFocus = autoFocus && !disabled[0], endAutoFocus = autoFocus && !startAutoFocus && !disabled[1];
  return /* @__PURE__ */ React.createElement(RefResizeObserver, {
    onResize: syncActiveOffset
  }, /* @__PURE__ */ React.createElement("div", _extends({}, rootProps, {
    className: cn(prefixCls, "".concat(prefixCls, "-range"), _defineProperty$2(_defineProperty$2(_defineProperty$2(_defineProperty$2({}, "".concat(prefixCls, "-focused"), focused), "".concat(prefixCls, "-disabled"), disabled.every(function(i) {
      return i;
    })), "".concat(prefixCls, "-invalid"), invalid.some(function(i) {
      return i;
    })), "".concat(prefixCls, "-rtl"), rtl), className),
    style: style2,
    ref: rootRef,
    onClick,
    onMouseDown: /* @__PURE__ */ __name(function(e2) {
      var target = e2.target;
      target !== inputStartRef.current.inputElement && target !== inputEndRef.current.inputElement && e2.preventDefault(), _onMouseDown == null || _onMouseDown(e2);
    }, "onMouseDown")
  }), prefix && /* @__PURE__ */ React.createElement("div", {
    className: "".concat(prefixCls, "-prefix")
  }, prefix), /* @__PURE__ */ React.createElement(Input$4, _extends({
    ref: inputStartRef
  }, getInputProps(0), {
    autoFocus: startAutoFocus,
    tabIndex,
    "date-range": "start"
  })), /* @__PURE__ */ React.createElement("div", {
    className: "".concat(prefixCls, "-range-separator")
  }, separator), /* @__PURE__ */ React.createElement(Input$4, _extends({
    ref: inputEndRef
  }, getInputProps(1), {
    autoFocus: endAutoFocus,
    tabIndex,
    "date-range": "end"
  })), /* @__PURE__ */ React.createElement("div", {
    className: "".concat(prefixCls, "-active-bar"),
    style: activeBarStyle
  }), /* @__PURE__ */ React.createElement(Icon$1, {
    type: "suffix",
    icon: suffixIcon
  }), showClear && /* @__PURE__ */ React.createElement(ClearIcon, {
    icon: clearIcon,
    onClear
  })));
}
__name(RangeSelector, "RangeSelector");
var RefRangeSelector = /* @__PURE__ */ React.forwardRef(RangeSelector);
process.env.NODE_ENV !== "production" && (RefRangeSelector.displayName = "RangeSelector");
function separateConfig(config, defaultConfig2) {
  var singleConfig = config ?? defaultConfig2;
  return Array.isArray(singleConfig) ? singleConfig : [singleConfig, singleConfig];
}
__name(separateConfig, "separateConfig");
function getActiveRange(activeIndex) {
  return activeIndex === 1 ? "end" : "start";
}
__name(getActiveRange, "getActiveRange");
function RangePicker$2(props, ref) {
  var _useFilledProps = useFilledProps(props, function() {
    var disabled2 = props.disabled, allowEmpty2 = props.allowEmpty, mergedDisabled = separateConfig(disabled2, !1), mergedAllowEmpty = separateConfig(allowEmpty2, !1);
    return {
      disabled: mergedDisabled,
      allowEmpty: mergedAllowEmpty
    };
  }), _useFilledProps2 = _slicedToArray(_useFilledProps, 6), filledProps = _useFilledProps2[0], internalPicker = _useFilledProps2[1], complexPicker = _useFilledProps2[2], formatList = _useFilledProps2[3], maskFormat = _useFilledProps2[4], isInvalidateDate = _useFilledProps2[5], prefixCls = filledProps.prefixCls, styles2 = filledProps.styles, classNames = filledProps.classNames, placement = filledProps.placement, defaultValue = filledProps.defaultValue, value = filledProps.value, needConfirm = filledProps.needConfirm, onKeyDown2 = filledProps.onKeyDown, disabled = filledProps.disabled, allowEmpty = filledProps.allowEmpty, disabledDate = filledProps.disabledDate, minDate = filledProps.minDate, maxDate = filledProps.maxDate, defaultOpen = filledProps.defaultOpen, open = filledProps.open, onOpenChange = filledProps.onOpenChange, locale2 = filledProps.locale, generateConfig2 = filledProps.generateConfig, picker = filledProps.picker, showNow = filledProps.showNow, showToday = filledProps.showToday, showTime = filledProps.showTime, mode = filledProps.mode, onPanelChange = filledProps.onPanelChange, onCalendarChange = filledProps.onCalendarChange, onOk = filledProps.onOk, defaultPickerValue = filledProps.defaultPickerValue, pickerValue = filledProps.pickerValue, onPickerValueChange = filledProps.onPickerValueChange, inputReadOnly = filledProps.inputReadOnly, suffixIcon = filledProps.suffixIcon, onFocus = filledProps.onFocus, onBlur = filledProps.onBlur, presets = filledProps.presets, ranges = filledProps.ranges, components2 = filledProps.components, cellRender = filledProps.cellRender, dateRender = filledProps.dateRender, monthCellRender = filledProps.monthCellRender, onClick = filledProps.onClick, selectorRef = usePickerRef(ref), _useOpen = useOpen(open, defaultOpen, disabled, onOpenChange), _useOpen2 = _slicedToArray(_useOpen, 2), mergedOpen = _useOpen2[0], setMergeOpen = _useOpen2[1], triggerOpen = /* @__PURE__ */ __name(function(nextOpen, config) {
    (disabled.some(function(fieldDisabled) {
      return !fieldDisabled;
    }) || !nextOpen) && setMergeOpen(nextOpen, config);
  }, "triggerOpen"), _useInnerValue = useInnerValue(generateConfig2, locale2, formatList, !0, !1, defaultValue, value, onCalendarChange, onOk), _useInnerValue2 = _slicedToArray(_useInnerValue, 5), mergedValue = _useInnerValue2[0], setInnerValue = _useInnerValue2[1], getCalendarValue = _useInnerValue2[2], triggerCalendarChange = _useInnerValue2[3], triggerOk = _useInnerValue2[4], calendarValue = getCalendarValue(), _useRangeActive = useRangeActive(disabled, allowEmpty, mergedOpen), _useRangeActive2 = _slicedToArray(_useRangeActive, 7), focused = _useRangeActive2[0], triggerFocus2 = _useRangeActive2[1], lastOperation = _useRangeActive2[2], activeIndex = _useRangeActive2[3], setActiveIndex = _useRangeActive2[4], nextActiveIndex = _useRangeActive2[5], activeIndexList = _useRangeActive2[6], onSharedFocus = /* @__PURE__ */ __name(function(event, index2) {
    triggerFocus2(!0), onFocus == null || onFocus(event, {
      range: getActiveRange(index2 ?? activeIndex)
    });
  }, "onSharedFocus"), onSharedBlur = /* @__PURE__ */ __name(function(event, index2) {
    triggerFocus2(!1), onBlur == null || onBlur(event, {
      range: getActiveRange(index2 ?? activeIndex)
    });
  }, "onSharedBlur"), mergedShowTime = React.useMemo(function() {
    if (!showTime)
      return null;
    var disabledTime = showTime.disabledTime, proxyDisabledTime = disabledTime ? function(date4) {
      var range3 = getActiveRange(activeIndex), fromDate = getFromDate(calendarValue, activeIndexList, activeIndex);
      return disabledTime(date4, range3, {
        from: fromDate
      });
    } : void 0;
    return _objectSpread2$1(_objectSpread2$1({}, showTime), {}, {
      disabledTime: proxyDisabledTime
    });
  }, [showTime, activeIndex, calendarValue, activeIndexList]), _useMergedState = useMergedState([picker, picker], {
    value: mode
  }), _useMergedState2 = _slicedToArray(_useMergedState, 2), modes = _useMergedState2[0], setModes = _useMergedState2[1], mergedMode = modes[activeIndex] || picker, internalMode = mergedMode === "date" && mergedShowTime ? "datetime" : mergedMode, multiplePanel = internalMode === picker && internalMode !== "time", mergedShowNow = useShowNow(picker, mergedMode, showNow, showToday, !0), _useRangeValue = useRangeValue(filledProps, mergedValue, setInnerValue, getCalendarValue, triggerCalendarChange, disabled, formatList, focused, mergedOpen, isInvalidateDate), _useRangeValue2 = _slicedToArray(_useRangeValue, 3), flushSubmit = _useRangeValue2[0], triggerSubmitChange = _useRangeValue2[1], hasSubmitValue = _useRangeValue2[2], mergedDisabledDate = useRangeDisabledDate(calendarValue, disabled, activeIndexList, generateConfig2, locale2, disabledDate), _useFieldsInvalidate = useFieldsInvalidate(calendarValue, isInvalidateDate, allowEmpty), _useFieldsInvalidate2 = _slicedToArray(_useFieldsInvalidate, 2), submitInvalidates = _useFieldsInvalidate2[0], onSelectorInvalid = _useFieldsInvalidate2[1], _useRangePickerValue = useRangePickerValue(generateConfig2, locale2, calendarValue, modes, mergedOpen, activeIndex, internalPicker, multiplePanel, defaultPickerValue, pickerValue, mergedShowTime == null ? void 0 : mergedShowTime.defaultOpenValue, onPickerValueChange, minDate, maxDate), _useRangePickerValue2 = _slicedToArray(_useRangePickerValue, 2), currentPickerValue = _useRangePickerValue2[0], setCurrentPickerValue = _useRangePickerValue2[1], triggerModeChange = useEvent(function(nextPickerValue, nextMode, triggerEvent) {
    var clone = fillIndex(modes, activeIndex, nextMode);
    if ((clone[0] !== modes[0] || clone[1] !== modes[1]) && setModes(clone), onPanelChange && triggerEvent !== !1) {
      var clonePickerValue = _toConsumableArray(calendarValue);
      nextPickerValue && (clonePickerValue[activeIndex] = nextPickerValue), onPanelChange(clonePickerValue, clone);
    }
  }), fillCalendarValue = /* @__PURE__ */ __name(function(date4, index2) {
    return (
      // Trigger change only when date changed
      fillIndex(calendarValue, index2, date4)
    );
  }, "fillCalendarValue"), triggerPartConfirm = /* @__PURE__ */ __name(function(date4, skipFocus) {
    var nextValue = calendarValue;
    date4 && (nextValue = fillCalendarValue(date4, activeIndex));
    var nextIndex = nextActiveIndex(nextValue);
    triggerCalendarChange(nextValue), flushSubmit(activeIndex, nextIndex === null), nextIndex === null ? triggerOpen(!1, {
      force: !0
    }) : skipFocus || selectorRef.current.focus({
      index: nextIndex
    });
  }, "triggerPartConfirm"), onSelectorClick = /* @__PURE__ */ __name(function(event) {
    var _activeElement, rootNode = event.target.getRootNode();
    if (!selectorRef.current.nativeElement.contains((_activeElement = rootNode.activeElement) !== null && _activeElement !== void 0 ? _activeElement : document.activeElement)) {
      var enabledIndex = disabled.findIndex(function(d) {
        return !d;
      });
      enabledIndex >= 0 && selectorRef.current.focus({
        index: enabledIndex
      });
    }
    triggerOpen(!0), onClick == null || onClick(event);
  }, "onSelectorClick"), onSelectorClear = /* @__PURE__ */ __name(function() {
    triggerSubmitChange(null), triggerOpen(!1, {
      force: !0
    });
  }, "onSelectorClear"), _React$useState = React.useState(null), _React$useState2 = _slicedToArray(_React$useState, 2), hoverSource = _React$useState2[0], setHoverSource = _React$useState2[1], _React$useState3 = React.useState(null), _React$useState4 = _slicedToArray(_React$useState3, 2), internalHoverValues = _React$useState4[0], setInternalHoverValues = _React$useState4[1], hoverValues = React.useMemo(function() {
    return internalHoverValues || calendarValue;
  }, [calendarValue, internalHoverValues]);
  React.useEffect(function() {
    mergedOpen || setInternalHoverValues(null);
  }, [mergedOpen]);
  var _React$useState5 = React.useState(0), _React$useState6 = _slicedToArray(_React$useState5, 2), activeOffset = _React$useState6[0], setActiveOffset = _React$useState6[1], presetList = usePresets(presets, ranges), onPresetHover = /* @__PURE__ */ __name(function(nextValues) {
    setInternalHoverValues(nextValues), setHoverSource("preset");
  }, "onPresetHover"), onPresetSubmit = /* @__PURE__ */ __name(function(nextValues) {
    var passed = triggerSubmitChange(nextValues);
    passed && triggerOpen(!1, {
      force: !0
    });
  }, "onPresetSubmit"), onNow = /* @__PURE__ */ __name(function(now2) {
    triggerPartConfirm(now2);
  }, "onNow"), onPanelHover = /* @__PURE__ */ __name(function(date4) {
    setInternalHoverValues(date4 ? fillCalendarValue(date4, activeIndex) : null), setHoverSource("cell");
  }, "onPanelHover"), onPanelFocus = /* @__PURE__ */ __name(function(event) {
    triggerOpen(!0), onSharedFocus(event);
  }, "onPanelFocus"), onPanelMouseDown = /* @__PURE__ */ __name(function() {
    lastOperation("panel");
  }, "onPanelMouseDown"), onPanelSelect = /* @__PURE__ */ __name(function(date4) {
    var clone = fillIndex(calendarValue, activeIndex, date4);
    triggerCalendarChange(clone), !needConfirm && !complexPicker && internalPicker === internalMode && triggerPartConfirm(date4);
  }, "onPanelSelect"), onPopupClose = /* @__PURE__ */ __name(function() {
    triggerOpen(!1);
  }, "onPopupClose"), onInternalCellRender = useCellRender$1(cellRender, dateRender, monthCellRender, getActiveRange(activeIndex)), panelValue = calendarValue[activeIndex] || null, isPopupInvalidateDate = useEvent(function(date4) {
    return isInvalidateDate(date4, {
      activeIndex
    });
  }), panelProps = React.useMemo(function() {
    var domProps = pickAttrs(filledProps, !1), restProps = omit(filledProps, [].concat(_toConsumableArray(Object.keys(domProps)), ["onChange", "onCalendarChange", "style", "className", "onPanelChange", "disabledTime"]));
    return restProps;
  }, [filledProps]), panel = /* @__PURE__ */ React.createElement(Popup, _extends({}, panelProps, {
    showNow: mergedShowNow,
    showTime: mergedShowTime,
    range: !0,
    multiplePanel,
    activeOffset,
    placement,
    disabledDate: mergedDisabledDate,
    onFocus: onPanelFocus,
    onBlur: onSharedBlur,
    onPanelMouseDown,
    picker,
    mode: mergedMode,
    internalMode,
    onPanelChange: triggerModeChange,
    format: maskFormat,
    value: panelValue,
    isInvalid: isPopupInvalidateDate,
    onChange: null,
    onSelect: onPanelSelect,
    pickerValue: currentPickerValue,
    defaultOpenValue: toArray$3(showTime == null ? void 0 : showTime.defaultOpenValue)[activeIndex],
    onPickerValueChange: setCurrentPickerValue,
    hoverValue: hoverValues,
    onHover: onPanelHover,
    needConfirm,
    onSubmit: triggerPartConfirm,
    onOk: triggerOk,
    presets: presetList,
    onPresetHover,
    onPresetSubmit,
    onNow,
    cellRender: onInternalCellRender
  })), onSelectorChange = /* @__PURE__ */ __name(function(date4, index2) {
    var clone = fillCalendarValue(date4, index2);
    triggerCalendarChange(clone);
  }, "onSelectorChange"), onSelectorInputChange = /* @__PURE__ */ __name(function() {
    lastOperation("input");
  }, "onSelectorInputChange"), onSelectorFocus = /* @__PURE__ */ __name(function(event, index2) {
    var activeListLen = activeIndexList.length, lastActiveIndex = activeIndexList[activeListLen - 1];
    if (activeListLen && lastActiveIndex !== index2 && needConfirm && // Not change index if is not filled
    !allowEmpty[lastActiveIndex] && !hasSubmitValue(lastActiveIndex) && calendarValue[lastActiveIndex]) {
      selectorRef.current.focus({
        index: lastActiveIndex
      });
      return;
    }
    lastOperation("input"), triggerOpen(!0, {
      inherit: !0
    }), activeIndex !== index2 && mergedOpen && !needConfirm && complexPicker && triggerPartConfirm(null, !0), setActiveIndex(index2), onSharedFocus(event, index2);
  }, "onSelectorFocus"), onSelectorBlur = /* @__PURE__ */ __name(function(event, index2) {
    if (triggerOpen(!1), !needConfirm && lastOperation() === "input") {
      var nextIndex = nextActiveIndex(calendarValue);
      flushSubmit(activeIndex, nextIndex === null);
    }
    onSharedBlur(event, index2);
  }, "onSelectorBlur"), onSelectorKeyDown = /* @__PURE__ */ __name(function(event, preventDefault) {
    event.key === "Tab" && triggerPartConfirm(null, !0), onKeyDown2 == null || onKeyDown2(event, preventDefault);
  }, "onSelectorKeyDown"), context = React.useMemo(function() {
    return {
      prefixCls,
      locale: locale2,
      generateConfig: generateConfig2,
      button: components2.button,
      input: components2.input
    };
  }, [prefixCls, locale2, generateConfig2, components2.button, components2.input]);
  if (useLayoutEffect$1(function() {
    mergedOpen && activeIndex !== void 0 && triggerModeChange(null, picker, !1);
  }, [mergedOpen, activeIndex, picker]), useLayoutEffect$1(function() {
    var lastOp = lastOperation();
    !mergedOpen && lastOp === "input" && (triggerOpen(!1), triggerPartConfirm(null, !0)), !mergedOpen && complexPicker && !needConfirm && lastOp === "panel" && (triggerOpen(!0), triggerPartConfirm());
  }, [mergedOpen]), process.env.NODE_ENV !== "production") {
    var isIndexEmpty = /* @__PURE__ */ __name(function(index2) {
      return (
        // Value is empty
        !(value != null && value[index2]) && // DefaultValue is empty
        !(defaultValue != null && defaultValue[index2])
      );
    }, "isIndexEmpty");
    disabled.some(function(fieldDisabled, index2) {
      return fieldDisabled && isIndexEmpty(index2) && !allowEmpty[index2];
    }) && warningOnce(!1, "`disabled` should not set with empty `value`. You should set `allowEmpty` or `value` instead.");
  }
  return /* @__PURE__ */ React.createElement(PickerContext.Provider, {
    value: context
  }, /* @__PURE__ */ React.createElement(PickerTrigger, _extends({}, pickTriggerProps(filledProps), {
    popupElement: panel,
    popupStyle: styles2.popup,
    popupClassName: classNames.popup,
    visible: mergedOpen,
    onClose: onPopupClose,
    range: !0
  }), /* @__PURE__ */ React.createElement(
    RefRangeSelector,
    _extends({}, filledProps, {
      // Ref
      ref: selectorRef,
      suffixIcon,
      activeIndex: focused || mergedOpen ? activeIndex : null,
      activeHelp: !!internalHoverValues,
      allHelp: !!internalHoverValues && hoverSource === "preset",
      focused,
      onFocus: onSelectorFocus,
      onBlur: onSelectorBlur,
      onKeyDown: onSelectorKeyDown,
      onSubmit: triggerPartConfirm,
      value: hoverValues,
      maskFormat,
      onChange: onSelectorChange,
      onInputChange: onSelectorInputChange,
      format: formatList,
      inputReadOnly,
      disabled,
      open: mergedOpen,
      onOpenChange: triggerOpen,
      onClick: onSelectorClick,
      onClear: onSelectorClear,
      invalid: submitInvalidates,
      onInvalid: onSelectorInvalid,
      onActiveOffset: setActiveOffset
    })
  )));
}
__name(RangePicker$2, "RangePicker$2");
var RefRangePicker = /* @__PURE__ */ React.forwardRef(RangePicker$2);
process.env.NODE_ENV !== "production" && (RefRangePicker.displayName = "RefRangePicker");
function MultipleDates(props) {
  var prefixCls = props.prefixCls, value = props.value, onRemove = props.onRemove, _props$removeIcon = props.removeIcon, removeIcon = _props$removeIcon === void 0 ? "×" : _props$removeIcon, formatDate = props.formatDate, disabled = props.disabled, maxTagCount = props.maxTagCount, placeholder = props.placeholder, selectorCls = "".concat(prefixCls, "-selector"), selectionCls = "".concat(prefixCls, "-selection"), overflowCls = "".concat(selectionCls, "-overflow");
  function renderSelector(content, onClose) {
    return /* @__PURE__ */ React.createElement("span", {
      className: cn("".concat(selectionCls, "-item")),
      title: typeof content == "string" ? content : null
    }, /* @__PURE__ */ React.createElement("span", {
      className: "".concat(selectionCls, "-item-content")
    }, content), !disabled && onClose && /* @__PURE__ */ React.createElement("span", {
      onMouseDown: /* @__PURE__ */ __name(function(e2) {
        e2.preventDefault();
      }, "onMouseDown"),
      onClick: onClose,
      className: "".concat(selectionCls, "-item-remove")
    }, removeIcon));
  }
  __name(renderSelector, "renderSelector");
  function renderItem(date4) {
    var displayLabel = formatDate(date4), onClose = /* @__PURE__ */ __name(function(event) {
      event && event.stopPropagation(), onRemove(date4);
    }, "onClose");
    return renderSelector(displayLabel, onClose);
  }
  __name(renderItem, "renderItem");
  function renderRest(omittedValues) {
    var content = "+ ".concat(omittedValues.length, " ...");
    return renderSelector(content);
  }
  return __name(renderRest, "renderRest"), /* @__PURE__ */ React.createElement("div", {
    className: selectorCls
  }, /* @__PURE__ */ React.createElement(ForwardOverflow, {
    prefixCls: overflowCls,
    data: value,
    renderItem,
    renderRest,
    itemKey: /* @__PURE__ */ __name(function(date4) {
      return formatDate(date4);
    }, "itemKey"),
    maxCount: maxTagCount
  }), !value.length && /* @__PURE__ */ React.createElement("span", {
    className: "".concat(prefixCls, "-selection-placeholder")
  }, placeholder));
}
__name(MultipleDates, "MultipleDates");
var _excluded$m = ["id", "open", "prefix", "clearIcon", "suffixIcon", "activeHelp", "allHelp", "focused", "onFocus", "onBlur", "onKeyDown", "locale", "generateConfig", "placeholder", "className", "style", "onClick", "onClear", "internalPicker", "value", "onChange", "onSubmit", "onInputChange", "multiple", "maxTagCount", "format", "maskFormat", "preserveInvalidOnBlur", "onInvalid", "disabled", "invalid", "inputReadOnly", "direction", "onOpenChange", "onMouseDown", "required", "aria-required", "autoFocus", "tabIndex", "removeIcon"];
function SingleSelector2(props, ref) {
  props.id;
  var open = props.open, prefix = props.prefix, clearIcon = props.clearIcon, suffixIcon = props.suffixIcon;
  props.activeHelp, props.allHelp;
  var focused = props.focused;
  props.onFocus, props.onBlur, props.onKeyDown;
  var locale2 = props.locale, generateConfig2 = props.generateConfig, placeholder = props.placeholder, className = props.className, style2 = props.style, onClick = props.onClick, onClear = props.onClear, internalPicker = props.internalPicker, value = props.value, onChange = props.onChange, onSubmit = props.onSubmit;
  props.onInputChange;
  var multiple = props.multiple, maxTagCount = props.maxTagCount;
  props.format, props.maskFormat, props.preserveInvalidOnBlur, props.onInvalid;
  var disabled = props.disabled, invalid = props.invalid;
  props.inputReadOnly;
  var direction = props.direction;
  props.onOpenChange;
  var _onMouseDown = props.onMouseDown;
  props.required, props["aria-required"];
  var autoFocus = props.autoFocus, tabIndex = props.tabIndex, removeIcon = props.removeIcon, restProps = _objectWithoutProperties(props, _excluded$m), rtl = direction === "rtl", _React$useContext = React.useContext(PickerContext), prefixCls = _React$useContext.prefixCls, rootRef = React.useRef(), inputRef = React.useRef();
  React.useImperativeHandle(ref, function() {
    return {
      nativeElement: rootRef.current,
      focus: /* @__PURE__ */ __name(function(options) {
        var _inputRef$current;
        (_inputRef$current = inputRef.current) === null || _inputRef$current === void 0 || _inputRef$current.focus(options);
      }, "focus"),
      blur: /* @__PURE__ */ __name(function() {
        var _inputRef$current2;
        (_inputRef$current2 = inputRef.current) === null || _inputRef$current2 === void 0 || _inputRef$current2.blur();
      }, "blur")
    };
  });
  var rootProps = useRootProps(restProps), onSingleChange = /* @__PURE__ */ __name(function(date4) {
    onChange([date4]);
  }, "onSingleChange"), onMultipleRemove = /* @__PURE__ */ __name(function(date4) {
    var nextValues = value.filter(function(oriDate) {
      return oriDate && !isSame(generateConfig2, locale2, oriDate, date4, internalPicker);
    });
    onChange(nextValues), open || onSubmit();
  }, "onMultipleRemove"), _useInputProps = useInputProps(_objectSpread2$1(_objectSpread2$1({}, props), {}, {
    onChange: onSingleChange
  }), function(_ref) {
    var valueTexts = _ref.valueTexts;
    return {
      value: valueTexts[0] || "",
      active: focused
    };
  }), _useInputProps2 = _slicedToArray(_useInputProps, 2), getInputProps = _useInputProps2[0], getText = _useInputProps2[1], showClear = !!(clearIcon && value.length && !disabled), selectorNode = multiple ? /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement(MultipleDates, {
    prefixCls,
    value,
    onRemove: onMultipleRemove,
    formatDate: getText,
    maxTagCount,
    disabled,
    removeIcon,
    placeholder
  }), /* @__PURE__ */ React.createElement("input", {
    className: "".concat(prefixCls, "-multiple-input"),
    value: value.map(getText).join(","),
    ref: inputRef,
    readOnly: !0,
    autoFocus,
    tabIndex
  }), /* @__PURE__ */ React.createElement(Icon$1, {
    type: "suffix",
    icon: suffixIcon
  }), showClear && /* @__PURE__ */ React.createElement(ClearIcon, {
    icon: clearIcon,
    onClear
  })) : /* @__PURE__ */ React.createElement(Input$4, _extends({
    ref: inputRef
  }, getInputProps(), {
    autoFocus,
    tabIndex,
    suffixIcon,
    clearIcon: showClear && /* @__PURE__ */ React.createElement(ClearIcon, {
      icon: clearIcon,
      onClear
    }),
    showActiveCls: !1
  }));
  return /* @__PURE__ */ React.createElement("div", _extends({}, rootProps, {
    className: cn(prefixCls, _defineProperty$2(_defineProperty$2(_defineProperty$2(_defineProperty$2(_defineProperty$2({}, "".concat(prefixCls, "-multiple"), multiple), "".concat(prefixCls, "-focused"), focused), "".concat(prefixCls, "-disabled"), disabled), "".concat(prefixCls, "-invalid"), invalid), "".concat(prefixCls, "-rtl"), rtl), className),
    style: style2,
    ref: rootRef,
    onClick,
    onMouseDown: /* @__PURE__ */ __name(function(e2) {
      var _inputRef$current3, target = e2.target;
      target !== ((_inputRef$current3 = inputRef.current) === null || _inputRef$current3 === void 0 ? void 0 : _inputRef$current3.inputElement) && e2.preventDefault(), _onMouseDown == null || _onMouseDown(e2);
    }, "onMouseDown")
  }), prefix && /* @__PURE__ */ React.createElement("div", {
    className: "".concat(prefixCls, "-prefix")
  }, prefix), selectorNode);
}
__name(SingleSelector2, "SingleSelector");
var RefSingleSelector = /* @__PURE__ */ React.forwardRef(SingleSelector2);
process.env.NODE_ENV !== "production" && (RefSingleSelector.displayName = "SingleSelector");
function Picker2(props, ref) {
  var _useFilledProps = useFilledProps(props), _useFilledProps2 = _slicedToArray(_useFilledProps, 6), filledProps = _useFilledProps2[0], internalPicker = _useFilledProps2[1], complexPicker = _useFilledProps2[2], formatList = _useFilledProps2[3], maskFormat = _useFilledProps2[4], isInvalidateDate = _useFilledProps2[5], _ref = filledProps, prefixCls = _ref.prefixCls, styles2 = _ref.styles, classNames = _ref.classNames, order2 = _ref.order, defaultValue = _ref.defaultValue, value = _ref.value, needConfirm = _ref.needConfirm, onChange = _ref.onChange, onKeyDown2 = _ref.onKeyDown, disabled = _ref.disabled, disabledDate = _ref.disabledDate, minDate = _ref.minDate, maxDate = _ref.maxDate, defaultOpen = _ref.defaultOpen, open = _ref.open, onOpenChange = _ref.onOpenChange, locale2 = _ref.locale, generateConfig2 = _ref.generateConfig, picker = _ref.picker, showNow = _ref.showNow, showToday = _ref.showToday, showTime = _ref.showTime, mode = _ref.mode, onPanelChange = _ref.onPanelChange, onCalendarChange = _ref.onCalendarChange, onOk = _ref.onOk, multiple = _ref.multiple, defaultPickerValue = _ref.defaultPickerValue, pickerValue = _ref.pickerValue, onPickerValueChange = _ref.onPickerValueChange, inputReadOnly = _ref.inputReadOnly, suffixIcon = _ref.suffixIcon, removeIcon = _ref.removeIcon, onFocus = _ref.onFocus, onBlur = _ref.onBlur, presets = _ref.presets, components2 = _ref.components, cellRender = _ref.cellRender, dateRender = _ref.dateRender, monthCellRender = _ref.monthCellRender, onClick = _ref.onClick, selectorRef = usePickerRef(ref);
  function pickerParam(values) {
    return values === null ? null : multiple ? values : values[0];
  }
  __name(pickerParam, "pickerParam");
  var toggleDates = useToggleDates(generateConfig2, locale2, internalPicker), _useOpen = useOpen(open, defaultOpen, [disabled], onOpenChange), _useOpen2 = _slicedToArray(_useOpen, 2), mergedOpen = _useOpen2[0], triggerOpen = _useOpen2[1], onInternalCalendarChange = /* @__PURE__ */ __name(function(dates, dateStrings, info) {
    if (onCalendarChange) {
      var filteredInfo = _objectSpread2$1({}, info);
      delete filteredInfo.range, onCalendarChange(pickerParam(dates), pickerParam(dateStrings), filteredInfo);
    }
  }, "onInternalCalendarChange"), onInternalOk = /* @__PURE__ */ __name(function(dates) {
    onOk == null || onOk(pickerParam(dates));
  }, "onInternalOk"), _useInnerValue = useInnerValue(generateConfig2, locale2, formatList, !1, order2, defaultValue, value, onInternalCalendarChange, onInternalOk), _useInnerValue2 = _slicedToArray(_useInnerValue, 5), mergedValue = _useInnerValue2[0], setInnerValue = _useInnerValue2[1], getCalendarValue = _useInnerValue2[2], triggerCalendarChange = _useInnerValue2[3], triggerOk = _useInnerValue2[4], calendarValue = getCalendarValue(), _useRangeActive = useRangeActive([disabled]), _useRangeActive2 = _slicedToArray(_useRangeActive, 4), focused = _useRangeActive2[0], triggerFocus2 = _useRangeActive2[1], lastOperation = _useRangeActive2[2], activeIndex = _useRangeActive2[3], onSharedFocus = /* @__PURE__ */ __name(function(event) {
    triggerFocus2(!0), onFocus == null || onFocus(event, {});
  }, "onSharedFocus"), onSharedBlur = /* @__PURE__ */ __name(function(event) {
    triggerFocus2(!1), onBlur == null || onBlur(event, {});
  }, "onSharedBlur"), _useMergedState = useMergedState(picker, {
    value: mode
  }), _useMergedState2 = _slicedToArray(_useMergedState, 2), mergedMode = _useMergedState2[0], setMode = _useMergedState2[1], internalMode = mergedMode === "date" && showTime ? "datetime" : mergedMode, mergedShowNow = useShowNow(picker, mergedMode, showNow, showToday), onInternalChange = onChange && function(dates, dateStrings) {
    onChange(pickerParam(dates), pickerParam(dateStrings));
  }, _useRangeValue = useRangeValue(
    _objectSpread2$1(_objectSpread2$1({}, filledProps), {}, {
      onChange: onInternalChange
    }),
    mergedValue,
    setInnerValue,
    getCalendarValue,
    triggerCalendarChange,
    [],
    //disabled,
    formatList,
    focused,
    mergedOpen,
    isInvalidateDate
  ), _useRangeValue2 = _slicedToArray(_useRangeValue, 2), triggerSubmitChange = _useRangeValue2[1], _useFieldsInvalidate = useFieldsInvalidate(calendarValue, isInvalidateDate), _useFieldsInvalidate2 = _slicedToArray(_useFieldsInvalidate, 2), submitInvalidates = _useFieldsInvalidate2[0], onSelectorInvalid = _useFieldsInvalidate2[1], submitInvalidate = React.useMemo(function() {
    return submitInvalidates.some(function(invalidated) {
      return invalidated;
    });
  }, [submitInvalidates]), onInternalPickerValueChange = /* @__PURE__ */ __name(function(dates, info) {
    if (onPickerValueChange) {
      var cleanInfo = _objectSpread2$1(_objectSpread2$1({}, info), {}, {
        mode: info.mode[0]
      });
      delete cleanInfo.range, onPickerValueChange(dates[0], cleanInfo);
    }
  }, "onInternalPickerValueChange"), _useRangePickerValue = useRangePickerValue(
    generateConfig2,
    locale2,
    calendarValue,
    [mergedMode],
    mergedOpen,
    activeIndex,
    internalPicker,
    !1,
    // multiplePanel,
    defaultPickerValue,
    pickerValue,
    toArray$3(showTime == null ? void 0 : showTime.defaultOpenValue),
    onInternalPickerValueChange,
    minDate,
    maxDate
  ), _useRangePickerValue2 = _slicedToArray(_useRangePickerValue, 2), currentPickerValue = _useRangePickerValue2[0], setCurrentPickerValue = _useRangePickerValue2[1], triggerModeChange = useEvent(function(nextPickerValue, nextMode, triggerEvent) {
    if (setMode(nextMode), onPanelChange && triggerEvent !== !1) {
      var lastPickerValue = nextPickerValue || calendarValue[calendarValue.length - 1];
      onPanelChange(lastPickerValue, nextMode);
    }
  }), triggerConfirm = /* @__PURE__ */ __name(function() {
    triggerSubmitChange(getCalendarValue()), triggerOpen(!1, {
      force: !0
    });
  }, "triggerConfirm"), onSelectorClick = /* @__PURE__ */ __name(function(event) {
    !disabled && !selectorRef.current.nativeElement.contains(document.activeElement) && selectorRef.current.focus(), triggerOpen(!0), onClick == null || onClick(event);
  }, "onSelectorClick"), onSelectorClear = /* @__PURE__ */ __name(function() {
    triggerSubmitChange(null), triggerOpen(!1, {
      force: !0
    });
  }, "onSelectorClear"), _React$useState = React.useState(null), _React$useState2 = _slicedToArray(_React$useState, 2), hoverSource = _React$useState2[0], setHoverSource = _React$useState2[1], _React$useState3 = React.useState(null), _React$useState4 = _slicedToArray(_React$useState3, 2), internalHoverValue = _React$useState4[0], setInternalHoverValue = _React$useState4[1], hoverValues = React.useMemo(function() {
    var values = [internalHoverValue].concat(_toConsumableArray(calendarValue)).filter(function(date4) {
      return date4;
    });
    return multiple ? values : values.slice(0, 1);
  }, [calendarValue, internalHoverValue, multiple]), selectorValues = React.useMemo(function() {
    return !multiple && internalHoverValue ? [internalHoverValue] : calendarValue.filter(function(date4) {
      return date4;
    });
  }, [calendarValue, internalHoverValue, multiple]);
  React.useEffect(function() {
    mergedOpen || setInternalHoverValue(null);
  }, [mergedOpen]);
  var presetList = usePresets(presets), onPresetHover = /* @__PURE__ */ __name(function(nextValue) {
    setInternalHoverValue(nextValue), setHoverSource("preset");
  }, "onPresetHover"), onPresetSubmit = /* @__PURE__ */ __name(function(nextValue) {
    var nextCalendarValues = multiple ? toggleDates(getCalendarValue(), nextValue) : [nextValue], passed = triggerSubmitChange(nextCalendarValues);
    passed && !multiple && triggerOpen(!1, {
      force: !0
    });
  }, "onPresetSubmit"), onNow = /* @__PURE__ */ __name(function(now2) {
    onPresetSubmit(now2);
  }, "onNow"), onPanelHover = /* @__PURE__ */ __name(function(date4) {
    setInternalHoverValue(date4), setHoverSource("cell");
  }, "onPanelHover"), onPanelFocus = /* @__PURE__ */ __name(function(event) {
    triggerOpen(!0), onSharedFocus(event);
  }, "onPanelFocus"), onPanelSelect = /* @__PURE__ */ __name(function(date4) {
    if (lastOperation("panel"), !(multiple && internalMode !== picker)) {
      var nextValues = multiple ? toggleDates(getCalendarValue(), date4) : [date4];
      triggerCalendarChange(nextValues), !needConfirm && !complexPicker && internalPicker === internalMode && triggerConfirm();
    }
  }, "onPanelSelect"), onPopupClose = /* @__PURE__ */ __name(function() {
    triggerOpen(!1);
  }, "onPopupClose"), onInternalCellRender = useCellRender$1(cellRender, dateRender, monthCellRender), panelProps = React.useMemo(function() {
    var domProps = pickAttrs(filledProps, !1), restProps = omit(filledProps, [].concat(_toConsumableArray(Object.keys(domProps)), ["onChange", "onCalendarChange", "style", "className", "onPanelChange"]));
    return _objectSpread2$1(_objectSpread2$1({}, restProps), {}, {
      multiple: filledProps.multiple
    });
  }, [filledProps]), panel = /* @__PURE__ */ React.createElement(Popup, _extends({}, panelProps, {
    showNow: mergedShowNow,
    showTime,
    disabledDate,
    onFocus: onPanelFocus,
    onBlur: onSharedBlur,
    picker,
    mode: mergedMode,
    internalMode,
    onPanelChange: triggerModeChange,
    format: maskFormat,
    value: calendarValue,
    isInvalid: isInvalidateDate,
    onChange: null,
    onSelect: onPanelSelect,
    pickerValue: currentPickerValue,
    defaultOpenValue: showTime == null ? void 0 : showTime.defaultOpenValue,
    onPickerValueChange: setCurrentPickerValue,
    hoverValue: hoverValues,
    onHover: onPanelHover,
    needConfirm,
    onSubmit: triggerConfirm,
    onOk: triggerOk,
    presets: presetList,
    onPresetHover,
    onPresetSubmit,
    onNow,
    cellRender: onInternalCellRender
  })), onSelectorChange = /* @__PURE__ */ __name(function(date4) {
    triggerCalendarChange(date4);
  }, "onSelectorChange"), onSelectorInputChange = /* @__PURE__ */ __name(function() {
    lastOperation("input");
  }, "onSelectorInputChange"), onSelectorFocus = /* @__PURE__ */ __name(function(event) {
    lastOperation("input"), triggerOpen(!0, {
      inherit: !0
    }), onSharedFocus(event);
  }, "onSelectorFocus"), onSelectorBlur = /* @__PURE__ */ __name(function(event) {
    triggerOpen(!1), onSharedBlur(event);
  }, "onSelectorBlur"), onSelectorKeyDown = /* @__PURE__ */ __name(function(event, preventDefault) {
    event.key === "Tab" && triggerConfirm(), onKeyDown2 == null || onKeyDown2(event, preventDefault);
  }, "onSelectorKeyDown"), context = React.useMemo(function() {
    return {
      prefixCls,
      locale: locale2,
      generateConfig: generateConfig2,
      button: components2.button,
      input: components2.input
    };
  }, [prefixCls, locale2, generateConfig2, components2.button, components2.input]);
  return useLayoutEffect$1(function() {
    mergedOpen && activeIndex !== void 0 && triggerModeChange(null, picker, !1);
  }, [mergedOpen, activeIndex, picker]), useLayoutEffect$1(function() {
    var lastOp = lastOperation();
    !mergedOpen && lastOp === "input" && (triggerOpen(!1), triggerConfirm()), !mergedOpen && complexPicker && !needConfirm && lastOp === "panel" && (triggerOpen(!0), triggerConfirm());
  }, [mergedOpen]), /* @__PURE__ */ React.createElement(PickerContext.Provider, {
    value: context
  }, /* @__PURE__ */ React.createElement(PickerTrigger, _extends({}, pickTriggerProps(filledProps), {
    popupElement: panel,
    popupStyle: styles2.popup,
    popupClassName: classNames.popup,
    visible: mergedOpen,
    onClose: onPopupClose
  }), /* @__PURE__ */ React.createElement(
    RefSingleSelector,
    _extends({}, filledProps, {
      // Ref
      ref: selectorRef,
      suffixIcon,
      removeIcon,
      activeHelp: !!internalHoverValue,
      allHelp: !!internalHoverValue && hoverSource === "preset",
      focused,
      onFocus: onSelectorFocus,
      onBlur: onSelectorBlur,
      onKeyDown: onSelectorKeyDown,
      onSubmit: triggerConfirm,
      value: selectorValues,
      maskFormat,
      onChange: onSelectorChange,
      onInputChange: onSelectorInputChange,
      internalPicker,
      format: formatList,
      inputReadOnly,
      disabled,
      open: mergedOpen,
      onOpenChange: triggerOpen,
      onClick: onSelectorClick,
      onClear: onSelectorClear,
      invalid: submitInvalidate,
      onInvalid: /* @__PURE__ */ __name(function(invalid) {
        onSelectorInvalid(invalid, 0);
      }, "onInvalid")
    })
  )));
}
__name(Picker2, "Picker");
var RefPicker = /* @__PURE__ */ React.forwardRef(Picker2);
process.env.NODE_ENV !== "production" && (RefPicker.displayName = "RefPicker");
const RadioGroupContext = /* @__PURE__ */ React.createContext(null), RadioGroupContextProvider = RadioGroupContext.Provider, RadioOptionTypeContext = /* @__PURE__ */ React.createContext(null), RadioOptionTypeContextProvider = RadioOptionTypeContext.Provider;
var _excluded$l = ["prefixCls", "className", "style", "checked", "disabled", "defaultChecked", "type", "title", "onChange"], Checkbox$3 = /* @__PURE__ */ forwardRef(function(props, ref) {
  var _props$prefixCls = props.prefixCls, prefixCls = _props$prefixCls === void 0 ? "rc-checkbox" : _props$prefixCls, className = props.className, style2 = props.style, checked = props.checked, disabled = props.disabled, _props$defaultChecked = props.defaultChecked, defaultChecked = _props$defaultChecked === void 0 ? !1 : _props$defaultChecked, _props$type = props.type, type4 = _props$type === void 0 ? "checkbox" : _props$type, title2 = props.title, onChange = props.onChange, inputProps = _objectWithoutProperties(props, _excluded$l), inputRef = useRef(null), holderRef = useRef(null), _useMergedState = useMergedState(defaultChecked, {
    value: checked
  }), _useMergedState2 = _slicedToArray(_useMergedState, 2), rawValue = _useMergedState2[0], setRawValue = _useMergedState2[1];
  useImperativeHandle(ref, function() {
    return {
      focus: /* @__PURE__ */ __name(function(options) {
        var _inputRef$current;
        (_inputRef$current = inputRef.current) === null || _inputRef$current === void 0 || _inputRef$current.focus(options);
      }, "focus"),
      blur: /* @__PURE__ */ __name(function() {
        var _inputRef$current2;
        (_inputRef$current2 = inputRef.current) === null || _inputRef$current2 === void 0 || _inputRef$current2.blur();
      }, "blur"),
      input: inputRef.current,
      nativeElement: holderRef.current
    };
  });
  var classString = cn(prefixCls, className, _defineProperty$2(_defineProperty$2({}, "".concat(prefixCls, "-checked"), rawValue), "".concat(prefixCls, "-disabled"), disabled)), handleChange = /* @__PURE__ */ __name(function(e2) {
    disabled || ("checked" in props || setRawValue(e2.target.checked), onChange == null || onChange({
      target: _objectSpread2$1(_objectSpread2$1({}, props), {}, {
        type: type4,
        checked: e2.target.checked
      }),
      stopPropagation: /* @__PURE__ */ __name(function() {
        e2.stopPropagation();
      }, "stopPropagation"),
      preventDefault: /* @__PURE__ */ __name(function() {
        e2.preventDefault();
      }, "preventDefault"),
      nativeEvent: e2.nativeEvent
    }));
  }, "handleChange");
  return /* @__PURE__ */ React.createElement("span", {
    className: classString,
    title: title2,
    style: style2,
    ref: holderRef
  }, /* @__PURE__ */ React.createElement("input", _extends({}, inputProps, {
    className: "".concat(prefixCls, "-input"),
    ref: inputRef,
    onChange: handleChange,
    disabled,
    checked: !!rawValue,
    type: type4
  })), /* @__PURE__ */ React.createElement("span", {
    className: "".concat(prefixCls, "-inner")
  }));
});
function useBubbleLock(onOriginInputClick) {
  const labelClickLockRef = React__default.useRef(null), clearLock = /* @__PURE__ */ __name(() => {
    wrapperRaf.cancel(labelClickLockRef.current), labelClickLockRef.current = null;
  }, "clearLock");
  return [/* @__PURE__ */ __name(() => {
    clearLock(), labelClickLockRef.current = wrapperRaf(() => {
      labelClickLockRef.current = null;
    });
  }, "onLabelClick"), /* @__PURE__ */ __name((e2) => {
    labelClickLockRef.current && (e2.stopPropagation(), clearLock()), onOriginInputClick == null || onOriginInputClick(e2);
  }, "onInputClick")];
}
__name(useBubbleLock, "useBubbleLock");
const getGroupRadioStyle = /* @__PURE__ */ __name((token2) => {
  const {
    componentCls,
    antCls
  } = token2, groupPrefixCls = `${componentCls}-group`;
  return {
    [groupPrefixCls]: Object.assign(Object.assign({}, resetComponent(token2)), {
      display: "inline-block",
      fontSize: 0,
      // RTL
      [`&${groupPrefixCls}-rtl`]: {
        direction: "rtl"
      },
      [`&${groupPrefixCls}-block`]: {
        display: "flex"
      },
      [`${antCls}-badge ${antCls}-badge-count`]: {
        zIndex: 1
      },
      [`> ${antCls}-badge:not(:first-child) > ${antCls}-button-wrapper`]: {
        borderInlineStart: "none"
      }
    })
  };
}, "getGroupRadioStyle"), getRadioBasicStyle = /* @__PURE__ */ __name((token2) => {
  const {
    componentCls,
    wrapperMarginInlineEnd,
    colorPrimary,
    radioSize,
    motionDurationSlow,
    motionDurationMid,
    motionEaseInOutCirc,
    colorBgContainer,
    colorBorder,
    lineWidth,
    colorBgContainerDisabled,
    colorTextDisabled,
    paddingXS,
    dotColorDisabled,
    lineType,
    radioColor,
    radioBgColor,
    calc
  } = token2, radioInnerPrefixCls = `${componentCls}-inner`, radioDotDisabledSize = calc(radioSize).sub(calc(4).mul(2)), radioSizeCalc = calc(1).mul(radioSize).equal({
    unit: !0
  });
  return {
    [`${componentCls}-wrapper`]: Object.assign(Object.assign({}, resetComponent(token2)), {
      display: "inline-flex",
      alignItems: "baseline",
      marginInlineStart: 0,
      marginInlineEnd: wrapperMarginInlineEnd,
      cursor: "pointer",
      // RTL
      [`&${componentCls}-wrapper-rtl`]: {
        direction: "rtl"
      },
      "&-disabled": {
        cursor: "not-allowed",
        color: token2.colorTextDisabled
      },
      "&::after": {
        display: "inline-block",
        width: 0,
        overflow: "hidden",
        content: '"\\a0"'
      },
      "&-block": {
        flex: 1,
        justifyContent: "center"
      },
      // hashId 在 wrapper 上，只能铺平
      [`${componentCls}-checked::after`]: {
        position: "absolute",
        insetBlockStart: 0,
        insetInlineStart: 0,
        width: "100%",
        height: "100%",
        border: `${unit$1(lineWidth)} ${lineType} ${colorPrimary}`,
        borderRadius: "50%",
        visibility: "hidden",
        opacity: 0,
        content: '""'
      },
      [componentCls]: Object.assign(Object.assign({}, resetComponent(token2)), {
        position: "relative",
        display: "inline-block",
        outline: "none",
        cursor: "pointer",
        alignSelf: "center",
        borderRadius: "50%"
      }),
      [`${componentCls}-wrapper:hover &,
        &:hover ${radioInnerPrefixCls}`]: {
        borderColor: colorPrimary
      },
      [`${componentCls}-input:focus-visible + ${radioInnerPrefixCls}`]: Object.assign({}, genFocusOutline(token2)),
      [`${componentCls}:hover::after, ${componentCls}-wrapper:hover &::after`]: {
        visibility: "visible"
      },
      [`${componentCls}-inner`]: {
        "&::after": {
          boxSizing: "border-box",
          position: "absolute",
          insetBlockStart: "50%",
          insetInlineStart: "50%",
          display: "block",
          width: radioSizeCalc,
          height: radioSizeCalc,
          marginBlockStart: calc(1).mul(radioSize).div(-2).equal({
            unit: !0
          }),
          marginInlineStart: calc(1).mul(radioSize).div(-2).equal({
            unit: !0
          }),
          backgroundColor: radioColor,
          borderBlockStart: 0,
          borderInlineStart: 0,
          borderRadius: radioSizeCalc,
          transform: "scale(0)",
          opacity: 0,
          transition: `all ${motionDurationSlow} ${motionEaseInOutCirc}`,
          content: '""'
        },
        boxSizing: "border-box",
        position: "relative",
        insetBlockStart: 0,
        insetInlineStart: 0,
        display: "block",
        width: radioSizeCalc,
        height: radioSizeCalc,
        backgroundColor: colorBgContainer,
        borderColor: colorBorder,
        borderStyle: "solid",
        borderWidth: lineWidth,
        borderRadius: "50%",
        transition: `all ${motionDurationMid}`
      },
      [`${componentCls}-input`]: {
        position: "absolute",
        inset: 0,
        zIndex: 1,
        cursor: "pointer",
        opacity: 0
      },
      // 选中状态
      [`${componentCls}-checked`]: {
        [radioInnerPrefixCls]: {
          borderColor: colorPrimary,
          backgroundColor: radioBgColor,
          "&::after": {
            transform: `scale(${token2.calc(token2.dotSize).div(radioSize).equal()})`,
            opacity: 1,
            transition: `all ${motionDurationSlow} ${motionEaseInOutCirc}`
          }
        }
      },
      [`${componentCls}-disabled`]: {
        cursor: "not-allowed",
        [radioInnerPrefixCls]: {
          backgroundColor: colorBgContainerDisabled,
          borderColor: colorBorder,
          cursor: "not-allowed",
          "&::after": {
            backgroundColor: dotColorDisabled
          }
        },
        [`${componentCls}-input`]: {
          cursor: "not-allowed"
        },
        [`${componentCls}-disabled + span`]: {
          color: colorTextDisabled,
          cursor: "not-allowed"
        },
        [`&${componentCls}-checked`]: {
          [radioInnerPrefixCls]: {
            "&::after": {
              transform: `scale(${calc(radioDotDisabledSize).div(radioSize).equal()})`
            }
          }
        }
      },
      [`span${componentCls} + *`]: {
        paddingInlineStart: paddingXS,
        paddingInlineEnd: paddingXS
      }
    })
  };
}, "getRadioBasicStyle"), getRadioButtonStyle = /* @__PURE__ */ __name((token2) => {
  const {
    buttonColor,
    controlHeight,
    componentCls,
    lineWidth,
    lineType,
    colorBorder,
    motionDurationSlow,
    motionDurationMid,
    buttonPaddingInline,
    fontSize,
    buttonBg,
    fontSizeLG,
    controlHeightLG,
    controlHeightSM,
    paddingXS,
    borderRadius,
    borderRadiusSM,
    borderRadiusLG,
    buttonCheckedBg,
    buttonSolidCheckedColor,
    colorTextDisabled,
    colorBgContainerDisabled,
    buttonCheckedBgDisabled,
    buttonCheckedColorDisabled,
    colorPrimary,
    colorPrimaryHover,
    colorPrimaryActive,
    buttonSolidCheckedBg,
    buttonSolidCheckedHoverBg,
    buttonSolidCheckedActiveBg,
    calc
  } = token2;
  return {
    [`${componentCls}-button-wrapper`]: {
      position: "relative",
      display: "inline-block",
      height: controlHeight,
      margin: 0,
      paddingInline: buttonPaddingInline,
      paddingBlock: 0,
      color: buttonColor,
      fontSize,
      lineHeight: unit$1(calc(controlHeight).sub(calc(lineWidth).mul(2)).equal()),
      background: buttonBg,
      border: `${unit$1(lineWidth)} ${lineType} ${colorBorder}`,
      // strange align fix for chrome but works
      // https://gw.alipayobjects.com/zos/rmsportal/VFTfKXJuogBAXcvfAUWJ.gif
      borderBlockStartWidth: calc(lineWidth).add(0.02).equal(),
      borderInlineStartWidth: 0,
      borderInlineEndWidth: lineWidth,
      cursor: "pointer",
      transition: [`color ${motionDurationMid}`, `background ${motionDurationMid}`, `box-shadow ${motionDurationMid}`].join(","),
      a: {
        color: buttonColor
      },
      [`> ${componentCls}-button`]: {
        position: "absolute",
        insetBlockStart: 0,
        insetInlineStart: 0,
        zIndex: -1,
        width: "100%",
        height: "100%"
      },
      "&:not(:first-child)": {
        "&::before": {
          position: "absolute",
          insetBlockStart: calc(lineWidth).mul(-1).equal(),
          insetInlineStart: calc(lineWidth).mul(-1).equal(),
          display: "block",
          boxSizing: "content-box",
          width: 1,
          height: "100%",
          paddingBlock: lineWidth,
          paddingInline: 0,
          backgroundColor: colorBorder,
          transition: `background-color ${motionDurationSlow}`,
          content: '""'
        }
      },
      "&:first-child": {
        borderInlineStart: `${unit$1(lineWidth)} ${lineType} ${colorBorder}`,
        borderStartStartRadius: borderRadius,
        borderEndStartRadius: borderRadius
      },
      "&:last-child": {
        borderStartEndRadius: borderRadius,
        borderEndEndRadius: borderRadius
      },
      "&:first-child:last-child": {
        borderRadius
      },
      [`${componentCls}-group-large &`]: {
        height: controlHeightLG,
        fontSize: fontSizeLG,
        lineHeight: unit$1(calc(controlHeightLG).sub(calc(lineWidth).mul(2)).equal()),
        "&:first-child": {
          borderStartStartRadius: borderRadiusLG,
          borderEndStartRadius: borderRadiusLG
        },
        "&:last-child": {
          borderStartEndRadius: borderRadiusLG,
          borderEndEndRadius: borderRadiusLG
        }
      },
      [`${componentCls}-group-small &`]: {
        height: controlHeightSM,
        paddingInline: calc(paddingXS).sub(lineWidth).equal(),
        paddingBlock: 0,
        lineHeight: unit$1(calc(controlHeightSM).sub(calc(lineWidth).mul(2)).equal()),
        "&:first-child": {
          borderStartStartRadius: borderRadiusSM,
          borderEndStartRadius: borderRadiusSM
        },
        "&:last-child": {
          borderStartEndRadius: borderRadiusSM,
          borderEndEndRadius: borderRadiusSM
        }
      },
      "&:hover": {
        position: "relative",
        color: colorPrimary
      },
      "&:has(:focus-visible)": Object.assign({}, genFocusOutline(token2)),
      [`${componentCls}-inner, input[type='checkbox'], input[type='radio']`]: {
        width: 0,
        height: 0,
        opacity: 0,
        pointerEvents: "none"
      },
      [`&-checked:not(${componentCls}-button-wrapper-disabled)`]: {
        zIndex: 1,
        color: colorPrimary,
        background: buttonCheckedBg,
        borderColor: colorPrimary,
        "&::before": {
          backgroundColor: colorPrimary
        },
        "&:first-child": {
          borderColor: colorPrimary
        },
        "&:hover": {
          color: colorPrimaryHover,
          borderColor: colorPrimaryHover,
          "&::before": {
            backgroundColor: colorPrimaryHover
          }
        },
        "&:active": {
          color: colorPrimaryActive,
          borderColor: colorPrimaryActive,
          "&::before": {
            backgroundColor: colorPrimaryActive
          }
        }
      },
      [`${componentCls}-group-solid &-checked:not(${componentCls}-button-wrapper-disabled)`]: {
        color: buttonSolidCheckedColor,
        background: buttonSolidCheckedBg,
        borderColor: buttonSolidCheckedBg,
        "&:hover": {
          color: buttonSolidCheckedColor,
          background: buttonSolidCheckedHoverBg,
          borderColor: buttonSolidCheckedHoverBg
        },
        "&:active": {
          color: buttonSolidCheckedColor,
          background: buttonSolidCheckedActiveBg,
          borderColor: buttonSolidCheckedActiveBg
        }
      },
      "&-disabled": {
        color: colorTextDisabled,
        backgroundColor: colorBgContainerDisabled,
        borderColor: colorBorder,
        cursor: "not-allowed",
        "&:first-child, &:hover": {
          color: colorTextDisabled,
          backgroundColor: colorBgContainerDisabled,
          borderColor: colorBorder
        }
      },
      [`&-disabled${componentCls}-button-wrapper-checked`]: {
        color: buttonCheckedColorDisabled,
        backgroundColor: buttonCheckedBgDisabled,
        borderColor: colorBorder,
        boxShadow: "none"
      },
      "&-block": {
        flex: 1,
        textAlign: "center"
      }
    }
  };
}, "getRadioButtonStyle"), prepareComponentToken$e = /* @__PURE__ */ __name((token2) => {
  const {
    wireframe,
    padding,
    marginXS,
    lineWidth,
    fontSizeLG,
    colorText,
    colorBgContainer,
    colorTextDisabled,
    controlItemBgActiveDisabled,
    colorTextLightSolid,
    colorPrimary,
    colorPrimaryHover,
    colorPrimaryActive,
    colorWhite
  } = token2, dotPadding = 4, radioSize = fontSizeLG, radioDotSize = wireframe ? radioSize - dotPadding * 2 : radioSize - (dotPadding + lineWidth) * 2;
  return {
    // Radio
    radioSize,
    dotSize: radioDotSize,
    dotColorDisabled: colorTextDisabled,
    // Radio buttons
    buttonSolidCheckedColor: colorTextLightSolid,
    buttonSolidCheckedBg: colorPrimary,
    buttonSolidCheckedHoverBg: colorPrimaryHover,
    buttonSolidCheckedActiveBg: colorPrimaryActive,
    buttonBg: colorBgContainer,
    buttonCheckedBg: colorBgContainer,
    buttonColor: colorText,
    buttonCheckedBgDisabled: controlItemBgActiveDisabled,
    buttonCheckedColorDisabled: colorTextDisabled,
    buttonPaddingInline: padding - lineWidth,
    wrapperMarginInlineEnd: marginXS,
    // internal
    radioColor: wireframe ? colorPrimary : colorWhite,
    radioBgColor: wireframe ? colorBgContainer : colorPrimary
  };
}, "prepareComponentToken$e"), useStyle$h = genStyleHooks("Radio", (token2) => {
  const {
    controlOutline,
    controlOutlineWidth
  } = token2, radioFocusShadow = `0 0 0 ${unit$1(controlOutlineWidth)} ${controlOutline}`, radioToken = merge(token2, {
    radioFocusShadow,
    radioButtonFocusShadow: radioFocusShadow
  });
  return [getGroupRadioStyle(radioToken), getRadioBasicStyle(radioToken), getRadioButtonStyle(radioToken)];
}, prepareComponentToken$e, {
  unitless: {
    radioSize: !0,
    dotSize: !0
  }
});
var __rest$F = function(s, e2) {
  var t2 = {};
  for (var p in s) Object.prototype.hasOwnProperty.call(s, p) && e2.indexOf(p) < 0 && (t2[p] = s[p]);
  if (s != null && typeof Object.getOwnPropertySymbols == "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++)
    e2.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]) && (t2[p[i]] = s[p[i]]);
  return t2;
};
const InternalRadio = /* @__PURE__ */ __name((props, ref) => {
  var _a, _b;
  const groupContext = React.useContext(RadioGroupContext), radioOptionTypeContext = React.useContext(RadioOptionTypeContext), {
    getPrefixCls,
    direction,
    radio
  } = React.useContext(ConfigContext), innerRef = React.useRef(null), mergedRef = composeRef(ref, innerRef), {
    isFormItemInput
  } = React.useContext(FormItemInputContext);
  if (process.env.NODE_ENV !== "production") {
    const warning3 = devUseWarning("Radio");
    process.env.NODE_ENV !== "production" && warning3(!("optionType" in props), "usage", "`optionType` is only support in Radio.Group.");
  }
  const onChange = /* @__PURE__ */ __name((e2) => {
    var _a2, _b2;
    (_a2 = props.onChange) === null || _a2 === void 0 || _a2.call(props, e2), (_b2 = groupContext == null ? void 0 : groupContext.onChange) === null || _b2 === void 0 || _b2.call(groupContext, e2);
  }, "onChange"), {
    prefixCls: customizePrefixCls,
    className,
    rootClassName,
    children,
    style: style2,
    title: title2
  } = props, restProps = __rest$F(props, ["prefixCls", "className", "rootClassName", "children", "style", "title"]), radioPrefixCls = getPrefixCls("radio", customizePrefixCls), isButtonType = ((groupContext == null ? void 0 : groupContext.optionType) || radioOptionTypeContext) === "button", prefixCls = isButtonType ? `${radioPrefixCls}-button` : radioPrefixCls, rootCls = useCSSVarCls(radioPrefixCls), [wrapCSSVar, hashId, cssVarCls] = useStyle$h(radioPrefixCls, rootCls), radioProps = Object.assign({}, restProps), disabled = React.useContext(DisabledContext);
  groupContext && (radioProps.name = groupContext.name, radioProps.onChange = onChange, radioProps.checked = props.value === groupContext.value, radioProps.disabled = (_a = radioProps.disabled) !== null && _a !== void 0 ? _a : groupContext.disabled), radioProps.disabled = (_b = radioProps.disabled) !== null && _b !== void 0 ? _b : disabled;
  const wrapperClassString = cn(`${prefixCls}-wrapper`, {
    [`${prefixCls}-wrapper-checked`]: radioProps.checked,
    [`${prefixCls}-wrapper-disabled`]: radioProps.disabled,
    [`${prefixCls}-wrapper-rtl`]: direction === "rtl",
    [`${prefixCls}-wrapper-in-form-item`]: isFormItemInput,
    [`${prefixCls}-wrapper-block`]: !!(groupContext != null && groupContext.block)
  }, radio == null ? void 0 : radio.className, className, rootClassName, hashId, cssVarCls, rootCls), [onLabelClick, onInputClick] = useBubbleLock(radioProps.onClick);
  return wrapCSSVar(/* @__PURE__ */ React.createElement(Wave, {
    component: "Radio",
    disabled: radioProps.disabled
  }, /* @__PURE__ */ React.createElement("label", {
    className: wrapperClassString,
    style: Object.assign(Object.assign({}, radio == null ? void 0 : radio.style), style2),
    onMouseEnter: props.onMouseEnter,
    onMouseLeave: props.onMouseLeave,
    title: title2,
    onClick: onLabelClick
  }, /* @__PURE__ */ React.createElement(Checkbox$3, Object.assign({}, radioProps, {
    className: cn(radioProps.className, {
      [TARGET_CLS]: !isButtonType
    }),
    type: "radio",
    prefixCls,
    ref: mergedRef,
    onClick: onInputClick
  })), children !== void 0 ? /* @__PURE__ */ React.createElement("span", null, children) : null)));
}, "InternalRadio"), Radio$1 = /* @__PURE__ */ React.forwardRef(InternalRadio);
process.env.NODE_ENV !== "production" && (Radio$1.displayName = "Radio");
const RadioGroup = /* @__PURE__ */ React.forwardRef((props, ref) => {
  const {
    getPrefixCls,
    direction
  } = React.useContext(ConfigContext), {
    prefixCls: customizePrefixCls,
    className,
    rootClassName,
    options,
    buttonStyle = "outline",
    disabled,
    children,
    size: customizeSize,
    style: style2,
    id: id2,
    optionType,
    name,
    defaultValue,
    value: customizedValue,
    block = !1,
    onChange,
    onMouseEnter,
    onMouseLeave,
    onFocus,
    onBlur
  } = props, [value, setValue] = useMergedState(defaultValue, {
    value: customizedValue
  }), onRadioChange = React.useCallback((event) => {
    const lastValue = value, val = event.target.value;
    "value" in props || setValue(val), val !== lastValue && (onChange == null || onChange(event));
  }, [value, setValue, onChange]), prefixCls = getPrefixCls("radio", customizePrefixCls), groupPrefixCls = `${prefixCls}-group`, rootCls = useCSSVarCls(prefixCls), [wrapCSSVar, hashId, cssVarCls] = useStyle$h(prefixCls, rootCls);
  let childrenToRender = children;
  options && options.length > 0 && (childrenToRender = options.map((option) => typeof option == "string" || typeof option == "number" ? /* @__PURE__ */ React.createElement(Radio$1, {
    key: option.toString(),
    prefixCls,
    disabled,
    value: option,
    checked: value === option
  }, option) : /* @__PURE__ */ React.createElement(Radio$1, {
    key: `radio-group-value-options-${option.value}`,
    prefixCls,
    disabled: option.disabled || disabled,
    value: option.value,
    checked: value === option.value,
    title: option.title,
    style: option.style,
    id: option.id,
    required: option.required
  }, option.label)));
  const mergedSize = useSize(customizeSize), classString = cn(groupPrefixCls, `${groupPrefixCls}-${buttonStyle}`, {
    [`${groupPrefixCls}-${mergedSize}`]: mergedSize,
    [`${groupPrefixCls}-rtl`]: direction === "rtl",
    [`${groupPrefixCls}-block`]: block
  }, className, rootClassName, hashId, cssVarCls, rootCls), memoizedValue = React.useMemo(() => ({
    onChange: onRadioChange,
    value,
    disabled,
    name,
    optionType,
    block
  }), [onRadioChange, value, disabled, name, optionType, block]);
  return wrapCSSVar(/* @__PURE__ */ React.createElement("div", Object.assign({}, pickAttrs(props, {
    aria: !0,
    data: !0
  }), {
    className: classString,
    style: style2,
    onMouseEnter,
    onMouseLeave,
    onFocus,
    onBlur,
    id: id2,
    ref
  }), /* @__PURE__ */ React.createElement(RadioGroupContextProvider, {
    value: memoizedValue
  }, childrenToRender)));
}), Group$1 = /* @__PURE__ */ React.memo(RadioGroup);
var __rest$E = function(s, e2) {
  var t2 = {};
  for (var p in s) Object.prototype.hasOwnProperty.call(s, p) && e2.indexOf(p) < 0 && (t2[p] = s[p]);
  if (s != null && typeof Object.getOwnPropertySymbols == "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++)
    e2.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]) && (t2[p[i]] = s[p[i]]);
  return t2;
};
const RadioButton = /* @__PURE__ */ __name((props, ref) => {
  const {
    getPrefixCls
  } = React.useContext(ConfigContext), {
    prefixCls: customizePrefixCls
  } = props, radioProps = __rest$E(props, ["prefixCls"]), prefixCls = getPrefixCls("radio", customizePrefixCls);
  return /* @__PURE__ */ React.createElement(RadioOptionTypeContextProvider, {
    value: "button"
  }, /* @__PURE__ */ React.createElement(Radio$1, Object.assign({
    prefixCls
  }, radioProps, {
    type: "radio",
    ref
  })));
}, "RadioButton"), Button$1 = /* @__PURE__ */ React.forwardRef(RadioButton), Radio = Radio$1;
Radio.Button = Button$1;
Radio.Group = Group$1;
Radio.__ANT_RADIO = !0;
function initInputToken(token2) {
  return merge(token2, {
    inputAffixPadding: token2.paddingXXS
  });
}
__name(initInputToken, "initInputToken");
const initComponentToken$1 = /* @__PURE__ */ __name((token2) => {
  const {
    controlHeight,
    fontSize,
    lineHeight,
    lineWidth,
    controlHeightSM,
    controlHeightLG,
    fontSizeLG,
    lineHeightLG,
    paddingSM,
    controlPaddingHorizontalSM,
    controlPaddingHorizontal,
    colorFillAlter,
    colorPrimaryHover,
    colorPrimary,
    controlOutlineWidth,
    controlOutline,
    colorErrorOutline,
    colorWarningOutline,
    colorBgContainer
  } = token2;
  return {
    paddingBlock: Math.max(Math.round((controlHeight - fontSize * lineHeight) / 2 * 10) / 10 - lineWidth, 0),
    paddingBlockSM: Math.max(Math.round((controlHeightSM - fontSize * lineHeight) / 2 * 10) / 10 - lineWidth, 0),
    paddingBlockLG: Math.ceil((controlHeightLG - fontSizeLG * lineHeightLG) / 2 * 10) / 10 - lineWidth,
    paddingInline: paddingSM - lineWidth,
    paddingInlineSM: controlPaddingHorizontalSM - lineWidth,
    paddingInlineLG: controlPaddingHorizontal - lineWidth,
    addonBg: colorFillAlter,
    activeBorderColor: colorPrimary,
    hoverBorderColor: colorPrimaryHover,
    activeShadow: `0 0 0 ${controlOutlineWidth}px ${controlOutline}`,
    errorActiveShadow: `0 0 0 ${controlOutlineWidth}px ${colorErrorOutline}`,
    warningActiveShadow: `0 0 0 ${controlOutlineWidth}px ${colorWarningOutline}`,
    hoverBg: colorBgContainer,
    activeBg: colorBgContainer,
    inputFontSize: fontSize,
    inputFontSizeLG: fontSizeLG,
    inputFontSizeSM: fontSize
  };
}, "initComponentToken$1"), genHoverStyle = /* @__PURE__ */ __name((token2) => ({
  borderColor: token2.hoverBorderColor,
  backgroundColor: token2.hoverBg
}), "genHoverStyle"), genDisabledStyle = /* @__PURE__ */ __name((token2) => ({
  color: token2.colorTextDisabled,
  backgroundColor: token2.colorBgContainerDisabled,
  borderColor: token2.colorBorder,
  boxShadow: "none",
  cursor: "not-allowed",
  opacity: 1,
  "input[disabled], textarea[disabled]": {
    cursor: "not-allowed"
  },
  "&:hover:not([disabled])": Object.assign({}, genHoverStyle(merge(token2, {
    hoverBorderColor: token2.colorBorder,
    hoverBg: token2.colorBgContainerDisabled
  })))
}), "genDisabledStyle"), genBaseOutlinedStyle = /* @__PURE__ */ __name((token2, options) => ({
  background: token2.colorBgContainer,
  borderWidth: token2.lineWidth,
  borderStyle: token2.lineType,
  borderColor: options.borderColor,
  "&:hover": {
    borderColor: options.hoverBorderColor,
    backgroundColor: token2.hoverBg
  },
  "&:focus, &:focus-within": {
    borderColor: options.activeBorderColor,
    boxShadow: options.activeShadow,
    outline: 0,
    backgroundColor: token2.activeBg
  }
}), "genBaseOutlinedStyle"), genOutlinedStatusStyle = /* @__PURE__ */ __name((token2, options) => ({
  [`&${token2.componentCls}-status-${options.status}:not(${token2.componentCls}-disabled)`]: Object.assign(Object.assign({}, genBaseOutlinedStyle(token2, options)), {
    [`${token2.componentCls}-prefix, ${token2.componentCls}-suffix`]: {
      color: options.affixColor
    }
  }),
  [`&${token2.componentCls}-status-${options.status}${token2.componentCls}-disabled`]: {
    borderColor: options.borderColor
  }
}), "genOutlinedStatusStyle"), genOutlinedStyle = /* @__PURE__ */ __name((token2, extraStyles) => ({
  "&-outlined": Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, genBaseOutlinedStyle(token2, {
    borderColor: token2.colorBorder,
    hoverBorderColor: token2.hoverBorderColor,
    activeBorderColor: token2.activeBorderColor,
    activeShadow: token2.activeShadow
  })), {
    [`&${token2.componentCls}-disabled, &[disabled]`]: Object.assign({}, genDisabledStyle(token2))
  }), genOutlinedStatusStyle(token2, {
    status: "error",
    borderColor: token2.colorError,
    hoverBorderColor: token2.colorErrorBorderHover,
    activeBorderColor: token2.colorError,
    activeShadow: token2.errorActiveShadow,
    affixColor: token2.colorError
  })), genOutlinedStatusStyle(token2, {
    status: "warning",
    borderColor: token2.colorWarning,
    hoverBorderColor: token2.colorWarningBorderHover,
    activeBorderColor: token2.colorWarning,
    activeShadow: token2.warningActiveShadow,
    affixColor: token2.colorWarning
  })), extraStyles)
}), "genOutlinedStyle"), genOutlinedGroupStatusStyle = /* @__PURE__ */ __name((token2, options) => ({
  [`&${token2.componentCls}-group-wrapper-status-${options.status}`]: {
    [`${token2.componentCls}-group-addon`]: {
      borderColor: options.addonBorderColor,
      color: options.addonColor
    }
  }
}), "genOutlinedGroupStatusStyle"), genOutlinedGroupStyle = /* @__PURE__ */ __name((token2) => ({
  "&-outlined": Object.assign(Object.assign(Object.assign({
    [`${token2.componentCls}-group`]: {
      "&-addon": {
        background: token2.addonBg,
        border: `${unit$1(token2.lineWidth)} ${token2.lineType} ${token2.colorBorder}`
      },
      "&-addon:first-child": {
        borderInlineEnd: 0
      },
      "&-addon:last-child": {
        borderInlineStart: 0
      }
    }
  }, genOutlinedGroupStatusStyle(token2, {
    status: "error",
    addonBorderColor: token2.colorError,
    addonColor: token2.colorErrorText
  })), genOutlinedGroupStatusStyle(token2, {
    status: "warning",
    addonBorderColor: token2.colorWarning,
    addonColor: token2.colorWarningText
  })), {
    [`&${token2.componentCls}-group-wrapper-disabled`]: {
      [`${token2.componentCls}-group-addon`]: Object.assign({}, genDisabledStyle(token2))
    }
  })
}), "genOutlinedGroupStyle"), genBorderlessStyle = /* @__PURE__ */ __name((token2, extraStyles) => {
  const {
    componentCls
  } = token2;
  return {
    "&-borderless": Object.assign({
      background: "transparent",
      border: "none",
      "&:focus, &:focus-within": {
        outline: "none"
      },
      // >>>>> Disabled
      [`&${componentCls}-disabled, &[disabled]`]: {
        color: token2.colorTextDisabled,
        cursor: "not-allowed"
      },
      // >>>>> Status
      [`&${componentCls}-status-error`]: {
        "&, & input, & textarea": {
          color: token2.colorError
        }
      },
      [`&${componentCls}-status-warning`]: {
        "&, & input, & textarea": {
          color: token2.colorWarning
        }
      }
    }, extraStyles)
  };
}, "genBorderlessStyle"), genBaseFilledStyle = /* @__PURE__ */ __name((token2, options) => ({
  background: options.bg,
  borderWidth: token2.lineWidth,
  borderStyle: token2.lineType,
  borderColor: "transparent",
  "input&, & input, textarea&, & textarea": {
    color: options == null ? void 0 : options.inputColor
  },
  "&:hover": {
    background: options.hoverBg
  },
  "&:focus, &:focus-within": {
    outline: 0,
    borderColor: options.activeBorderColor,
    backgroundColor: token2.activeBg
  }
}), "genBaseFilledStyle"), genFilledStatusStyle = /* @__PURE__ */ __name((token2, options) => ({
  [`&${token2.componentCls}-status-${options.status}:not(${token2.componentCls}-disabled)`]: Object.assign(Object.assign({}, genBaseFilledStyle(token2, options)), {
    [`${token2.componentCls}-prefix, ${token2.componentCls}-suffix`]: {
      color: options.affixColor
    }
  })
}), "genFilledStatusStyle"), genFilledStyle = /* @__PURE__ */ __name((token2, extraStyles) => ({
  "&-filled": Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, genBaseFilledStyle(token2, {
    bg: token2.colorFillTertiary,
    hoverBg: token2.colorFillSecondary,
    activeBorderColor: token2.activeBorderColor
  })), {
    [`&${token2.componentCls}-disabled, &[disabled]`]: Object.assign({}, genDisabledStyle(token2))
  }), genFilledStatusStyle(token2, {
    status: "error",
    bg: token2.colorErrorBg,
    hoverBg: token2.colorErrorBgHover,
    activeBorderColor: token2.colorError,
    inputColor: token2.colorErrorText,
    affixColor: token2.colorError
  })), genFilledStatusStyle(token2, {
    status: "warning",
    bg: token2.colorWarningBg,
    hoverBg: token2.colorWarningBgHover,
    activeBorderColor: token2.colorWarning,
    inputColor: token2.colorWarningText,
    affixColor: token2.colorWarning
  })), extraStyles)
}), "genFilledStyle"), genFilledGroupStatusStyle = /* @__PURE__ */ __name((token2, options) => ({
  [`&${token2.componentCls}-group-wrapper-status-${options.status}`]: {
    [`${token2.componentCls}-group-addon`]: {
      background: options.addonBg,
      color: options.addonColor
    }
  }
}), "genFilledGroupStatusStyle"), genFilledGroupStyle = /* @__PURE__ */ __name((token2) => ({
  "&-filled": Object.assign(Object.assign(Object.assign({
    [`${token2.componentCls}-group`]: {
      "&-addon": {
        background: token2.colorFillTertiary
      },
      [`${token2.componentCls}-filled:not(:focus):not(:focus-within)`]: {
        "&:not(:first-child)": {
          borderInlineStart: `${unit$1(token2.lineWidth)} ${token2.lineType} ${token2.colorSplit}`
        },
        "&:not(:last-child)": {
          borderInlineEnd: `${unit$1(token2.lineWidth)} ${token2.lineType} ${token2.colorSplit}`
        }
      }
    }
  }, genFilledGroupStatusStyle(token2, {
    status: "error",
    addonBg: token2.colorErrorBg,
    addonColor: token2.colorErrorText
  })), genFilledGroupStatusStyle(token2, {
    status: "warning",
    addonBg: token2.colorWarningBg,
    addonColor: token2.colorWarningText
  })), {
    [`&${token2.componentCls}-group-wrapper-disabled`]: {
      [`${token2.componentCls}-group`]: {
        "&-addon": {
          background: token2.colorFillTertiary,
          color: token2.colorTextDisabled
        },
        "&-addon:first-child": {
          borderInlineStart: `${unit$1(token2.lineWidth)} ${token2.lineType} ${token2.colorBorder}`,
          borderTop: `${unit$1(token2.lineWidth)} ${token2.lineType} ${token2.colorBorder}`,
          borderBottom: `${unit$1(token2.lineWidth)} ${token2.lineType} ${token2.colorBorder}`
        },
        "&-addon:last-child": {
          borderInlineEnd: `${unit$1(token2.lineWidth)} ${token2.lineType} ${token2.colorBorder}`,
          borderTop: `${unit$1(token2.lineWidth)} ${token2.lineType} ${token2.colorBorder}`,
          borderBottom: `${unit$1(token2.lineWidth)} ${token2.lineType} ${token2.colorBorder}`
        }
      }
    }
  })
}), "genFilledGroupStyle"), genPlaceholderStyle = /* @__PURE__ */ __name((color) => ({
  // Firefox
  "&::-moz-placeholder": {
    opacity: 1
  },
  "&::placeholder": {
    color,
    userSelect: "none"
    // https://github.com/ant-design/ant-design/pull/32639
  },
  "&:placeholder-shown": {
    textOverflow: "ellipsis"
  }
}), "genPlaceholderStyle"), genInputLargeStyle = /* @__PURE__ */ __name((token2) => {
  const {
    paddingBlockLG,
    lineHeightLG,
    borderRadiusLG,
    paddingInlineLG
  } = token2;
  return {
    padding: `${unit$1(paddingBlockLG)} ${unit$1(paddingInlineLG)}`,
    fontSize: token2.inputFontSizeLG,
    lineHeight: lineHeightLG,
    borderRadius: borderRadiusLG
  };
}, "genInputLargeStyle"), genInputSmallStyle = /* @__PURE__ */ __name((token2) => ({
  padding: `${unit$1(token2.paddingBlockSM)} ${unit$1(token2.paddingInlineSM)}`,
  fontSize: token2.inputFontSizeSM,
  borderRadius: token2.borderRadiusSM
}), "genInputSmallStyle"), genBasicInputStyle = /* @__PURE__ */ __name((token2) => Object.assign(Object.assign({
  position: "relative",
  display: "inline-block",
  width: "100%",
  minWidth: 0,
  padding: `${unit$1(token2.paddingBlock)} ${unit$1(token2.paddingInline)}`,
  color: token2.colorText,
  fontSize: token2.inputFontSize,
  lineHeight: token2.lineHeight,
  borderRadius: token2.borderRadius,
  transition: `all ${token2.motionDurationMid}`
}, genPlaceholderStyle(token2.colorTextPlaceholder)), {
  // Reset height for `textarea`s
  "textarea&": {
    maxWidth: "100%",
    // prevent textarea resize from coming out of its container
    height: "auto",
    minHeight: token2.controlHeight,
    lineHeight: token2.lineHeight,
    verticalAlign: "bottom",
    transition: `all ${token2.motionDurationSlow}, height 0s`,
    resize: "vertical"
  },
  // Size
  "&-lg": Object.assign({}, genInputLargeStyle(token2)),
  "&-sm": Object.assign({}, genInputSmallStyle(token2)),
  // RTL
  "&-rtl, &-textarea-rtl": {
    direction: "rtl"
  }
}), "genBasicInputStyle"), genInputGroupStyle = /* @__PURE__ */ __name((token2) => {
  const {
    componentCls,
    antCls
  } = token2;
  return {
    position: "relative",
    display: "table",
    width: "100%",
    borderCollapse: "separate",
    borderSpacing: 0,
    // Undo padding and float of grid classes
    "&[class*='col-']": {
      paddingInlineEnd: token2.paddingXS,
      "&:last-child": {
        paddingInlineEnd: 0
      }
    },
    // Sizing options
    [`&-lg ${componentCls}, &-lg > ${componentCls}-group-addon`]: Object.assign({}, genInputLargeStyle(token2)),
    [`&-sm ${componentCls}, &-sm > ${componentCls}-group-addon`]: Object.assign({}, genInputSmallStyle(token2)),
    // Fix https://github.com/ant-design/ant-design/issues/5754
    [`&-lg ${antCls}-select-single ${antCls}-select-selector`]: {
      height: token2.controlHeightLG
    },
    [`&-sm ${antCls}-select-single ${antCls}-select-selector`]: {
      height: token2.controlHeightSM
    },
    [`> ${componentCls}`]: {
      display: "table-cell",
      "&:not(:first-child):not(:last-child)": {
        borderRadius: 0
      }
    },
    [`${componentCls}-group`]: {
      "&-addon, &-wrap": {
        display: "table-cell",
        width: 1,
        whiteSpace: "nowrap",
        verticalAlign: "middle",
        "&:not(:first-child):not(:last-child)": {
          borderRadius: 0
        }
      },
      "&-wrap > *": {
        display: "block !important"
      },
      "&-addon": {
        position: "relative",
        padding: `0 ${unit$1(token2.paddingInline)}`,
        color: token2.colorText,
        fontWeight: "normal",
        fontSize: token2.inputFontSize,
        textAlign: "center",
        borderRadius: token2.borderRadius,
        transition: `all ${token2.motionDurationSlow}`,
        lineHeight: 1,
        // Reset Select's style in addon
        [`${antCls}-select`]: {
          margin: `${unit$1(token2.calc(token2.paddingBlock).add(1).mul(-1).equal())} ${unit$1(token2.calc(token2.paddingInline).mul(-1).equal())}`,
          [`&${antCls}-select-single:not(${antCls}-select-customize-input):not(${antCls}-pagination-size-changer)`]: {
            [`${antCls}-select-selector`]: {
              backgroundColor: "inherit",
              border: `${unit$1(token2.lineWidth)} ${token2.lineType} transparent`,
              boxShadow: "none"
            }
          }
        },
        // https://github.com/ant-design/ant-design/issues/31333
        [`${antCls}-cascader-picker`]: {
          margin: `-9px ${unit$1(token2.calc(token2.paddingInline).mul(-1).equal())}`,
          backgroundColor: "transparent",
          [`${antCls}-cascader-input`]: {
            textAlign: "start",
            border: 0,
            boxShadow: "none"
          }
        }
      }
    },
    [componentCls]: {
      width: "100%",
      marginBottom: 0,
      textAlign: "inherit",
      "&:focus": {
        zIndex: 1,
        // Fix https://gw.alipayobjects.com/zos/rmsportal/DHNpoqfMXSfrSnlZvhsJ.png
        borderInlineEndWidth: 1
      },
      "&:hover": {
        zIndex: 1,
        borderInlineEndWidth: 1,
        [`${componentCls}-search-with-button &`]: {
          zIndex: 0
        }
      }
    },
    // Reset rounded corners
    [`> ${componentCls}:first-child, ${componentCls}-group-addon:first-child`]: {
      borderStartEndRadius: 0,
      borderEndEndRadius: 0,
      // Reset Select's style in addon
      [`${antCls}-select ${antCls}-select-selector`]: {
        borderStartEndRadius: 0,
        borderEndEndRadius: 0
      }
    },
    [`> ${componentCls}-affix-wrapper`]: {
      [`&:not(:first-child) ${componentCls}`]: {
        borderStartStartRadius: 0,
        borderEndStartRadius: 0
      },
      [`&:not(:last-child) ${componentCls}`]: {
        borderStartEndRadius: 0,
        borderEndEndRadius: 0
      }
    },
    [`> ${componentCls}:last-child, ${componentCls}-group-addon:last-child`]: {
      borderStartStartRadius: 0,
      borderEndStartRadius: 0,
      // Reset Select's style in addon
      [`${antCls}-select ${antCls}-select-selector`]: {
        borderStartStartRadius: 0,
        borderEndStartRadius: 0
      }
    },
    [`${componentCls}-affix-wrapper`]: {
      "&:not(:last-child)": {
        borderStartEndRadius: 0,
        borderEndEndRadius: 0,
        [`${componentCls}-search &`]: {
          borderStartStartRadius: token2.borderRadius,
          borderEndStartRadius: token2.borderRadius
        }
      },
      [`&:not(:first-child), ${componentCls}-search &:not(:first-child)`]: {
        borderStartStartRadius: 0,
        borderEndStartRadius: 0
      }
    },
    [`&${componentCls}-group-compact`]: Object.assign(Object.assign({
      display: "block"
    }, clearFix()), {
      [`${componentCls}-group-addon, ${componentCls}-group-wrap, > ${componentCls}`]: {
        "&:not(:first-child):not(:last-child)": {
          borderInlineEndWidth: token2.lineWidth,
          "&:hover, &:focus": {
            zIndex: 1
          }
        }
      },
      "& > *": {
        display: "inline-flex",
        float: "none",
        verticalAlign: "top",
        // https://github.com/ant-design/ant-design-pro/issues/139
        borderRadius: 0
      },
      [`
        & > ${componentCls}-affix-wrapper,
        & > ${componentCls}-number-affix-wrapper,
        & > ${antCls}-picker-range
      `]: {
        display: "inline-flex"
      },
      "& > *:not(:last-child)": {
        marginInlineEnd: token2.calc(token2.lineWidth).mul(-1).equal(),
        borderInlineEndWidth: token2.lineWidth
      },
      // Undo float for .ant-input-group .ant-input
      [componentCls]: {
        float: "none"
      },
      // reset border for Select, DatePicker, AutoComplete, Cascader, Mention, TimePicker, Input
      [`& > ${antCls}-select > ${antCls}-select-selector,
      & > ${antCls}-select-auto-complete ${componentCls},
      & > ${antCls}-cascader-picker ${componentCls},
      & > ${componentCls}-group-wrapper ${componentCls}`]: {
        borderInlineEndWidth: token2.lineWidth,
        borderRadius: 0,
        "&:hover, &:focus": {
          zIndex: 1
        }
      },
      [`& > ${antCls}-select-focused`]: {
        zIndex: 1
      },
      // update z-index for arrow icon
      [`& > ${antCls}-select > ${antCls}-select-arrow`]: {
        zIndex: 1
        // https://github.com/ant-design/ant-design/issues/20371
      },
      [`& > *:first-child,
      & > ${antCls}-select:first-child > ${antCls}-select-selector,
      & > ${antCls}-select-auto-complete:first-child ${componentCls},
      & > ${antCls}-cascader-picker:first-child ${componentCls}`]: {
        borderStartStartRadius: token2.borderRadius,
        borderEndStartRadius: token2.borderRadius
      },
      [`& > *:last-child,
      & > ${antCls}-select:last-child > ${antCls}-select-selector,
      & > ${antCls}-cascader-picker:last-child ${componentCls},
      & > ${antCls}-cascader-picker-focused:last-child ${componentCls}`]: {
        borderInlineEndWidth: token2.lineWidth,
        borderStartEndRadius: token2.borderRadius,
        borderEndEndRadius: token2.borderRadius
      },
      // https://github.com/ant-design/ant-design/issues/12493
      [`& > ${antCls}-select-auto-complete ${componentCls}`]: {
        verticalAlign: "top"
      },
      [`${componentCls}-group-wrapper + ${componentCls}-group-wrapper`]: {
        marginInlineStart: token2.calc(token2.lineWidth).mul(-1).equal(),
        [`${componentCls}-affix-wrapper`]: {
          borderRadius: 0
        }
      },
      [`${componentCls}-group-wrapper:not(:last-child)`]: {
        [`&${componentCls}-search > ${componentCls}-group`]: {
          [`& > ${componentCls}-group-addon > ${componentCls}-search-button`]: {
            borderRadius: 0
          },
          [`& > ${componentCls}`]: {
            borderStartStartRadius: token2.borderRadius,
            borderStartEndRadius: 0,
            borderEndEndRadius: 0,
            borderEndStartRadius: token2.borderRadius
          }
        }
      }
    })
  };
}, "genInputGroupStyle"), genInputStyle = /* @__PURE__ */ __name((token2) => {
  const {
    componentCls,
    controlHeightSM,
    lineWidth,
    calc
  } = token2, colorSmallPadding = calc(controlHeightSM).sub(calc(lineWidth).mul(2)).sub(16).div(2).equal();
  return {
    [componentCls]: Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, resetComponent(token2)), genBasicInputStyle(token2)), genOutlinedStyle(token2)), genFilledStyle(token2)), genBorderlessStyle(token2)), {
      '&[type="color"]': {
        height: token2.controlHeight,
        [`&${componentCls}-lg`]: {
          height: token2.controlHeightLG
        },
        [`&${componentCls}-sm`]: {
          height: controlHeightSM,
          paddingTop: colorSmallPadding,
          paddingBottom: colorSmallPadding
        }
      },
      '&[type="search"]::-webkit-search-cancel-button, &[type="search"]::-webkit-search-decoration': {
        "-webkit-appearance": "none"
      }
    })
  };
}, "genInputStyle"), genAllowClearStyle = /* @__PURE__ */ __name((token2) => {
  const {
    componentCls
  } = token2;
  return {
    // ========================= Input =========================
    [`${componentCls}-clear-icon`]: {
      margin: 0,
      lineHeight: 0,
      color: token2.colorTextQuaternary,
      fontSize: token2.fontSizeIcon,
      verticalAlign: -1,
      // https://github.com/ant-design/ant-design/pull/18151
      // https://codesandbox.io/s/wizardly-sun-u10br
      cursor: "pointer",
      transition: `color ${token2.motionDurationSlow}`,
      "&:hover": {
        color: token2.colorTextTertiary
      },
      "&:active": {
        color: token2.colorText
      },
      "&-hidden": {
        visibility: "hidden"
      },
      "&-has-suffix": {
        margin: `0 ${unit$1(token2.inputAffixPadding)}`
      }
    }
  };
}, "genAllowClearStyle"), genAffixStyle = /* @__PURE__ */ __name((token2) => {
  const {
    componentCls,
    inputAffixPadding,
    colorTextDescription,
    motionDurationSlow,
    colorIcon,
    colorIconHover,
    iconCls
  } = token2, affixCls = `${componentCls}-affix-wrapper`, affixClsDisabled = `${componentCls}-affix-wrapper-disabled`;
  return {
    [affixCls]: Object.assign(Object.assign(Object.assign(Object.assign({}, genBasicInputStyle(token2)), {
      display: "inline-flex",
      [`&:not(${componentCls}-disabled):hover`]: {
        zIndex: 1,
        [`${componentCls}-search-with-button &`]: {
          zIndex: 0
        }
      },
      "&-focused, &:focus": {
        zIndex: 1
      },
      [`> input${componentCls}`]: {
        padding: 0
      },
      [`> input${componentCls}, > textarea${componentCls}`]: {
        fontSize: "inherit",
        border: "none",
        borderRadius: 0,
        outline: "none",
        background: "transparent",
        color: "inherit",
        "&::-ms-reveal": {
          display: "none"
        },
        "&:focus": {
          boxShadow: "none !important"
        }
      },
      "&::before": {
        display: "inline-block",
        width: 0,
        visibility: "hidden",
        content: '"\\a0"'
      },
      [componentCls]: {
        "&-prefix, &-suffix": {
          display: "flex",
          flex: "none",
          alignItems: "center",
          "> *:not(:last-child)": {
            marginInlineEnd: token2.paddingXS
          }
        },
        "&-show-count-suffix": {
          color: colorTextDescription
        },
        "&-show-count-has-suffix": {
          marginInlineEnd: token2.paddingXXS
        },
        "&-prefix": {
          marginInlineEnd: inputAffixPadding
        },
        "&-suffix": {
          marginInlineStart: inputAffixPadding
        }
      }
    }), genAllowClearStyle(token2)), {
      // password
      [`${iconCls}${componentCls}-password-icon`]: {
        color: colorIcon,
        cursor: "pointer",
        transition: `all ${motionDurationSlow}`,
        "&:hover": {
          color: colorIconHover
        }
      }
    }),
    [affixClsDisabled]: {
      // password disabled
      [`${iconCls}${componentCls}-password-icon`]: {
        color: colorIcon,
        cursor: "not-allowed",
        "&:hover": {
          color: colorIcon
        }
      }
    }
  };
}, "genAffixStyle"), genGroupStyle = /* @__PURE__ */ __name((token2) => {
  const {
    componentCls,
    borderRadiusLG,
    borderRadiusSM
  } = token2;
  return {
    [`${componentCls}-group`]: Object.assign(Object.assign(Object.assign({}, resetComponent(token2)), genInputGroupStyle(token2)), {
      "&-rtl": {
        direction: "rtl"
      },
      "&-wrapper": Object.assign(Object.assign(Object.assign({
        display: "inline-block",
        width: "100%",
        textAlign: "start",
        verticalAlign: "top",
        "&-rtl": {
          direction: "rtl"
        },
        // Size
        "&-lg": {
          [`${componentCls}-group-addon`]: {
            borderRadius: borderRadiusLG,
            fontSize: token2.inputFontSizeLG
          }
        },
        "&-sm": {
          [`${componentCls}-group-addon`]: {
            borderRadius: borderRadiusSM
          }
        }
      }, genOutlinedGroupStyle(token2)), genFilledGroupStyle(token2)), {
        // '&-disabled': {
        //   [`${componentCls}-group-addon`]: {
        //     ...genDisabledStyle(token),
        //   },
        // },
        // Fix the issue of using icons in Space Compact mode
        // https://github.com/ant-design/ant-design/issues/42122
        [`&:not(${componentCls}-compact-first-item):not(${componentCls}-compact-last-item)${componentCls}-compact-item`]: {
          [`${componentCls}, ${componentCls}-group-addon`]: {
            borderRadius: 0
          }
        },
        [`&:not(${componentCls}-compact-last-item)${componentCls}-compact-first-item`]: {
          [`${componentCls}, ${componentCls}-group-addon`]: {
            borderStartEndRadius: 0,
            borderEndEndRadius: 0
          }
        },
        [`&:not(${componentCls}-compact-first-item)${componentCls}-compact-last-item`]: {
          [`${componentCls}, ${componentCls}-group-addon`]: {
            borderStartStartRadius: 0,
            borderEndStartRadius: 0
          }
        },
        // Fix the issue of input use show-count param in space compact mode
        // https://github.com/ant-design/ant-design/issues/46872
        [`&:not(${componentCls}-compact-last-item)${componentCls}-compact-item`]: {
          [`${componentCls}-affix-wrapper`]: {
            borderStartEndRadius: 0,
            borderEndEndRadius: 0
          }
        }
      })
    })
  };
}, "genGroupStyle"), genSearchInputStyle = /* @__PURE__ */ __name((token2) => {
  const {
    componentCls,
    antCls
  } = token2, searchPrefixCls = `${componentCls}-search`;
  return {
    [searchPrefixCls]: {
      [componentCls]: {
        "&:hover, &:focus": {
          [`+ ${componentCls}-group-addon ${searchPrefixCls}-button:not(${antCls}-btn-primary)`]: {
            borderInlineStartColor: token2.colorPrimaryHover
          }
        }
      },
      [`${componentCls}-affix-wrapper`]: {
        height: token2.controlHeight,
        borderRadius: 0
      },
      // fix slight height diff in Firefox:
      // https://ant.design/components/auto-complete-cn/#auto-complete-demo-certain-category
      [`${componentCls}-lg`]: {
        lineHeight: token2.calc(token2.lineHeightLG).sub(2e-4).equal()
      },
      [`> ${componentCls}-group`]: {
        [`> ${componentCls}-group-addon:last-child`]: {
          insetInlineStart: -1,
          padding: 0,
          border: 0,
          [`${searchPrefixCls}-button`]: {
            // Fix https://github.com/ant-design/ant-design/issues/47150
            marginInlineEnd: -1,
            borderStartStartRadius: 0,
            borderEndStartRadius: 0,
            boxShadow: "none"
          },
          [`${searchPrefixCls}-button:not(${antCls}-btn-primary)`]: {
            color: token2.colorTextDescription,
            "&:hover": {
              color: token2.colorPrimaryHover
            },
            "&:active": {
              color: token2.colorPrimaryActive
            },
            [`&${antCls}-btn-loading::before`]: {
              insetInlineStart: 0,
              insetInlineEnd: 0,
              insetBlockStart: 0,
              insetBlockEnd: 0
            }
          }
        }
      },
      [`${searchPrefixCls}-button`]: {
        height: token2.controlHeight,
        "&:hover, &:focus": {
          zIndex: 1
        }
      },
      "&-large": {
        [`${componentCls}-affix-wrapper, ${searchPrefixCls}-button`]: {
          height: token2.controlHeightLG
        }
      },
      "&-small": {
        [`${componentCls}-affix-wrapper, ${searchPrefixCls}-button`]: {
          height: token2.controlHeightSM
        }
      },
      "&-rtl": {
        direction: "rtl"
      },
      // ===================== Compact Item Customized Styles =====================
      [`&${componentCls}-compact-item`]: {
        [`&:not(${componentCls}-compact-last-item)`]: {
          [`${componentCls}-group-addon`]: {
            [`${componentCls}-search-button`]: {
              marginInlineEnd: token2.calc(token2.lineWidth).mul(-1).equal(),
              borderRadius: 0
            }
          }
        },
        [`&:not(${componentCls}-compact-first-item)`]: {
          [`${componentCls},${componentCls}-affix-wrapper`]: {
            borderRadius: 0
          }
        },
        [`> ${componentCls}-group-addon ${componentCls}-search-button,
        > ${componentCls},
        ${componentCls}-affix-wrapper`]: {
          "&:hover, &:focus, &:active": {
            zIndex: 2
          }
        },
        [`> ${componentCls}-affix-wrapper-focused`]: {
          zIndex: 2
        }
      }
    }
  };
}, "genSearchInputStyle"), genTextAreaStyle = /* @__PURE__ */ __name((token2) => {
  const {
    componentCls,
    paddingLG
  } = token2, textareaPrefixCls = `${componentCls}-textarea`;
  return {
    [textareaPrefixCls]: {
      position: "relative",
      "&-show-count": {
        // https://github.com/ant-design/ant-design/issues/33049
        [`> ${componentCls}`]: {
          height: "100%"
        },
        [`${componentCls}-data-count`]: {
          position: "absolute",
          bottom: token2.calc(token2.fontSize).mul(token2.lineHeight).mul(-1).equal(),
          insetInlineEnd: 0,
          color: token2.colorTextDescription,
          whiteSpace: "nowrap",
          pointerEvents: "none"
        }
      },
      [`
        &-allow-clear > ${componentCls},
        &-affix-wrapper${textareaPrefixCls}-has-feedback ${componentCls}
      `]: {
        paddingInlineEnd: paddingLG
      },
      [`&-affix-wrapper${componentCls}-affix-wrapper`]: {
        padding: 0,
        [`> textarea${componentCls}`]: {
          fontSize: "inherit",
          border: "none",
          outline: "none",
          background: "transparent",
          "&:focus": {
            boxShadow: "none !important"
          }
        },
        [`${componentCls}-suffix`]: {
          margin: 0,
          "> *:not(:last-child)": {
            marginInline: 0
          },
          // Clear Icon
          [`${componentCls}-clear-icon`]: {
            position: "absolute",
            insetInlineEnd: token2.paddingInline,
            insetBlockStart: token2.paddingXS
          },
          // Feedback Icon
          [`${textareaPrefixCls}-suffix`]: {
            position: "absolute",
            top: 0,
            insetInlineEnd: token2.paddingInline,
            bottom: 0,
            zIndex: 1,
            display: "inline-flex",
            alignItems: "center",
            margin: "auto",
            pointerEvents: "none"
          }
        }
      },
      [`&-affix-wrapper${componentCls}-affix-wrapper-sm`]: {
        [`${componentCls}-suffix`]: {
          [`${componentCls}-clear-icon`]: {
            insetInlineEnd: token2.paddingInlineSM
          }
        }
      }
    }
  };
}, "genTextAreaStyle"), genRangeStyle = /* @__PURE__ */ __name((token2) => {
  const {
    componentCls
  } = token2;
  return {
    [`${componentCls}-out-of-range`]: {
      [`&, & input, & textarea, ${componentCls}-show-count-suffix, ${componentCls}-data-count`]: {
        color: token2.colorError
      }
    }
  };
}, "genRangeStyle"), useStyle$g = genStyleHooks("Input", (token2) => {
  const inputToken = merge(token2, initInputToken(token2));
  return [
    genInputStyle(inputToken),
    genTextAreaStyle(inputToken),
    genAffixStyle(inputToken),
    genGroupStyle(inputToken),
    genSearchInputStyle(inputToken),
    genRangeStyle(inputToken),
    // =====================================================
    // ==             Space Compact                       ==
    // =====================================================
    genCompactItemStyle(inputToken)
  ];
}, initComponentToken$1, {
  resetFont: !1
}), genSize = /* @__PURE__ */ __name((token2, suffix) => {
  const {
    componentCls,
    controlHeight
  } = token2, suffixCls = suffix ? `${componentCls}-${suffix}` : "", multipleSelectorUnit = getMultipleSelectorUnit(token2);
  return [
    // genSelectionStyle(token, suffix),
    {
      [`${componentCls}-multiple${suffixCls}`]: {
        paddingBlock: multipleSelectorUnit.containerPadding,
        paddingInlineStart: multipleSelectorUnit.basePadding,
        minHeight: controlHeight,
        // ======================== Selections ========================
        [`${componentCls}-selection-item`]: {
          height: multipleSelectorUnit.itemHeight,
          lineHeight: unit$1(multipleSelectorUnit.itemLineHeight)
        }
      }
    }
  ];
}, "genSize"), genPickerMultipleStyle = /* @__PURE__ */ __name((token2) => {
  const {
    componentCls,
    calc,
    lineWidth
  } = token2, smallToken = merge(token2, {
    fontHeight: token2.fontSize,
    selectHeight: token2.controlHeightSM,
    multipleSelectItemHeight: token2.multipleItemHeightSM,
    borderRadius: token2.borderRadiusSM,
    borderRadiusSM: token2.borderRadiusXS,
    controlHeight: token2.controlHeightSM
  }), largeToken = merge(token2, {
    fontHeight: calc(token2.multipleItemHeightLG).sub(calc(lineWidth).mul(2).equal()).equal(),
    fontSize: token2.fontSizeLG,
    selectHeight: token2.controlHeightLG,
    multipleSelectItemHeight: token2.multipleItemHeightLG,
    borderRadius: token2.borderRadiusLG,
    borderRadiusSM: token2.borderRadius,
    controlHeight: token2.controlHeightLG
  });
  return [
    // ======================== Size ========================
    genSize(smallToken, "small"),
    genSize(token2),
    genSize(largeToken, "large"),
    // ====================== Selection ======================
    {
      [`${componentCls}${componentCls}-multiple`]: Object.assign(Object.assign({
        width: "100%",
        cursor: "text",
        // ==================== Selector =====================
        [`${componentCls}-selector`]: {
          flex: "auto",
          padding: 0,
          position: "relative",
          "&:after": {
            margin: 0
          },
          // ================== placeholder ==================
          [`${componentCls}-selection-placeholder`]: {
            position: "absolute",
            top: "50%",
            insetInlineStart: token2.inputPaddingHorizontalBase,
            insetInlineEnd: 0,
            transform: "translateY(-50%)",
            transition: `all ${token2.motionDurationSlow}`,
            overflow: "hidden",
            whiteSpace: "nowrap",
            textOverflow: "ellipsis",
            flex: 1,
            color: token2.colorTextPlaceholder,
            pointerEvents: "none"
          }
        }
      }, genOverflowStyle(token2)), {
        // ====================== Input ======================
        // Input is `readonly`, which is used for a11y only
        [`${componentCls}-multiple-input`]: {
          width: 0,
          height: 0,
          border: 0,
          visibility: "hidden",
          position: "absolute",
          zIndex: -1
        }
      })
    }
  ];
}, "genPickerMultipleStyle"), genPickerCellInnerStyle = /* @__PURE__ */ __name((token2) => {
  const {
    pickerCellCls,
    pickerCellInnerCls,
    cellHeight,
    borderRadiusSM,
    motionDurationMid,
    cellHoverBg,
    lineWidth,
    lineType,
    colorPrimary,
    cellActiveWithRangeBg,
    colorTextLightSolid,
    colorTextDisabled,
    cellBgDisabled,
    colorFillSecondary
  } = token2;
  return {
    "&::before": {
      position: "absolute",
      top: "50%",
      insetInlineStart: 0,
      insetInlineEnd: 0,
      zIndex: 1,
      height: cellHeight,
      transform: "translateY(-50%)",
      content: '""',
      pointerEvents: "none"
    },
    // >>> Default
    [pickerCellInnerCls]: {
      position: "relative",
      zIndex: 2,
      display: "inline-block",
      minWidth: cellHeight,
      height: cellHeight,
      lineHeight: unit$1(cellHeight),
      borderRadius: borderRadiusSM,
      transition: `background ${motionDurationMid}`
    },
    // >>> Hover
    [`&:hover:not(${pickerCellCls}-in-view):not(${pickerCellCls}-disabled),
    &:hover:not(${pickerCellCls}-selected):not(${pickerCellCls}-range-start):not(${pickerCellCls}-range-end):not(${pickerCellCls}-disabled)`]: {
      [pickerCellInnerCls]: {
        background: cellHoverBg
      }
    },
    // >>> Today
    [`&-in-view${pickerCellCls}-today ${pickerCellInnerCls}`]: {
      "&::before": {
        position: "absolute",
        top: 0,
        insetInlineEnd: 0,
        bottom: 0,
        insetInlineStart: 0,
        zIndex: 1,
        border: `${unit$1(lineWidth)} ${lineType} ${colorPrimary}`,
        borderRadius: borderRadiusSM,
        content: '""'
      }
    },
    // >>> In Range
    [`&-in-view${pickerCellCls}-in-range,
      &-in-view${pickerCellCls}-range-start,
      &-in-view${pickerCellCls}-range-end`]: {
      position: "relative",
      [`&:not(${pickerCellCls}-disabled):before`]: {
        background: cellActiveWithRangeBg
      }
    },
    // >>> Selected
    [`&-in-view${pickerCellCls}-selected,
      &-in-view${pickerCellCls}-range-start,
      &-in-view${pickerCellCls}-range-end`]: {
      [`&:not(${pickerCellCls}-disabled) ${pickerCellInnerCls}`]: {
        color: colorTextLightSolid,
        background: colorPrimary
      },
      [`&${pickerCellCls}-disabled ${pickerCellInnerCls}`]: {
        background: colorFillSecondary
      }
    },
    [`&-in-view${pickerCellCls}-range-start:not(${pickerCellCls}-disabled):before`]: {
      insetInlineStart: "50%"
    },
    [`&-in-view${pickerCellCls}-range-end:not(${pickerCellCls}-disabled):before`]: {
      insetInlineEnd: "50%"
    },
    // range start border-radius
    [`&-in-view${pickerCellCls}-range-start:not(${pickerCellCls}-range-end) ${pickerCellInnerCls}`]: {
      borderStartStartRadius: borderRadiusSM,
      borderEndStartRadius: borderRadiusSM,
      borderStartEndRadius: 0,
      borderEndEndRadius: 0
    },
    // range end border-radius
    [`&-in-view${pickerCellCls}-range-end:not(${pickerCellCls}-range-start) ${pickerCellInnerCls}`]: {
      borderStartStartRadius: 0,
      borderEndStartRadius: 0,
      borderStartEndRadius: borderRadiusSM,
      borderEndEndRadius: borderRadiusSM
    },
    // >>> Disabled
    "&-disabled": {
      color: colorTextDisabled,
      cursor: "not-allowed",
      [pickerCellInnerCls]: {
        background: "transparent"
      },
      "&::before": {
        background: cellBgDisabled
      }
    },
    [`&-disabled${pickerCellCls}-today ${pickerCellInnerCls}::before`]: {
      borderColor: colorTextDisabled
    }
  };
}, "genPickerCellInnerStyle"), genPanelStyle = /* @__PURE__ */ __name((token2) => {
  const {
    componentCls,
    pickerCellCls,
    pickerCellInnerCls,
    pickerYearMonthCellWidth,
    pickerControlIconSize,
    cellWidth,
    paddingSM,
    paddingXS,
    paddingXXS,
    colorBgContainer,
    lineWidth,
    lineType,
    borderRadiusLG,
    colorPrimary,
    colorTextHeading,
    colorSplit,
    pickerControlIconBorderWidth,
    colorIcon,
    textHeight,
    motionDurationMid,
    colorIconHover,
    fontWeightStrong,
    cellHeight,
    pickerCellPaddingVertical,
    colorTextDisabled,
    colorText,
    fontSize,
    motionDurationSlow,
    withoutTimeCellHeight,
    pickerQuarterPanelContentHeight,
    borderRadiusSM,
    colorTextLightSolid,
    cellHoverBg,
    timeColumnHeight,
    timeColumnWidth,
    timeCellHeight,
    controlItemBgActive,
    marginXXS,
    pickerDatePanelPaddingHorizontal,
    pickerControlIconMargin
  } = token2, pickerPanelWidth = token2.calc(cellWidth).mul(7).add(token2.calc(pickerDatePanelPaddingHorizontal).mul(2)).equal();
  return {
    [componentCls]: {
      "&-panel": {
        display: "inline-flex",
        flexDirection: "column",
        textAlign: "center",
        background: colorBgContainer,
        borderRadius: borderRadiusLG,
        outline: "none",
        "&-focused": {
          borderColor: colorPrimary
        },
        "&-rtl": {
          [`${componentCls}-prev-icon,
              ${componentCls}-super-prev-icon`]: {
            transform: "rotate(45deg)"
          },
          [`${componentCls}-next-icon,
              ${componentCls}-super-next-icon`]: {
            transform: "rotate(-135deg)"
          },
          [`${componentCls}-time-panel`]: {
            [`${componentCls}-content`]: {
              direction: "ltr",
              "> *": {
                direction: "rtl"
              }
            }
          }
        }
      },
      // ========================================================
      // =                     Shared Panel                     =
      // ========================================================
      "&-decade-panel,\n        &-year-panel,\n        &-quarter-panel,\n        &-month-panel,\n        &-week-panel,\n        &-date-panel,\n        &-time-panel": {
        display: "flex",
        flexDirection: "column",
        width: pickerPanelWidth
      },
      // ======================= Header =======================
      "&-header": {
        display: "flex",
        padding: `0 ${unit$1(paddingXS)}`,
        color: colorTextHeading,
        borderBottom: `${unit$1(lineWidth)} ${lineType} ${colorSplit}`,
        "> *": {
          flex: "none"
        },
        button: {
          padding: 0,
          color: colorIcon,
          lineHeight: unit$1(textHeight),
          background: "transparent",
          border: 0,
          cursor: "pointer",
          transition: `color ${motionDurationMid}`,
          fontSize: "inherit",
          display: "inline-flex",
          alignItems: "center",
          justifyContent: "center"
        },
        "> button": {
          minWidth: "1.6em",
          fontSize,
          "&:hover": {
            color: colorIconHover
          },
          "&:disabled": {
            opacity: 0.25,
            pointerEvents: "none"
          }
        },
        "&-view": {
          flex: "auto",
          fontWeight: fontWeightStrong,
          lineHeight: unit$1(textHeight),
          "> button": {
            color: "inherit",
            fontWeight: "inherit",
            "&:not(:first-child)": {
              marginInlineStart: paddingXS
            },
            "&:hover": {
              color: colorPrimary
            }
          }
        }
      },
      // Arrow button
      "&-prev-icon,\n        &-next-icon,\n        &-super-prev-icon,\n        &-super-next-icon": {
        position: "relative",
        width: pickerControlIconSize,
        height: pickerControlIconSize,
        "&::before": {
          position: "absolute",
          top: 0,
          insetInlineStart: 0,
          width: pickerControlIconSize,
          height: pickerControlIconSize,
          border: "0 solid currentcolor",
          borderBlockWidth: `${unit$1(pickerControlIconBorderWidth)} 0`,
          borderInlineWidth: `${unit$1(pickerControlIconBorderWidth)} 0`,
          content: '""'
        }
      },
      "&-super-prev-icon,\n        &-super-next-icon": {
        "&::after": {
          position: "absolute",
          top: pickerControlIconMargin,
          insetInlineStart: pickerControlIconMargin,
          display: "inline-block",
          width: pickerControlIconSize,
          height: pickerControlIconSize,
          border: "0 solid currentcolor",
          borderBlockWidth: `${unit$1(pickerControlIconBorderWidth)} 0`,
          borderInlineWidth: `${unit$1(pickerControlIconBorderWidth)} 0`,
          content: '""'
        }
      },
      "&-prev-icon, &-super-prev-icon": {
        transform: "rotate(-45deg)"
      },
      "&-next-icon, &-super-next-icon": {
        transform: "rotate(135deg)"
      },
      // ======================== Body ========================
      "&-content": {
        width: "100%",
        tableLayout: "fixed",
        borderCollapse: "collapse",
        "th, td": {
          position: "relative",
          minWidth: cellHeight,
          fontWeight: "normal"
        },
        th: {
          height: token2.calc(cellHeight).add(token2.calc(pickerCellPaddingVertical).mul(2)).equal(),
          color: colorText,
          verticalAlign: "middle"
        }
      },
      "&-cell": Object.assign({
        padding: `${unit$1(pickerCellPaddingVertical)} 0`,
        color: colorTextDisabled,
        cursor: "pointer",
        // In view
        "&-in-view": {
          color: colorText
        }
      }, genPickerCellInnerStyle(token2)),
      "&-decade-panel,\n        &-year-panel,\n        &-quarter-panel,\n        &-month-panel": {
        [`${componentCls}-content`]: {
          height: token2.calc(withoutTimeCellHeight).mul(4).equal()
        },
        [pickerCellInnerCls]: {
          padding: `0 ${unit$1(paddingXS)}`
        }
      },
      "&-quarter-panel": {
        [`${componentCls}-content`]: {
          height: pickerQuarterPanelContentHeight
        }
      },
      // ========================================================
      // =                       Special                        =
      // ========================================================
      // ===================== Decade Panel =====================
      "&-decade-panel": {
        [pickerCellInnerCls]: {
          padding: `0 ${unit$1(token2.calc(paddingXS).div(2).equal())}`
        },
        [`${componentCls}-cell::before`]: {
          display: "none"
        }
      },
      // ============= Year & Quarter & Month Panel =============
      "&-year-panel,\n        &-quarter-panel,\n        &-month-panel": {
        [`${componentCls}-body`]: {
          padding: `0 ${unit$1(paddingXS)}`
        },
        [pickerCellInnerCls]: {
          width: pickerYearMonthCellWidth
        }
      },
      // ====================== Date Panel ======================
      "&-date-panel": {
        [`${componentCls}-body`]: {
          padding: `${unit$1(paddingXS)} ${unit$1(pickerDatePanelPaddingHorizontal)}`
        },
        [`${componentCls}-content th`]: {
          boxSizing: "border-box",
          padding: 0
        }
      },
      // ====================== Week Panel ======================
      "&-week-panel": {
        // Clear cell style
        [`${componentCls}-cell`]: {
          [`&:hover ${pickerCellInnerCls},
            &-selected ${pickerCellInnerCls},
            ${pickerCellInnerCls}`]: {
            background: "transparent !important"
          }
        },
        "&-row": {
          td: {
            "&:before": {
              transition: `background ${motionDurationMid}`
            },
            "&:first-child:before": {
              borderStartStartRadius: borderRadiusSM,
              borderEndStartRadius: borderRadiusSM
            },
            "&:last-child:before": {
              borderStartEndRadius: borderRadiusSM,
              borderEndEndRadius: borderRadiusSM
            }
          },
          "&:hover td:before": {
            background: cellHoverBg
          },
          "&-range-start td, &-range-end td, &-selected td, &-hover td": {
            // Rise priority to override hover style
            [`&${pickerCellCls}`]: {
              "&:before": {
                background: colorPrimary
              },
              [`&${componentCls}-cell-week`]: {
                color: new TinyColor(colorTextLightSolid).setAlpha(0.5).toHexString()
              },
              [pickerCellInnerCls]: {
                color: colorTextLightSolid
              }
            }
          },
          "&-range-hover td:before": {
            background: controlItemBgActive
          }
        }
      },
      // >>> ShowWeek
      "&-week-panel, &-date-panel-show-week": {
        [`${componentCls}-body`]: {
          padding: `${unit$1(paddingXS)} ${unit$1(paddingSM)}`
        },
        [`${componentCls}-content th`]: {
          width: "auto"
        }
      },
      // ==================== Datetime Panel ====================
      "&-datetime-panel": {
        display: "flex",
        [`${componentCls}-time-panel`]: {
          borderInlineStart: `${unit$1(lineWidth)} ${lineType} ${colorSplit}`
        },
        [`${componentCls}-date-panel,
          ${componentCls}-time-panel`]: {
          transition: `opacity ${motionDurationSlow}`
        },
        // Keyboard
        "&-active": {
          [`${componentCls}-date-panel,
            ${componentCls}-time-panel`]: {
            opacity: 0.3,
            "&-active": {
              opacity: 1
            }
          }
        }
      },
      // ====================== Time Panel ======================
      "&-time-panel": {
        width: "auto",
        minWidth: "auto",
        [`${componentCls}-content`]: {
          display: "flex",
          flex: "auto",
          height: timeColumnHeight
        },
        "&-column": {
          flex: "1 0 auto",
          width: timeColumnWidth,
          margin: `${unit$1(paddingXXS)} 0`,
          padding: 0,
          overflowY: "hidden",
          textAlign: "start",
          listStyle: "none",
          transition: `background ${motionDurationMid}`,
          overflowX: "hidden",
          "&::-webkit-scrollbar": {
            width: 8,
            backgroundColor: "transparent"
          },
          "&::-webkit-scrollbar-thumb": {
            backgroundColor: token2.colorTextTertiary,
            borderRadius: token2.borderRadiusSM
          },
          // For Firefox
          "&": {
            scrollbarWidth: "thin",
            scrollbarColor: `${token2.colorTextTertiary} transparent`
          },
          "&::after": {
            display: "block",
            height: `calc(100% - ${unit$1(timeCellHeight)})`,
            content: '""'
          },
          "&:not(:first-child)": {
            borderInlineStart: `${unit$1(lineWidth)} ${lineType} ${colorSplit}`
          },
          "&-active": {
            background: new TinyColor(controlItemBgActive).setAlpha(0.2).toHexString()
          },
          "&:hover": {
            overflowY: "auto"
          },
          "> li": {
            margin: 0,
            padding: 0,
            [`&${componentCls}-time-panel-cell`]: {
              marginInline: marginXXS,
              [`${componentCls}-time-panel-cell-inner`]: {
                display: "block",
                width: token2.calc(timeColumnWidth).sub(token2.calc(marginXXS).mul(2)).equal(),
                height: timeCellHeight,
                margin: 0,
                paddingBlock: 0,
                paddingInlineEnd: 0,
                paddingInlineStart: token2.calc(timeColumnWidth).sub(timeCellHeight).div(2).equal(),
                color: colorText,
                lineHeight: unit$1(timeCellHeight),
                borderRadius: borderRadiusSM,
                cursor: "pointer",
                transition: `background ${motionDurationMid}`,
                "&:hover": {
                  background: cellHoverBg
                }
              },
              "&-selected": {
                [`${componentCls}-time-panel-cell-inner`]: {
                  background: controlItemBgActive
                }
              },
              "&-disabled": {
                [`${componentCls}-time-panel-cell-inner`]: {
                  color: colorTextDisabled,
                  background: "transparent",
                  cursor: "not-allowed"
                }
              }
            }
          }
        }
      }
    }
  };
}, "genPanelStyle"), genPickerPanelStyle = /* @__PURE__ */ __name((token2) => {
  const {
    componentCls,
    textHeight,
    lineWidth,
    paddingSM,
    antCls,
    colorPrimary,
    cellActiveWithRangeBg,
    colorPrimaryBorder,
    lineType,
    colorSplit
  } = token2;
  return {
    [`${componentCls}-dropdown`]: {
      // ======================== Footer ========================
      [`${componentCls}-footer`]: {
        borderTop: `${unit$1(lineWidth)} ${lineType} ${colorSplit}`,
        "&-extra": {
          padding: `0 ${unit$1(paddingSM)}`,
          lineHeight: unit$1(token2.calc(textHeight).sub(token2.calc(lineWidth).mul(2)).equal()),
          textAlign: "start",
          "&:not(:last-child)": {
            borderBottom: `${unit$1(lineWidth)} ${lineType} ${colorSplit}`
          }
        }
      },
      // ==================== Footer > Ranges ===================
      [`${componentCls}-panels + ${componentCls}-footer ${componentCls}-ranges`]: {
        justifyContent: "space-between"
      },
      [`${componentCls}-ranges`]: {
        marginBlock: 0,
        paddingInline: unit$1(paddingSM),
        overflow: "hidden",
        textAlign: "start",
        listStyle: "none",
        display: "flex",
        justifyContent: "center",
        alignItems: "center",
        "> li": {
          lineHeight: unit$1(token2.calc(textHeight).sub(token2.calc(lineWidth).mul(2)).equal()),
          display: "inline-block"
        },
        [`${componentCls}-now-btn-disabled`]: {
          pointerEvents: "none",
          color: token2.colorTextDisabled
        },
        // https://github.com/ant-design/ant-design/issues/23687
        [`${componentCls}-preset > ${antCls}-tag-blue`]: {
          color: colorPrimary,
          background: cellActiveWithRangeBg,
          borderColor: colorPrimaryBorder,
          cursor: "pointer"
        },
        [`${componentCls}-ok`]: {
          paddingBlock: token2.calc(lineWidth).mul(2).equal(),
          marginInlineStart: "auto"
        }
      }
    }
  };
}, "genPickerPanelStyle"), initPickerPanelToken = /* @__PURE__ */ __name((token2) => {
  const {
    componentCls,
    controlHeightLG,
    paddingXXS,
    padding
  } = token2;
  return {
    pickerCellCls: `${componentCls}-cell`,
    pickerCellInnerCls: `${componentCls}-cell-inner`,
    pickerYearMonthCellWidth: token2.calc(controlHeightLG).mul(1.5).equal(),
    pickerQuarterPanelContentHeight: token2.calc(controlHeightLG).mul(1.4).equal(),
    pickerCellPaddingVertical: token2.calc(paddingXXS).add(token2.calc(paddingXXS).div(2)).equal(),
    pickerCellBorderGap: 2,
    // Magic for gap between cells
    pickerControlIconSize: 7,
    pickerControlIconMargin: 4,
    pickerControlIconBorderWidth: 1.5,
    pickerDatePanelPaddingHorizontal: token2.calc(padding).add(token2.calc(paddingXXS).div(2)).equal()
    // 18 in normal
  };
}, "initPickerPanelToken"), initPanelComponentToken = /* @__PURE__ */ __name((token2) => {
  const {
    colorBgContainerDisabled,
    controlHeight,
    controlHeightSM,
    controlHeightLG,
    paddingXXS,
    lineWidth
  } = token2, dblPaddingXXS = paddingXXS * 2, dblLineWidth = lineWidth * 2, multipleItemHeight = Math.min(controlHeight - dblPaddingXXS, controlHeight - dblLineWidth), multipleItemHeightSM = Math.min(controlHeightSM - dblPaddingXXS, controlHeightSM - dblLineWidth), multipleItemHeightLG = Math.min(controlHeightLG - dblPaddingXXS, controlHeightLG - dblLineWidth);
  return {
    INTERNAL_FIXED_ITEM_MARGIN: Math.floor(paddingXXS / 2),
    cellHoverBg: token2.controlItemBgHover,
    cellActiveWithRangeBg: token2.controlItemBgActive,
    cellHoverWithRangeBg: new TinyColor(token2.colorPrimary).lighten(35).toHexString(),
    cellRangeBorderColor: new TinyColor(token2.colorPrimary).lighten(20).toHexString(),
    cellBgDisabled: colorBgContainerDisabled,
    timeColumnWidth: controlHeightLG * 1.4,
    timeColumnHeight: 28 * 8,
    timeCellHeight: 28,
    cellWidth: controlHeightSM * 1.5,
    cellHeight: controlHeightSM,
    textHeight: controlHeightLG,
    withoutTimeCellHeight: controlHeightLG * 1.65,
    multipleItemBg: token2.colorFillSecondary,
    multipleItemBorderColor: "transparent",
    multipleItemHeight,
    multipleItemHeightSM,
    multipleItemHeightLG,
    multipleSelectorBgDisabled: colorBgContainerDisabled,
    multipleItemColorDisabled: token2.colorTextDisabled,
    multipleItemBorderColorDisabled: "transparent"
  };
}, "initPanelComponentToken"), prepareComponentToken$d = /* @__PURE__ */ __name((token2) => Object.assign(Object.assign(Object.assign(Object.assign({}, initComponentToken$1(token2)), initPanelComponentToken(token2)), getArrowToken(token2)), {
  presetsWidth: 120,
  presetsMaxWidth: 200,
  zIndexPopup: token2.zIndexPopupBase + 50
}), "prepareComponentToken$d"), genVariantsStyle = /* @__PURE__ */ __name((token2) => {
  const {
    componentCls
  } = token2;
  return {
    [componentCls]: [
      Object.assign(Object.assign(Object.assign({}, genOutlinedStyle(token2)), genFilledStyle(token2)), genBorderlessStyle(token2)),
      // ========================= Multiple =========================
      {
        "&-outlined": {
          [`&${componentCls}-multiple ${componentCls}-selection-item`]: {
            background: token2.multipleItemBg,
            border: `${unit$1(token2.lineWidth)} ${token2.lineType} ${token2.multipleItemBorderColor}`
          }
        },
        "&-filled": {
          [`&${componentCls}-multiple ${componentCls}-selection-item`]: {
            background: token2.colorBgContainer,
            border: `${unit$1(token2.lineWidth)} ${token2.lineType} ${token2.colorSplit}`
          }
        },
        "&-borderless": {
          [`&${componentCls}-multiple ${componentCls}-selection-item`]: {
            background: token2.multipleItemBg,
            border: `${unit$1(token2.lineWidth)} ${token2.lineType} ${token2.multipleItemBorderColor}`
          }
        }
      }
    ]
  };
}, "genVariantsStyle"), genPickerPadding = /* @__PURE__ */ __name((token2, inputHeight, fontHeight, paddingHorizontal) => {
  const height = token2.calc(fontHeight).add(2).equal(), paddingTop = token2.max(token2.calc(inputHeight).sub(height).div(2).equal(), 0), paddingBottom = token2.max(token2.calc(inputHeight).sub(height).sub(paddingTop).equal(), 0);
  return {
    padding: `${unit$1(paddingTop)} ${unit$1(paddingHorizontal)} ${unit$1(paddingBottom)}`
  };
}, "genPickerPadding"), genPickerStatusStyle = /* @__PURE__ */ __name((token2) => {
  const {
    componentCls,
    colorError,
    colorWarning
  } = token2;
  return {
    [`${componentCls}:not(${componentCls}-disabled):not([disabled])`]: {
      [`&${componentCls}-status-error`]: {
        [`${componentCls}-active-bar`]: {
          background: colorError
        }
      },
      [`&${componentCls}-status-warning`]: {
        [`${componentCls}-active-bar`]: {
          background: colorWarning
        }
      }
    }
  };
}, "genPickerStatusStyle"), genPickerStyle = /* @__PURE__ */ __name((token2) => {
  const {
    componentCls,
    antCls,
    controlHeight,
    paddingInline,
    lineWidth,
    lineType,
    colorBorder,
    borderRadius,
    motionDurationMid,
    colorTextDisabled,
    colorTextPlaceholder,
    controlHeightLG,
    fontSizeLG,
    controlHeightSM,
    paddingInlineSM,
    paddingXS,
    marginXS,
    colorTextDescription,
    lineWidthBold,
    colorPrimary,
    motionDurationSlow,
    zIndexPopup,
    paddingXXS,
    sizePopupArrow,
    colorBgElevated,
    borderRadiusLG,
    boxShadowSecondary,
    borderRadiusSM,
    colorSplit,
    cellHoverBg,
    presetsWidth,
    presetsMaxWidth,
    boxShadowPopoverArrow,
    fontHeight,
    fontHeightLG,
    lineHeightLG
  } = token2;
  return [
    {
      [componentCls]: Object.assign(Object.assign(Object.assign({}, resetComponent(token2)), genPickerPadding(token2, controlHeight, fontHeight, paddingInline)), {
        position: "relative",
        display: "inline-flex",
        alignItems: "center",
        lineHeight: 1,
        borderRadius,
        transition: `border ${motionDurationMid}, box-shadow ${motionDurationMid}, background ${motionDurationMid}`,
        [`${componentCls}-prefix`]: {
          marginInlineEnd: token2.inputAffixPadding
        },
        // ======================== Input =========================
        [`${componentCls}-input`]: {
          position: "relative",
          display: "inline-flex",
          alignItems: "center",
          width: "100%",
          "> input": Object.assign(Object.assign({
            position: "relative",
            display: "inline-block",
            width: "100%",
            color: "inherit",
            fontSize: token2.fontSize,
            lineHeight: token2.lineHeight,
            transition: `all ${motionDurationMid}`
          }, genPlaceholderStyle(colorTextPlaceholder)), {
            flex: "auto",
            // Fix Firefox flex not correct:
            // https://github.com/ant-design/ant-design/pull/20023#issuecomment-564389553
            minWidth: 1,
            height: "auto",
            padding: 0,
            background: "transparent",
            border: 0,
            fontFamily: "inherit",
            "&:focus": {
              boxShadow: "none",
              outline: 0
            },
            "&[disabled]": {
              background: "transparent",
              color: colorTextDisabled,
              cursor: "not-allowed"
            }
          }),
          "&-placeholder": {
            "> input": {
              color: colorTextPlaceholder
            }
          }
        },
        // Size
        "&-large": Object.assign(Object.assign({}, genPickerPadding(token2, controlHeightLG, fontHeightLG, paddingInline)), {
          [`${componentCls}-input > input`]: {
            fontSize: fontSizeLG,
            lineHeight: lineHeightLG
          }
        }),
        "&-small": Object.assign({}, genPickerPadding(token2, controlHeightSM, fontHeight, paddingInlineSM)),
        [`${componentCls}-suffix`]: {
          display: "flex",
          flex: "none",
          alignSelf: "center",
          marginInlineStart: token2.calc(paddingXS).div(2).equal(),
          color: colorTextDisabled,
          lineHeight: 1,
          pointerEvents: "none",
          transition: `opacity ${motionDurationMid}, color ${motionDurationMid}`,
          "> *": {
            verticalAlign: "top",
            "&:not(:last-child)": {
              marginInlineEnd: marginXS
            }
          }
        },
        [`${componentCls}-clear`]: {
          position: "absolute",
          top: "50%",
          insetInlineEnd: 0,
          color: colorTextDisabled,
          lineHeight: 1,
          transform: "translateY(-50%)",
          cursor: "pointer",
          opacity: 0,
          transition: `opacity ${motionDurationMid}, color ${motionDurationMid}`,
          "> *": {
            verticalAlign: "top"
          },
          "&:hover": {
            color: colorTextDescription
          }
        },
        "&:hover": {
          [`${componentCls}-clear`]: {
            opacity: 1
          },
          // Should use the following selector, but since `:has` has poor compatibility,
          // we use `:not(:last-child)` instead, which may cause some problems in some cases.
          // [`${componentCls}-suffix:has(+ ${componentCls}-clear)`]: {
          [`${componentCls}-suffix:not(:last-child)`]: {
            opacity: 0
          }
        },
        [`${componentCls}-separator`]: {
          position: "relative",
          display: "inline-block",
          width: "1em",
          height: fontSizeLG,
          color: colorTextDisabled,
          fontSize: fontSizeLG,
          verticalAlign: "top",
          cursor: "default",
          [`${componentCls}-focused &`]: {
            color: colorTextDescription
          },
          [`${componentCls}-range-separator &`]: {
            [`${componentCls}-disabled &`]: {
              cursor: "not-allowed"
            }
          }
        },
        // ======================== Range =========================
        "&-range": {
          position: "relative",
          display: "inline-flex",
          // Active bar
          [`${componentCls}-active-bar`]: {
            bottom: token2.calc(lineWidth).mul(-1).equal(),
            height: lineWidthBold,
            background: colorPrimary,
            opacity: 0,
            transition: `all ${motionDurationSlow} ease-out`,
            pointerEvents: "none"
          },
          [`&${componentCls}-focused`]: {
            [`${componentCls}-active-bar`]: {
              opacity: 1
            }
          },
          [`${componentCls}-range-separator`]: {
            alignItems: "center",
            padding: `0 ${unit$1(paddingXS)}`,
            lineHeight: 1
          }
        },
        // ======================== Clear =========================
        "&-range, &-multiple": {
          // Clear
          [`${componentCls}-clear`]: {
            insetInlineEnd: paddingInline
          },
          [`&${componentCls}-small`]: {
            [`${componentCls}-clear`]: {
              insetInlineEnd: paddingInlineSM
            }
          }
        },
        // ======================= Dropdown =======================
        "&-dropdown": Object.assign(Object.assign(Object.assign({}, resetComponent(token2)), genPanelStyle(token2)), {
          pointerEvents: "none",
          position: "absolute",
          // Fix incorrect position of picker popup
          // https://github.com/ant-design/ant-design/issues/35590
          top: -9999,
          left: {
            _skip_check_: !0,
            value: -9999
          },
          zIndex: zIndexPopup,
          [`&${componentCls}-dropdown-hidden`]: {
            display: "none"
          },
          "&-rtl": {
            direction: "rtl"
          },
          [`&${componentCls}-dropdown-placement-bottomLeft,
            &${componentCls}-dropdown-placement-bottomRight`]: {
            [`${componentCls}-range-arrow`]: {
              top: 0,
              display: "block",
              transform: "translateY(-100%)"
            }
          },
          [`&${componentCls}-dropdown-placement-topLeft,
            &${componentCls}-dropdown-placement-topRight`]: {
            [`${componentCls}-range-arrow`]: {
              bottom: 0,
              display: "block",
              transform: "translateY(100%) rotate(180deg)"
            }
          },
          [`&${antCls}-slide-up-enter${antCls}-slide-up-enter-active${componentCls}-dropdown-placement-topLeft,
          &${antCls}-slide-up-enter${antCls}-slide-up-enter-active${componentCls}-dropdown-placement-topRight,
          &${antCls}-slide-up-appear${antCls}-slide-up-appear-active${componentCls}-dropdown-placement-topLeft,
          &${antCls}-slide-up-appear${antCls}-slide-up-appear-active${componentCls}-dropdown-placement-topRight`]: {
            animationName: slideDownIn
          },
          [`&${antCls}-slide-up-enter${antCls}-slide-up-enter-active${componentCls}-dropdown-placement-bottomLeft,
          &${antCls}-slide-up-enter${antCls}-slide-up-enter-active${componentCls}-dropdown-placement-bottomRight,
          &${antCls}-slide-up-appear${antCls}-slide-up-appear-active${componentCls}-dropdown-placement-bottomLeft,
          &${antCls}-slide-up-appear${antCls}-slide-up-appear-active${componentCls}-dropdown-placement-bottomRight`]: {
            animationName: slideUpIn
          },
          // https://github.com/ant-design/ant-design/issues/48727
          [`&${antCls}-slide-up-leave ${componentCls}-panel-container`]: {
            pointerEvents: "none"
          },
          [`&${antCls}-slide-up-leave${antCls}-slide-up-leave-active${componentCls}-dropdown-placement-topLeft,
          &${antCls}-slide-up-leave${antCls}-slide-up-leave-active${componentCls}-dropdown-placement-topRight`]: {
            animationName: slideDownOut
          },
          [`&${antCls}-slide-up-leave${antCls}-slide-up-leave-active${componentCls}-dropdown-placement-bottomLeft,
          &${antCls}-slide-up-leave${antCls}-slide-up-leave-active${componentCls}-dropdown-placement-bottomRight`]: {
            animationName: slideUpOut
          },
          // Time picker with additional style
          [`${componentCls}-panel > ${componentCls}-time-panel`]: {
            paddingTop: paddingXXS
          },
          // ======================== Ranges ========================
          [`${componentCls}-range-wrapper`]: {
            display: "flex",
            position: "relative"
          },
          [`${componentCls}-range-arrow`]: Object.assign(Object.assign({
            position: "absolute",
            zIndex: 1,
            display: "none",
            paddingInline: token2.calc(paddingInline).mul(1.5).equal(),
            boxSizing: "content-box",
            transition: `all ${motionDurationSlow} ease-out`
          }, genRoundedArrow(token2, colorBgElevated, boxShadowPopoverArrow)), {
            "&:before": {
              insetInlineStart: token2.calc(paddingInline).mul(1.5).equal()
            }
          }),
          [`${componentCls}-panel-container`]: {
            overflow: "hidden",
            verticalAlign: "top",
            background: colorBgElevated,
            borderRadius: borderRadiusLG,
            boxShadow: boxShadowSecondary,
            transition: `margin ${motionDurationSlow}`,
            display: "inline-block",
            pointerEvents: "auto",
            // ======================== Layout ========================
            [`${componentCls}-panel-layout`]: {
              display: "flex",
              flexWrap: "nowrap",
              alignItems: "stretch"
            },
            // ======================== Preset ========================
            [`${componentCls}-presets`]: {
              display: "flex",
              flexDirection: "column",
              minWidth: presetsWidth,
              maxWidth: presetsMaxWidth,
              ul: {
                height: 0,
                flex: "auto",
                listStyle: "none",
                overflow: "auto",
                margin: 0,
                padding: paddingXS,
                borderInlineEnd: `${unit$1(lineWidth)} ${lineType} ${colorSplit}`,
                li: Object.assign(Object.assign({}, textEllipsis), {
                  borderRadius: borderRadiusSM,
                  paddingInline: paddingXS,
                  paddingBlock: token2.calc(controlHeightSM).sub(fontHeight).div(2).equal(),
                  cursor: "pointer",
                  transition: `all ${motionDurationSlow}`,
                  "+ li": {
                    marginTop: marginXS
                  },
                  "&:hover": {
                    background: cellHoverBg
                  }
                })
              }
            },
            // ======================== Panels ========================
            [`${componentCls}-panels`]: {
              display: "inline-flex",
              flexWrap: "nowrap",
              // [`${componentCls}-panel`]: {
              //   borderWidth: `0 0 ${unit(lineWidth)}`,
              // },
              "&:last-child": {
                [`${componentCls}-panel`]: {
                  borderWidth: 0
                }
              }
            },
            [`${componentCls}-panel`]: {
              verticalAlign: "top",
              background: "transparent",
              borderRadius: 0,
              borderWidth: 0,
              [`${componentCls}-content, table`]: {
                textAlign: "center"
              },
              "&-focused": {
                borderColor: colorBorder
              }
            }
          }
        }),
        "&-dropdown-range": {
          padding: `${unit$1(token2.calc(sizePopupArrow).mul(2).div(3).equal())} 0`,
          "&-hidden": {
            display: "none"
          }
        },
        "&-rtl": {
          direction: "rtl",
          [`${componentCls}-separator`]: {
            transform: "rotate(180deg)"
          },
          [`${componentCls}-footer`]: {
            "&-extra": {
              direction: "rtl"
            }
          }
        }
      })
    },
    // Follow code may reuse in other components
    initSlideMotion(token2, "slide-up"),
    initSlideMotion(token2, "slide-down"),
    initMoveMotion(token2, "move-up"),
    initMoveMotion(token2, "move-down")
  ];
}, "genPickerStyle"), useStyle$f = genStyleHooks("DatePicker", (token2) => {
  const pickerToken = merge(initInputToken(token2), initPickerPanelToken(token2), {
    inputPaddingHorizontalBase: token2.calc(token2.paddingSM).sub(1).equal(),
    multipleSelectItemHeight: token2.multipleItemHeight,
    selectHeight: token2.controlHeight
  });
  return [
    genPickerPanelStyle(pickerToken),
    genPickerStyle(pickerToken),
    genVariantsStyle(pickerToken),
    genPickerStatusStyle(pickerToken),
    genPickerMultipleStyle(pickerToken),
    // =====================================================
    // ==             Space Compact                       ==
    // =====================================================
    genCompactItemStyle(token2, {
      focusElCls: `${token2.componentCls}-focused`
    })
  ];
}, prepareComponentToken$d);
var PlusOutlined$1 = { icon: { tag: "svg", attrs: { viewBox: "64 64 896 896", focusable: "false" }, children: [{ tag: "path", attrs: { d: "M482 152h60q8 0 8 8v704q0 8-8 8h-60q-8 0-8-8V160q0-8 8-8z" } }, { tag: "path", attrs: { d: "M192 474h672q8 0 8 8v60q0 8-8 8H160q-8 0-8-8v-60q0-8 8-8z" } }] }, name: "plus", theme: "outlined" }, PlusOutlined = /* @__PURE__ */ __name(function(props, ref) {
  return /* @__PURE__ */ React.createElement(Icon$3, _extends({}, props, {
    ref,
    icon: PlusOutlined$1
  }));
}, "PlusOutlined"), RefIcon$r = /* @__PURE__ */ React.forwardRef(PlusOutlined);
process.env.NODE_ENV !== "production" && (RefIcon$r.displayName = "PlusOutlined");
const TabContext = /* @__PURE__ */ createContext$1(null);
var useIndicator = /* @__PURE__ */ __name(function(options) {
  var activeTabOffset = options.activeTabOffset, horizontal = options.horizontal, rtl = options.rtl, _options$indicator = options.indicator, indicator = _options$indicator === void 0 ? {} : _options$indicator, size = indicator.size, _indicator$align = indicator.align, align = _indicator$align === void 0 ? "center" : _indicator$align, _useState = useState(), _useState2 = _slicedToArray(_useState, 2), inkStyle = _useState2[0], setInkStyle = _useState2[1], inkBarRafRef = useRef(), getLength = React__default.useCallback(function(origin) {
    return typeof size == "function" ? size(origin) : typeof size == "number" ? size : origin;
  }, [size]);
  function cleanInkBarRaf() {
    wrapperRaf.cancel(inkBarRafRef.current);
  }
  return __name(cleanInkBarRaf, "cleanInkBarRaf"), useEffect(function() {
    var newInkStyle = {};
    if (activeTabOffset)
      if (horizontal) {
        newInkStyle.width = getLength(activeTabOffset.width);
        var key = rtl ? "right" : "left";
        align === "start" && (newInkStyle[key] = activeTabOffset[key]), align === "center" && (newInkStyle[key] = activeTabOffset[key] + activeTabOffset.width / 2, newInkStyle.transform = rtl ? "translateX(50%)" : "translateX(-50%)"), align === "end" && (newInkStyle[key] = activeTabOffset[key] + activeTabOffset.width, newInkStyle.transform = "translateX(-100%)");
      } else
        newInkStyle.height = getLength(activeTabOffset.height), align === "start" && (newInkStyle.top = activeTabOffset.top), align === "center" && (newInkStyle.top = activeTabOffset.top + activeTabOffset.height / 2, newInkStyle.transform = "translateY(-50%)"), align === "end" && (newInkStyle.top = activeTabOffset.top + activeTabOffset.height, newInkStyle.transform = "translateY(-100%)");
    return cleanInkBarRaf(), inkBarRafRef.current = wrapperRaf(function() {
      setInkStyle(newInkStyle);
    }), cleanInkBarRaf;
  }, [activeTabOffset, horizontal, rtl, align, getLength]), {
    style: inkStyle
  };
}, "useIndicator"), DEFAULT_SIZE$1 = {
  width: 0,
  height: 0,
  left: 0,
  top: 0
};
function useOffsets(tabs, tabSizes, holderScrollWidth) {
  return useMemo$1(function() {
    for (var _tabs$, map = /* @__PURE__ */ new Map(), lastOffset = tabSizes.get((_tabs$ = tabs[0]) === null || _tabs$ === void 0 ? void 0 : _tabs$.key) || DEFAULT_SIZE$1, rightOffset = lastOffset.left + lastOffset.width, i = 0; i < tabs.length; i += 1) {
      var key = tabs[i].key, data = tabSizes.get(key);
      if (!data) {
        var _tabs;
        data = tabSizes.get((_tabs = tabs[i - 1]) === null || _tabs === void 0 ? void 0 : _tabs.key) || DEFAULT_SIZE$1;
      }
      var entity = map.get(key) || _objectSpread2$1({}, data);
      entity.right = rightOffset - entity.left - entity.width, map.set(key, entity);
    }
    return map;
  }, [tabs.map(function(tab) {
    return tab.key;
  }).join("_"), tabSizes, holderScrollWidth]);
}
__name(useOffsets, "useOffsets");
function useSyncState$1(defaultState, onChange) {
  var stateRef = React.useRef(defaultState), _React$useState = React.useState({}), _React$useState2 = _slicedToArray(_React$useState, 2), forceUpdate = _React$useState2[1];
  function setState(updater) {
    var newValue = typeof updater == "function" ? updater(stateRef.current) : updater;
    newValue !== stateRef.current && onChange(newValue, stateRef.current), stateRef.current = newValue, forceUpdate({});
  }
  return __name(setState, "setState"), [stateRef.current, setState];
}
__name(useSyncState$1, "useSyncState$1");
var MIN_SWIPE_DISTANCE = 0.1, STOP_SWIPE_DISTANCE = 0.01, REFRESH_INTERVAL = 20, SPEED_OFF_MULTIPLE = Math.pow(0.995, REFRESH_INTERVAL);
function useTouchMove(ref, onOffset) {
  var _useState = useState(), _useState2 = _slicedToArray(_useState, 2), touchPosition = _useState2[0], setTouchPosition = _useState2[1], _useState3 = useState(0), _useState4 = _slicedToArray(_useState3, 2), lastTimestamp = _useState4[0], setLastTimestamp = _useState4[1], _useState5 = useState(0), _useState6 = _slicedToArray(_useState5, 2), lastTimeDiff = _useState6[0], setLastTimeDiff = _useState6[1], _useState7 = useState(), _useState8 = _slicedToArray(_useState7, 2), lastOffset = _useState8[0], setLastOffset = _useState8[1], motionRef = useRef();
  function onTouchStart(e2) {
    var _e$touches$ = e2.touches[0], screenX = _e$touches$.screenX, screenY = _e$touches$.screenY;
    setTouchPosition({
      x: screenX,
      y: screenY
    }), window.clearInterval(motionRef.current);
  }
  __name(onTouchStart, "onTouchStart");
  function onTouchMove(e2) {
    if (touchPosition) {
      var _e$touches$2 = e2.touches[0], screenX = _e$touches$2.screenX, screenY = _e$touches$2.screenY;
      setTouchPosition({
        x: screenX,
        y: screenY
      });
      var offsetX = screenX - touchPosition.x, offsetY = screenY - touchPosition.y;
      onOffset(offsetX, offsetY);
      var now2 = Date.now();
      setLastTimestamp(now2), setLastTimeDiff(now2 - lastTimestamp), setLastOffset({
        x: offsetX,
        y: offsetY
      });
    }
  }
  __name(onTouchMove, "onTouchMove");
  function onTouchEnd() {
    if (touchPosition && (setTouchPosition(null), setLastOffset(null), lastOffset)) {
      var distanceX = lastOffset.x / lastTimeDiff, distanceY = lastOffset.y / lastTimeDiff, absX = Math.abs(distanceX), absY = Math.abs(distanceY);
      if (Math.max(absX, absY) < MIN_SWIPE_DISTANCE) return;
      var currentX = distanceX, currentY = distanceY;
      motionRef.current = window.setInterval(function() {
        if (Math.abs(currentX) < STOP_SWIPE_DISTANCE && Math.abs(currentY) < STOP_SWIPE_DISTANCE) {
          window.clearInterval(motionRef.current);
          return;
        }
        currentX *= SPEED_OFF_MULTIPLE, currentY *= SPEED_OFF_MULTIPLE, onOffset(currentX * REFRESH_INTERVAL, currentY * REFRESH_INTERVAL);
      }, REFRESH_INTERVAL);
    }
  }
  __name(onTouchEnd, "onTouchEnd");
  var lastWheelDirectionRef = useRef();
  function onWheel(e2) {
    var deltaX = e2.deltaX, deltaY = e2.deltaY, mixed = 0, absX = Math.abs(deltaX), absY = Math.abs(deltaY);
    absX === absY ? mixed = lastWheelDirectionRef.current === "x" ? deltaX : deltaY : absX > absY ? (mixed = deltaX, lastWheelDirectionRef.current = "x") : (mixed = deltaY, lastWheelDirectionRef.current = "y"), onOffset(-mixed, -mixed) && e2.preventDefault();
  }
  __name(onWheel, "onWheel");
  var touchEventsRef = useRef(null);
  touchEventsRef.current = {
    onTouchStart,
    onTouchMove,
    onTouchEnd,
    onWheel
  }, React.useEffect(function() {
    function onProxyTouchStart(e2) {
      touchEventsRef.current.onTouchStart(e2);
    }
    __name(onProxyTouchStart, "onProxyTouchStart");
    function onProxyTouchMove(e2) {
      touchEventsRef.current.onTouchMove(e2);
    }
    __name(onProxyTouchMove, "onProxyTouchMove");
    function onProxyTouchEnd(e2) {
      touchEventsRef.current.onTouchEnd(e2);
    }
    __name(onProxyTouchEnd, "onProxyTouchEnd");
    function onProxyWheel(e2) {
      touchEventsRef.current.onWheel(e2);
    }
    return __name(onProxyWheel, "onProxyWheel"), document.addEventListener("touchmove", onProxyTouchMove, {
      passive: !1
    }), document.addEventListener("touchend", onProxyTouchEnd, {
      passive: !0
    }), ref.current.addEventListener("touchstart", onProxyTouchStart, {
      passive: !0
    }), ref.current.addEventListener("wheel", onProxyWheel, {
      passive: !1
    }), function() {
      document.removeEventListener("touchmove", onProxyTouchMove), document.removeEventListener("touchend", onProxyTouchEnd);
    };
  }, []);
}
__name(useTouchMove, "useTouchMove");
function useUpdate(callback) {
  var _useState = useState(0), _useState2 = _slicedToArray(_useState, 2), count = _useState2[0], setCount = _useState2[1], effectRef = useRef(0), callbackRef = useRef();
  return callbackRef.current = callback, useLayoutUpdateEffect(function() {
    var _callbackRef$current;
    (_callbackRef$current = callbackRef.current) === null || _callbackRef$current === void 0 || _callbackRef$current.call(callbackRef);
  }, [count]), function() {
    effectRef.current === count && (effectRef.current += 1, setCount(effectRef.current));
  };
}
__name(useUpdate, "useUpdate");
function useUpdateState(defaultState) {
  var batchRef = useRef([]), _useState3 = useState({}), _useState4 = _slicedToArray(_useState3, 2), forceUpdate = _useState4[1], state = useRef(typeof defaultState == "function" ? defaultState() : defaultState), flushUpdate = useUpdate(function() {
    var current = state.current;
    batchRef.current.forEach(function(callback) {
      current = callback(current);
    }), batchRef.current = [], state.current = current, forceUpdate({});
  });
  function updater(callback) {
    batchRef.current.push(callback), flushUpdate();
  }
  return __name(updater, "updater"), [state.current, updater];
}
__name(useUpdateState, "useUpdateState");
var DEFAULT_SIZE = {
  width: 0,
  height: 0,
  left: 0,
  top: 0,
  right: 0
};
function useVisibleRange(tabOffsets, visibleTabContentValue, transform, tabContentSizeValue, addNodeSizeValue, operationNodeSizeValue, _ref) {
  var tabs = _ref.tabs, tabPosition = _ref.tabPosition, rtl = _ref.rtl, charUnit, position2, transformSize;
  return ["top", "bottom"].includes(tabPosition) ? (charUnit = "width", position2 = rtl ? "right" : "left", transformSize = Math.abs(transform)) : (charUnit = "height", position2 = "top", transformSize = -transform), useMemo$1(function() {
    if (!tabs.length)
      return [0, 0];
    for (var len = tabs.length, endIndex = len, i = 0; i < len; i += 1) {
      var offset2 = tabOffsets.get(tabs[i].key) || DEFAULT_SIZE;
      if (Math.floor(offset2[position2] + offset2[charUnit]) > Math.floor(transformSize + visibleTabContentValue)) {
        endIndex = i - 1;
        break;
      }
    }
    for (var startIndex = 0, _i = len - 1; _i >= 0; _i -= 1) {
      var _offset = tabOffsets.get(tabs[_i].key) || DEFAULT_SIZE;
      if (_offset[position2] < transformSize) {
        startIndex = _i + 1;
        break;
      }
    }
    return startIndex >= endIndex ? [0, 0] : [startIndex, endIndex];
  }, [tabOffsets, visibleTabContentValue, tabContentSizeValue, addNodeSizeValue, operationNodeSizeValue, transformSize, tabPosition, tabs.map(function(tab) {
    return tab.key;
  }).join("_"), rtl]);
}
__name(useVisibleRange, "useVisibleRange");
function stringify(obj) {
  var tgt;
  return obj instanceof Map ? (tgt = {}, obj.forEach(function(v, k) {
    tgt[k] = v;
  })) : tgt = obj, JSON.stringify(tgt);
}
__name(stringify, "stringify");
var RC_TABS_DOUBLE_QUOTE = "TABS_DQ";
function genDataNodeKey(key) {
  return String(key).replace(/"/g, RC_TABS_DOUBLE_QUOTE);
}
__name(genDataNodeKey, "genDataNodeKey");
function getRemovable(closable, closeIcon, editable, disabled) {
  return (
    // Only editable tabs can be removed
    !(!editable || // Tabs cannot be removed when disabled
    disabled || // closable is false
    closable === !1 || // If closable is undefined, the remove button should be hidden when closeIcon is null or false
    closable === void 0 && (closeIcon === !1 || closeIcon === null))
  );
}
__name(getRemovable, "getRemovable");
var AddButton = /* @__PURE__ */ React.forwardRef(function(props, ref) {
  var prefixCls = props.prefixCls, editable = props.editable, locale2 = props.locale, style2 = props.style;
  return !editable || editable.showAdd === !1 ? null : /* @__PURE__ */ React.createElement("button", {
    ref,
    type: "button",
    className: "".concat(prefixCls, "-nav-add"),
    style: style2,
    "aria-label": (locale2 == null ? void 0 : locale2.addAriaLabel) || "Add tab",
    onClick: /* @__PURE__ */ __name(function(event) {
      editable.onEdit("add", {
        event
      });
    }, "onClick")
  }, editable.addIcon || "+");
}), ExtraContent = /* @__PURE__ */ React.forwardRef(function(props, ref) {
  var position2 = props.position, prefixCls = props.prefixCls, extra = props.extra;
  if (!extra)
    return null;
  var content, assertExtra = {};
  return _typeof$4(extra) === "object" && !/* @__PURE__ */ React.isValidElement(extra) ? assertExtra = extra : assertExtra.right = extra, position2 === "right" && (content = assertExtra.right), position2 === "left" && (content = assertExtra.left), content ? /* @__PURE__ */ React.createElement("div", {
    className: "".concat(prefixCls, "-extra-content"),
    ref
  }, content) : null;
});
process.env.NODE_ENV !== "production" && (ExtraContent.displayName = "ExtraContent");
var OperationNode = /* @__PURE__ */ React.forwardRef(function(props, ref) {
  var prefixCls = props.prefixCls, id2 = props.id, tabs = props.tabs, locale2 = props.locale, mobile = props.mobile, _props$more = props.more, moreProps = _props$more === void 0 ? {} : _props$more, style2 = props.style, className = props.className, editable = props.editable, tabBarGutter = props.tabBarGutter, rtl = props.rtl, removeAriaLabel = props.removeAriaLabel, onTabClick = props.onTabClick, getPopupContainer = props.getPopupContainer, popupClassName = props.popupClassName, _useState = useState(!1), _useState2 = _slicedToArray(_useState, 2), open = _useState2[0], setOpen = _useState2[1], _useState3 = useState(null), _useState4 = _slicedToArray(_useState3, 2), selectedKey = _useState4[0], setSelectedKey = _useState4[1], _moreProps$icon = moreProps.icon, moreIcon = _moreProps$icon === void 0 ? "More" : _moreProps$icon, popupId = "".concat(id2, "-more-popup"), dropdownPrefix = "".concat(prefixCls, "-dropdown"), selectedItemId = selectedKey !== null ? "".concat(popupId, "-").concat(selectedKey) : null, dropdownAriaLabel = locale2 == null ? void 0 : locale2.dropdownAriaLabel;
  function onRemoveTab(event, key) {
    event.preventDefault(), event.stopPropagation(), editable.onEdit("remove", {
      key,
      event
    });
  }
  __name(onRemoveTab, "onRemoveTab");
  var menu = /* @__PURE__ */ React.createElement(ExportMenu, {
    onClick: /* @__PURE__ */ __name(function(_ref) {
      var key = _ref.key, domEvent = _ref.domEvent;
      onTabClick(key, domEvent), setOpen(!1);
    }, "onClick"),
    prefixCls: "".concat(dropdownPrefix, "-menu"),
    id: popupId,
    tabIndex: -1,
    role: "listbox",
    "aria-activedescendant": selectedItemId,
    selectedKeys: [selectedKey],
    "aria-label": dropdownAriaLabel !== void 0 ? dropdownAriaLabel : "expanded dropdown"
  }, tabs.map(function(tab) {
    var closable = tab.closable, disabled = tab.disabled, closeIcon = tab.closeIcon, key = tab.key, label2 = tab.label, removable = getRemovable(closable, closeIcon, editable, disabled);
    return /* @__PURE__ */ React.createElement(MenuItem$2, {
      key,
      id: "".concat(popupId, "-").concat(key),
      role: "option",
      "aria-controls": id2 && "".concat(id2, "-panel-").concat(key),
      disabled
    }, /* @__PURE__ */ React.createElement("span", null, label2), removable && /* @__PURE__ */ React.createElement("button", {
      type: "button",
      "aria-label": removeAriaLabel || "remove",
      tabIndex: 0,
      className: "".concat(dropdownPrefix, "-menu-item-remove"),
      onClick: /* @__PURE__ */ __name(function(e2) {
        e2.stopPropagation(), onRemoveTab(e2, key);
      }, "onClick")
    }, closeIcon || editable.removeIcon || "×"));
  }));
  function selectOffset(offset2) {
    for (var enabledTabs = tabs.filter(function(tab2) {
      return !tab2.disabled;
    }), selectedIndex = enabledTabs.findIndex(function(tab2) {
      return tab2.key === selectedKey;
    }) || 0, len = enabledTabs.length, i = 0; i < len; i += 1) {
      selectedIndex = (selectedIndex + offset2 + len) % len;
      var tab = enabledTabs[selectedIndex];
      if (!tab.disabled) {
        setSelectedKey(tab.key);
        return;
      }
    }
  }
  __name(selectOffset, "selectOffset");
  function onKeyDown2(e2) {
    var which = e2.which;
    if (!open) {
      [KeyCode.DOWN, KeyCode.SPACE, KeyCode.ENTER].includes(which) && (setOpen(!0), e2.preventDefault());
      return;
    }
    switch (which) {
      case KeyCode.UP:
        selectOffset(-1), e2.preventDefault();
        break;
      case KeyCode.DOWN:
        selectOffset(1), e2.preventDefault();
        break;
      case KeyCode.ESC:
        setOpen(!1);
        break;
      case KeyCode.SPACE:
      case KeyCode.ENTER:
        selectedKey !== null && onTabClick(selectedKey, e2);
        break;
    }
  }
  __name(onKeyDown2, "onKeyDown"), useEffect(function() {
    var ele = document.getElementById(selectedItemId);
    ele && ele.scrollIntoView && ele.scrollIntoView(!1);
  }, [selectedKey]), useEffect(function() {
    open || setSelectedKey(null);
  }, [open]);
  var moreStyle = _defineProperty$2({}, rtl ? "marginRight" : "marginLeft", tabBarGutter);
  tabs.length || (moreStyle.visibility = "hidden", moreStyle.order = 1);
  var overlayClassName = cn(_defineProperty$2({}, "".concat(dropdownPrefix, "-rtl"), rtl)), moreNode = mobile ? null : /* @__PURE__ */ React.createElement(Dropdown$3, _extends({
    prefixCls: dropdownPrefix,
    overlay: menu,
    visible: tabs.length ? open : !1,
    onVisibleChange: setOpen,
    overlayClassName: cn(overlayClassName, popupClassName),
    mouseEnterDelay: 0.1,
    mouseLeaveDelay: 0.1,
    getPopupContainer
  }, moreProps), /* @__PURE__ */ React.createElement("button", {
    type: "button",
    className: "".concat(prefixCls, "-nav-more"),
    style: moreStyle,
    tabIndex: -1,
    "aria-hidden": "true",
    "aria-haspopup": "listbox",
    "aria-controls": popupId,
    id: "".concat(id2, "-more"),
    "aria-expanded": open,
    onKeyDown: onKeyDown2
  }, moreIcon));
  return /* @__PURE__ */ React.createElement("div", {
    className: cn("".concat(prefixCls, "-nav-operations"), className),
    style: style2,
    ref
  }, moreNode, /* @__PURE__ */ React.createElement(AddButton, {
    prefixCls,
    locale: locale2,
    editable
  }));
});
const OperationNode$1 = /* @__PURE__ */ React.memo(OperationNode, function(_2, next2) {
  return (
    // https://github.com/ant-design/ant-design/issues/32544
    // We'd better remove syntactic sugar in `rc-menu` since this has perf issue
    next2.tabMoving
  );
});
var TabNode = /* @__PURE__ */ __name(function(props) {
  var prefixCls = props.prefixCls, id2 = props.id, active = props.active, _props$tab = props.tab, key = _props$tab.key, label2 = _props$tab.label, disabled = _props$tab.disabled, closeIcon = _props$tab.closeIcon, icon = _props$tab.icon, closable = props.closable, renderWrapper = props.renderWrapper, removeAriaLabel = props.removeAriaLabel, editable = props.editable, onClick = props.onClick, onFocus = props.onFocus, style2 = props.style, tabPrefix = "".concat(prefixCls, "-tab"), removable = getRemovable(closable, closeIcon, editable, disabled);
  function onInternalClick(e2) {
    disabled || onClick(e2);
  }
  __name(onInternalClick, "onInternalClick");
  function onRemoveTab(event) {
    event.preventDefault(), event.stopPropagation(), editable.onEdit("remove", {
      key,
      event
    });
  }
  __name(onRemoveTab, "onRemoveTab");
  var labelNode = React.useMemo(function() {
    return icon && typeof label2 == "string" ? /* @__PURE__ */ React.createElement("span", null, label2) : label2;
  }, [label2, icon]), node2 = /* @__PURE__ */ React.createElement("div", {
    key,
    "data-node-key": genDataNodeKey(key),
    className: cn(tabPrefix, _defineProperty$2(_defineProperty$2(_defineProperty$2({}, "".concat(tabPrefix, "-with-remove"), removable), "".concat(tabPrefix, "-active"), active), "".concat(tabPrefix, "-disabled"), disabled)),
    style: style2,
    onClick: onInternalClick
  }, /* @__PURE__ */ React.createElement("div", {
    role: "tab",
    "aria-selected": active,
    id: id2 && "".concat(id2, "-tab-").concat(key),
    className: "".concat(tabPrefix, "-btn"),
    "aria-controls": id2 && "".concat(id2, "-panel-").concat(key),
    "aria-disabled": disabled,
    tabIndex: disabled ? null : 0,
    onClick: /* @__PURE__ */ __name(function(e2) {
      e2.stopPropagation(), onInternalClick(e2);
    }, "onClick"),
    onKeyDown: /* @__PURE__ */ __name(function(e2) {
      [KeyCode.SPACE, KeyCode.ENTER].includes(e2.which) && (e2.preventDefault(), onInternalClick(e2));
    }, "onKeyDown"),
    onFocus
  }, icon && /* @__PURE__ */ React.createElement("span", {
    className: "".concat(tabPrefix, "-icon")
  }, icon), label2 && labelNode), removable && /* @__PURE__ */ React.createElement("button", {
    type: "button",
    "aria-label": removeAriaLabel || "remove",
    tabIndex: 0,
    className: "".concat(tabPrefix, "-remove"),
    onClick: /* @__PURE__ */ __name(function(e2) {
      e2.stopPropagation(), onRemoveTab(e2);
    }, "onClick")
  }, closeIcon || editable.removeIcon || "×"));
  return renderWrapper ? renderWrapper(node2) : node2;
}, "TabNode"), getTabSize = /* @__PURE__ */ __name(function(tab, containerRect) {
  var offsetWidth = tab.offsetWidth, offsetHeight = tab.offsetHeight, offsetTop = tab.offsetTop, offsetLeft = tab.offsetLeft, _tab$getBoundingClien = tab.getBoundingClientRect(), width = _tab$getBoundingClien.width, height = _tab$getBoundingClien.height, left = _tab$getBoundingClien.left, top = _tab$getBoundingClien.top;
  return Math.abs(width - offsetWidth) < 1 ? [width, height, left - containerRect.left, top - containerRect.top] : [offsetWidth, offsetHeight, offsetLeft, offsetTop];
}, "getTabSize"), getSize$1 = /* @__PURE__ */ __name(function(refObj) {
  var _ref = refObj.current || {}, _ref$offsetWidth = _ref.offsetWidth, offsetWidth = _ref$offsetWidth === void 0 ? 0 : _ref$offsetWidth, _ref$offsetHeight = _ref.offsetHeight, offsetHeight = _ref$offsetHeight === void 0 ? 0 : _ref$offsetHeight;
  if (refObj.current) {
    var _refObj$current$getBo = refObj.current.getBoundingClientRect(), width = _refObj$current$getBo.width, height = _refObj$current$getBo.height;
    if (Math.abs(width - offsetWidth) < 1)
      return [width, height];
  }
  return [offsetWidth, offsetHeight];
}, "getSize"), getUnitValue = /* @__PURE__ */ __name(function(size, tabPositionTopOrBottom) {
  return size[tabPositionTopOrBottom ? 0 : 1];
}, "getUnitValue"), TabNavList = /* @__PURE__ */ React.forwardRef(function(props, ref) {
  var className = props.className, style2 = props.style, id2 = props.id, animated = props.animated, activeKey = props.activeKey, rtl = props.rtl, extra = props.extra, editable = props.editable, locale2 = props.locale, tabPosition = props.tabPosition, tabBarGutter = props.tabBarGutter, children = props.children, onTabClick = props.onTabClick, onTabScroll = props.onTabScroll, indicator = props.indicator, _React$useContext = React.useContext(TabContext), prefixCls = _React$useContext.prefixCls, tabs = _React$useContext.tabs, containerRef = useRef(null), extraLeftRef = useRef(null), extraRightRef = useRef(null), tabsWrapperRef = useRef(null), tabListRef = useRef(null), operationsRef = useRef(null), innerAddButtonRef = useRef(null), tabPositionTopOrBottom = tabPosition === "top" || tabPosition === "bottom", _useSyncState = useSyncState$1(0, function(next2, prev2) {
    tabPositionTopOrBottom && onTabScroll && onTabScroll({
      direction: next2 > prev2 ? "left" : "right"
    });
  }), _useSyncState2 = _slicedToArray(_useSyncState, 2), transformLeft = _useSyncState2[0], setTransformLeft = _useSyncState2[1], _useSyncState3 = useSyncState$1(0, function(next2, prev2) {
    !tabPositionTopOrBottom && onTabScroll && onTabScroll({
      direction: next2 > prev2 ? "top" : "bottom"
    });
  }), _useSyncState4 = _slicedToArray(_useSyncState3, 2), transformTop = _useSyncState4[0], setTransformTop = _useSyncState4[1], _useState = useState([0, 0]), _useState2 = _slicedToArray(_useState, 2), containerExcludeExtraSize = _useState2[0], setContainerExcludeExtraSize = _useState2[1], _useState3 = useState([0, 0]), _useState4 = _slicedToArray(_useState3, 2), tabContentSize = _useState4[0], setTabContentSize = _useState4[1], _useState5 = useState([0, 0]), _useState6 = _slicedToArray(_useState5, 2), addSize = _useState6[0], setAddSize = _useState6[1], _useState7 = useState([0, 0]), _useState8 = _slicedToArray(_useState7, 2), operationSize = _useState8[0], setOperationSize = _useState8[1], _useUpdateState = useUpdateState(/* @__PURE__ */ new Map()), _useUpdateState2 = _slicedToArray(_useUpdateState, 2), tabSizes = _useUpdateState2[0], setTabSizes = _useUpdateState2[1], tabOffsets = useOffsets(tabs, tabSizes, tabContentSize[0]), containerExcludeExtraSizeValue = getUnitValue(containerExcludeExtraSize, tabPositionTopOrBottom), tabContentSizeValue = getUnitValue(tabContentSize, tabPositionTopOrBottom), addSizeValue = getUnitValue(addSize, tabPositionTopOrBottom), operationSizeValue = getUnitValue(operationSize, tabPositionTopOrBottom), needScroll = Math.floor(containerExcludeExtraSizeValue) < Math.floor(tabContentSizeValue + addSizeValue), visibleTabContentValue = needScroll ? containerExcludeExtraSizeValue - operationSizeValue : containerExcludeExtraSizeValue - addSizeValue, operationsHiddenClassName = "".concat(prefixCls, "-nav-operations-hidden"), transformMin = 0, transformMax = 0;
  tabPositionTopOrBottom && rtl ? (transformMin = 0, transformMax = Math.max(0, tabContentSizeValue - visibleTabContentValue)) : (transformMin = Math.min(0, visibleTabContentValue - tabContentSizeValue), transformMax = 0);
  function alignInRange(value) {
    return value < transformMin ? transformMin : value > transformMax ? transformMax : value;
  }
  __name(alignInRange, "alignInRange");
  var touchMovingRef = useRef(null), _useState9 = useState(), _useState10 = _slicedToArray(_useState9, 2), lockAnimation = _useState10[0], setLockAnimation = _useState10[1];
  function doLockAnimation() {
    setLockAnimation(Date.now());
  }
  __name(doLockAnimation, "doLockAnimation");
  function clearTouchMoving() {
    touchMovingRef.current && clearTimeout(touchMovingRef.current);
  }
  __name(clearTouchMoving, "clearTouchMoving"), useTouchMove(tabsWrapperRef, function(offsetX, offsetY) {
    function doMove(setState, offset2) {
      setState(function(value) {
        var newValue = alignInRange(value + offset2);
        return newValue;
      });
    }
    return __name(doMove, "doMove"), needScroll ? (tabPositionTopOrBottom ? doMove(setTransformLeft, offsetX) : doMove(setTransformTop, offsetY), clearTouchMoving(), doLockAnimation(), !0) : !1;
  }), useEffect(function() {
    return clearTouchMoving(), lockAnimation && (touchMovingRef.current = setTimeout(function() {
      setLockAnimation(0);
    }, 100)), clearTouchMoving;
  }, [lockAnimation]);
  var _useVisibleRange = useVisibleRange(
    tabOffsets,
    // Container
    visibleTabContentValue,
    // Transform
    tabPositionTopOrBottom ? transformLeft : transformTop,
    // Tabs
    tabContentSizeValue,
    // Add
    addSizeValue,
    // Operation
    operationSizeValue,
    _objectSpread2$1(_objectSpread2$1({}, props), {}, {
      tabs
    })
  ), _useVisibleRange2 = _slicedToArray(_useVisibleRange, 2), visibleStart = _useVisibleRange2[0], visibleEnd = _useVisibleRange2[1], scrollToTab = useEvent(function() {
    var key = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : activeKey, tabOffset = tabOffsets.get(key) || {
      width: 0,
      height: 0,
      left: 0,
      right: 0,
      top: 0
    };
    if (tabPositionTopOrBottom) {
      var newTransform = transformLeft;
      rtl ? tabOffset.right < transformLeft ? newTransform = tabOffset.right : tabOffset.right + tabOffset.width > transformLeft + visibleTabContentValue && (newTransform = tabOffset.right + tabOffset.width - visibleTabContentValue) : tabOffset.left < -transformLeft ? newTransform = -tabOffset.left : tabOffset.left + tabOffset.width > -transformLeft + visibleTabContentValue && (newTransform = -(tabOffset.left + tabOffset.width - visibleTabContentValue)), setTransformTop(0), setTransformLeft(alignInRange(newTransform));
    } else {
      var _newTransform = transformTop;
      tabOffset.top < -transformTop ? _newTransform = -tabOffset.top : tabOffset.top + tabOffset.height > -transformTop + visibleTabContentValue && (_newTransform = -(tabOffset.top + tabOffset.height - visibleTabContentValue)), setTransformLeft(0), setTransformTop(alignInRange(_newTransform));
    }
  }), tabNodeStyle = {};
  tabPosition === "top" || tabPosition === "bottom" ? tabNodeStyle[rtl ? "marginRight" : "marginLeft"] = tabBarGutter : tabNodeStyle.marginTop = tabBarGutter;
  var tabNodes = tabs.map(function(tab, i) {
    var key = tab.key;
    return /* @__PURE__ */ React.createElement(TabNode, {
      id: id2,
      prefixCls,
      key,
      tab,
      style: i === 0 ? void 0 : tabNodeStyle,
      closable: tab.closable,
      editable,
      active: key === activeKey,
      renderWrapper: children,
      removeAriaLabel: locale2 == null ? void 0 : locale2.removeAriaLabel,
      onClick: /* @__PURE__ */ __name(function(e2) {
        onTabClick(key, e2);
      }, "onClick"),
      onFocus: /* @__PURE__ */ __name(function() {
        scrollToTab(key), doLockAnimation(), tabsWrapperRef.current && (rtl || (tabsWrapperRef.current.scrollLeft = 0), tabsWrapperRef.current.scrollTop = 0);
      }, "onFocus")
    });
  }), updateTabSizes = /* @__PURE__ */ __name(function() {
    return setTabSizes(function() {
      var _tabListRef$current, newSizes = /* @__PURE__ */ new Map(), listRect = (_tabListRef$current = tabListRef.current) === null || _tabListRef$current === void 0 ? void 0 : _tabListRef$current.getBoundingClientRect();
      return tabs.forEach(function(_ref2) {
        var _tabListRef$current2, key = _ref2.key, btnNode = (_tabListRef$current2 = tabListRef.current) === null || _tabListRef$current2 === void 0 ? void 0 : _tabListRef$current2.querySelector('[data-node-key="'.concat(genDataNodeKey(key), '"]'));
        if (btnNode) {
          var _getTabSize = getTabSize(btnNode, listRect), _getTabSize2 = _slicedToArray(_getTabSize, 4), width = _getTabSize2[0], height = _getTabSize2[1], left = _getTabSize2[2], top = _getTabSize2[3];
          newSizes.set(key, {
            width,
            height,
            left,
            top
          });
        }
      }), newSizes;
    });
  }, "updateTabSizes");
  useEffect(function() {
    updateTabSizes();
  }, [tabs.map(function(tab) {
    return tab.key;
  }).join("_")]);
  var onListHolderResize = useUpdate(function() {
    var containerSize = getSize$1(containerRef), extraLeftSize = getSize$1(extraLeftRef), extraRightSize = getSize$1(extraRightRef);
    setContainerExcludeExtraSize([containerSize[0] - extraLeftSize[0] - extraRightSize[0], containerSize[1] - extraLeftSize[1] - extraRightSize[1]]);
    var newAddSize = getSize$1(innerAddButtonRef);
    setAddSize(newAddSize);
    var newOperationSize = getSize$1(operationsRef);
    setOperationSize(newOperationSize);
    var tabContentFullSize = getSize$1(tabListRef);
    setTabContentSize([tabContentFullSize[0] - newAddSize[0], tabContentFullSize[1] - newAddSize[1]]), updateTabSizes();
  }), startHiddenTabs = tabs.slice(0, visibleStart), endHiddenTabs = tabs.slice(visibleEnd + 1), hiddenTabs = [].concat(_toConsumableArray(startHiddenTabs), _toConsumableArray(endHiddenTabs)), activeTabOffset = tabOffsets.get(activeKey), _useIndicator = useIndicator({
    activeTabOffset,
    horizontal: tabPositionTopOrBottom,
    indicator,
    rtl
  }), indicatorStyle = _useIndicator.style;
  useEffect(function() {
    scrollToTab();
  }, [activeKey, transformMin, transformMax, stringify(activeTabOffset), stringify(tabOffsets), tabPositionTopOrBottom]), useEffect(function() {
    onListHolderResize();
  }, [rtl]);
  var hasDropdown = !!hiddenTabs.length, wrapPrefix = "".concat(prefixCls, "-nav-wrap"), pingLeft, pingRight, pingTop, pingBottom;
  return tabPositionTopOrBottom ? rtl ? (pingRight = transformLeft > 0, pingLeft = transformLeft !== transformMax) : (pingLeft = transformLeft < 0, pingRight = transformLeft !== transformMin) : (pingTop = transformTop < 0, pingBottom = transformTop !== transformMin), /* @__PURE__ */ React.createElement(RefResizeObserver, {
    onResize: onListHolderResize
  }, /* @__PURE__ */ React.createElement("div", {
    ref: useComposeRef(ref, containerRef),
    role: "tablist",
    className: cn("".concat(prefixCls, "-nav"), className),
    style: style2,
    onKeyDown: /* @__PURE__ */ __name(function() {
      doLockAnimation();
    }, "onKeyDown")
  }, /* @__PURE__ */ React.createElement(ExtraContent, {
    ref: extraLeftRef,
    position: "left",
    extra,
    prefixCls
  }), /* @__PURE__ */ React.createElement(RefResizeObserver, {
    onResize: onListHolderResize
  }, /* @__PURE__ */ React.createElement("div", {
    className: cn(wrapPrefix, _defineProperty$2(_defineProperty$2(_defineProperty$2(_defineProperty$2({}, "".concat(wrapPrefix, "-ping-left"), pingLeft), "".concat(wrapPrefix, "-ping-right"), pingRight), "".concat(wrapPrefix, "-ping-top"), pingTop), "".concat(wrapPrefix, "-ping-bottom"), pingBottom)),
    ref: tabsWrapperRef
  }, /* @__PURE__ */ React.createElement(RefResizeObserver, {
    onResize: onListHolderResize
  }, /* @__PURE__ */ React.createElement("div", {
    ref: tabListRef,
    className: "".concat(prefixCls, "-nav-list"),
    style: {
      transform: "translate(".concat(transformLeft, "px, ").concat(transformTop, "px)"),
      transition: lockAnimation ? "none" : void 0
    }
  }, tabNodes, /* @__PURE__ */ React.createElement(AddButton, {
    ref: innerAddButtonRef,
    prefixCls,
    locale: locale2,
    editable,
    style: _objectSpread2$1(_objectSpread2$1({}, tabNodes.length === 0 ? void 0 : tabNodeStyle), {}, {
      visibility: hasDropdown ? "hidden" : null
    })
  }), /* @__PURE__ */ React.createElement("div", {
    className: cn("".concat(prefixCls, "-ink-bar"), _defineProperty$2({}, "".concat(prefixCls, "-ink-bar-animated"), animated.inkBar)),
    style: indicatorStyle
  }))))), /* @__PURE__ */ React.createElement(OperationNode$1, _extends({}, props, {
    removeAriaLabel: locale2 == null ? void 0 : locale2.removeAriaLabel,
    ref: operationsRef,
    prefixCls,
    tabs: hiddenTabs,
    className: !hasDropdown && operationsHiddenClassName,
    tabMoving: !!lockAnimation
  })), /* @__PURE__ */ React.createElement(ExtraContent, {
    ref: extraRightRef,
    position: "right",
    extra,
    prefixCls
  })));
}), TabPane$1 = /* @__PURE__ */ React.forwardRef(function(props, ref) {
  var prefixCls = props.prefixCls, className = props.className, style2 = props.style, id2 = props.id, active = props.active, tabKey = props.tabKey, children = props.children;
  return /* @__PURE__ */ React.createElement("div", {
    id: id2 && "".concat(id2, "-panel-").concat(tabKey),
    role: "tabpanel",
    tabIndex: active ? 0 : -1,
    "aria-labelledby": id2 && "".concat(id2, "-tab-").concat(tabKey),
    "aria-hidden": !active,
    style: style2,
    className: cn(prefixCls, active && "".concat(prefixCls, "-active"), className),
    ref
  }, children);
});
process.env.NODE_ENV !== "production" && (TabPane$1.displayName = "TabPane");
var _excluded$k = ["renderTabBar"], _excluded2$2 = ["label", "key"], TabNavListWrapper = /* @__PURE__ */ __name(function(_ref) {
  var renderTabBar = _ref.renderTabBar, restProps = _objectWithoutProperties(_ref, _excluded$k), _React$useContext = React.useContext(TabContext), tabs = _React$useContext.tabs;
  if (renderTabBar) {
    var tabNavBarProps = _objectSpread2$1(_objectSpread2$1({}, restProps), {}, {
      // Legacy support. We do not use this actually
      panes: tabs.map(function(_ref2) {
        var label2 = _ref2.label, key = _ref2.key, restTabProps = _objectWithoutProperties(_ref2, _excluded2$2);
        return /* @__PURE__ */ React.createElement(TabPane$1, _extends({
          tab: label2,
          key,
          tabKey: key
        }, restTabProps));
      })
    });
    return renderTabBar(tabNavBarProps, TabNavList);
  }
  return /* @__PURE__ */ React.createElement(TabNavList, restProps);
}, "TabNavListWrapper");
process.env.NODE_ENV !== "production" && (TabNavListWrapper.displayName = "TabNavListWrapper");
var _excluded$j = ["key", "forceRender", "style", "className", "destroyInactiveTabPane"], TabPanelList = /* @__PURE__ */ __name(function(props) {
  var id2 = props.id, activeKey = props.activeKey, animated = props.animated, tabPosition = props.tabPosition, destroyInactiveTabPane = props.destroyInactiveTabPane, _React$useContext = React.useContext(TabContext), prefixCls = _React$useContext.prefixCls, tabs = _React$useContext.tabs, tabPaneAnimated = animated.tabPane, tabPanePrefixCls = "".concat(prefixCls, "-tabpane");
  return /* @__PURE__ */ React.createElement("div", {
    className: cn("".concat(prefixCls, "-content-holder"))
  }, /* @__PURE__ */ React.createElement("div", {
    className: cn("".concat(prefixCls, "-content"), "".concat(prefixCls, "-content-").concat(tabPosition), _defineProperty$2({}, "".concat(prefixCls, "-content-animated"), tabPaneAnimated))
  }, tabs.map(function(item) {
    var key = item.key, forceRender = item.forceRender, paneStyle = item.style, paneClassName = item.className, itemDestroyInactiveTabPane = item.destroyInactiveTabPane, restTabProps = _objectWithoutProperties(item, _excluded$j), active = key === activeKey;
    return /* @__PURE__ */ React.createElement(CSSMotion, _extends({
      key,
      visible: active,
      forceRender,
      removeOnLeave: !!(destroyInactiveTabPane || itemDestroyInactiveTabPane),
      leavedClassName: "".concat(tabPanePrefixCls, "-hidden")
    }, animated.tabPaneMotion), function(_ref, ref) {
      var motionStyle = _ref.style, motionClassName = _ref.className;
      return /* @__PURE__ */ React.createElement(TabPane$1, _extends({}, restTabProps, {
        prefixCls: tabPanePrefixCls,
        id: id2,
        tabKey: key,
        animated: tabPaneAnimated,
        active,
        style: _objectSpread2$1(_objectSpread2$1({}, paneStyle), motionStyle),
        className: cn(paneClassName, motionClassName),
        ref
      }));
    });
  })));
}, "TabPanelList");
function useAnimateConfig$1() {
  var animated = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {
    inkBar: !0,
    tabPane: !1
  }, mergedAnimated;
  return animated === !1 ? mergedAnimated = {
    inkBar: !1,
    tabPane: !1
  } : animated === !0 ? mergedAnimated = {
    inkBar: !0,
    tabPane: !1
  } : mergedAnimated = _objectSpread2$1({
    inkBar: !0
  }, _typeof$4(animated) === "object" ? animated : {}), mergedAnimated.tabPaneMotion && mergedAnimated.tabPane === void 0 && (mergedAnimated.tabPane = !0), !mergedAnimated.tabPaneMotion && mergedAnimated.tabPane && (process.env.NODE_ENV !== "production" && warningOnce(!1, "`animated.tabPane` is true but `animated.tabPaneMotion` is not provided. Motion will not work."), mergedAnimated.tabPane = !1), mergedAnimated;
}
__name(useAnimateConfig$1, "useAnimateConfig$1");
var _excluded$i = ["id", "prefixCls", "className", "items", "direction", "activeKey", "defaultActiveKey", "editable", "animated", "tabPosition", "tabBarGutter", "tabBarStyle", "tabBarExtraContent", "locale", "more", "destroyInactiveTabPane", "renderTabBar", "onChange", "onTabClick", "onTabScroll", "getPopupContainer", "popupClassName", "indicator"], uuid$1 = 0, Tabs$1 = /* @__PURE__ */ React.forwardRef(function(props, ref) {
  var id2 = props.id, _props$prefixCls = props.prefixCls, prefixCls = _props$prefixCls === void 0 ? "rc-tabs" : _props$prefixCls, className = props.className, items = props.items, direction = props.direction, activeKey = props.activeKey, defaultActiveKey = props.defaultActiveKey, editable = props.editable, animated = props.animated, _props$tabPosition = props.tabPosition, tabPosition = _props$tabPosition === void 0 ? "top" : _props$tabPosition, tabBarGutter = props.tabBarGutter, tabBarStyle = props.tabBarStyle, tabBarExtraContent = props.tabBarExtraContent, locale2 = props.locale, more = props.more, destroyInactiveTabPane = props.destroyInactiveTabPane, renderTabBar = props.renderTabBar, onChange = props.onChange, onTabClick = props.onTabClick, onTabScroll = props.onTabScroll, getPopupContainer = props.getPopupContainer, popupClassName = props.popupClassName, indicator = props.indicator, restProps = _objectWithoutProperties(props, _excluded$i), tabs = React.useMemo(function() {
    return (items || []).filter(function(item) {
      return item && _typeof$4(item) === "object" && "key" in item;
    });
  }, [items]), rtl = direction === "rtl", mergedAnimated = useAnimateConfig$1(animated), _useState = useState(!1), _useState2 = _slicedToArray(_useState, 2), mobile = _useState2[0], setMobile = _useState2[1];
  useEffect(function() {
    setMobile(isMobile());
  }, []);
  var _useMergedState = useMergedState(function() {
    var _tabs$;
    return (_tabs$ = tabs[0]) === null || _tabs$ === void 0 ? void 0 : _tabs$.key;
  }, {
    value: activeKey,
    defaultValue: defaultActiveKey
  }), _useMergedState2 = _slicedToArray(_useMergedState, 2), mergedActiveKey = _useMergedState2[0], setMergedActiveKey = _useMergedState2[1], _useState3 = useState(function() {
    return tabs.findIndex(function(tab) {
      return tab.key === mergedActiveKey;
    });
  }), _useState4 = _slicedToArray(_useState3, 2), activeIndex = _useState4[0], setActiveIndex = _useState4[1];
  useEffect(function() {
    var newActiveIndex = tabs.findIndex(function(tab) {
      return tab.key === mergedActiveKey;
    });
    if (newActiveIndex === -1) {
      var _tabs$newActiveIndex;
      newActiveIndex = Math.max(0, Math.min(activeIndex, tabs.length - 1)), setMergedActiveKey((_tabs$newActiveIndex = tabs[newActiveIndex]) === null || _tabs$newActiveIndex === void 0 ? void 0 : _tabs$newActiveIndex.key);
    }
    setActiveIndex(newActiveIndex);
  }, [tabs.map(function(tab) {
    return tab.key;
  }).join("_"), mergedActiveKey, activeIndex]);
  var _useMergedState3 = useMergedState(null, {
    value: id2
  }), _useMergedState4 = _slicedToArray(_useMergedState3, 2), mergedId = _useMergedState4[0], setMergedId = _useMergedState4[1];
  useEffect(function() {
    id2 || (setMergedId("rc-tabs-".concat(process.env.NODE_ENV === "test" ? "test" : uuid$1)), uuid$1 += 1);
  }, []);
  function onInternalTabClick(key, e2) {
    onTabClick == null || onTabClick(key, e2);
    var isActiveChanged = key !== mergedActiveKey;
    setMergedActiveKey(key), isActiveChanged && (onChange == null || onChange(key));
  }
  __name(onInternalTabClick, "onInternalTabClick");
  var sharedProps = {
    id: mergedId,
    activeKey: mergedActiveKey,
    animated: mergedAnimated,
    tabPosition,
    rtl,
    mobile
  }, tabNavBarProps = _objectSpread2$1(_objectSpread2$1({}, sharedProps), {}, {
    editable,
    locale: locale2,
    more,
    tabBarGutter,
    onTabClick: onInternalTabClick,
    onTabScroll,
    extra: tabBarExtraContent,
    style: tabBarStyle,
    panes: null,
    getPopupContainer,
    popupClassName,
    indicator
  });
  return /* @__PURE__ */ React.createElement(TabContext.Provider, {
    value: {
      tabs,
      prefixCls
    }
  }, /* @__PURE__ */ React.createElement("div", _extends({
    ref,
    id: id2,
    className: cn(prefixCls, "".concat(prefixCls, "-").concat(tabPosition), _defineProperty$2(_defineProperty$2(_defineProperty$2({}, "".concat(prefixCls, "-mobile"), mobile), "".concat(prefixCls, "-editable"), editable), "".concat(prefixCls, "-rtl"), rtl), className)
  }, restProps), /* @__PURE__ */ React.createElement(TabNavListWrapper, _extends({}, tabNavBarProps, {
    renderTabBar
  })), /* @__PURE__ */ React.createElement(TabPanelList, _extends({
    destroyInactiveTabPane
  }, sharedProps, {
    animated: mergedAnimated
  }))));
});
process.env.NODE_ENV !== "production" && (Tabs$1.displayName = "Tabs");
const motion = {
  motionAppear: !1,
  motionEnter: !0,
  motionLeave: !0
};
function useAnimateConfig(prefixCls) {
  let animated = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
    inkBar: !0,
    tabPane: !1
  }, mergedAnimated;
  return animated === !1 ? mergedAnimated = {
    inkBar: !1,
    tabPane: !1
  } : animated === !0 ? mergedAnimated = {
    inkBar: !0,
    tabPane: !0
  } : mergedAnimated = Object.assign({
    inkBar: !0
  }, typeof animated == "object" ? animated : {}), mergedAnimated.tabPane && (mergedAnimated.tabPaneMotion = Object.assign(Object.assign({}, motion), {
    motionName: getTransitionName(prefixCls, "switch")
  })), mergedAnimated;
}
__name(useAnimateConfig, "useAnimateConfig");
var __rest$D = function(s, e2) {
  var t2 = {};
  for (var p in s) Object.prototype.hasOwnProperty.call(s, p) && e2.indexOf(p) < 0 && (t2[p] = s[p]);
  if (s != null && typeof Object.getOwnPropertySymbols == "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++)
    e2.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]) && (t2[p[i]] = s[p[i]]);
  return t2;
};
function filter(items) {
  return items.filter((item) => item);
}
__name(filter, "filter");
function useLegacyItems(items, children) {
  if (process.env.NODE_ENV !== "production" && devUseWarning("Tabs").deprecated(!children, "Tabs.TabPane", "items"), items)
    return items;
  const childrenItems = toArray$7(children).map((node2) => {
    if (/* @__PURE__ */ React.isValidElement(node2)) {
      const {
        key,
        props
      } = node2, _a = props || {}, {
        tab
      } = _a, restProps = __rest$D(_a, ["tab"]);
      return Object.assign(Object.assign({
        key: String(key)
      }, restProps), {
        label: tab
      });
    }
    return null;
  });
  return filter(childrenItems);
}
__name(useLegacyItems, "useLegacyItems");
const genMotionStyle$1 = /* @__PURE__ */ __name((token2) => {
  const {
    componentCls,
    motionDurationSlow
  } = token2;
  return [
    {
      [componentCls]: {
        [`${componentCls}-switch`]: {
          "&-appear, &-enter": {
            transition: "none",
            "&-start": {
              opacity: 0
            },
            "&-active": {
              opacity: 1,
              transition: `opacity ${motionDurationSlow}`
            }
          },
          "&-leave": {
            position: "absolute",
            transition: "none",
            inset: 0,
            "&-start": {
              opacity: 1
            },
            "&-active": {
              opacity: 0,
              transition: `opacity ${motionDurationSlow}`
            }
          }
        }
      }
    },
    // Follow code may reuse in other components
    [initSlideMotion(token2, "slide-up"), initSlideMotion(token2, "slide-down")]
  ];
}, "genMotionStyle$1"), genCardStyle$1 = /* @__PURE__ */ __name((token2) => {
  const {
    componentCls,
    tabsCardPadding,
    cardBg,
    cardGutter,
    colorBorderSecondary,
    itemSelectedColor
  } = token2;
  return {
    [`${componentCls}-card`]: {
      [`> ${componentCls}-nav, > div > ${componentCls}-nav`]: {
        [`${componentCls}-tab`]: {
          margin: 0,
          padding: tabsCardPadding,
          background: cardBg,
          border: `${unit$1(token2.lineWidth)} ${token2.lineType} ${colorBorderSecondary}`,
          transition: `all ${token2.motionDurationSlow} ${token2.motionEaseInOut}`
        },
        [`${componentCls}-tab-active`]: {
          color: itemSelectedColor,
          background: token2.colorBgContainer
        },
        [`${componentCls}-ink-bar`]: {
          visibility: "hidden"
        }
      },
      // ========================== Top & Bottom ==========================
      [`&${componentCls}-top, &${componentCls}-bottom`]: {
        [`> ${componentCls}-nav, > div > ${componentCls}-nav`]: {
          [`${componentCls}-tab + ${componentCls}-tab`]: {
            marginLeft: {
              _skip_check_: !0,
              value: unit$1(cardGutter)
            }
          }
        }
      },
      [`&${componentCls}-top`]: {
        [`> ${componentCls}-nav, > div > ${componentCls}-nav`]: {
          [`${componentCls}-tab`]: {
            borderRadius: `${unit$1(token2.borderRadiusLG)} ${unit$1(token2.borderRadiusLG)} 0 0`
          },
          [`${componentCls}-tab-active`]: {
            borderBottomColor: token2.colorBgContainer
          }
        }
      },
      [`&${componentCls}-bottom`]: {
        [`> ${componentCls}-nav, > div > ${componentCls}-nav`]: {
          [`${componentCls}-tab`]: {
            borderRadius: `0 0 ${unit$1(token2.borderRadiusLG)} ${unit$1(token2.borderRadiusLG)}`
          },
          [`${componentCls}-tab-active`]: {
            borderTopColor: token2.colorBgContainer
          }
        }
      },
      // ========================== Left & Right ==========================
      [`&${componentCls}-left, &${componentCls}-right`]: {
        [`> ${componentCls}-nav, > div > ${componentCls}-nav`]: {
          [`${componentCls}-tab + ${componentCls}-tab`]: {
            marginTop: unit$1(cardGutter)
          }
        }
      },
      [`&${componentCls}-left`]: {
        [`> ${componentCls}-nav, > div > ${componentCls}-nav`]: {
          [`${componentCls}-tab`]: {
            borderRadius: {
              _skip_check_: !0,
              value: `${unit$1(token2.borderRadiusLG)} 0 0 ${unit$1(token2.borderRadiusLG)}`
            }
          },
          [`${componentCls}-tab-active`]: {
            borderRightColor: {
              _skip_check_: !0,
              value: token2.colorBgContainer
            }
          }
        }
      },
      [`&${componentCls}-right`]: {
        [`> ${componentCls}-nav, > div > ${componentCls}-nav`]: {
          [`${componentCls}-tab`]: {
            borderRadius: {
              _skip_check_: !0,
              value: `0 ${unit$1(token2.borderRadiusLG)} ${unit$1(token2.borderRadiusLG)} 0`
            }
          },
          [`${componentCls}-tab-active`]: {
            borderLeftColor: {
              _skip_check_: !0,
              value: token2.colorBgContainer
            }
          }
        }
      }
    }
  };
}, "genCardStyle$1"), genDropdownStyle = /* @__PURE__ */ __name((token2) => {
  const {
    componentCls,
    itemHoverColor,
    dropdownEdgeChildVerticalPadding
  } = token2;
  return {
    [`${componentCls}-dropdown`]: Object.assign(Object.assign({}, resetComponent(token2)), {
      position: "absolute",
      top: -9999,
      left: {
        _skip_check_: !0,
        value: -9999
      },
      zIndex: token2.zIndexPopup,
      display: "block",
      "&-hidden": {
        display: "none"
      },
      [`${componentCls}-dropdown-menu`]: {
        maxHeight: token2.tabsDropdownHeight,
        margin: 0,
        padding: `${unit$1(dropdownEdgeChildVerticalPadding)} 0`,
        overflowX: "hidden",
        overflowY: "auto",
        textAlign: {
          _skip_check_: !0,
          value: "left"
        },
        listStyleType: "none",
        backgroundColor: token2.colorBgContainer,
        backgroundClip: "padding-box",
        borderRadius: token2.borderRadiusLG,
        outline: "none",
        boxShadow: token2.boxShadowSecondary,
        "&-item": Object.assign(Object.assign({}, textEllipsis), {
          display: "flex",
          alignItems: "center",
          minWidth: token2.tabsDropdownWidth,
          margin: 0,
          padding: `${unit$1(token2.paddingXXS)} ${unit$1(token2.paddingSM)}`,
          color: token2.colorText,
          fontWeight: "normal",
          fontSize: token2.fontSize,
          lineHeight: token2.lineHeight,
          cursor: "pointer",
          transition: `all ${token2.motionDurationSlow}`,
          "> span": {
            flex: 1,
            whiteSpace: "nowrap"
          },
          "&-remove": {
            flex: "none",
            marginLeft: {
              _skip_check_: !0,
              value: token2.marginSM
            },
            color: token2.colorTextDescription,
            fontSize: token2.fontSizeSM,
            background: "transparent",
            border: 0,
            cursor: "pointer",
            "&:hover": {
              color: itemHoverColor
            }
          },
          "&:hover": {
            background: token2.controlItemBgHover
          },
          "&-disabled": {
            "&, &:hover": {
              color: token2.colorTextDisabled,
              background: "transparent",
              cursor: "not-allowed"
            }
          }
        })
      }
    })
  };
}, "genDropdownStyle"), genPositionStyle = /* @__PURE__ */ __name((token2) => {
  const {
    componentCls,
    margin,
    colorBorderSecondary,
    horizontalMargin,
    verticalItemPadding,
    verticalItemMargin,
    calc
  } = token2;
  return {
    // ========================== Top & Bottom ==========================
    [`${componentCls}-top, ${componentCls}-bottom`]: {
      flexDirection: "column",
      [`> ${componentCls}-nav, > div > ${componentCls}-nav`]: {
        margin: horizontalMargin,
        "&::before": {
          position: "absolute",
          right: {
            _skip_check_: !0,
            value: 0
          },
          left: {
            _skip_check_: !0,
            value: 0
          },
          borderBottom: `${unit$1(token2.lineWidth)} ${token2.lineType} ${colorBorderSecondary}`,
          content: "''"
        },
        [`${componentCls}-ink-bar`]: {
          height: token2.lineWidthBold,
          "&-animated": {
            transition: `width ${token2.motionDurationSlow}, left ${token2.motionDurationSlow},
            right ${token2.motionDurationSlow}`
          }
        },
        [`${componentCls}-nav-wrap`]: {
          "&::before, &::after": {
            top: 0,
            bottom: 0,
            width: token2.controlHeight
          },
          "&::before": {
            left: {
              _skip_check_: !0,
              value: 0
            },
            boxShadow: token2.boxShadowTabsOverflowLeft
          },
          "&::after": {
            right: {
              _skip_check_: !0,
              value: 0
            },
            boxShadow: token2.boxShadowTabsOverflowRight
          },
          [`&${componentCls}-nav-wrap-ping-left::before`]: {
            opacity: 1
          },
          [`&${componentCls}-nav-wrap-ping-right::after`]: {
            opacity: 1
          }
        }
      }
    },
    [`${componentCls}-top`]: {
      [`> ${componentCls}-nav,
        > div > ${componentCls}-nav`]: {
        "&::before": {
          bottom: 0
        },
        [`${componentCls}-ink-bar`]: {
          bottom: 0
        }
      }
    },
    [`${componentCls}-bottom`]: {
      [`> ${componentCls}-nav, > div > ${componentCls}-nav`]: {
        order: 1,
        marginTop: margin,
        marginBottom: 0,
        "&::before": {
          top: 0
        },
        [`${componentCls}-ink-bar`]: {
          top: 0
        }
      },
      [`> ${componentCls}-content-holder, > div > ${componentCls}-content-holder`]: {
        order: 0
      }
    },
    // ========================== Left & Right ==========================
    [`${componentCls}-left, ${componentCls}-right`]: {
      [`> ${componentCls}-nav, > div > ${componentCls}-nav`]: {
        flexDirection: "column",
        minWidth: calc(token2.controlHeight).mul(1.25).equal(),
        // >>>>>>>>>>> Tab
        [`${componentCls}-tab`]: {
          padding: verticalItemPadding,
          textAlign: "center"
        },
        [`${componentCls}-tab + ${componentCls}-tab`]: {
          margin: verticalItemMargin
        },
        // >>>>>>>>>>> Nav
        [`${componentCls}-nav-wrap`]: {
          flexDirection: "column",
          "&::before, &::after": {
            right: {
              _skip_check_: !0,
              value: 0
            },
            left: {
              _skip_check_: !0,
              value: 0
            },
            height: token2.controlHeight
          },
          "&::before": {
            top: 0,
            boxShadow: token2.boxShadowTabsOverflowTop
          },
          "&::after": {
            bottom: 0,
            boxShadow: token2.boxShadowTabsOverflowBottom
          },
          [`&${componentCls}-nav-wrap-ping-top::before`]: {
            opacity: 1
          },
          [`&${componentCls}-nav-wrap-ping-bottom::after`]: {
            opacity: 1
          }
        },
        // >>>>>>>>>>> Ink Bar
        [`${componentCls}-ink-bar`]: {
          width: token2.lineWidthBold,
          "&-animated": {
            transition: `height ${token2.motionDurationSlow}, top ${token2.motionDurationSlow}`
          }
        },
        [`${componentCls}-nav-list, ${componentCls}-nav-operations`]: {
          flex: "1 0 auto",
          // fix safari scroll problem
          flexDirection: "column"
        }
      }
    },
    [`${componentCls}-left`]: {
      [`> ${componentCls}-nav, > div > ${componentCls}-nav`]: {
        [`${componentCls}-ink-bar`]: {
          right: {
            _skip_check_: !0,
            value: 0
          }
        }
      },
      [`> ${componentCls}-content-holder, > div > ${componentCls}-content-holder`]: {
        marginLeft: {
          _skip_check_: !0,
          value: unit$1(calc(token2.lineWidth).mul(-1).equal())
        },
        borderLeft: {
          _skip_check_: !0,
          value: `${unit$1(token2.lineWidth)} ${token2.lineType} ${token2.colorBorder}`
        },
        [`> ${componentCls}-content > ${componentCls}-tabpane`]: {
          paddingLeft: {
            _skip_check_: !0,
            value: token2.paddingLG
          }
        }
      }
    },
    [`${componentCls}-right`]: {
      [`> ${componentCls}-nav, > div > ${componentCls}-nav`]: {
        order: 1,
        [`${componentCls}-ink-bar`]: {
          left: {
            _skip_check_: !0,
            value: 0
          }
        }
      },
      [`> ${componentCls}-content-holder, > div > ${componentCls}-content-holder`]: {
        order: 0,
        marginRight: {
          _skip_check_: !0,
          value: calc(token2.lineWidth).mul(-1).equal()
        },
        borderRight: {
          _skip_check_: !0,
          value: `${unit$1(token2.lineWidth)} ${token2.lineType} ${token2.colorBorder}`
        },
        [`> ${componentCls}-content > ${componentCls}-tabpane`]: {
          paddingRight: {
            _skip_check_: !0,
            value: token2.paddingLG
          }
        }
      }
    }
  };
}, "genPositionStyle"), genSizeStyle$1 = /* @__PURE__ */ __name((token2) => {
  const {
    componentCls,
    cardPaddingSM,
    cardPaddingLG,
    horizontalItemPaddingSM,
    horizontalItemPaddingLG
  } = token2;
  return {
    [componentCls]: {
      "&-small": {
        [`> ${componentCls}-nav`]: {
          [`${componentCls}-tab`]: {
            padding: horizontalItemPaddingSM,
            fontSize: token2.titleFontSizeSM
          }
        }
      },
      "&-large": {
        [`> ${componentCls}-nav`]: {
          [`${componentCls}-tab`]: {
            padding: horizontalItemPaddingLG,
            fontSize: token2.titleFontSizeLG
          }
        }
      }
    },
    [`${componentCls}-card`]: {
      [`&${componentCls}-small`]: {
        [`> ${componentCls}-nav`]: {
          [`${componentCls}-tab`]: {
            padding: cardPaddingSM
          }
        },
        [`&${componentCls}-bottom`]: {
          [`> ${componentCls}-nav ${componentCls}-tab`]: {
            borderRadius: `0 0 ${unit$1(token2.borderRadius)} ${unit$1(token2.borderRadius)}`
          }
        },
        [`&${componentCls}-top`]: {
          [`> ${componentCls}-nav ${componentCls}-tab`]: {
            borderRadius: `${unit$1(token2.borderRadius)} ${unit$1(token2.borderRadius)} 0 0`
          }
        },
        [`&${componentCls}-right`]: {
          [`> ${componentCls}-nav ${componentCls}-tab`]: {
            borderRadius: {
              _skip_check_: !0,
              value: `0 ${unit$1(token2.borderRadius)} ${unit$1(token2.borderRadius)} 0`
            }
          }
        },
        [`&${componentCls}-left`]: {
          [`> ${componentCls}-nav ${componentCls}-tab`]: {
            borderRadius: {
              _skip_check_: !0,
              value: `${unit$1(token2.borderRadius)} 0 0 ${unit$1(token2.borderRadius)}`
            }
          }
        }
      },
      [`&${componentCls}-large`]: {
        [`> ${componentCls}-nav`]: {
          [`${componentCls}-tab`]: {
            padding: cardPaddingLG
          }
        }
      }
    }
  };
}, "genSizeStyle$1"), genTabStyle = /* @__PURE__ */ __name((token2) => {
  const {
    componentCls,
    itemActiveColor,
    itemHoverColor,
    iconCls,
    tabsHorizontalItemMargin,
    horizontalItemPadding,
    itemSelectedColor,
    itemColor
  } = token2, tabCls = `${componentCls}-tab`;
  return {
    [tabCls]: {
      position: "relative",
      WebkitTouchCallout: "none",
      WebkitTapHighlightColor: "transparent",
      display: "inline-flex",
      alignItems: "center",
      padding: horizontalItemPadding,
      fontSize: token2.titleFontSize,
      background: "transparent",
      border: 0,
      outline: "none",
      cursor: "pointer",
      color: itemColor,
      "&-btn, &-remove": Object.assign({
        "&:focus:not(:focus-visible), &:active": {
          color: itemActiveColor
        }
      }, genFocusStyle(token2)),
      "&-btn": {
        outline: "none",
        transition: `all ${token2.motionDurationSlow}`,
        [`${tabCls}-icon:not(:last-child)`]: {
          marginInlineEnd: token2.marginSM
        }
      },
      "&-remove": {
        flex: "none",
        marginRight: {
          _skip_check_: !0,
          value: token2.calc(token2.marginXXS).mul(-1).equal()
        },
        marginLeft: {
          _skip_check_: !0,
          value: token2.marginXS
        },
        color: token2.colorTextDescription,
        fontSize: token2.fontSizeSM,
        background: "transparent",
        border: "none",
        outline: "none",
        cursor: "pointer",
        transition: `all ${token2.motionDurationSlow}`,
        "&:hover": {
          color: token2.colorTextHeading
        }
      },
      "&:hover": {
        color: itemHoverColor
      },
      [`&${tabCls}-active ${tabCls}-btn`]: {
        color: itemSelectedColor,
        textShadow: token2.tabsActiveTextShadow
      },
      [`&${tabCls}-disabled`]: {
        color: token2.colorTextDisabled,
        cursor: "not-allowed"
      },
      [`&${tabCls}-disabled ${tabCls}-btn, &${tabCls}-disabled ${componentCls}-remove`]: {
        "&:focus, &:active": {
          color: token2.colorTextDisabled
        }
      },
      [`& ${tabCls}-remove ${iconCls}`]: {
        margin: 0
      },
      [`${iconCls}:not(:last-child)`]: {
        marginRight: {
          _skip_check_: !0,
          value: token2.marginSM
        }
      }
    },
    [`${tabCls} + ${tabCls}`]: {
      margin: {
        _skip_check_: !0,
        value: tabsHorizontalItemMargin
      }
    }
  };
}, "genTabStyle"), genRtlStyle$1 = /* @__PURE__ */ __name((token2) => {
  const {
    componentCls,
    tabsHorizontalItemMarginRTL,
    iconCls,
    cardGutter,
    calc
  } = token2;
  return {
    [`${componentCls}-rtl`]: {
      direction: "rtl",
      [`${componentCls}-nav`]: {
        [`${componentCls}-tab`]: {
          margin: {
            _skip_check_: !0,
            value: tabsHorizontalItemMarginRTL
          },
          [`${componentCls}-tab:last-of-type`]: {
            marginLeft: {
              _skip_check_: !0,
              value: 0
            }
          },
          [iconCls]: {
            marginRight: {
              _skip_check_: !0,
              value: 0
            },
            marginLeft: {
              _skip_check_: !0,
              value: unit$1(token2.marginSM)
            }
          },
          [`${componentCls}-tab-remove`]: {
            marginRight: {
              _skip_check_: !0,
              value: unit$1(token2.marginXS)
            },
            marginLeft: {
              _skip_check_: !0,
              value: unit$1(calc(token2.marginXXS).mul(-1).equal())
            },
            [iconCls]: {
              margin: 0
            }
          }
        }
      },
      [`&${componentCls}-left`]: {
        [`> ${componentCls}-nav`]: {
          order: 1
        },
        [`> ${componentCls}-content-holder`]: {
          order: 0
        }
      },
      [`&${componentCls}-right`]: {
        [`> ${componentCls}-nav`]: {
          order: 0
        },
        [`> ${componentCls}-content-holder`]: {
          order: 1
        }
      },
      // ====================== Card ======================
      [`&${componentCls}-card${componentCls}-top, &${componentCls}-card${componentCls}-bottom`]: {
        [`> ${componentCls}-nav, > div > ${componentCls}-nav`]: {
          [`${componentCls}-tab + ${componentCls}-tab`]: {
            marginRight: {
              _skip_check_: !0,
              value: cardGutter
            },
            marginLeft: {
              _skip_check_: !0,
              value: 0
            }
          }
        }
      }
    },
    [`${componentCls}-dropdown-rtl`]: {
      direction: "rtl"
    },
    [`${componentCls}-menu-item`]: {
      [`${componentCls}-dropdown-rtl`]: {
        textAlign: {
          _skip_check_: !0,
          value: "right"
        }
      }
    }
  };
}, "genRtlStyle$1"), genTabsStyle = /* @__PURE__ */ __name((token2) => {
  const {
    componentCls,
    tabsCardPadding,
    cardHeight,
    cardGutter,
    itemHoverColor,
    itemActiveColor,
    colorBorderSecondary
  } = token2;
  return {
    [componentCls]: Object.assign(Object.assign(Object.assign(Object.assign({}, resetComponent(token2)), {
      display: "flex",
      // ========================== Navigation ==========================
      [`> ${componentCls}-nav, > div > ${componentCls}-nav`]: {
        position: "relative",
        display: "flex",
        flex: "none",
        alignItems: "center",
        [`${componentCls}-nav-wrap`]: {
          position: "relative",
          display: "flex",
          flex: "auto",
          alignSelf: "stretch",
          overflow: "hidden",
          whiteSpace: "nowrap",
          transform: "translate(0)",
          // Fix chrome render bug
          // >>>>> Ping shadow
          "&::before, &::after": {
            position: "absolute",
            zIndex: 1,
            opacity: 0,
            transition: `opacity ${token2.motionDurationSlow}`,
            content: "''",
            pointerEvents: "none"
          }
        },
        [`${componentCls}-nav-list`]: {
          position: "relative",
          display: "flex",
          transition: `opacity ${token2.motionDurationSlow}`
        },
        // >>>>>>>> Operations
        [`${componentCls}-nav-operations`]: {
          display: "flex",
          alignSelf: "stretch"
        },
        [`${componentCls}-nav-operations-hidden`]: {
          position: "absolute",
          visibility: "hidden",
          pointerEvents: "none"
        },
        [`${componentCls}-nav-more`]: {
          position: "relative",
          padding: tabsCardPadding,
          background: "transparent",
          border: 0,
          color: token2.colorText,
          "&::after": {
            position: "absolute",
            right: {
              _skip_check_: !0,
              value: 0
            },
            bottom: 0,
            left: {
              _skip_check_: !0,
              value: 0
            },
            height: token2.calc(token2.controlHeightLG).div(8).equal(),
            transform: "translateY(100%)",
            content: "''"
          }
        },
        [`${componentCls}-nav-add`]: Object.assign({
          minWidth: cardHeight,
          marginLeft: {
            _skip_check_: !0,
            value: cardGutter
          },
          padding: unit$1(token2.paddingXS),
          background: "transparent",
          border: `${unit$1(token2.lineWidth)} ${token2.lineType} ${colorBorderSecondary}`,
          borderRadius: `${unit$1(token2.borderRadiusLG)} ${unit$1(token2.borderRadiusLG)} 0 0`,
          outline: "none",
          cursor: "pointer",
          color: token2.colorText,
          transition: `all ${token2.motionDurationSlow} ${token2.motionEaseInOut}`,
          "&:hover": {
            color: itemHoverColor
          },
          "&:active, &:focus:not(:focus-visible)": {
            color: itemActiveColor
          }
        }, genFocusStyle(token2))
      },
      [`${componentCls}-extra-content`]: {
        flex: "none"
      },
      // ============================ InkBar ============================
      [`${componentCls}-ink-bar`]: {
        position: "absolute",
        background: token2.inkBarColor,
        pointerEvents: "none"
      }
    }), genTabStyle(token2)), {
      // =========================== TabPanes ===========================
      [`${componentCls}-content`]: {
        position: "relative",
        width: "100%"
      },
      [`${componentCls}-content-holder`]: {
        flex: "auto",
        minWidth: 0,
        minHeight: 0
      },
      [`${componentCls}-tabpane`]: {
        outline: "none",
        "&-hidden": {
          display: "none"
        }
      }
    }),
    [`${componentCls}-centered`]: {
      [`> ${componentCls}-nav, > div > ${componentCls}-nav`]: {
        [`${componentCls}-nav-wrap`]: {
          [`&:not([class*='${componentCls}-nav-wrap-ping']) > ${componentCls}-nav-list`]: {
            margin: "auto"
          }
        }
      }
    }
  };
}, "genTabsStyle"), prepareComponentToken$c = /* @__PURE__ */ __name((token2) => {
  const cardHeight = token2.controlHeightLG;
  return {
    zIndexPopup: token2.zIndexPopupBase + 50,
    cardBg: token2.colorFillAlter,
    cardHeight,
    // Initialize with empty string, because cardPadding will be calculated with cardHeight by default.
    cardPadding: `${(cardHeight - Math.round(token2.fontSize * token2.lineHeight)) / 2 - token2.lineWidth}px ${token2.padding}px`,
    cardPaddingSM: `${token2.paddingXXS * 1.5}px ${token2.padding}px`,
    cardPaddingLG: `${token2.paddingXS}px ${token2.padding}px ${token2.paddingXXS * 1.5}px`,
    titleFontSize: token2.fontSize,
    titleFontSizeLG: token2.fontSizeLG,
    titleFontSizeSM: token2.fontSize,
    inkBarColor: token2.colorPrimary,
    horizontalMargin: `0 0 ${token2.margin}px 0`,
    horizontalItemGutter: 32,
    // Fixed Value
    // Initialize with empty string, because horizontalItemMargin will be calculated with horizontalItemGutter by default.
    horizontalItemMargin: "",
    horizontalItemMarginRTL: "",
    horizontalItemPadding: `${token2.paddingSM}px 0`,
    horizontalItemPaddingSM: `${token2.paddingXS}px 0`,
    horizontalItemPaddingLG: `${token2.padding}px 0`,
    verticalItemPadding: `${token2.paddingXS}px ${token2.paddingLG}px`,
    verticalItemMargin: `${token2.margin}px 0 0 0`,
    itemColor: token2.colorText,
    itemSelectedColor: token2.colorPrimary,
    itemHoverColor: token2.colorPrimaryHover,
    itemActiveColor: token2.colorPrimaryActive,
    cardGutter: token2.marginXXS / 2
  };
}, "prepareComponentToken$c"), useStyle$e = genStyleHooks("Tabs", (token2) => {
  const tabsToken = merge(token2, {
    // `cardPadding` is empty by default, so we could calculate with dynamic `cardHeight`
    tabsCardPadding: token2.cardPadding,
    dropdownEdgeChildVerticalPadding: token2.paddingXXS,
    tabsActiveTextShadow: "0 0 0.25px currentcolor",
    tabsDropdownHeight: 200,
    tabsDropdownWidth: 120,
    tabsHorizontalItemMargin: `0 0 0 ${unit$1(token2.horizontalItemGutter)}`,
    tabsHorizontalItemMarginRTL: `0 0 0 ${unit$1(token2.horizontalItemGutter)}`
  });
  return [genSizeStyle$1(tabsToken), genRtlStyle$1(tabsToken), genPositionStyle(tabsToken), genDropdownStyle(tabsToken), genCardStyle$1(tabsToken), genTabsStyle(tabsToken), genMotionStyle$1(tabsToken)];
}, prepareComponentToken$c), TabPane = /* @__PURE__ */ __name(() => null, "TabPane");
process.env.NODE_ENV !== "production" && (TabPane.displayName = "DeprecatedTabPane");
var __rest$C = function(s, e2) {
  var t2 = {};
  for (var p in s) Object.prototype.hasOwnProperty.call(s, p) && e2.indexOf(p) < 0 && (t2[p] = s[p]);
  if (s != null && typeof Object.getOwnPropertySymbols == "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++)
    e2.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]) && (t2[p[i]] = s[p[i]]);
  return t2;
};
const Tabs = /* @__PURE__ */ __name((props) => {
  var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l;
  const {
    type: type4,
    className,
    rootClassName,
    size: customSize,
    onEdit,
    hideAdd,
    centered,
    addIcon,
    removeIcon,
    moreIcon,
    more,
    popupClassName,
    children,
    items,
    animated,
    style: style2,
    indicatorSize,
    indicator
  } = props, otherProps = __rest$C(props, ["type", "className", "rootClassName", "size", "onEdit", "hideAdd", "centered", "addIcon", "removeIcon", "moreIcon", "more", "popupClassName", "children", "items", "animated", "style", "indicatorSize", "indicator"]), {
    prefixCls: customizePrefixCls
  } = otherProps, {
    direction,
    tabs,
    getPrefixCls,
    getPopupContainer
  } = React.useContext(ConfigContext), prefixCls = getPrefixCls("tabs", customizePrefixCls), rootCls = useCSSVarCls(prefixCls), [wrapCSSVar, hashId, cssVarCls] = useStyle$e(prefixCls, rootCls);
  let editable;
  type4 === "editable-card" && (editable = {
    onEdit: /* @__PURE__ */ __name((editType, _ref) => {
      let {
        key,
        event
      } = _ref;
      onEdit == null || onEdit(editType === "add" ? event : key, editType);
    }, "onEdit"),
    removeIcon: (_a = removeIcon ?? (tabs == null ? void 0 : tabs.removeIcon)) !== null && _a !== void 0 ? _a : /* @__PURE__ */ React.createElement(RefIcon$B, null),
    addIcon: (addIcon ?? (tabs == null ? void 0 : tabs.addIcon)) || /* @__PURE__ */ React.createElement(RefIcon$r, null),
    showAdd: hideAdd !== !0
  });
  const rootPrefixCls = getPrefixCls();
  if (process.env.NODE_ENV !== "production") {
    const warning3 = devUseWarning("Tabs");
    process.env.NODE_ENV !== "production" && warning3(!("onPrevClick" in props) && !("onNextClick" in props), "breaking", "`onPrevClick` and `onNextClick` has been removed. Please use `onTabScroll` instead."), process.env.NODE_ENV !== "production" && warning3(!(indicatorSize || tabs != null && tabs.indicatorSize), "deprecated", "`indicatorSize` has been deprecated. Please use `indicator={{ size: ... }}` instead.");
  }
  const size = useSize(customSize), mergedItems = useLegacyItems(items, children), mergedAnimated = useAnimateConfig(prefixCls, animated), mergedStyle = Object.assign(Object.assign({}, tabs == null ? void 0 : tabs.style), style2), mergedIndicator = {
    align: (_b = indicator == null ? void 0 : indicator.align) !== null && _b !== void 0 ? _b : (_c = tabs == null ? void 0 : tabs.indicator) === null || _c === void 0 ? void 0 : _c.align,
    size: (_g = (_e = (_d = indicator == null ? void 0 : indicator.size) !== null && _d !== void 0 ? _d : indicatorSize) !== null && _e !== void 0 ? _e : (_f = tabs == null ? void 0 : tabs.indicator) === null || _f === void 0 ? void 0 : _f.size) !== null && _g !== void 0 ? _g : tabs == null ? void 0 : tabs.indicatorSize
  };
  return wrapCSSVar(/* @__PURE__ */ React.createElement(Tabs$1, Object.assign({
    direction,
    getPopupContainer
  }, otherProps, {
    items: mergedItems,
    className: cn({
      [`${prefixCls}-${size}`]: size,
      [`${prefixCls}-card`]: ["card", "editable-card"].includes(type4),
      [`${prefixCls}-editable-card`]: type4 === "editable-card",
      [`${prefixCls}-centered`]: centered
    }, tabs == null ? void 0 : tabs.className, className, rootClassName, hashId, cssVarCls, rootCls),
    popupClassName: cn(popupClassName, hashId, cssVarCls, rootCls),
    style: mergedStyle,
    editable,
    more: Object.assign({
      icon: (_l = (_k = (_j = (_h = tabs == null ? void 0 : tabs.more) === null || _h === void 0 ? void 0 : _h.icon) !== null && _j !== void 0 ? _j : tabs == null ? void 0 : tabs.moreIcon) !== null && _k !== void 0 ? _k : moreIcon) !== null && _l !== void 0 ? _l : /* @__PURE__ */ React.createElement(RefIcon$s, null),
      transitionName: `${rootPrefixCls}-slide-up`
    }, more),
    prefixCls,
    animated: mergedAnimated,
    indicator: mergedIndicator
  })));
}, "Tabs");
Tabs.TabPane = TabPane;
process.env.NODE_ENV !== "production" && (Tabs.displayName = "Tabs");
var __rest$B = function(s, e2) {
  var t2 = {};
  for (var p in s) Object.prototype.hasOwnProperty.call(s, p) && e2.indexOf(p) < 0 && (t2[p] = s[p]);
  if (s != null && typeof Object.getOwnPropertySymbols == "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++)
    e2.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]) && (t2[p[i]] = s[p[i]]);
  return t2;
};
const Grid$1 = /* @__PURE__ */ __name((_a) => {
  var {
    prefixCls,
    className,
    hoverable = !0
  } = _a, props = __rest$B(_a, ["prefixCls", "className", "hoverable"]);
  const {
    getPrefixCls
  } = React.useContext(ConfigContext), prefix = getPrefixCls("card", prefixCls), classString = cn(`${prefix}-grid`, className, {
    [`${prefix}-grid-hoverable`]: hoverable
  });
  return /* @__PURE__ */ React.createElement("div", Object.assign({}, props, {
    className: classString
  }));
}, "Grid$1"), genCardHeadStyle = /* @__PURE__ */ __name((token2) => {
  const {
    antCls,
    componentCls,
    headerHeight,
    cardPaddingBase,
    tabsMarginBottom
  } = token2;
  return Object.assign(Object.assign({
    display: "flex",
    justifyContent: "center",
    flexDirection: "column",
    minHeight: headerHeight,
    marginBottom: -1,
    padding: `0 ${unit$1(cardPaddingBase)}`,
    color: token2.colorTextHeading,
    fontWeight: token2.fontWeightStrong,
    fontSize: token2.headerFontSize,
    background: token2.headerBg,
    borderBottom: `${unit$1(token2.lineWidth)} ${token2.lineType} ${token2.colorBorderSecondary}`,
    borderRadius: `${unit$1(token2.borderRadiusLG)} ${unit$1(token2.borderRadiusLG)} 0 0`
  }, clearFix()), {
    "&-wrapper": {
      width: "100%",
      display: "flex",
      alignItems: "center"
    },
    "&-title": Object.assign(Object.assign({
      display: "inline-block",
      flex: 1
    }, textEllipsis), {
      [`
          > ${componentCls}-typography,
          > ${componentCls}-typography-edit-content
        `]: {
        insetInlineStart: 0,
        marginTop: 0,
        marginBottom: 0
      }
    }),
    [`${antCls}-tabs-top`]: {
      clear: "both",
      marginBottom: tabsMarginBottom,
      color: token2.colorText,
      fontWeight: "normal",
      fontSize: token2.fontSize,
      "&-bar": {
        borderBottom: `${unit$1(token2.lineWidth)} ${token2.lineType} ${token2.colorBorderSecondary}`
      }
    }
  });
}, "genCardHeadStyle"), genCardGridStyle = /* @__PURE__ */ __name((token2) => {
  const {
    cardPaddingBase,
    colorBorderSecondary,
    cardShadow,
    lineWidth
  } = token2;
  return {
    width: "33.33%",
    padding: cardPaddingBase,
    border: 0,
    borderRadius: 0,
    boxShadow: `
      ${unit$1(lineWidth)} 0 0 0 ${colorBorderSecondary},
      0 ${unit$1(lineWidth)} 0 0 ${colorBorderSecondary},
      ${unit$1(lineWidth)} ${unit$1(lineWidth)} 0 0 ${colorBorderSecondary},
      ${unit$1(lineWidth)} 0 0 0 ${colorBorderSecondary} inset,
      0 ${unit$1(lineWidth)} 0 0 ${colorBorderSecondary} inset;
    `,
    transition: `all ${token2.motionDurationMid}`,
    "&-hoverable:hover": {
      position: "relative",
      zIndex: 1,
      boxShadow: cardShadow
    }
  };
}, "genCardGridStyle"), genCardActionsStyle = /* @__PURE__ */ __name((token2) => {
  const {
    componentCls,
    iconCls,
    actionsLiMargin,
    cardActionsIconSize,
    colorBorderSecondary,
    actionsBg
  } = token2;
  return Object.assign(Object.assign({
    margin: 0,
    padding: 0,
    listStyle: "none",
    background: actionsBg,
    borderTop: `${unit$1(token2.lineWidth)} ${token2.lineType} ${colorBorderSecondary}`,
    display: "flex",
    borderRadius: `0 0 ${unit$1(token2.borderRadiusLG)} ${unit$1(token2.borderRadiusLG)}`
  }, clearFix()), {
    "& > li": {
      margin: actionsLiMargin,
      color: token2.colorTextDescription,
      textAlign: "center",
      "> span": {
        position: "relative",
        display: "block",
        minWidth: token2.calc(token2.cardActionsIconSize).mul(2).equal(),
        fontSize: token2.fontSize,
        lineHeight: token2.lineHeight,
        cursor: "pointer",
        "&:hover": {
          color: token2.colorPrimary,
          transition: `color ${token2.motionDurationMid}`
        },
        [`a:not(${componentCls}-btn), > ${iconCls}`]: {
          display: "inline-block",
          width: "100%",
          color: token2.colorTextDescription,
          lineHeight: unit$1(token2.fontHeight),
          transition: `color ${token2.motionDurationMid}`,
          "&:hover": {
            color: token2.colorPrimary
          }
        },
        [`> ${iconCls}`]: {
          fontSize: cardActionsIconSize,
          lineHeight: unit$1(token2.calc(cardActionsIconSize).mul(token2.lineHeight).equal())
        }
      },
      "&:not(:last-child)": {
        borderInlineEnd: `${unit$1(token2.lineWidth)} ${token2.lineType} ${colorBorderSecondary}`
      }
    }
  });
}, "genCardActionsStyle"), genCardMetaStyle = /* @__PURE__ */ __name((token2) => Object.assign(Object.assign({
  margin: `${unit$1(token2.calc(token2.marginXXS).mul(-1).equal())} 0`,
  display: "flex"
}, clearFix()), {
  "&-avatar": {
    paddingInlineEnd: token2.padding
  },
  "&-detail": {
    overflow: "hidden",
    flex: 1,
    "> div:not(:last-child)": {
      marginBottom: token2.marginXS
    }
  },
  "&-title": Object.assign({
    color: token2.colorTextHeading,
    fontWeight: token2.fontWeightStrong,
    fontSize: token2.fontSizeLG
  }, textEllipsis),
  "&-description": {
    color: token2.colorTextDescription
  }
}), "genCardMetaStyle"), genCardTypeInnerStyle = /* @__PURE__ */ __name((token2) => {
  const {
    componentCls,
    cardPaddingBase,
    colorFillAlter
  } = token2;
  return {
    [`${componentCls}-head`]: {
      padding: `0 ${unit$1(cardPaddingBase)}`,
      background: colorFillAlter,
      "&-title": {
        fontSize: token2.fontSize
      }
    },
    [`${componentCls}-body`]: {
      padding: `${unit$1(token2.padding)} ${unit$1(cardPaddingBase)}`
    }
  };
}, "genCardTypeInnerStyle"), genCardLoadingStyle = /* @__PURE__ */ __name((token2) => {
  const {
    componentCls
  } = token2;
  return {
    overflow: "hidden",
    [`${componentCls}-body`]: {
      userSelect: "none"
    }
  };
}, "genCardLoadingStyle"), genCardStyle = /* @__PURE__ */ __name((token2) => {
  const {
    componentCls,
    cardShadow,
    cardHeadPadding,
    colorBorderSecondary,
    boxShadowTertiary,
    cardPaddingBase,
    extraColor
  } = token2;
  return {
    [componentCls]: Object.assign(Object.assign({}, resetComponent(token2)), {
      position: "relative",
      background: token2.colorBgContainer,
      borderRadius: token2.borderRadiusLG,
      [`&:not(${componentCls}-bordered)`]: {
        boxShadow: boxShadowTertiary
      },
      [`${componentCls}-head`]: genCardHeadStyle(token2),
      [`${componentCls}-extra`]: {
        // https://stackoverflow.com/a/22429853/3040605
        marginInlineStart: "auto",
        color: extraColor,
        fontWeight: "normal",
        fontSize: token2.fontSize
      },
      [`${componentCls}-body`]: Object.assign({
        padding: cardPaddingBase,
        borderRadius: `0 0 ${unit$1(token2.borderRadiusLG)} ${unit$1(token2.borderRadiusLG)}`
      }, clearFix()),
      [`${componentCls}-grid`]: genCardGridStyle(token2),
      [`${componentCls}-cover`]: {
        "> *": {
          display: "block",
          width: "100%",
          borderRadius: `${unit$1(token2.borderRadiusLG)} ${unit$1(token2.borderRadiusLG)} 0 0`
        }
      },
      [`${componentCls}-actions`]: genCardActionsStyle(token2),
      [`${componentCls}-meta`]: genCardMetaStyle(token2)
    }),
    [`${componentCls}-bordered`]: {
      border: `${unit$1(token2.lineWidth)} ${token2.lineType} ${colorBorderSecondary}`,
      [`${componentCls}-cover`]: {
        marginTop: -1,
        marginInlineStart: -1,
        marginInlineEnd: -1
      }
    },
    [`${componentCls}-hoverable`]: {
      cursor: "pointer",
      transition: `box-shadow ${token2.motionDurationMid}, border-color ${token2.motionDurationMid}`,
      "&:hover": {
        borderColor: "transparent",
        boxShadow: cardShadow
      }
    },
    [`${componentCls}-contain-grid`]: {
      borderRadius: `${unit$1(token2.borderRadiusLG)} ${unit$1(token2.borderRadiusLG)} 0 0 `,
      [`${componentCls}-body`]: {
        display: "flex",
        flexWrap: "wrap"
      },
      [`&:not(${componentCls}-loading) ${componentCls}-body`]: {
        marginBlockStart: token2.calc(token2.lineWidth).mul(-1).equal(),
        marginInlineStart: token2.calc(token2.lineWidth).mul(-1).equal(),
        padding: 0
      }
    },
    [`${componentCls}-contain-tabs`]: {
      [`> div${componentCls}-head`]: {
        minHeight: 0,
        [`${componentCls}-head-title, ${componentCls}-extra`]: {
          paddingTop: cardHeadPadding
        }
      }
    },
    [`${componentCls}-type-inner`]: genCardTypeInnerStyle(token2),
    [`${componentCls}-loading`]: genCardLoadingStyle(token2),
    [`${componentCls}-rtl`]: {
      direction: "rtl"
    }
  };
}, "genCardStyle"), genCardSizeStyle = /* @__PURE__ */ __name((token2) => {
  const {
    componentCls,
    cardPaddingSM,
    headerHeightSM,
    headerFontSizeSM
  } = token2;
  return {
    [`${componentCls}-small`]: {
      [`> ${componentCls}-head`]: {
        minHeight: headerHeightSM,
        padding: `0 ${unit$1(cardPaddingSM)}`,
        fontSize: headerFontSizeSM,
        [`> ${componentCls}-head-wrapper`]: {
          [`> ${componentCls}-extra`]: {
            fontSize: token2.fontSize
          }
        }
      },
      [`> ${componentCls}-body`]: {
        padding: cardPaddingSM
      }
    },
    [`${componentCls}-small${componentCls}-contain-tabs`]: {
      [`> ${componentCls}-head`]: {
        [`${componentCls}-head-title, ${componentCls}-extra`]: {
          paddingTop: 0,
          display: "flex",
          alignItems: "center"
        }
      }
    }
  };
}, "genCardSizeStyle"), prepareComponentToken$b = /* @__PURE__ */ __name((token2) => ({
  headerBg: "transparent",
  headerFontSize: token2.fontSizeLG,
  headerFontSizeSM: token2.fontSize,
  headerHeight: token2.fontSizeLG * token2.lineHeightLG + token2.padding * 2,
  headerHeightSM: token2.fontSize * token2.lineHeight + token2.paddingXS * 2,
  actionsBg: token2.colorBgContainer,
  actionsLiMargin: `${token2.paddingSM}px 0`,
  tabsMarginBottom: -token2.padding - token2.lineWidth,
  extraColor: token2.colorText
}), "prepareComponentToken$b"), useStyle$d = genStyleHooks("Card", (token2) => {
  const cardToken = merge(token2, {
    cardShadow: token2.boxShadowCard,
    cardHeadPadding: token2.padding,
    cardPaddingBase: token2.paddingLG,
    cardActionsIconSize: token2.fontSize,
    cardPaddingSM: 12
    // Fixed padding.
  });
  return [
    // Style
    genCardStyle(cardToken),
    // Size
    genCardSizeStyle(cardToken)
  ];
}, prepareComponentToken$b);
var __rest$A = function(s, e2) {
  var t2 = {};
  for (var p in s) Object.prototype.hasOwnProperty.call(s, p) && e2.indexOf(p) < 0 && (t2[p] = s[p]);
  if (s != null && typeof Object.getOwnPropertySymbols == "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++)
    e2.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]) && (t2[p[i]] = s[p[i]]);
  return t2;
};
const ActionNode = /* @__PURE__ */ __name((props) => {
  const {
    actionClasses,
    actions = [],
    actionStyle
  } = props;
  return /* @__PURE__ */ React.createElement("ul", {
    className: actionClasses,
    style: actionStyle
  }, actions.map((action, index2) => {
    const key = `action-${index2}`;
    return /* @__PURE__ */ React.createElement("li", {
      style: {
        width: `${100 / actions.length}%`
      },
      key
    }, /* @__PURE__ */ React.createElement("span", null, action));
  }));
}, "ActionNode"), Card$2 = /* @__PURE__ */ React.forwardRef((props, ref) => {
  const {
    prefixCls: customizePrefixCls,
    className,
    rootClassName,
    style: style2,
    extra,
    headStyle = {},
    bodyStyle = {},
    title: title2,
    loading,
    bordered = !0,
    size: customizeSize,
    type: type4,
    cover,
    actions,
    tabList,
    children,
    activeTabKey,
    defaultActiveTabKey,
    tabBarExtraContent,
    hoverable,
    tabProps = {},
    classNames: customClassNames,
    styles: customStyles
  } = props, others = __rest$A(props, ["prefixCls", "className", "rootClassName", "style", "extra", "headStyle", "bodyStyle", "title", "loading", "bordered", "size", "type", "cover", "actions", "tabList", "children", "activeTabKey", "defaultActiveTabKey", "tabBarExtraContent", "hoverable", "tabProps", "classNames", "styles"]), {
    getPrefixCls,
    direction,
    card
  } = React.useContext(ConfigContext);
  if (process.env.NODE_ENV !== "production") {
    const warning3 = devUseWarning("Card");
    [["headStyle", "styles.header"], ["bodyStyle", "styles.body"]].forEach((_ref) => {
      let [deprecatedName, newName] = _ref;
      warning3.deprecated(!(deprecatedName in props), deprecatedName, newName);
    });
  }
  const onTabChange = /* @__PURE__ */ __name((key) => {
    var _a;
    (_a = props.onTabChange) === null || _a === void 0 || _a.call(props, key);
  }, "onTabChange"), moduleClass = /* @__PURE__ */ __name((moduleName) => {
    var _a;
    return cn((_a = card == null ? void 0 : card.classNames) === null || _a === void 0 ? void 0 : _a[moduleName], customClassNames == null ? void 0 : customClassNames[moduleName]);
  }, "moduleClass"), moduleStyle = /* @__PURE__ */ __name((moduleName) => {
    var _a;
    return Object.assign(Object.assign({}, (_a = card == null ? void 0 : card.styles) === null || _a === void 0 ? void 0 : _a[moduleName]), customStyles == null ? void 0 : customStyles[moduleName]);
  }, "moduleStyle"), isContainGrid = React.useMemo(() => {
    let containGrid = !1;
    return React.Children.forEach(children, (element) => {
      (element == null ? void 0 : element.type) === Grid$1 && (containGrid = !0);
    }), containGrid;
  }, [children]), prefixCls = getPrefixCls("card", customizePrefixCls), [wrapCSSVar, hashId, cssVarCls] = useStyle$d(prefixCls), loadingBlock = /* @__PURE__ */ React.createElement(Skeleton, {
    loading: !0,
    active: !0,
    paragraph: {
      rows: 4
    },
    title: !1
  }, children), hasActiveTabKey = activeTabKey !== void 0, extraProps = Object.assign(Object.assign({}, tabProps), {
    [hasActiveTabKey ? "activeKey" : "defaultActiveKey"]: hasActiveTabKey ? activeTabKey : defaultActiveTabKey,
    tabBarExtraContent
  });
  let head;
  const mergedSize = useSize(customizeSize), tabSize = !mergedSize || mergedSize === "default" ? "large" : mergedSize, tabs = tabList ? /* @__PURE__ */ React.createElement(Tabs, Object.assign({
    size: tabSize
  }, extraProps, {
    className: `${prefixCls}-head-tabs`,
    onChange: onTabChange,
    items: tabList.map((_a) => {
      var {
        tab
      } = _a, item = __rest$A(_a, ["tab"]);
      return Object.assign({
        label: tab
      }, item);
    })
  })) : null;
  if (title2 || extra || tabs) {
    const headClasses = cn(`${prefixCls}-head`, moduleClass("header")), titleClasses = cn(`${prefixCls}-head-title`, moduleClass("title")), extraClasses = cn(`${prefixCls}-extra`, moduleClass("extra")), mergedHeadStyle = Object.assign(Object.assign({}, headStyle), moduleStyle("header"));
    head = /* @__PURE__ */ React.createElement("div", {
      className: headClasses,
      style: mergedHeadStyle
    }, /* @__PURE__ */ React.createElement("div", {
      className: `${prefixCls}-head-wrapper`
    }, title2 && /* @__PURE__ */ React.createElement("div", {
      className: titleClasses,
      style: moduleStyle("title")
    }, title2), extra && /* @__PURE__ */ React.createElement("div", {
      className: extraClasses,
      style: moduleStyle("extra")
    }, extra)), tabs);
  }
  const coverClasses = cn(`${prefixCls}-cover`, moduleClass("cover")), coverDom = cover ? /* @__PURE__ */ React.createElement("div", {
    className: coverClasses,
    style: moduleStyle("cover")
  }, cover) : null, bodyClasses = cn(`${prefixCls}-body`, moduleClass("body")), mergedBodyStyle = Object.assign(Object.assign({}, bodyStyle), moduleStyle("body")), body = /* @__PURE__ */ React.createElement("div", {
    className: bodyClasses,
    style: mergedBodyStyle
  }, loading ? loadingBlock : children), actionClasses = cn(`${prefixCls}-actions`, moduleClass("actions")), actionDom = actions != null && actions.length ? /* @__PURE__ */ React.createElement(ActionNode, {
    actionClasses,
    actionStyle: moduleStyle("actions"),
    actions
  }) : null, divProps = omit(others, ["onTabChange"]), classString = cn(prefixCls, card == null ? void 0 : card.className, {
    [`${prefixCls}-loading`]: loading,
    [`${prefixCls}-bordered`]: bordered,
    [`${prefixCls}-hoverable`]: hoverable,
    [`${prefixCls}-contain-grid`]: isContainGrid,
    [`${prefixCls}-contain-tabs`]: tabList == null ? void 0 : tabList.length,
    [`${prefixCls}-${mergedSize}`]: mergedSize,
    [`${prefixCls}-type-${type4}`]: !!type4,
    [`${prefixCls}-rtl`]: direction === "rtl"
  }, className, rootClassName, hashId, cssVarCls), mergedStyle = Object.assign(Object.assign({}, card == null ? void 0 : card.style), style2);
  return wrapCSSVar(/* @__PURE__ */ React.createElement("div", Object.assign({
    ref
  }, divProps, {
    className: classString,
    style: mergedStyle
  }), head, coverDom, body, actionDom));
});
var __rest$z = function(s, e2) {
  var t2 = {};
  for (var p in s) Object.prototype.hasOwnProperty.call(s, p) && e2.indexOf(p) < 0 && (t2[p] = s[p]);
  if (s != null && typeof Object.getOwnPropertySymbols == "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++)
    e2.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]) && (t2[p[i]] = s[p[i]]);
  return t2;
};
const Meta = /* @__PURE__ */ __name((props) => {
  const {
    prefixCls: customizePrefixCls,
    className,
    avatar,
    title: title2,
    description
  } = props, others = __rest$z(props, ["prefixCls", "className", "avatar", "title", "description"]), {
    getPrefixCls
  } = React.useContext(ConfigContext), prefixCls = getPrefixCls("card", customizePrefixCls), classString = cn(`${prefixCls}-meta`, className), avatarDom = avatar ? /* @__PURE__ */ React.createElement("div", {
    className: `${prefixCls}-meta-avatar`
  }, avatar) : null, titleDom = title2 ? /* @__PURE__ */ React.createElement("div", {
    className: `${prefixCls}-meta-title`
  }, title2) : null, descriptionDom = description ? /* @__PURE__ */ React.createElement("div", {
    className: `${prefixCls}-meta-description`
  }, description) : null, MetaDetail = titleDom || descriptionDom ? /* @__PURE__ */ React.createElement("div", {
    className: `${prefixCls}-meta-detail`
  }, titleDom, descriptionDom) : null;
  return /* @__PURE__ */ React.createElement("div", Object.assign({}, others, {
    className: classString
  }), avatarDom, MetaDetail);
}, "Meta"), Card$1 = Card$2;
Card$1.Grid = Grid$1;
Card$1.Meta = Meta;
process.env.NODE_ENV !== "production" && (Card$1.displayName = "Card");
function throttle(delay, callback, options) {
  var _ref = options || {}, _ref$noTrailing = _ref.noTrailing, noTrailing = _ref$noTrailing === void 0 ? !1 : _ref$noTrailing, _ref$noLeading = _ref.noLeading, noLeading = _ref$noLeading === void 0 ? !1 : _ref$noLeading, _ref$debounceMode = _ref.debounceMode, debounceMode = _ref$debounceMode === void 0 ? void 0 : _ref$debounceMode, timeoutID, cancelled = !1, lastExec = 0;
  function clearExistingTimeout() {
    timeoutID && clearTimeout(timeoutID);
  }
  __name(clearExistingTimeout, "clearExistingTimeout");
  function cancel(options2) {
    var _ref2 = options2 || {}, _ref2$upcomingOnly = _ref2.upcomingOnly, upcomingOnly = _ref2$upcomingOnly === void 0 ? !1 : _ref2$upcomingOnly;
    clearExistingTimeout(), cancelled = !upcomingOnly;
  }
  __name(cancel, "cancel");
  function wrapper() {
    for (var _len = arguments.length, arguments_ = new Array(_len), _key = 0; _key < _len; _key++)
      arguments_[_key] = arguments[_key];
    var self2 = this, elapsed = Date.now() - lastExec;
    if (cancelled)
      return;
    function exec() {
      lastExec = Date.now(), callback.apply(self2, arguments_);
    }
    __name(exec, "exec");
    function clear() {
      timeoutID = void 0;
    }
    __name(clear, "clear"), !noLeading && debounceMode && !timeoutID && exec(), clearExistingTimeout(), debounceMode === void 0 && elapsed > delay ? noLeading ? (lastExec = Date.now(), noTrailing || (timeoutID = setTimeout(debounceMode ? clear : exec, delay))) : exec() : noTrailing !== !0 && (timeoutID = setTimeout(debounceMode ? clear : exec, debounceMode === void 0 ? delay - elapsed : delay));
  }
  return __name(wrapper, "wrapper"), wrapper.cancel = cancel, wrapper;
}
__name(throttle, "throttle");
function debounce(delay, callback, options) {
  var _ref = {}, _ref$atBegin = _ref.atBegin, atBegin = _ref$atBegin === void 0 ? !1 : _ref$atBegin;
  return throttle(delay, callback, {
    debounceMode: atBegin !== !1
  });
}
__name(debounce, "debounce");
function getEntity(keyEntities, key) {
  return keyEntities[key];
}
__name(getEntity, "getEntity");
var _excluded$h = ["children"];
function getPosition(level, index2) {
  return "".concat(level, "-").concat(index2);
}
__name(getPosition, "getPosition");
function isTreeNode(node2) {
  return node2 && node2.type && node2.type.isTreeNode;
}
__name(isTreeNode, "isTreeNode");
function getKey(key, pos) {
  return key ?? pos;
}
__name(getKey, "getKey");
function fillFieldNames(fieldNames) {
  var _ref = fieldNames || {}, title2 = _ref.title, _title = _ref._title, key = _ref.key, children = _ref.children, mergedTitle = title2 || "title";
  return {
    title: mergedTitle,
    _title: _title || [mergedTitle],
    key: key || "key",
    children: children || "children"
  };
}
__name(fillFieldNames, "fillFieldNames");
function warningWithoutKey(treeData, fieldNames) {
  var keys2 = /* @__PURE__ */ new Map();
  function dig(list) {
    var path2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
    (list || []).forEach(function(treeNode) {
      var key = treeNode[fieldNames.key], children = treeNode[fieldNames.children];
      warningOnce(key != null, "Tree node must have a certain key: [".concat(path2).concat(key, "]"));
      var recordKey = String(key);
      warningOnce(!keys2.has(recordKey) || key === null || key === void 0, "Same 'key' exist in the Tree: ".concat(recordKey)), keys2.set(recordKey, !0), dig(children, "".concat(path2).concat(recordKey, " > "));
    });
  }
  __name(dig, "dig"), dig(treeData);
}
__name(warningWithoutKey, "warningWithoutKey");
function convertTreeToData(rootNodes) {
  function dig(node2) {
    var treeNodes = toArray$7(node2);
    return treeNodes.map(function(treeNode) {
      if (!isTreeNode(treeNode))
        return warningOnce(!treeNode, "Tree/TreeNode can only accept TreeNode as children."), null;
      var key = treeNode.key, _treeNode$props = treeNode.props, children = _treeNode$props.children, rest = _objectWithoutProperties(_treeNode$props, _excluded$h), dataNode = _objectSpread2$1({
        key
      }, rest), parsedChildren = dig(children);
      return parsedChildren.length && (dataNode.children = parsedChildren), dataNode;
    }).filter(function(dataNode) {
      return dataNode;
    });
  }
  return __name(dig, "dig"), dig(rootNodes);
}
__name(convertTreeToData, "convertTreeToData");
function flattenTreeData(treeNodeList, expandedKeys, fieldNames) {
  var _fillFieldNames = fillFieldNames(fieldNames), fieldTitles = _fillFieldNames._title, fieldKey = _fillFieldNames.key, fieldChildren = _fillFieldNames.children, expandedKeySet = new Set(expandedKeys === !0 ? [] : expandedKeys), flattenList = [];
  function dig(list) {
    var parent = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
    return list.map(function(treeNode, index2) {
      for (var pos = getPosition(parent ? parent.pos : "0", index2), mergedKey = getKey(treeNode[fieldKey], pos), mergedTitle, i = 0; i < fieldTitles.length; i += 1) {
        var fieldTitle = fieldTitles[i];
        if (treeNode[fieldTitle] !== void 0) {
          mergedTitle = treeNode[fieldTitle];
          break;
        }
      }
      var flattenNode = Object.assign(omit(treeNode, [].concat(_toConsumableArray(fieldTitles), [fieldKey, fieldChildren])), {
        title: mergedTitle,
        key: mergedKey,
        parent,
        pos,
        children: null,
        data: treeNode,
        isStart: [].concat(_toConsumableArray(parent ? parent.isStart : []), [index2 === 0]),
        isEnd: [].concat(_toConsumableArray(parent ? parent.isEnd : []), [index2 === list.length - 1])
      });
      return flattenList.push(flattenNode), expandedKeys === !0 || expandedKeySet.has(mergedKey) ? flattenNode.children = dig(treeNode[fieldChildren] || [], flattenNode) : flattenNode.children = [], flattenNode;
    });
  }
  return __name(dig, "dig"), dig(treeNodeList), flattenList;
}
__name(flattenTreeData, "flattenTreeData");
function traverseDataNodes(dataNodes, callback, config) {
  var mergedConfig = {};
  _typeof$4(config) === "object" ? mergedConfig = config : mergedConfig = {
    externalGetKey: config
  }, mergedConfig = mergedConfig || {};
  var _mergedConfig = mergedConfig, childrenPropName = _mergedConfig.childrenPropName, externalGetKey = _mergedConfig.externalGetKey, fieldNames = _mergedConfig.fieldNames, _fillFieldNames2 = fillFieldNames(fieldNames), fieldKey = _fillFieldNames2.key, fieldChildren = _fillFieldNames2.children, mergeChildrenPropName = childrenPropName || fieldChildren, syntheticGetKey;
  externalGetKey ? typeof externalGetKey == "string" ? syntheticGetKey = /* @__PURE__ */ __name(function(node2) {
    return node2[externalGetKey];
  }, "syntheticGetKey") : typeof externalGetKey == "function" && (syntheticGetKey = /* @__PURE__ */ __name(function(node2) {
    return externalGetKey(node2);
  }, "syntheticGetKey")) : syntheticGetKey = /* @__PURE__ */ __name(function(node2, pos) {
    return getKey(node2[fieldKey], pos);
  }, "syntheticGetKey");
  function processNode(node2, index2, parent, pathNodes) {
    var children = node2 ? node2[mergeChildrenPropName] : dataNodes, pos = node2 ? getPosition(parent.pos, index2) : "0", connectNodes = node2 ? [].concat(_toConsumableArray(pathNodes), [node2]) : [];
    if (node2) {
      var key = syntheticGetKey(node2, pos), _data = {
        node: node2,
        index: index2,
        pos,
        key,
        parentPos: parent.node ? parent.pos : null,
        level: parent.level + 1,
        nodes: connectNodes
      };
      callback(_data);
    }
    children && children.forEach(function(subNode, subIndex) {
      processNode(subNode, subIndex, {
        node: node2,
        pos,
        level: parent ? parent.level + 1 : -1
      }, connectNodes);
    });
  }
  __name(processNode, "processNode"), processNode(null);
}
__name(traverseDataNodes, "traverseDataNodes");
function convertDataToEntities(dataNodes) {
  var _ref2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, initWrapper = _ref2.initWrapper, processEntity = _ref2.processEntity, onProcessFinished = _ref2.onProcessFinished, externalGetKey = _ref2.externalGetKey, childrenPropName = _ref2.childrenPropName, fieldNames = _ref2.fieldNames, legacyExternalGetKey = arguments.length > 2 ? arguments[2] : void 0, mergedExternalGetKey = externalGetKey || legacyExternalGetKey, posEntities = {}, keyEntities = {}, wrapper = {
    posEntities,
    keyEntities
  };
  return initWrapper && (wrapper = initWrapper(wrapper) || wrapper), traverseDataNodes(dataNodes, function(item) {
    var node2 = item.node, index2 = item.index, pos = item.pos, key = item.key, parentPos = item.parentPos, level = item.level, nodes = item.nodes, entity = {
      node: node2,
      nodes,
      index: index2,
      key,
      pos,
      level
    }, mergedKey = getKey(key, pos);
    posEntities[pos] = entity, keyEntities[mergedKey] = entity, entity.parent = posEntities[parentPos], entity.parent && (entity.parent.children = entity.parent.children || [], entity.parent.children.push(entity)), processEntity && processEntity(entity, wrapper);
  }, {
    externalGetKey: mergedExternalGetKey,
    childrenPropName,
    fieldNames
  }), onProcessFinished && onProcessFinished(wrapper), wrapper;
}
__name(convertDataToEntities, "convertDataToEntities");
function getTreeNodeProps(key, _ref3) {
  var expandedKeys = _ref3.expandedKeys, selectedKeys = _ref3.selectedKeys, loadedKeys = _ref3.loadedKeys, loadingKeys = _ref3.loadingKeys, checkedKeys = _ref3.checkedKeys, halfCheckedKeys = _ref3.halfCheckedKeys, dragOverNodeKey = _ref3.dragOverNodeKey, dropPosition = _ref3.dropPosition, keyEntities = _ref3.keyEntities, entity = getEntity(keyEntities, key), treeNodeProps = {
    eventKey: key,
    expanded: expandedKeys.indexOf(key) !== -1,
    selected: selectedKeys.indexOf(key) !== -1,
    loaded: loadedKeys.indexOf(key) !== -1,
    loading: loadingKeys.indexOf(key) !== -1,
    checked: checkedKeys.indexOf(key) !== -1,
    halfChecked: halfCheckedKeys.indexOf(key) !== -1,
    pos: String(entity ? entity.pos : ""),
    // [Legacy] Drag props
    // Since the interaction of drag is changed, the semantic of the props are
    // not accuracy, I think it should be finally removed
    dragOver: dragOverNodeKey === key && dropPosition === 0,
    dragOverGapTop: dragOverNodeKey === key && dropPosition === -1,
    dragOverGapBottom: dragOverNodeKey === key && dropPosition === 1
  };
  return treeNodeProps;
}
__name(getTreeNodeProps, "getTreeNodeProps");
function convertNodePropsToEventData(props) {
  var data = props.data, expanded = props.expanded, selected = props.selected, checked = props.checked, loaded = props.loaded, loading = props.loading, halfChecked = props.halfChecked, dragOver = props.dragOver, dragOverGapTop = props.dragOverGapTop, dragOverGapBottom = props.dragOverGapBottom, pos = props.pos, active = props.active, eventKey = props.eventKey, eventData = _objectSpread2$1(_objectSpread2$1({}, data), {}, {
    expanded,
    selected,
    checked,
    loaded,
    loading,
    halfChecked,
    dragOver,
    dragOverGapTop,
    dragOverGapBottom,
    pos,
    active,
    key: eventKey
  });
  return "props" in eventData || Object.defineProperty(eventData, "props", {
    get: /* @__PURE__ */ __name(function() {
      return warningOnce(!1, "Second param return from event is node data instead of TreeNode instance. Please read value directly instead of reading from `props`."), props;
    }, "get")
  }), eventData;
}
__name(convertNodePropsToEventData, "convertNodePropsToEventData");
function removeFromCheckedKeys(halfCheckedKeys, checkedKeys) {
  var filteredKeys = /* @__PURE__ */ new Set();
  return halfCheckedKeys.forEach(function(key) {
    checkedKeys.has(key) || filteredKeys.add(key);
  }), filteredKeys;
}
__name(removeFromCheckedKeys, "removeFromCheckedKeys");
function isCheckDisabled(node2) {
  var _ref = node2 || {}, disabled = _ref.disabled, disableCheckbox = _ref.disableCheckbox, checkable = _ref.checkable;
  return !!(disabled || disableCheckbox) || checkable === !1;
}
__name(isCheckDisabled, "isCheckDisabled");
function fillConductCheck(keys2, levelEntities, maxLevel, syntheticGetCheckDisabled) {
  for (var checkedKeys = new Set(keys2), halfCheckedKeys = /* @__PURE__ */ new Set(), level = 0; level <= maxLevel; level += 1) {
    var entities = levelEntities.get(level) || /* @__PURE__ */ new Set();
    entities.forEach(function(entity) {
      var key = entity.key, node2 = entity.node, _entity$children = entity.children, children = _entity$children === void 0 ? [] : _entity$children;
      checkedKeys.has(key) && !syntheticGetCheckDisabled(node2) && children.filter(function(childEntity) {
        return !syntheticGetCheckDisabled(childEntity.node);
      }).forEach(function(childEntity) {
        checkedKeys.add(childEntity.key);
      });
    });
  }
  for (var visitedKeys = /* @__PURE__ */ new Set(), _level = maxLevel; _level >= 0; _level -= 1) {
    var _entities = levelEntities.get(_level) || /* @__PURE__ */ new Set();
    _entities.forEach(function(entity) {
      var parent = entity.parent, node2 = entity.node;
      if (!(syntheticGetCheckDisabled(node2) || !entity.parent || visitedKeys.has(entity.parent.key))) {
        if (syntheticGetCheckDisabled(entity.parent.node)) {
          visitedKeys.add(parent.key);
          return;
        }
        var allChecked = !0, partialChecked = !1;
        (parent.children || []).filter(function(childEntity) {
          return !syntheticGetCheckDisabled(childEntity.node);
        }).forEach(function(_ref2) {
          var key = _ref2.key, checked = checkedKeys.has(key);
          allChecked && !checked && (allChecked = !1), !partialChecked && (checked || halfCheckedKeys.has(key)) && (partialChecked = !0);
        }), allChecked && checkedKeys.add(parent.key), partialChecked && halfCheckedKeys.add(parent.key), visitedKeys.add(parent.key);
      }
    });
  }
  return {
    checkedKeys: Array.from(checkedKeys),
    halfCheckedKeys: Array.from(removeFromCheckedKeys(halfCheckedKeys, checkedKeys))
  };
}
__name(fillConductCheck, "fillConductCheck");
function cleanConductCheck(keys2, halfKeys, levelEntities, maxLevel, syntheticGetCheckDisabled) {
  for (var checkedKeys = new Set(keys2), halfCheckedKeys = new Set(halfKeys), level = 0; level <= maxLevel; level += 1) {
    var entities = levelEntities.get(level) || /* @__PURE__ */ new Set();
    entities.forEach(function(entity) {
      var key = entity.key, node2 = entity.node, _entity$children2 = entity.children, children = _entity$children2 === void 0 ? [] : _entity$children2;
      !checkedKeys.has(key) && !halfCheckedKeys.has(key) && !syntheticGetCheckDisabled(node2) && children.filter(function(childEntity) {
        return !syntheticGetCheckDisabled(childEntity.node);
      }).forEach(function(childEntity) {
        checkedKeys.delete(childEntity.key);
      });
    });
  }
  halfCheckedKeys = /* @__PURE__ */ new Set();
  for (var visitedKeys = /* @__PURE__ */ new Set(), _level2 = maxLevel; _level2 >= 0; _level2 -= 1) {
    var _entities2 = levelEntities.get(_level2) || /* @__PURE__ */ new Set();
    _entities2.forEach(function(entity) {
      var parent = entity.parent, node2 = entity.node;
      if (!(syntheticGetCheckDisabled(node2) || !entity.parent || visitedKeys.has(entity.parent.key))) {
        if (syntheticGetCheckDisabled(entity.parent.node)) {
          visitedKeys.add(parent.key);
          return;
        }
        var allChecked = !0, partialChecked = !1;
        (parent.children || []).filter(function(childEntity) {
          return !syntheticGetCheckDisabled(childEntity.node);
        }).forEach(function(_ref3) {
          var key = _ref3.key, checked = checkedKeys.has(key);
          allChecked && !checked && (allChecked = !1), !partialChecked && (checked || halfCheckedKeys.has(key)) && (partialChecked = !0);
        }), allChecked || checkedKeys.delete(parent.key), partialChecked && halfCheckedKeys.add(parent.key), visitedKeys.add(parent.key);
      }
    });
  }
  return {
    checkedKeys: Array.from(checkedKeys),
    halfCheckedKeys: Array.from(removeFromCheckedKeys(halfCheckedKeys, checkedKeys))
  };
}
__name(cleanConductCheck, "cleanConductCheck");
function conductCheck(keyList, checked, keyEntities, getCheckDisabled) {
  var warningMissKeys = [], syntheticGetCheckDisabled;
  getCheckDisabled ? syntheticGetCheckDisabled = getCheckDisabled : syntheticGetCheckDisabled = isCheckDisabled;
  var keys2 = new Set(keyList.filter(function(key) {
    var hasEntity = !!getEntity(keyEntities, key);
    return hasEntity || warningMissKeys.push(key), hasEntity;
  })), levelEntities = /* @__PURE__ */ new Map(), maxLevel = 0;
  Object.keys(keyEntities).forEach(function(key) {
    var entity = keyEntities[key], level = entity.level, levelSet = levelEntities.get(level);
    levelSet || (levelSet = /* @__PURE__ */ new Set(), levelEntities.set(level, levelSet)), levelSet.add(entity), maxLevel = Math.max(maxLevel, level);
  }), warningOnce(!warningMissKeys.length, "Tree missing follow keys: ".concat(warningMissKeys.slice(0, 100).map(function(key) {
    return "'".concat(key, "'");
  }).join(", ")));
  var result;
  return checked === !0 ? result = fillConductCheck(keys2, levelEntities, maxLevel, syntheticGetCheckDisabled) : result = cleanConductCheck(keys2, checked.halfCheckedKeys, levelEntities, maxLevel, syntheticGetCheckDisabled), result;
}
__name(conductCheck, "conductCheck");
const genCheckboxStyle = /* @__PURE__ */ __name((token2) => {
  const {
    checkboxCls
  } = token2, wrapperCls = `${checkboxCls}-wrapper`;
  return [
    // ===================== Basic =====================
    {
      // Group
      [`${checkboxCls}-group`]: Object.assign(Object.assign({}, resetComponent(token2)), {
        display: "inline-flex",
        flexWrap: "wrap",
        columnGap: token2.marginXS,
        // Group > Grid
        [`> ${token2.antCls}-row`]: {
          flex: 1
        }
      }),
      // Wrapper
      [wrapperCls]: Object.assign(Object.assign({}, resetComponent(token2)), {
        display: "inline-flex",
        alignItems: "baseline",
        cursor: "pointer",
        // Fix checkbox & radio in flex align #30260
        "&:after": {
          display: "inline-block",
          width: 0,
          overflow: "hidden",
          content: "'\\a0'"
        },
        // Checkbox near checkbox
        [`& + ${wrapperCls}`]: {
          marginInlineStart: 0
        },
        [`&${wrapperCls}-in-form-item`]: {
          'input[type="checkbox"]': {
            width: 14,
            // FIXME: magic
            height: 14
            // FIXME: magic
          }
        }
      }),
      // Wrapper > Checkbox
      [checkboxCls]: Object.assign(Object.assign({}, resetComponent(token2)), {
        position: "relative",
        whiteSpace: "nowrap",
        lineHeight: 1,
        cursor: "pointer",
        borderRadius: token2.borderRadiusSM,
        // To make alignment right when `controlHeight` is changed
        // Ref: https://github.com/ant-design/ant-design/issues/41564
        alignSelf: "center",
        // Wrapper > Checkbox > input
        [`${checkboxCls}-input`]: {
          position: "absolute",
          // Since baseline align will get additional space offset,
          // we need to move input to top to make it align with text.
          // Ref: https://github.com/ant-design/ant-design/issues/38926#issuecomment-1486137799
          inset: 0,
          zIndex: 1,
          cursor: "pointer",
          opacity: 0,
          margin: 0,
          [`&:focus-visible + ${checkboxCls}-inner`]: Object.assign({}, genFocusOutline(token2))
        },
        // Wrapper > Checkbox > inner
        [`${checkboxCls}-inner`]: {
          boxSizing: "border-box",
          display: "block",
          width: token2.checkboxSize,
          height: token2.checkboxSize,
          direction: "ltr",
          backgroundColor: token2.colorBgContainer,
          border: `${unit$1(token2.lineWidth)} ${token2.lineType} ${token2.colorBorder}`,
          borderRadius: token2.borderRadiusSM,
          borderCollapse: "separate",
          transition: `all ${token2.motionDurationSlow}`,
          "&:after": {
            boxSizing: "border-box",
            position: "absolute",
            top: "50%",
            insetInlineStart: "25%",
            display: "table",
            width: token2.calc(token2.checkboxSize).div(14).mul(5).equal(),
            height: token2.calc(token2.checkboxSize).div(14).mul(8).equal(),
            border: `${unit$1(token2.lineWidthBold)} solid ${token2.colorWhite}`,
            borderTop: 0,
            borderInlineStart: 0,
            transform: "rotate(45deg) scale(0) translate(-50%,-50%)",
            opacity: 0,
            content: '""',
            transition: `all ${token2.motionDurationFast} ${token2.motionEaseInBack}, opacity ${token2.motionDurationFast}`
          }
        },
        // Wrapper > Checkbox + Text
        "& + span": {
          paddingInlineStart: token2.paddingXS,
          paddingInlineEnd: token2.paddingXS
        }
      })
    },
    // ===================== Hover =====================
    {
      // Wrapper & Wrapper > Checkbox
      [`
        ${wrapperCls}:not(${wrapperCls}-disabled),
        ${checkboxCls}:not(${checkboxCls}-disabled)
      `]: {
        [`&:hover ${checkboxCls}-inner`]: {
          borderColor: token2.colorPrimary
        }
      },
      [`${wrapperCls}:not(${wrapperCls}-disabled)`]: {
        [`&:hover ${checkboxCls}-checked:not(${checkboxCls}-disabled) ${checkboxCls}-inner`]: {
          backgroundColor: token2.colorPrimaryHover,
          borderColor: "transparent"
        },
        [`&:hover ${checkboxCls}-checked:not(${checkboxCls}-disabled):after`]: {
          borderColor: token2.colorPrimaryHover
        }
      }
    },
    // ==================== Checked ====================
    {
      // Wrapper > Checkbox
      [`${checkboxCls}-checked`]: {
        [`${checkboxCls}-inner`]: {
          backgroundColor: token2.colorPrimary,
          borderColor: token2.colorPrimary,
          "&:after": {
            opacity: 1,
            transform: "rotate(45deg) scale(1) translate(-50%,-50%)",
            transition: `all ${token2.motionDurationMid} ${token2.motionEaseOutBack} ${token2.motionDurationFast}`
          }
        }
      },
      [`
        ${wrapperCls}-checked:not(${wrapperCls}-disabled),
        ${checkboxCls}-checked:not(${checkboxCls}-disabled)
      `]: {
        [`&:hover ${checkboxCls}-inner`]: {
          backgroundColor: token2.colorPrimaryHover,
          borderColor: "transparent"
        }
      }
    },
    // ================= Indeterminate =================
    {
      [checkboxCls]: {
        "&-indeterminate": {
          // Wrapper > Checkbox > inner
          [`${checkboxCls}-inner`]: {
            backgroundColor: `${token2.colorBgContainer} !important`,
            borderColor: `${token2.colorBorder} !important`,
            "&:after": {
              top: "50%",
              insetInlineStart: "50%",
              width: token2.calc(token2.fontSizeLG).div(2).equal(),
              height: token2.calc(token2.fontSizeLG).div(2).equal(),
              backgroundColor: token2.colorPrimary,
              border: 0,
              transform: "translate(-50%, -50%) scale(1)",
              opacity: 1,
              content: '""'
            }
          },
          // https://github.com/ant-design/ant-design/issues/50074
          [`&:hover ${checkboxCls}-inner`]: {
            backgroundColor: `${token2.colorBgContainer} !important`,
            borderColor: `${token2.colorPrimary} !important`
          }
        }
      }
    },
    // ==================== Disable ====================
    {
      // Wrapper
      [`${wrapperCls}-disabled`]: {
        cursor: "not-allowed"
      },
      // Wrapper > Checkbox
      [`${checkboxCls}-disabled`]: {
        // Wrapper > Checkbox > input
        [`&, ${checkboxCls}-input`]: {
          cursor: "not-allowed",
          // Disabled for native input to enable Tooltip event handler
          // ref: https://github.com/ant-design/ant-design/issues/39822#issuecomment-1365075901
          pointerEvents: "none"
        },
        // Wrapper > Checkbox > inner
        [`${checkboxCls}-inner`]: {
          background: token2.colorBgContainerDisabled,
          borderColor: token2.colorBorder,
          "&:after": {
            borderColor: token2.colorTextDisabled
          }
        },
        "&:after": {
          display: "none"
        },
        "& + span": {
          color: token2.colorTextDisabled
        },
        [`&${checkboxCls}-indeterminate ${checkboxCls}-inner::after`]: {
          background: token2.colorTextDisabled
        }
      }
    }
  ];
}, "genCheckboxStyle");
function getStyle(prefixCls, token2) {
  const checkboxToken = merge(token2, {
    checkboxCls: `.${prefixCls}`,
    checkboxSize: token2.controlInteractiveSize
  });
  return [genCheckboxStyle(checkboxToken)];
}
__name(getStyle, "getStyle");
const useStyle$c = genStyleHooks("Checkbox", (token2, _ref) => {
  let {
    prefixCls
  } = _ref;
  return [getStyle(prefixCls, token2)];
}), GroupContext = /* @__PURE__ */ React__default.createContext(null);
var __rest$y = function(s, e2) {
  var t2 = {};
  for (var p in s) Object.prototype.hasOwnProperty.call(s, p) && e2.indexOf(p) < 0 && (t2[p] = s[p]);
  if (s != null && typeof Object.getOwnPropertySymbols == "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++)
    e2.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]) && (t2[p[i]] = s[p[i]]);
  return t2;
};
const InternalCheckbox = /* @__PURE__ */ __name((props, ref) => {
  var _a;
  const {
    prefixCls: customizePrefixCls,
    className,
    rootClassName,
    children,
    indeterminate = !1,
    style: style2,
    onMouseEnter,
    onMouseLeave,
    skipGroup = !1,
    disabled
  } = props, restProps = __rest$y(props, ["prefixCls", "className", "rootClassName", "children", "indeterminate", "style", "onMouseEnter", "onMouseLeave", "skipGroup", "disabled"]), {
    getPrefixCls,
    direction,
    checkbox
  } = React.useContext(ConfigContext), checkboxGroup = React.useContext(GroupContext), {
    isFormItemInput
  } = React.useContext(FormItemInputContext), contextDisabled = React.useContext(DisabledContext), mergedDisabled = (_a = (checkboxGroup == null ? void 0 : checkboxGroup.disabled) || disabled) !== null && _a !== void 0 ? _a : contextDisabled, prevValue = React.useRef(restProps.value), checkboxRef = React.useRef(null), mergedRef = composeRef(ref, checkboxRef);
  if (process.env.NODE_ENV !== "production") {
    const warning3 = devUseWarning("Checkbox");
    process.env.NODE_ENV !== "production" && warning3("checked" in restProps || !!checkboxGroup || !("value" in restProps), "usage", "`value` is not a valid prop, do you mean `checked`?");
  }
  React.useEffect(() => {
    checkboxGroup == null || checkboxGroup.registerValue(restProps.value);
  }, []), React.useEffect(() => {
    if (!skipGroup)
      return restProps.value !== prevValue.current && (checkboxGroup == null || checkboxGroup.cancelValue(prevValue.current), checkboxGroup == null || checkboxGroup.registerValue(restProps.value), prevValue.current = restProps.value), () => checkboxGroup == null ? void 0 : checkboxGroup.cancelValue(restProps.value);
  }, [restProps.value]), React.useEffect(() => {
    var _a2;
    !((_a2 = checkboxRef.current) === null || _a2 === void 0) && _a2.input && (checkboxRef.current.input.indeterminate = indeterminate);
  }, [indeterminate]);
  const prefixCls = getPrefixCls("checkbox", customizePrefixCls), rootCls = useCSSVarCls(prefixCls), [wrapCSSVar, hashId, cssVarCls] = useStyle$c(prefixCls, rootCls), checkboxProps = Object.assign({}, restProps);
  checkboxGroup && !skipGroup && (checkboxProps.onChange = function() {
    restProps.onChange && restProps.onChange.apply(restProps, arguments), checkboxGroup.toggleOption && checkboxGroup.toggleOption({
      label: children,
      value: restProps.value
    });
  }, checkboxProps.name = checkboxGroup.name, checkboxProps.checked = checkboxGroup.value.includes(restProps.value));
  const classString = cn(`${prefixCls}-wrapper`, {
    [`${prefixCls}-rtl`]: direction === "rtl",
    [`${prefixCls}-wrapper-checked`]: checkboxProps.checked,
    [`${prefixCls}-wrapper-disabled`]: mergedDisabled,
    [`${prefixCls}-wrapper-in-form-item`]: isFormItemInput
  }, checkbox == null ? void 0 : checkbox.className, className, rootClassName, cssVarCls, rootCls, hashId), checkboxClass = cn({
    [`${prefixCls}-indeterminate`]: indeterminate
  }, TARGET_CLS, hashId), [onLabelClick, onInputClick] = useBubbleLock(checkboxProps.onClick);
  return wrapCSSVar(/* @__PURE__ */ React.createElement(Wave, {
    component: "Checkbox",
    disabled: mergedDisabled
  }, /* @__PURE__ */ React.createElement("label", {
    className: classString,
    style: Object.assign(Object.assign({}, checkbox == null ? void 0 : checkbox.style), style2),
    onMouseEnter,
    onMouseLeave,
    onClick: onLabelClick
  }, /* @__PURE__ */ React.createElement(Checkbox$3, Object.assign({}, checkboxProps, {
    onClick: onInputClick,
    prefixCls,
    className: checkboxClass,
    disabled: mergedDisabled,
    ref: mergedRef
  })), children !== void 0 && /* @__PURE__ */ React.createElement("span", null, children))));
}, "InternalCheckbox"), Checkbox$2 = /* @__PURE__ */ React.forwardRef(InternalCheckbox);
process.env.NODE_ENV !== "production" && (Checkbox$2.displayName = "Checkbox");
var __rest$x = function(s, e2) {
  var t2 = {};
  for (var p in s) Object.prototype.hasOwnProperty.call(s, p) && e2.indexOf(p) < 0 && (t2[p] = s[p]);
  if (s != null && typeof Object.getOwnPropertySymbols == "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++)
    e2.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]) && (t2[p[i]] = s[p[i]]);
  return t2;
};
const CheckboxGroup = /* @__PURE__ */ React.forwardRef((props, ref) => {
  const {
    defaultValue,
    children,
    options = [],
    prefixCls: customizePrefixCls,
    className,
    rootClassName,
    style: style2,
    onChange
  } = props, restProps = __rest$x(props, ["defaultValue", "children", "options", "prefixCls", "className", "rootClassName", "style", "onChange"]), {
    getPrefixCls,
    direction
  } = React.useContext(ConfigContext), [value, setValue] = React.useState(restProps.value || defaultValue || []), [registeredValues, setRegisteredValues] = React.useState([]);
  React.useEffect(() => {
    "value" in restProps && setValue(restProps.value || []);
  }, [restProps.value]);
  const memoOptions = React.useMemo(() => options.map((option) => typeof option == "string" || typeof option == "number" ? {
    label: option,
    value: option
  } : option), [options]), cancelValue = /* @__PURE__ */ __name((val) => {
    setRegisteredValues((prevValues) => prevValues.filter((v) => v !== val));
  }, "cancelValue"), registerValue = /* @__PURE__ */ __name((val) => {
    setRegisteredValues((prevValues) => [].concat(_toConsumableArray(prevValues), [val]));
  }, "registerValue"), toggleOption = /* @__PURE__ */ __name((option) => {
    const optionIndex = value.indexOf(option.value), newValue = _toConsumableArray(value);
    optionIndex === -1 ? newValue.push(option.value) : newValue.splice(optionIndex, 1), "value" in restProps || setValue(newValue), onChange == null || onChange(newValue.filter((val) => registeredValues.includes(val)).sort((a, b) => {
      const indexA = memoOptions.findIndex((opt) => opt.value === a), indexB = memoOptions.findIndex((opt) => opt.value === b);
      return indexA - indexB;
    }));
  }, "toggleOption"), prefixCls = getPrefixCls("checkbox", customizePrefixCls), groupPrefixCls = `${prefixCls}-group`, rootCls = useCSSVarCls(prefixCls), [wrapCSSVar, hashId, cssVarCls] = useStyle$c(prefixCls, rootCls), domProps = omit(restProps, ["value", "disabled"]), childrenNode = options.length ? memoOptions.map((option) => /* @__PURE__ */ React.createElement(Checkbox$2, {
    prefixCls,
    key: option.value.toString(),
    disabled: "disabled" in option ? option.disabled : restProps.disabled,
    value: option.value,
    checked: value.includes(option.value),
    onChange: option.onChange,
    className: `${groupPrefixCls}-item`,
    style: option.style,
    title: option.title,
    id: option.id,
    required: option.required
  }, option.label)) : children, context = {
    toggleOption,
    value,
    disabled: restProps.disabled,
    name: restProps.name,
    // https://github.com/ant-design/ant-design/issues/16376
    registerValue,
    cancelValue
  }, classString = cn(groupPrefixCls, {
    [`${groupPrefixCls}-rtl`]: direction === "rtl"
  }, className, rootClassName, cssVarCls, rootCls, hashId);
  return wrapCSSVar(/* @__PURE__ */ React.createElement("div", Object.assign({
    className: classString,
    style: style2
  }, domProps, {
    ref
  }), /* @__PURE__ */ React.createElement(GroupContext.Provider, {
    value: context
  }, childrenNode)));
}), Checkbox$1 = Checkbox$2;
Checkbox$1.Group = CheckboxGroup;
Checkbox$1.__ANT_CHECKBOX = !0;
process.env.NODE_ENV !== "production" && (Checkbox$1.displayName = "Checkbox");
const RowContext = /* @__PURE__ */ createContext$1({}), genGridRowStyle = /* @__PURE__ */ __name((token2) => {
  const {
    componentCls
  } = token2;
  return {
    // Grid system
    [componentCls]: {
      display: "flex",
      flexFlow: "row wrap",
      minWidth: 0,
      "&::before, &::after": {
        display: "flex"
      },
      "&-no-wrap": {
        flexWrap: "nowrap"
      },
      // The origin of the X-axis
      "&-start": {
        justifyContent: "flex-start"
      },
      // The center of the X-axis
      "&-center": {
        justifyContent: "center"
      },
      // The opposite of the X-axis
      "&-end": {
        justifyContent: "flex-end"
      },
      "&-space-between": {
        justifyContent: "space-between"
      },
      "&-space-around": {
        justifyContent: "space-around"
      },
      "&-space-evenly": {
        justifyContent: "space-evenly"
      },
      // Align at the top
      "&-top": {
        alignItems: "flex-start"
      },
      // Align at the center
      "&-middle": {
        alignItems: "center"
      },
      "&-bottom": {
        alignItems: "flex-end"
      }
    }
  };
}, "genGridRowStyle"), genGridColStyle = /* @__PURE__ */ __name((token2) => {
  const {
    componentCls
  } = token2;
  return {
    // Grid system
    [componentCls]: {
      position: "relative",
      maxWidth: "100%",
      // Prevent columns from collapsing when empty
      minHeight: 1
    }
  };
}, "genGridColStyle"), genLoopGridColumnsStyle = /* @__PURE__ */ __name((token2, sizeCls) => {
  const {
    prefixCls,
    componentCls,
    gridColumns
  } = token2, gridColumnsStyle = {};
  for (let i = gridColumns; i >= 0; i--)
    i === 0 ? (gridColumnsStyle[`${componentCls}${sizeCls}-${i}`] = {
      display: "none"
    }, gridColumnsStyle[`${componentCls}-push-${i}`] = {
      insetInlineStart: "auto"
    }, gridColumnsStyle[`${componentCls}-pull-${i}`] = {
      insetInlineEnd: "auto"
    }, gridColumnsStyle[`${componentCls}${sizeCls}-push-${i}`] = {
      insetInlineStart: "auto"
    }, gridColumnsStyle[`${componentCls}${sizeCls}-pull-${i}`] = {
      insetInlineEnd: "auto"
    }, gridColumnsStyle[`${componentCls}${sizeCls}-offset-${i}`] = {
      marginInlineStart: 0
    }, gridColumnsStyle[`${componentCls}${sizeCls}-order-${i}`] = {
      order: 0
    }) : (gridColumnsStyle[`${componentCls}${sizeCls}-${i}`] = [
      // https://github.com/ant-design/ant-design/issues/44456
      // Form set `display: flex` on Col which will override `display: block`.
      // Let's get it from css variable to support override.
      {
        "--ant-display": "block",
        // Fallback to display if variable not support
        display: "block"
      },
      {
        display: "var(--ant-display)",
        flex: `0 0 ${i / gridColumns * 100}%`,
        maxWidth: `${i / gridColumns * 100}%`
      }
    ], gridColumnsStyle[`${componentCls}${sizeCls}-push-${i}`] = {
      insetInlineStart: `${i / gridColumns * 100}%`
    }, gridColumnsStyle[`${componentCls}${sizeCls}-pull-${i}`] = {
      insetInlineEnd: `${i / gridColumns * 100}%`
    }, gridColumnsStyle[`${componentCls}${sizeCls}-offset-${i}`] = {
      marginInlineStart: `${i / gridColumns * 100}%`
    }, gridColumnsStyle[`${componentCls}${sizeCls}-order-${i}`] = {
      order: i
    });
  return gridColumnsStyle[`${componentCls}${sizeCls}-flex`] = {
    flex: `var(--${prefixCls}${sizeCls}-flex)`
  }, gridColumnsStyle;
}, "genLoopGridColumnsStyle"), genGridStyle = /* @__PURE__ */ __name((token2, sizeCls) => genLoopGridColumnsStyle(token2, sizeCls), "genGridStyle"), genGridMediaStyle = /* @__PURE__ */ __name((token2, screenSize, sizeCls) => ({
  [`@media (min-width: ${unit$1(screenSize)})`]: Object.assign({}, genGridStyle(token2, sizeCls))
}), "genGridMediaStyle"), prepareRowComponentToken = /* @__PURE__ */ __name(() => ({}), "prepareRowComponentToken"), prepareColComponentToken = /* @__PURE__ */ __name(() => ({}), "prepareColComponentToken"), useRowStyle = genStyleHooks("Grid", genGridRowStyle, prepareRowComponentToken), useColStyle = genStyleHooks("Grid", (token2) => {
  const gridToken = merge(token2, {
    gridColumns: 24
    // Row is divided into 24 parts in Grid
  }), gridMediaSizesMap = {
    "-sm": gridToken.screenSMMin,
    "-md": gridToken.screenMDMin,
    "-lg": gridToken.screenLGMin,
    "-xl": gridToken.screenXLMin,
    "-xxl": gridToken.screenXXLMin
  };
  return [genGridColStyle(gridToken), genGridStyle(gridToken, ""), genGridStyle(gridToken, "-xs"), Object.keys(gridMediaSizesMap).map((key) => genGridMediaStyle(gridToken, gridMediaSizesMap[key], key)).reduce((pre, cur) => Object.assign(Object.assign({}, pre), cur), {})];
}, prepareColComponentToken);
var __rest$w = function(s, e2) {
  var t2 = {};
  for (var p in s) Object.prototype.hasOwnProperty.call(s, p) && e2.indexOf(p) < 0 && (t2[p] = s[p]);
  if (s != null && typeof Object.getOwnPropertySymbols == "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++)
    e2.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]) && (t2[p[i]] = s[p[i]]);
  return t2;
};
function parseFlex(flex) {
  return typeof flex == "number" ? `${flex} ${flex} auto` : /^\d+(\.\d+)?(px|em|rem|%)$/.test(flex) ? `0 0 ${flex}` : flex;
}
__name(parseFlex, "parseFlex");
const sizes = ["xs", "sm", "md", "lg", "xl", "xxl"], Col = /* @__PURE__ */ React.forwardRef((props, ref) => {
  const {
    getPrefixCls,
    direction
  } = React.useContext(ConfigContext), {
    gutter,
    wrap
  } = React.useContext(RowContext), {
    prefixCls: customizePrefixCls,
    span,
    order: order2,
    offset: offset2,
    push,
    pull,
    className,
    children,
    flex,
    style: style2
  } = props, others = __rest$w(props, ["prefixCls", "span", "order", "offset", "push", "pull", "className", "children", "flex", "style"]), prefixCls = getPrefixCls("col", customizePrefixCls), [wrapCSSVar, hashId, cssVarCls] = useColStyle(prefixCls), sizeStyle = {};
  let sizeClassObj = {};
  sizes.forEach((size) => {
    let sizeProps = {};
    const propSize = props[size];
    typeof propSize == "number" ? sizeProps.span = propSize : typeof propSize == "object" && (sizeProps = propSize || {}), delete others[size], sizeClassObj = Object.assign(Object.assign({}, sizeClassObj), {
      [`${prefixCls}-${size}-${sizeProps.span}`]: sizeProps.span !== void 0,
      [`${prefixCls}-${size}-order-${sizeProps.order}`]: sizeProps.order || sizeProps.order === 0,
      [`${prefixCls}-${size}-offset-${sizeProps.offset}`]: sizeProps.offset || sizeProps.offset === 0,
      [`${prefixCls}-${size}-push-${sizeProps.push}`]: sizeProps.push || sizeProps.push === 0,
      [`${prefixCls}-${size}-pull-${sizeProps.pull}`]: sizeProps.pull || sizeProps.pull === 0,
      [`${prefixCls}-rtl`]: direction === "rtl"
    }), sizeProps.flex && (sizeClassObj[`${prefixCls}-${size}-flex`] = !0, sizeStyle[`--${prefixCls}-${size}-flex`] = parseFlex(sizeProps.flex));
  });
  const classes = cn(prefixCls, {
    [`${prefixCls}-${span}`]: span !== void 0,
    [`${prefixCls}-order-${order2}`]: order2,
    [`${prefixCls}-offset-${offset2}`]: offset2,
    [`${prefixCls}-push-${push}`]: push,
    [`${prefixCls}-pull-${pull}`]: pull
  }, className, sizeClassObj, hashId, cssVarCls), mergedStyle = {};
  if (gutter && gutter[0] > 0) {
    const horizontalGutter = gutter[0] / 2;
    mergedStyle.paddingLeft = horizontalGutter, mergedStyle.paddingRight = horizontalGutter;
  }
  return flex && (mergedStyle.flex = parseFlex(flex), wrap === !1 && !mergedStyle.minWidth && (mergedStyle.minWidth = 0)), wrapCSSVar(/* @__PURE__ */ React.createElement("div", Object.assign({}, others, {
    style: Object.assign(Object.assign(Object.assign({}, mergedStyle), style2), sizeStyle),
    className: classes,
    ref
  }), children));
});
process.env.NODE_ENV !== "production" && (Col.displayName = "Col");
var __rest$v = function(s, e2) {
  var t2 = {};
  for (var p in s) Object.prototype.hasOwnProperty.call(s, p) && e2.indexOf(p) < 0 && (t2[p] = s[p]);
  if (s != null && typeof Object.getOwnPropertySymbols == "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++)
    e2.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]) && (t2[p[i]] = s[p[i]]);
  return t2;
};
function useMergedPropByScreen(oriProp, screen) {
  const [prop, setProp] = React.useState(typeof oriProp == "string" ? oriProp : ""), calcMergedAlignOrJustify = /* @__PURE__ */ __name(() => {
    if (typeof oriProp == "string" && setProp(oriProp), typeof oriProp == "object")
      for (let i = 0; i < responsiveArray.length; i++) {
        const breakpoint = responsiveArray[i];
        if (!screen[breakpoint])
          continue;
        const curVal = oriProp[breakpoint];
        if (curVal !== void 0) {
          setProp(curVal);
          return;
        }
      }
  }, "calcMergedAlignOrJustify");
  return React.useEffect(() => {
    calcMergedAlignOrJustify();
  }, [JSON.stringify(oriProp), screen]), prop;
}
__name(useMergedPropByScreen, "useMergedPropByScreen");
const Row = /* @__PURE__ */ React.forwardRef((props, ref) => {
  const {
    prefixCls: customizePrefixCls,
    justify,
    align,
    className,
    style: style2,
    children,
    gutter = 0,
    wrap
  } = props, others = __rest$v(props, ["prefixCls", "justify", "align", "className", "style", "children", "gutter", "wrap"]), {
    getPrefixCls,
    direction
  } = React.useContext(ConfigContext), [screens, setScreens] = React.useState({
    xs: !0,
    sm: !0,
    md: !0,
    lg: !0,
    xl: !0,
    xxl: !0
  }), [curScreens, setCurScreens] = React.useState({
    xs: !1,
    sm: !1,
    md: !1,
    lg: !1,
    xl: !1,
    xxl: !1
  }), mergedAlign = useMergedPropByScreen(align, curScreens), mergedJustify = useMergedPropByScreen(justify, curScreens), gutterRef = React.useRef(gutter), responsiveObserver = useResponsiveObserver();
  React.useEffect(() => {
    const token2 = responsiveObserver.subscribe((screen) => {
      setCurScreens(screen);
      const currentGutter = gutterRef.current || 0;
      (!Array.isArray(currentGutter) && typeof currentGutter == "object" || Array.isArray(currentGutter) && (typeof currentGutter[0] == "object" || typeof currentGutter[1] == "object")) && setScreens(screen);
    });
    return () => responsiveObserver.unsubscribe(token2);
  }, []);
  const getGutter = /* @__PURE__ */ __name(() => {
    const results = [void 0, void 0];
    return (Array.isArray(gutter) ? gutter : [gutter, void 0]).forEach((g, index2) => {
      if (typeof g == "object")
        for (let i = 0; i < responsiveArray.length; i++) {
          const breakpoint = responsiveArray[i];
          if (screens[breakpoint] && g[breakpoint] !== void 0) {
            results[index2] = g[breakpoint];
            break;
          }
        }
      else
        results[index2] = g;
    }), results;
  }, "getGutter"), prefixCls = getPrefixCls("row", customizePrefixCls), [wrapCSSVar, hashId, cssVarCls] = useRowStyle(prefixCls), gutters = getGutter(), classes = cn(prefixCls, {
    [`${prefixCls}-no-wrap`]: wrap === !1,
    [`${prefixCls}-${mergedJustify}`]: mergedJustify,
    [`${prefixCls}-${mergedAlign}`]: mergedAlign,
    [`${prefixCls}-rtl`]: direction === "rtl"
  }, className, hashId, cssVarCls), rowStyle = {}, horizontalGutter = gutters[0] != null && gutters[0] > 0 ? gutters[0] / -2 : void 0;
  horizontalGutter && (rowStyle.marginLeft = horizontalGutter, rowStyle.marginRight = horizontalGutter);
  const [gutterH, gutterV] = gutters;
  rowStyle.rowGap = gutterV;
  const rowContext = React.useMemo(() => ({
    gutter: [gutterH, gutterV],
    wrap
  }), [gutterH, gutterV, wrap]);
  return wrapCSSVar(/* @__PURE__ */ React.createElement(RowContext.Provider, {
    value: rowContext
  }, /* @__PURE__ */ React.createElement("div", Object.assign({}, others, {
    className: classes,
    style: Object.assign(Object.assign({}, rowStyle), style2),
    ref
  }), children)));
});
process.env.NODE_ENV !== "production" && (Row.displayName = "Row");
var calcThumbStyle = /* @__PURE__ */ __name(function(targetElement, vertical) {
  if (!targetElement) return null;
  var style2 = {
    left: targetElement.offsetLeft,
    right: targetElement.parentElement.clientWidth - targetElement.clientWidth - targetElement.offsetLeft,
    width: targetElement.clientWidth,
    top: targetElement.offsetTop,
    bottom: targetElement.parentElement.clientHeight - targetElement.clientHeight - targetElement.offsetTop,
    height: targetElement.clientHeight
  };
  return vertical ? {
    left: 0,
    right: 0,
    width: 0,
    top: style2.top,
    bottom: style2.bottom,
    height: style2.height
  } : {
    left: style2.left,
    right: style2.right,
    width: style2.width,
    top: 0,
    bottom: 0,
    height: 0
  };
}, "calcThumbStyle"), toPX = /* @__PURE__ */ __name(function(value) {
  return value !== void 0 ? "".concat(value, "px") : void 0;
}, "toPX");
function MotionThumb(props) {
  var prefixCls = props.prefixCls, containerRef = props.containerRef, value = props.value, getValueIndex = props.getValueIndex, motionName = props.motionName, onMotionStart = props.onMotionStart, onMotionEnd = props.onMotionEnd, direction = props.direction, _props$vertical = props.vertical, vertical = _props$vertical === void 0 ? !1 : _props$vertical, thumbRef = React.useRef(null), _React$useState = React.useState(value), _React$useState2 = _slicedToArray(_React$useState, 2), prevValue = _React$useState2[0], setPrevValue = _React$useState2[1], findValueElement = /* @__PURE__ */ __name(function(val) {
    var _containerRef$current, index2 = getValueIndex(val), ele = (_containerRef$current = containerRef.current) === null || _containerRef$current === void 0 ? void 0 : _containerRef$current.querySelectorAll(".".concat(prefixCls, "-item"))[index2];
    return (ele == null ? void 0 : ele.offsetParent) && ele;
  }, "findValueElement"), _React$useState3 = React.useState(null), _React$useState4 = _slicedToArray(_React$useState3, 2), prevStyle = _React$useState4[0], setPrevStyle = _React$useState4[1], _React$useState5 = React.useState(null), _React$useState6 = _slicedToArray(_React$useState5, 2), nextStyle = _React$useState6[0], setNextStyle = _React$useState6[1];
  useLayoutEffect$1(function() {
    if (prevValue !== value) {
      var prev2 = findValueElement(prevValue), next2 = findValueElement(value), calcPrevStyle = calcThumbStyle(prev2, vertical), calcNextStyle = calcThumbStyle(next2, vertical);
      setPrevValue(value), setPrevStyle(calcPrevStyle), setNextStyle(calcNextStyle), prev2 && next2 ? onMotionStart() : onMotionEnd();
    }
  }, [value]);
  var thumbStart = React.useMemo(function() {
    if (vertical) {
      var _prevStyle$top;
      return toPX((_prevStyle$top = prevStyle == null ? void 0 : prevStyle.top) !== null && _prevStyle$top !== void 0 ? _prevStyle$top : 0);
    }
    return toPX(direction === "rtl" ? -(prevStyle == null ? void 0 : prevStyle.right) : prevStyle == null ? void 0 : prevStyle.left);
  }, [vertical, direction, prevStyle]), thumbActive = React.useMemo(function() {
    if (vertical) {
      var _nextStyle$top;
      return toPX((_nextStyle$top = nextStyle == null ? void 0 : nextStyle.top) !== null && _nextStyle$top !== void 0 ? _nextStyle$top : 0);
    }
    return toPX(direction === "rtl" ? -(nextStyle == null ? void 0 : nextStyle.right) : nextStyle == null ? void 0 : nextStyle.left);
  }, [vertical, direction, nextStyle]), onAppearStart = /* @__PURE__ */ __name(function() {
    return vertical ? {
      transform: "translateY(var(--thumb-start-top))",
      height: "var(--thumb-start-height)"
    } : {
      transform: "translateX(var(--thumb-start-left))",
      width: "var(--thumb-start-width)"
    };
  }, "onAppearStart"), onAppearActive = /* @__PURE__ */ __name(function() {
    return vertical ? {
      transform: "translateY(var(--thumb-active-top))",
      height: "var(--thumb-active-height)"
    } : {
      transform: "translateX(var(--thumb-active-left))",
      width: "var(--thumb-active-width)"
    };
  }, "onAppearActive"), onVisibleChanged = /* @__PURE__ */ __name(function() {
    setPrevStyle(null), setNextStyle(null), onMotionEnd();
  }, "onVisibleChanged");
  return !prevStyle || !nextStyle ? null : /* @__PURE__ */ React.createElement(CSSMotion, {
    visible: !0,
    motionName,
    motionAppear: !0,
    onAppearStart,
    onAppearActive,
    onVisibleChanged
  }, function(_ref, ref) {
    var motionClassName = _ref.className, motionStyle = _ref.style, mergedStyle = _objectSpread2$1(_objectSpread2$1({}, motionStyle), {}, {
      "--thumb-start-left": thumbStart,
      "--thumb-start-width": toPX(prevStyle == null ? void 0 : prevStyle.width),
      "--thumb-active-left": thumbActive,
      "--thumb-active-width": toPX(nextStyle == null ? void 0 : nextStyle.width),
      "--thumb-start-top": thumbStart,
      "--thumb-start-height": toPX(prevStyle == null ? void 0 : prevStyle.height),
      "--thumb-active-top": thumbActive,
      "--thumb-active-height": toPX(nextStyle == null ? void 0 : nextStyle.height)
    }), motionProps = {
      ref: composeRef(thumbRef, ref),
      style: mergedStyle,
      className: cn("".concat(prefixCls, "-thumb"), motionClassName)
    };
    return process.env.NODE_ENV === "test" && (motionProps["data-test-style"] = JSON.stringify(mergedStyle)), /* @__PURE__ */ React.createElement("div", motionProps);
  });
}
__name(MotionThumb, "MotionThumb");
var _excluded$g = ["prefixCls", "direction", "vertical", "options", "disabled", "defaultValue", "value", "onChange", "className", "motionName"];
function getValidTitle(option) {
  if (typeof option.title < "u")
    return option.title;
  if (_typeof$4(option.label) !== "object") {
    var _option$label;
    return (_option$label = option.label) === null || _option$label === void 0 ? void 0 : _option$label.toString();
  }
}
__name(getValidTitle, "getValidTitle");
function normalizeOptions(options) {
  return options.map(function(option) {
    if (_typeof$4(option) === "object" && option !== null) {
      var validTitle = getValidTitle(option);
      return _objectSpread2$1(_objectSpread2$1({}, option), {}, {
        title: validTitle
      });
    }
    return {
      label: option == null ? void 0 : option.toString(),
      title: option == null ? void 0 : option.toString(),
      value: option
    };
  });
}
__name(normalizeOptions, "normalizeOptions");
var InternalSegmentedOption = /* @__PURE__ */ __name(function(_ref) {
  var prefixCls = _ref.prefixCls, className = _ref.className, disabled = _ref.disabled, checked = _ref.checked, label2 = _ref.label, title2 = _ref.title, value = _ref.value, onChange = _ref.onChange, handleChange = /* @__PURE__ */ __name(function(event) {
    disabled || onChange(event, value);
  }, "handleChange");
  return /* @__PURE__ */ React.createElement("label", {
    className: cn(className, _defineProperty$2({}, "".concat(prefixCls, "-item-disabled"), disabled))
  }, /* @__PURE__ */ React.createElement("input", {
    className: "".concat(prefixCls, "-item-input"),
    type: "radio",
    disabled,
    checked,
    onChange: handleChange
  }), /* @__PURE__ */ React.createElement("div", {
    className: "".concat(prefixCls, "-item-label"),
    title: title2,
    role: "option",
    "aria-selected": checked
  }, label2));
}, "InternalSegmentedOption"), Segmented$2 = /* @__PURE__ */ React.forwardRef(function(props, ref) {
  var _segmentedOptions$, _classNames2, _props$prefixCls = props.prefixCls, prefixCls = _props$prefixCls === void 0 ? "rc-segmented" : _props$prefixCls, direction = props.direction, vertical = props.vertical, _props$options = props.options, options = _props$options === void 0 ? [] : _props$options, disabled = props.disabled, defaultValue = props.defaultValue, value = props.value, onChange = props.onChange, _props$className = props.className, className = _props$className === void 0 ? "" : _props$className, _props$motionName = props.motionName, motionName = _props$motionName === void 0 ? "thumb-motion" : _props$motionName, restProps = _objectWithoutProperties(props, _excluded$g), containerRef = React.useRef(null), mergedRef = React.useMemo(function() {
    return composeRef(containerRef, ref);
  }, [containerRef, ref]), segmentedOptions = React.useMemo(function() {
    return normalizeOptions(options);
  }, [options]), _useMergedState = useMergedState((_segmentedOptions$ = segmentedOptions[0]) === null || _segmentedOptions$ === void 0 ? void 0 : _segmentedOptions$.value, {
    value,
    defaultValue
  }), _useMergedState2 = _slicedToArray(_useMergedState, 2), rawValue = _useMergedState2[0], setRawValue = _useMergedState2[1], _React$useState = React.useState(!1), _React$useState2 = _slicedToArray(_React$useState, 2), thumbShow = _React$useState2[0], setThumbShow = _React$useState2[1], handleChange = /* @__PURE__ */ __name(function(event, val) {
    disabled || (setRawValue(val), onChange == null || onChange(val));
  }, "handleChange"), divProps = omit(restProps, ["children"]);
  return /* @__PURE__ */ React.createElement("div", _extends({
    role: "listbox",
    "aria-label": "segmented control"
  }, divProps, {
    className: cn(prefixCls, (_classNames2 = {}, _defineProperty$2(_classNames2, "".concat(prefixCls, "-rtl"), direction === "rtl"), _defineProperty$2(_classNames2, "".concat(prefixCls, "-disabled"), disabled), _defineProperty$2(_classNames2, "".concat(prefixCls, "-vertical"), vertical), _classNames2), className),
    ref: mergedRef
  }), /* @__PURE__ */ React.createElement("div", {
    className: "".concat(prefixCls, "-group")
  }, /* @__PURE__ */ React.createElement(MotionThumb, {
    vertical,
    prefixCls,
    value: rawValue,
    containerRef,
    motionName: "".concat(prefixCls, "-").concat(motionName),
    direction,
    getValueIndex: /* @__PURE__ */ __name(function(val) {
      return segmentedOptions.findIndex(function(n2) {
        return n2.value === val;
      });
    }, "getValueIndex"),
    onMotionStart: /* @__PURE__ */ __name(function() {
      setThumbShow(!0);
    }, "onMotionStart"),
    onMotionEnd: /* @__PURE__ */ __name(function() {
      setThumbShow(!1);
    }, "onMotionEnd")
  }), segmentedOptions.map(function(segmentedOption) {
    return /* @__PURE__ */ React.createElement(InternalSegmentedOption, _extends({}, segmentedOption, {
      key: segmentedOption.value,
      prefixCls,
      className: cn(segmentedOption.className, "".concat(prefixCls, "-item"), _defineProperty$2({}, "".concat(prefixCls, "-item-selected"), segmentedOption.value === rawValue && !thumbShow)),
      checked: segmentedOption.value === rawValue,
      onChange: handleChange,
      disabled: !!disabled || !!segmentedOption.disabled
    }));
  })));
});
process.env.NODE_ENV !== "production" && (Segmented$2.displayName = "Segmented");
var TypedSegmented = Segmented$2;
function getItemDisabledStyle(cls, token2) {
  return {
    [`${cls}, ${cls}:hover, ${cls}:focus`]: {
      color: token2.colorTextDisabled,
      cursor: "not-allowed"
    }
  };
}
__name(getItemDisabledStyle, "getItemDisabledStyle");
function getItemSelectedStyle(token2) {
  return {
    backgroundColor: token2.itemSelectedBg,
    boxShadow: token2.boxShadowTertiary
  };
}
__name(getItemSelectedStyle, "getItemSelectedStyle");
const segmentedTextEllipsisCss = Object.assign({
  overflow: "hidden"
}, textEllipsis), genSegmentedStyle = /* @__PURE__ */ __name((token2) => {
  const {
    componentCls
  } = token2, labelHeight = token2.calc(token2.controlHeight).sub(token2.calc(token2.trackPadding).mul(2)).equal(), labelHeightLG = token2.calc(token2.controlHeightLG).sub(token2.calc(token2.trackPadding).mul(2)).equal(), labelHeightSM = token2.calc(token2.controlHeightSM).sub(token2.calc(token2.trackPadding).mul(2)).equal();
  return {
    [componentCls]: Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, resetComponent(token2)), {
      display: "inline-block",
      padding: token2.trackPadding,
      color: token2.itemColor,
      background: token2.trackBg,
      borderRadius: token2.borderRadius,
      transition: `all ${token2.motionDurationMid} ${token2.motionEaseInOut}`,
      [`${componentCls}-group`]: {
        position: "relative",
        display: "flex",
        alignItems: "stretch",
        justifyItems: "flex-start",
        flexDirection: "row",
        width: "100%"
      },
      // RTL styles
      [`&${componentCls}-rtl`]: {
        direction: "rtl"
      },
      [`&${componentCls}-vertical`]: {
        [`${componentCls}-group`]: {
          flexDirection: "column"
        },
        [`${componentCls}-thumb`]: {
          width: "100%",
          height: 0,
          padding: `0 ${unit$1(token2.paddingXXS)}`
        }
      },
      // block styles
      [`&${componentCls}-block`]: {
        display: "flex"
      },
      [`&${componentCls}-block ${componentCls}-item`]: {
        flex: 1,
        minWidth: 0
      },
      // item styles
      [`${componentCls}-item`]: {
        position: "relative",
        textAlign: "center",
        cursor: "pointer",
        transition: `color ${token2.motionDurationMid} ${token2.motionEaseInOut}`,
        borderRadius: token2.borderRadiusSM,
        // Fix Safari render bug
        // https://github.com/ant-design/ant-design/issues/45250
        transform: "translateZ(0)",
        "&-selected": Object.assign(Object.assign({}, getItemSelectedStyle(token2)), {
          color: token2.itemSelectedColor
        }),
        "&::after": {
          content: '""',
          position: "absolute",
          zIndex: -1,
          width: "100%",
          height: "100%",
          top: 0,
          insetInlineStart: 0,
          borderRadius: "inherit",
          transition: `background-color ${token2.motionDurationMid}`,
          // This is mandatory to make it not clickable or hoverable
          // Ref: https://github.com/ant-design/ant-design/issues/40888
          pointerEvents: "none"
        },
        [`&:hover:not(${componentCls}-item-selected):not(${componentCls}-item-disabled)`]: {
          color: token2.itemHoverColor,
          "&::after": {
            backgroundColor: token2.itemHoverBg
          }
        },
        [`&:active:not(${componentCls}-item-selected):not(${componentCls}-item-disabled)`]: {
          color: token2.itemHoverColor,
          "&::after": {
            backgroundColor: token2.itemActiveBg
          }
        },
        "&-label": Object.assign({
          minHeight: labelHeight,
          lineHeight: unit$1(labelHeight),
          padding: `0 ${unit$1(token2.segmentedPaddingHorizontal)}`
        }, segmentedTextEllipsisCss),
        // syntactic sugar to add `icon` for Segmented Item
        "&-icon + *": {
          marginInlineStart: token2.calc(token2.marginSM).div(2).equal()
        },
        "&-input": {
          position: "absolute",
          insetBlockStart: 0,
          insetInlineStart: 0,
          width: 0,
          height: 0,
          opacity: 0,
          pointerEvents: "none"
        }
      },
      // thumb styles
      [`${componentCls}-thumb`]: Object.assign(Object.assign({}, getItemSelectedStyle(token2)), {
        position: "absolute",
        insetBlockStart: 0,
        insetInlineStart: 0,
        width: 0,
        height: "100%",
        padding: `${unit$1(token2.paddingXXS)} 0`,
        borderRadius: token2.borderRadiusSM,
        transition: `transform ${token2.motionDurationSlow} ${token2.motionEaseInOut}, height ${token2.motionDurationSlow} ${token2.motionEaseInOut}`,
        [`& ~ ${componentCls}-item:not(${componentCls}-item-selected):not(${componentCls}-item-disabled)::after`]: {
          backgroundColor: "transparent"
        }
      }),
      // size styles
      [`&${componentCls}-lg`]: {
        borderRadius: token2.borderRadiusLG,
        [`${componentCls}-item-label`]: {
          minHeight: labelHeightLG,
          lineHeight: unit$1(labelHeightLG),
          padding: `0 ${unit$1(token2.segmentedPaddingHorizontal)}`,
          fontSize: token2.fontSizeLG
        },
        [`${componentCls}-item, ${componentCls}-thumb`]: {
          borderRadius: token2.borderRadius
        }
      },
      [`&${componentCls}-sm`]: {
        borderRadius: token2.borderRadiusSM,
        [`${componentCls}-item-label`]: {
          minHeight: labelHeightSM,
          lineHeight: unit$1(labelHeightSM),
          padding: `0 ${unit$1(token2.segmentedPaddingHorizontalSM)}`
        },
        [`${componentCls}-item, ${componentCls}-thumb`]: {
          borderRadius: token2.borderRadiusXS
        }
      }
    }), getItemDisabledStyle(`&-disabled ${componentCls}-item`, token2)), getItemDisabledStyle(`${componentCls}-item-disabled`, token2)), {
      // transition effect when `appear-active`
      [`${componentCls}-thumb-motion-appear-active`]: {
        transition: `transform ${token2.motionDurationSlow} ${token2.motionEaseInOut}, width ${token2.motionDurationSlow} ${token2.motionEaseInOut}`,
        willChange: "transform, width"
      }
    })
  };
}, "genSegmentedStyle"), prepareComponentToken$a = /* @__PURE__ */ __name((token2) => {
  const {
    colorTextLabel,
    colorText,
    colorFillSecondary,
    colorBgElevated,
    colorFill,
    lineWidthBold,
    colorBgLayout
  } = token2;
  return {
    trackPadding: lineWidthBold,
    trackBg: colorBgLayout,
    itemColor: colorTextLabel,
    itemHoverColor: colorText,
    itemHoverBg: colorFillSecondary,
    itemSelectedBg: colorBgElevated,
    itemActiveBg: colorFill,
    itemSelectedColor: colorText
  };
}, "prepareComponentToken$a"), useStyle$b = genStyleHooks("Segmented", (token2) => {
  const {
    lineWidth,
    calc
  } = token2, segmentedToken = merge(token2, {
    segmentedPaddingHorizontal: calc(token2.controlPaddingHorizontal).sub(lineWidth).equal(),
    segmentedPaddingHorizontalSM: calc(token2.controlPaddingHorizontalSM).sub(lineWidth).equal()
  });
  return [genSegmentedStyle(segmentedToken)];
}, prepareComponentToken$a);
var __rest$u = function(s, e2) {
  var t2 = {};
  for (var p in s) Object.prototype.hasOwnProperty.call(s, p) && e2.indexOf(p) < 0 && (t2[p] = s[p]);
  if (s != null && typeof Object.getOwnPropertySymbols == "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++)
    e2.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]) && (t2[p[i]] = s[p[i]]);
  return t2;
};
function isSegmentedLabeledOptionWithIcon(option) {
  return typeof option == "object" && !!(option != null && option.icon);
}
__name(isSegmentedLabeledOptionWithIcon, "isSegmentedLabeledOptionWithIcon");
const InternalSegmented = /* @__PURE__ */ React.forwardRef((props, ref) => {
  const {
    prefixCls: customizePrefixCls,
    className,
    rootClassName,
    block,
    options = [],
    size: customSize = "middle",
    style: style2,
    vertical
  } = props, restProps = __rest$u(props, ["prefixCls", "className", "rootClassName", "block", "options", "size", "style", "vertical"]), {
    getPrefixCls,
    direction,
    segmented
  } = React.useContext(ConfigContext), prefixCls = getPrefixCls("segmented", customizePrefixCls), [wrapCSSVar, hashId, cssVarCls] = useStyle$b(prefixCls), mergedSize = useSize(customSize), extendedOptions = React.useMemo(() => options.map((option) => {
    if (isSegmentedLabeledOptionWithIcon(option)) {
      const {
        icon,
        label: label2
      } = option, restOption = __rest$u(option, ["icon", "label"]);
      return Object.assign(Object.assign({}, restOption), {
        label: /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement("span", {
          className: `${prefixCls}-item-icon`
        }, icon), label2 && /* @__PURE__ */ React.createElement("span", null, label2))
      });
    }
    return option;
  }), [options, prefixCls]), cls = cn(className, rootClassName, segmented == null ? void 0 : segmented.className, {
    [`${prefixCls}-block`]: block,
    [`${prefixCls}-sm`]: mergedSize === "small",
    [`${prefixCls}-lg`]: mergedSize === "large",
    [`${prefixCls}-vertical`]: vertical
  }, hashId, cssVarCls), mergedStyle = Object.assign(Object.assign({}, segmented == null ? void 0 : segmented.style), style2);
  return wrapCSSVar(/* @__PURE__ */ React.createElement(TypedSegmented, Object.assign({}, restProps, {
    className: cls,
    style: mergedStyle,
    options: extendedOptions,
    ref,
    prefixCls,
    direction,
    vertical
  })));
}), Segmented$1 = InternalSegmented;
process.env.NODE_ENV !== "production" && (Segmented$1.displayName = "Segmented");
var UpOutlined$1 = { icon: { tag: "svg", attrs: { viewBox: "64 64 896 896", focusable: "false" }, children: [{ tag: "path", attrs: { d: "M890.5 755.3L537.9 269.2c-12.8-17.6-39-17.6-51.7 0L133.5 755.3A8 8 0 00140 768h75c5.1 0 9.9-2.5 12.9-6.6L512 369.8l284.1 391.6c3 4.1 7.8 6.6 12.9 6.6h75c6.5 0 10.3-7.4 6.5-12.7z" } }] }, name: "up", theme: "outlined" }, UpOutlined = /* @__PURE__ */ __name(function(props, ref) {
  return /* @__PURE__ */ React.createElement(Icon$3, _extends({}, props, {
    ref,
    icon: UpOutlined$1
  }));
}, "UpOutlined"), RefIcon$q = /* @__PURE__ */ React.forwardRef(UpOutlined);
process.env.NODE_ENV !== "production" && (RefIcon$q.displayName = "UpOutlined");
function supportBigInt() {
  return typeof BigInt == "function";
}
__name(supportBigInt, "supportBigInt");
function isEmpty(value) {
  return !value && value !== 0 && !Number.isNaN(value) || !String(value).trim();
}
__name(isEmpty, "isEmpty");
function trimNumber(numStr) {
  var str = numStr.trim(), negative = str.startsWith("-");
  negative && (str = str.slice(1)), str = str.replace(/(\.\d*[^0])0*$/, "$1").replace(/\.0*$/, "").replace(/^0+/, ""), str.startsWith(".") && (str = "0".concat(str));
  var trimStr = str || "0", splitNumber = trimStr.split("."), integerStr = splitNumber[0] || "0", decimalStr = splitNumber[1] || "0";
  integerStr === "0" && decimalStr === "0" && (negative = !1);
  var negativeStr = negative ? "-" : "";
  return {
    negative,
    negativeStr,
    trimStr,
    integerStr,
    decimalStr,
    fullStr: "".concat(negativeStr).concat(trimStr)
  };
}
__name(trimNumber, "trimNumber");
function isE(number4) {
  var str = String(number4);
  return !Number.isNaN(Number(str)) && str.includes("e");
}
__name(isE, "isE");
function getNumberPrecision(number4) {
  var numStr = String(number4);
  if (isE(number4)) {
    var precision = Number(numStr.slice(numStr.indexOf("e-") + 2)), decimalMatch = numStr.match(/\.(\d+)/);
    return decimalMatch != null && decimalMatch[1] && (precision += decimalMatch[1].length), precision;
  }
  return numStr.includes(".") && validateNumber(numStr) ? numStr.length - numStr.indexOf(".") - 1 : 0;
}
__name(getNumberPrecision, "getNumberPrecision");
function num2str(number4) {
  var numStr = String(number4);
  if (isE(number4)) {
    if (number4 > Number.MAX_SAFE_INTEGER)
      return String(supportBigInt() ? BigInt(number4).toString() : Number.MAX_SAFE_INTEGER);
    if (number4 < Number.MIN_SAFE_INTEGER)
      return String(supportBigInt() ? BigInt(number4).toString() : Number.MIN_SAFE_INTEGER);
    numStr = number4.toFixed(getNumberPrecision(numStr));
  }
  return trimNumber(numStr).fullStr;
}
__name(num2str, "num2str");
function validateNumber(num) {
  return typeof num == "number" ? !Number.isNaN(num) : num ? (
    // Normal type: 11.28
    /^\s*-?\d+(\.\d+)?\s*$/.test(num) || // Pre-number: 1.
    /^\s*-?\d+\.\s*$/.test(num) || // Post-number: .1
    /^\s*-?\.\d+\s*$/.test(num)
  ) : !1;
}
__name(validateNumber, "validateNumber");
var BigIntDecimal = /* @__PURE__ */ function() {
  function BigIntDecimal2(value) {
    if (_classCallCheck$1(this, BigIntDecimal2), _defineProperty$2(this, "origin", ""), _defineProperty$2(this, "negative", void 0), _defineProperty$2(this, "integer", void 0), _defineProperty$2(this, "decimal", void 0), _defineProperty$2(this, "decimalLen", void 0), _defineProperty$2(this, "empty", void 0), _defineProperty$2(this, "nan", void 0), isEmpty(value)) {
      this.empty = !0;
      return;
    }
    if (this.origin = String(value), value === "-" || Number.isNaN(value)) {
      this.nan = !0;
      return;
    }
    var mergedValue = value;
    if (isE(mergedValue) && (mergedValue = Number(mergedValue)), mergedValue = typeof mergedValue == "string" ? mergedValue : num2str(mergedValue), validateNumber(mergedValue)) {
      var trimRet = trimNumber(mergedValue);
      this.negative = trimRet.negative;
      var numbers = trimRet.trimStr.split(".");
      this.integer = BigInt(numbers[0]);
      var decimalStr = numbers[1] || "0";
      this.decimal = BigInt(decimalStr), this.decimalLen = decimalStr.length;
    } else
      this.nan = !0;
  }
  return __name(BigIntDecimal2, "BigIntDecimal"), _createClass$1(BigIntDecimal2, [{
    key: "getMark",
    value: /* @__PURE__ */ __name(function() {
      return this.negative ? "-" : "";
    }, "getMark")
  }, {
    key: "getIntegerStr",
    value: /* @__PURE__ */ __name(function() {
      return this.integer.toString();
    }, "getIntegerStr")
    /**
     * @private get decimal string
     */
  }, {
    key: "getDecimalStr",
    value: /* @__PURE__ */ __name(function() {
      return this.decimal.toString().padStart(this.decimalLen, "0");
    }, "getDecimalStr")
    /**
     * @private Align BigIntDecimal with same decimal length. e.g. 12.3 + 5 = 1230000
     * This is used for add function only.
     */
  }, {
    key: "alignDecimal",
    value: /* @__PURE__ */ __name(function(decimalLength) {
      var str = "".concat(this.getMark()).concat(this.getIntegerStr()).concat(this.getDecimalStr().padEnd(decimalLength, "0"));
      return BigInt(str);
    }, "alignDecimal")
  }, {
    key: "negate",
    value: /* @__PURE__ */ __name(function() {
      var clone = new BigIntDecimal2(this.toString());
      return clone.negative = !clone.negative, clone;
    }, "negate")
  }, {
    key: "cal",
    value: /* @__PURE__ */ __name(function(offset2, calculator, calDecimalLen) {
      var maxDecimalLength = Math.max(this.getDecimalStr().length, offset2.getDecimalStr().length), myAlignedDecimal = this.alignDecimal(maxDecimalLength), offsetAlignedDecimal = offset2.alignDecimal(maxDecimalLength), valueStr = calculator(myAlignedDecimal, offsetAlignedDecimal).toString(), nextDecimalLength = calDecimalLen(maxDecimalLength), _trimNumber = trimNumber(valueStr), negativeStr = _trimNumber.negativeStr, trimStr = _trimNumber.trimStr, hydrateValueStr = "".concat(negativeStr).concat(trimStr.padStart(nextDecimalLength + 1, "0"));
      return new BigIntDecimal2("".concat(hydrateValueStr.slice(0, -nextDecimalLength), ".").concat(hydrateValueStr.slice(-nextDecimalLength)));
    }, "cal")
  }, {
    key: "add",
    value: /* @__PURE__ */ __name(function(value) {
      if (this.isInvalidate())
        return new BigIntDecimal2(value);
      var offset2 = new BigIntDecimal2(value);
      return offset2.isInvalidate() ? this : this.cal(offset2, function(num1, num2) {
        return num1 + num2;
      }, function(len) {
        return len;
      });
    }, "add")
  }, {
    key: "multi",
    value: /* @__PURE__ */ __name(function(value) {
      var target = new BigIntDecimal2(value);
      return this.isInvalidate() || target.isInvalidate() ? new BigIntDecimal2(NaN) : this.cal(target, function(num1, num2) {
        return num1 * num2;
      }, function(len) {
        return len * 2;
      });
    }, "multi")
  }, {
    key: "isEmpty",
    value: /* @__PURE__ */ __name(function() {
      return this.empty;
    }, "isEmpty")
  }, {
    key: "isNaN",
    value: /* @__PURE__ */ __name(function() {
      return this.nan;
    }, "isNaN")
  }, {
    key: "isInvalidate",
    value: /* @__PURE__ */ __name(function() {
      return this.isEmpty() || this.isNaN();
    }, "isInvalidate")
  }, {
    key: "equals",
    value: /* @__PURE__ */ __name(function(target) {
      return this.toString() === (target == null ? void 0 : target.toString());
    }, "equals")
  }, {
    key: "lessEquals",
    value: /* @__PURE__ */ __name(function(target) {
      return this.add(target.negate().toString()).toNumber() <= 0;
    }, "lessEquals")
  }, {
    key: "toNumber",
    value: /* @__PURE__ */ __name(function() {
      return this.isNaN() ? NaN : Number(this.toString());
    }, "toNumber")
  }, {
    key: "toString",
    value: /* @__PURE__ */ __name(function() {
      var safe = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : !0;
      return safe ? this.isInvalidate() ? "" : trimNumber("".concat(this.getMark()).concat(this.getIntegerStr(), ".").concat(this.getDecimalStr())).fullStr : this.origin;
    }, "toString")
  }]), BigIntDecimal2;
}(), NumberDecimal = /* @__PURE__ */ function() {
  function NumberDecimal2(value) {
    if (_classCallCheck$1(this, NumberDecimal2), _defineProperty$2(this, "origin", ""), _defineProperty$2(this, "number", void 0), _defineProperty$2(this, "empty", void 0), isEmpty(value)) {
      this.empty = !0;
      return;
    }
    this.origin = String(value), this.number = Number(value);
  }
  return __name(NumberDecimal2, "NumberDecimal"), _createClass$1(NumberDecimal2, [{
    key: "negate",
    value: /* @__PURE__ */ __name(function() {
      return new NumberDecimal2(-this.toNumber());
    }, "negate")
  }, {
    key: "add",
    value: /* @__PURE__ */ __name(function(value) {
      if (this.isInvalidate())
        return new NumberDecimal2(value);
      var target = Number(value);
      if (Number.isNaN(target))
        return this;
      var number4 = this.number + target;
      if (number4 > Number.MAX_SAFE_INTEGER)
        return new NumberDecimal2(Number.MAX_SAFE_INTEGER);
      if (number4 < Number.MIN_SAFE_INTEGER)
        return new NumberDecimal2(Number.MIN_SAFE_INTEGER);
      var maxPrecision = Math.max(getNumberPrecision(this.number), getNumberPrecision(target));
      return new NumberDecimal2(number4.toFixed(maxPrecision));
    }, "add")
  }, {
    key: "multi",
    value: /* @__PURE__ */ __name(function(value) {
      var target = Number(value);
      if (this.isInvalidate() || Number.isNaN(target))
        return new NumberDecimal2(NaN);
      var number4 = this.number * target;
      if (number4 > Number.MAX_SAFE_INTEGER)
        return new NumberDecimal2(Number.MAX_SAFE_INTEGER);
      if (number4 < Number.MIN_SAFE_INTEGER)
        return new NumberDecimal2(Number.MIN_SAFE_INTEGER);
      var maxPrecision = Math.max(getNumberPrecision(this.number), getNumberPrecision(target));
      return new NumberDecimal2(number4.toFixed(maxPrecision));
    }, "multi")
  }, {
    key: "isEmpty",
    value: /* @__PURE__ */ __name(function() {
      return this.empty;
    }, "isEmpty")
  }, {
    key: "isNaN",
    value: /* @__PURE__ */ __name(function() {
      return Number.isNaN(this.number);
    }, "isNaN")
  }, {
    key: "isInvalidate",
    value: /* @__PURE__ */ __name(function() {
      return this.isEmpty() || this.isNaN();
    }, "isInvalidate")
  }, {
    key: "equals",
    value: /* @__PURE__ */ __name(function(target) {
      return this.toNumber() === (target == null ? void 0 : target.toNumber());
    }, "equals")
  }, {
    key: "lessEquals",
    value: /* @__PURE__ */ __name(function(target) {
      return this.add(target.negate().toString()).toNumber() <= 0;
    }, "lessEquals")
  }, {
    key: "toNumber",
    value: /* @__PURE__ */ __name(function() {
      return this.number;
    }, "toNumber")
  }, {
    key: "toString",
    value: /* @__PURE__ */ __name(function() {
      var safe = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : !0;
      return safe ? this.isInvalidate() ? "" : num2str(this.number) : this.origin;
    }, "toString")
  }]), NumberDecimal2;
}();
function getMiniDecimal(value) {
  return supportBigInt() ? new BigIntDecimal(value) : new NumberDecimal(value);
}
__name(getMiniDecimal, "getMiniDecimal");
function toFixed(numStr, separatorStr, precision) {
  var cutOnly = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : !1;
  if (numStr === "")
    return "";
  var _trimNumber = trimNumber(numStr), negativeStr = _trimNumber.negativeStr, integerStr = _trimNumber.integerStr, decimalStr = _trimNumber.decimalStr, precisionDecimalStr = "".concat(separatorStr).concat(decimalStr), numberWithoutDecimal = "".concat(negativeStr).concat(integerStr);
  if (precision >= 0) {
    var advancedNum = Number(decimalStr[precision]);
    if (advancedNum >= 5 && !cutOnly) {
      var advancedDecimal = getMiniDecimal(numStr).add("".concat(negativeStr, "0.").concat("0".repeat(precision)).concat(10 - advancedNum));
      return toFixed(advancedDecimal.toString(), separatorStr, precision, cutOnly);
    }
    return precision === 0 ? numberWithoutDecimal : "".concat(numberWithoutDecimal).concat(separatorStr).concat(decimalStr.padEnd(precision, "0").slice(0, precision));
  }
  return precisionDecimalStr === ".0" ? numberWithoutDecimal : "".concat(numberWithoutDecimal).concat(precisionDecimalStr);
}
__name(toFixed, "toFixed");
function hasAddon(props) {
  return !!(props.addonBefore || props.addonAfter);
}
__name(hasAddon, "hasAddon");
function hasPrefixSuffix$1(props) {
  return !!(props.prefix || props.suffix || props.allowClear);
}
__name(hasPrefixSuffix$1, "hasPrefixSuffix$1");
function cloneEvent(event, target, value) {
  var currentTarget = target.cloneNode(!0), newEvent = Object.create(event, {
    target: {
      value: currentTarget
    },
    currentTarget: {
      value: currentTarget
    }
  });
  return currentTarget.value = value, typeof target.selectionStart == "number" && typeof target.selectionEnd == "number" && (currentTarget.selectionStart = target.selectionStart, currentTarget.selectionEnd = target.selectionEnd), currentTarget.setSelectionRange = function() {
    target.setSelectionRange.apply(target, arguments);
  }, newEvent;
}
__name(cloneEvent, "cloneEvent");
function resolveOnChange(target, e2, onChange, targetValue) {
  if (onChange) {
    var event = e2;
    if (e2.type === "click") {
      event = cloneEvent(e2, target, ""), onChange(event);
      return;
    }
    if (target.type !== "file" && targetValue !== void 0) {
      event = cloneEvent(e2, target, targetValue), onChange(event);
      return;
    }
    onChange(event);
  }
}
__name(resolveOnChange, "resolveOnChange");
function triggerFocus(element, option) {
  if (element) {
    element.focus(option);
    var _ref = option || {}, cursor = _ref.cursor;
    if (cursor) {
      var len = element.value.length;
      switch (cursor) {
        case "start":
          element.setSelectionRange(0, 0);
          break;
        case "end":
          element.setSelectionRange(len, len);
          break;
        default:
          element.setSelectionRange(0, len);
      }
    }
  }
}
__name(triggerFocus, "triggerFocus");
var BaseInput = /* @__PURE__ */ React__default.forwardRef(function(props, ref) {
  var _element$props, _element$props2, inputEl = props.inputElement, children = props.children, prefixCls = props.prefixCls, prefix = props.prefix, suffix = props.suffix, addonBefore = props.addonBefore, addonAfter = props.addonAfter, className = props.className, style2 = props.style, disabled = props.disabled, readOnly = props.readOnly, focused = props.focused, triggerFocus2 = props.triggerFocus, allowClear = props.allowClear, value = props.value, handleReset = props.handleReset, hidden2 = props.hidden, classes = props.classes, classNames = props.classNames, dataAttrs = props.dataAttrs, styles2 = props.styles, components2 = props.components, onClear = props.onClear, inputElement = children ?? inputEl, AffixWrapperComponent = (components2 == null ? void 0 : components2.affixWrapper) || "span", GroupWrapperComponent = (components2 == null ? void 0 : components2.groupWrapper) || "span", WrapperComponent = (components2 == null ? void 0 : components2.wrapper) || "span", GroupAddonComponent = (components2 == null ? void 0 : components2.groupAddon) || "span", containerRef = useRef(null), onInputClick = /* @__PURE__ */ __name(function(e2) {
    var _containerRef$current;
    (_containerRef$current = containerRef.current) !== null && _containerRef$current !== void 0 && _containerRef$current.contains(e2.target) && (triggerFocus2 == null || triggerFocus2());
  }, "onInputClick"), hasAffix = hasPrefixSuffix$1(props), element = /* @__PURE__ */ cloneElement$1(inputElement, {
    value,
    className: cn(inputElement.props.className, !hasAffix && (classNames == null ? void 0 : classNames.variant)) || null
  }), groupRef = useRef(null);
  if (React__default.useImperativeHandle(ref, function() {
    return {
      nativeElement: groupRef.current || containerRef.current
    };
  }), hasAffix) {
    var clearIcon = null;
    if (allowClear) {
      var needClear = !disabled && !readOnly && value, clearIconCls = "".concat(prefixCls, "-clear-icon"), iconNode = _typeof$4(allowClear) === "object" && allowClear !== null && allowClear !== void 0 && allowClear.clearIcon ? allowClear.clearIcon : "✖";
      clearIcon = /* @__PURE__ */ React__default.createElement("span", {
        onClick: /* @__PURE__ */ __name(function(event) {
          handleReset == null || handleReset(event), onClear == null || onClear();
        }, "onClick"),
        onMouseDown: /* @__PURE__ */ __name(function(e2) {
          return e2.preventDefault();
        }, "onMouseDown"),
        className: cn(clearIconCls, _defineProperty$2(_defineProperty$2({}, "".concat(clearIconCls, "-hidden"), !needClear), "".concat(clearIconCls, "-has-suffix"), !!suffix)),
        role: "button",
        tabIndex: -1
      }, iconNode);
    }
    var affixWrapperPrefixCls = "".concat(prefixCls, "-affix-wrapper"), affixWrapperCls = cn(affixWrapperPrefixCls, _defineProperty$2(_defineProperty$2(_defineProperty$2(_defineProperty$2(_defineProperty$2({}, "".concat(prefixCls, "-disabled"), disabled), "".concat(affixWrapperPrefixCls, "-disabled"), disabled), "".concat(affixWrapperPrefixCls, "-focused"), focused), "".concat(affixWrapperPrefixCls, "-readonly"), readOnly), "".concat(affixWrapperPrefixCls, "-input-with-clear-btn"), suffix && allowClear && value), classes == null ? void 0 : classes.affixWrapper, classNames == null ? void 0 : classNames.affixWrapper, classNames == null ? void 0 : classNames.variant), suffixNode = (suffix || allowClear) && /* @__PURE__ */ React__default.createElement("span", {
      className: cn("".concat(prefixCls, "-suffix"), classNames == null ? void 0 : classNames.suffix),
      style: styles2 == null ? void 0 : styles2.suffix
    }, clearIcon, suffix);
    element = /* @__PURE__ */ React__default.createElement(AffixWrapperComponent, _extends({
      className: affixWrapperCls,
      style: styles2 == null ? void 0 : styles2.affixWrapper,
      onClick: onInputClick
    }, dataAttrs == null ? void 0 : dataAttrs.affixWrapper, {
      ref: containerRef
    }), prefix && /* @__PURE__ */ React__default.createElement("span", {
      className: cn("".concat(prefixCls, "-prefix"), classNames == null ? void 0 : classNames.prefix),
      style: styles2 == null ? void 0 : styles2.prefix
    }, prefix), element, suffixNode);
  }
  if (hasAddon(props)) {
    var wrapperCls = "".concat(prefixCls, "-group"), addonCls = "".concat(wrapperCls, "-addon"), groupWrapperCls = "".concat(wrapperCls, "-wrapper"), mergedWrapperClassName = cn("".concat(prefixCls, "-wrapper"), wrapperCls, classes == null ? void 0 : classes.wrapper, classNames == null ? void 0 : classNames.wrapper), mergedGroupClassName = cn(groupWrapperCls, _defineProperty$2({}, "".concat(groupWrapperCls, "-disabled"), disabled), classes == null ? void 0 : classes.group, classNames == null ? void 0 : classNames.groupWrapper);
    element = /* @__PURE__ */ React__default.createElement(GroupWrapperComponent, {
      className: mergedGroupClassName,
      ref: groupRef
    }, /* @__PURE__ */ React__default.createElement(WrapperComponent, {
      className: mergedWrapperClassName
    }, addonBefore && /* @__PURE__ */ React__default.createElement(GroupAddonComponent, {
      className: addonCls
    }, addonBefore), element, addonAfter && /* @__PURE__ */ React__default.createElement(GroupAddonComponent, {
      className: addonCls
    }, addonAfter)));
  }
  return /* @__PURE__ */ React__default.cloneElement(element, {
    className: cn((_element$props = element.props) === null || _element$props === void 0 ? void 0 : _element$props.className, className) || null,
    style: _objectSpread2$1(_objectSpread2$1({}, (_element$props2 = element.props) === null || _element$props2 === void 0 ? void 0 : _element$props2.style), style2),
    hidden: hidden2
  });
}), _excluded$f = ["show"];
function useCount(count, showCount) {
  return React.useMemo(function() {
    var mergedConfig = {};
    showCount && (mergedConfig.show = _typeof$4(showCount) === "object" && showCount.formatter ? showCount.formatter : !!showCount), mergedConfig = _objectSpread2$1(_objectSpread2$1({}, mergedConfig), count);
    var _ref = mergedConfig, show = _ref.show, rest = _objectWithoutProperties(_ref, _excluded$f);
    return _objectSpread2$1(_objectSpread2$1({}, rest), {}, {
      show: !!show,
      showFormatter: typeof show == "function" ? show : void 0,
      strategy: rest.strategy || function(value) {
        return value.length;
      }
    });
  }, [count, showCount]);
}
__name(useCount, "useCount");
var _excluded$e = ["autoComplete", "onChange", "onFocus", "onBlur", "onPressEnter", "onKeyDown", "onKeyUp", "prefixCls", "disabled", "htmlSize", "className", "maxLength", "suffix", "showCount", "count", "type", "classes", "classNames", "styles", "onCompositionStart", "onCompositionEnd"], Input$3 = /* @__PURE__ */ forwardRef(function(props, ref) {
  var autoComplete = props.autoComplete, onChange = props.onChange, onFocus = props.onFocus, onBlur = props.onBlur, onPressEnter = props.onPressEnter, onKeyDown2 = props.onKeyDown, onKeyUp = props.onKeyUp, _props$prefixCls = props.prefixCls, prefixCls = _props$prefixCls === void 0 ? "rc-input" : _props$prefixCls, disabled = props.disabled, htmlSize = props.htmlSize, className = props.className, maxLength = props.maxLength, suffix = props.suffix, showCount = props.showCount, count = props.count, _props$type = props.type, type4 = _props$type === void 0 ? "text" : _props$type, classes = props.classes, classNames = props.classNames, styles2 = props.styles, _onCompositionStart = props.onCompositionStart, onCompositionEnd = props.onCompositionEnd, rest = _objectWithoutProperties(props, _excluded$e), _useState = useState(!1), _useState2 = _slicedToArray(_useState, 2), focused = _useState2[0], setFocused = _useState2[1], compositionRef = useRef(!1), keyLockRef = useRef(!1), inputRef = useRef(null), holderRef = useRef(null), focus = /* @__PURE__ */ __name(function(option) {
    inputRef.current && triggerFocus(inputRef.current, option);
  }, "focus"), _useMergedState = useMergedState(props.defaultValue, {
    value: props.value
  }), _useMergedState2 = _slicedToArray(_useMergedState, 2), value = _useMergedState2[0], setValue = _useMergedState2[1], formatValue2 = value == null ? "" : String(value), _useState3 = useState(null), _useState4 = _slicedToArray(_useState3, 2), selection = _useState4[0], setSelection = _useState4[1], countConfig = useCount(count, showCount), mergedMax = countConfig.max || maxLength, valueLength = countConfig.strategy(formatValue2), isOutOfRange = !!mergedMax && valueLength > mergedMax;
  useImperativeHandle(ref, function() {
    var _holderRef$current;
    return {
      focus,
      blur: /* @__PURE__ */ __name(function() {
        var _inputRef$current;
        (_inputRef$current = inputRef.current) === null || _inputRef$current === void 0 || _inputRef$current.blur();
      }, "blur"),
      setSelectionRange: /* @__PURE__ */ __name(function(start, end, direction) {
        var _inputRef$current2;
        (_inputRef$current2 = inputRef.current) === null || _inputRef$current2 === void 0 || _inputRef$current2.setSelectionRange(start, end, direction);
      }, "setSelectionRange"),
      select: /* @__PURE__ */ __name(function() {
        var _inputRef$current3;
        (_inputRef$current3 = inputRef.current) === null || _inputRef$current3 === void 0 || _inputRef$current3.select();
      }, "select"),
      input: inputRef.current,
      nativeElement: ((_holderRef$current = holderRef.current) === null || _holderRef$current === void 0 ? void 0 : _holderRef$current.nativeElement) || inputRef.current
    };
  }), useEffect(function() {
    keyLockRef.current && (keyLockRef.current = !1), setFocused(function(prev2) {
      return prev2 && disabled ? !1 : prev2;
    });
  }, [disabled]);
  var triggerChange = /* @__PURE__ */ __name(function(e2, currentValue, info) {
    var cutValue = currentValue;
    if (!compositionRef.current && countConfig.exceedFormatter && countConfig.max && countConfig.strategy(currentValue) > countConfig.max) {
      if (cutValue = countConfig.exceedFormatter(currentValue, {
        max: countConfig.max
      }), currentValue !== cutValue) {
        var _inputRef$current4, _inputRef$current5;
        setSelection([((_inputRef$current4 = inputRef.current) === null || _inputRef$current4 === void 0 ? void 0 : _inputRef$current4.selectionStart) || 0, ((_inputRef$current5 = inputRef.current) === null || _inputRef$current5 === void 0 ? void 0 : _inputRef$current5.selectionEnd) || 0]);
      }
    } else if (info.source === "compositionEnd")
      return;
    setValue(cutValue), inputRef.current && resolveOnChange(inputRef.current, e2, onChange, cutValue);
  }, "triggerChange");
  useEffect(function() {
    if (selection) {
      var _inputRef$current6;
      (_inputRef$current6 = inputRef.current) === null || _inputRef$current6 === void 0 || _inputRef$current6.setSelectionRange.apply(_inputRef$current6, _toConsumableArray(selection));
    }
  }, [selection]);
  var onInternalChange = /* @__PURE__ */ __name(function(e2) {
    triggerChange(e2, e2.target.value, {
      source: "change"
    });
  }, "onInternalChange"), onInternalCompositionEnd = /* @__PURE__ */ __name(function(e2) {
    compositionRef.current = !1, triggerChange(e2, e2.currentTarget.value, {
      source: "compositionEnd"
    }), onCompositionEnd == null || onCompositionEnd(e2);
  }, "onInternalCompositionEnd"), handleKeyDown = /* @__PURE__ */ __name(function(e2) {
    onPressEnter && e2.key === "Enter" && !keyLockRef.current && (keyLockRef.current = !0, onPressEnter(e2)), onKeyDown2 == null || onKeyDown2(e2);
  }, "handleKeyDown"), handleKeyUp = /* @__PURE__ */ __name(function(e2) {
    e2.key === "Enter" && (keyLockRef.current = !1), onKeyUp == null || onKeyUp(e2);
  }, "handleKeyUp"), handleFocus = /* @__PURE__ */ __name(function(e2) {
    setFocused(!0), onFocus == null || onFocus(e2);
  }, "handleFocus"), handleBlur = /* @__PURE__ */ __name(function(e2) {
    keyLockRef.current && (keyLockRef.current = !1), setFocused(!1), onBlur == null || onBlur(e2);
  }, "handleBlur"), handleReset = /* @__PURE__ */ __name(function(e2) {
    setValue(""), focus(), inputRef.current && resolveOnChange(inputRef.current, e2, onChange);
  }, "handleReset"), outOfRangeCls = isOutOfRange && "".concat(prefixCls, "-out-of-range"), getInputElement = /* @__PURE__ */ __name(function() {
    var otherProps = omit(props, [
      "prefixCls",
      "onPressEnter",
      "addonBefore",
      "addonAfter",
      "prefix",
      "suffix",
      "allowClear",
      // Input elements must be either controlled or uncontrolled,
      // specify either the value prop, or the defaultValue prop, but not both.
      "defaultValue",
      "showCount",
      "count",
      "classes",
      "htmlSize",
      "styles",
      "classNames",
      "onClear"
    ]);
    return /* @__PURE__ */ React__default.createElement("input", _extends({
      autoComplete
    }, otherProps, {
      onChange: onInternalChange,
      onFocus: handleFocus,
      onBlur: handleBlur,
      onKeyDown: handleKeyDown,
      onKeyUp: handleKeyUp,
      className: cn(prefixCls, _defineProperty$2({}, "".concat(prefixCls, "-disabled"), disabled), classNames == null ? void 0 : classNames.input),
      style: styles2 == null ? void 0 : styles2.input,
      ref: inputRef,
      size: htmlSize,
      type: type4,
      onCompositionStart: /* @__PURE__ */ __name(function(e2) {
        compositionRef.current = !0, _onCompositionStart == null || _onCompositionStart(e2);
      }, "onCompositionStart"),
      onCompositionEnd: onInternalCompositionEnd
    }));
  }, "getInputElement"), getSuffix = /* @__PURE__ */ __name(function() {
    var hasMaxLength = Number(mergedMax) > 0;
    if (suffix || countConfig.show) {
      var dataCount = countConfig.showFormatter ? countConfig.showFormatter({
        value: formatValue2,
        count: valueLength,
        maxLength: mergedMax
      }) : "".concat(valueLength).concat(hasMaxLength ? " / ".concat(mergedMax) : "");
      return /* @__PURE__ */ React__default.createElement(React__default.Fragment, null, countConfig.show && /* @__PURE__ */ React__default.createElement("span", {
        className: cn("".concat(prefixCls, "-show-count-suffix"), _defineProperty$2({}, "".concat(prefixCls, "-show-count-has-suffix"), !!suffix), classNames == null ? void 0 : classNames.count),
        style: _objectSpread2$1({}, styles2 == null ? void 0 : styles2.count)
      }, dataCount), suffix);
    }
    return null;
  }, "getSuffix");
  return /* @__PURE__ */ React__default.createElement(BaseInput, _extends({}, rest, {
    prefixCls,
    className: cn(className, outOfRangeCls),
    handleReset,
    value: formatValue2,
    focused,
    triggerFocus: focus,
    suffix: getSuffix(),
    disabled,
    classes,
    classNames,
    styles: styles2
  }), getInputElement());
});
function proxyObject(obj, extendProps) {
  return typeof Proxy < "u" && obj ? new Proxy(obj, {
    get: /* @__PURE__ */ __name(function(target, prop) {
      if (extendProps[prop])
        return extendProps[prop];
      var originProp = target[prop];
      return typeof originProp == "function" ? originProp.bind(target) : originProp;
    }, "get")
  }) : obj;
}
__name(proxyObject, "proxyObject");
function useCursor(input, focused) {
  var selectionRef = useRef(null);
  function recordCursor() {
    try {
      var start = input.selectionStart, end = input.selectionEnd, value = input.value, beforeTxt = value.substring(0, start), afterTxt = value.substring(end);
      selectionRef.current = {
        start,
        end,
        value,
        beforeTxt,
        afterTxt
      };
    } catch {
    }
  }
  __name(recordCursor, "recordCursor");
  function restoreCursor() {
    if (input && selectionRef.current && focused)
      try {
        var value = input.value, _selectionRef$current = selectionRef.current, beforeTxt = _selectionRef$current.beforeTxt, afterTxt = _selectionRef$current.afterTxt, start = _selectionRef$current.start, startPos = value.length;
        if (value.startsWith(beforeTxt))
          startPos = beforeTxt.length;
        else if (value.endsWith(afterTxt))
          startPos = value.length - selectionRef.current.afterTxt.length;
        else {
          var beforeLastChar = beforeTxt[start - 1], newIndex = value.indexOf(beforeLastChar, start - 1);
          newIndex !== -1 && (startPos = newIndex + 1);
        }
        input.setSelectionRange(startPos, startPos);
      } catch (e2) {
        warningOnce(!1, "Something warning of cursor restore. Please fire issue about this: ".concat(e2.message));
      }
  }
  return __name(restoreCursor, "restoreCursor"), [recordCursor, restoreCursor];
}
__name(useCursor, "useCursor");
var useMobile = /* @__PURE__ */ __name(function() {
  var _useState = useState(!1), _useState2 = _slicedToArray(_useState, 2), mobile = _useState2[0], setMobile = _useState2[1];
  return useLayoutEffect$1(function() {
    setMobile(isMobile());
  }, []), mobile;
}, "useMobile"), STEP_INTERVAL = 200, STEP_DELAY = 600;
function StepHandler(_ref) {
  var prefixCls = _ref.prefixCls, upNode = _ref.upNode, downNode = _ref.downNode, upDisabled = _ref.upDisabled, downDisabled = _ref.downDisabled, onStep = _ref.onStep, stepTimeoutRef = React.useRef(), frameIds = React.useRef([]), onStepRef = React.useRef();
  onStepRef.current = onStep;
  var onStopStep = /* @__PURE__ */ __name(function() {
    clearTimeout(stepTimeoutRef.current);
  }, "onStopStep"), onStepMouseDown = /* @__PURE__ */ __name(function(e2, up) {
    e2.preventDefault(), onStopStep(), onStepRef.current(up);
    function loopStep() {
      onStepRef.current(up), stepTimeoutRef.current = setTimeout(loopStep, STEP_INTERVAL);
    }
    __name(loopStep, "loopStep"), stepTimeoutRef.current = setTimeout(loopStep, STEP_DELAY);
  }, "onStepMouseDown");
  React.useEffect(function() {
    return function() {
      onStopStep(), frameIds.current.forEach(function(id2) {
        return wrapperRaf.cancel(id2);
      });
    };
  }, []);
  var isMobile2 = useMobile();
  if (isMobile2)
    return null;
  var handlerClassName = "".concat(prefixCls, "-handler"), upClassName = cn(handlerClassName, "".concat(handlerClassName, "-up"), _defineProperty$2({}, "".concat(handlerClassName, "-up-disabled"), upDisabled)), downClassName = cn(handlerClassName, "".concat(handlerClassName, "-down"), _defineProperty$2({}, "".concat(handlerClassName, "-down-disabled"), downDisabled)), safeOnStopStep = /* @__PURE__ */ __name(function() {
    return frameIds.current.push(wrapperRaf(onStopStep));
  }, "safeOnStopStep"), sharedHandlerProps = {
    unselectable: "on",
    role: "button",
    onMouseUp: safeOnStopStep,
    onMouseLeave: safeOnStopStep
  };
  return /* @__PURE__ */ React.createElement("div", {
    className: "".concat(handlerClassName, "-wrap")
  }, /* @__PURE__ */ React.createElement("span", _extends({}, sharedHandlerProps, {
    onMouseDown: /* @__PURE__ */ __name(function(e2) {
      onStepMouseDown(e2, !0);
    }, "onMouseDown"),
    "aria-label": "Increase Value",
    "aria-disabled": upDisabled,
    className: upClassName
  }), upNode || /* @__PURE__ */ React.createElement("span", {
    unselectable: "on",
    className: "".concat(prefixCls, "-handler-up-inner")
  })), /* @__PURE__ */ React.createElement("span", _extends({}, sharedHandlerProps, {
    onMouseDown: /* @__PURE__ */ __name(function(e2) {
      onStepMouseDown(e2, !1);
    }, "onMouseDown"),
    "aria-label": "Decrease Value",
    "aria-disabled": downDisabled,
    className: downClassName
  }), downNode || /* @__PURE__ */ React.createElement("span", {
    unselectable: "on",
    className: "".concat(prefixCls, "-handler-down-inner")
  })));
}
__name(StepHandler, "StepHandler");
function getDecupleSteps(step) {
  var stepStr = typeof step == "number" ? num2str(step) : trimNumber(step).fullStr, hasPoint = stepStr.includes(".");
  return hasPoint ? trimNumber(stepStr.replace(/(\d)\.(\d)/g, "$1$2.")).fullStr : step + "0";
}
__name(getDecupleSteps, "getDecupleSteps");
const useFrame = /* @__PURE__ */ __name(function() {
  var idRef = useRef(0), cleanUp = /* @__PURE__ */ __name(function() {
    wrapperRaf.cancel(idRef.current);
  }, "cleanUp");
  return useEffect(function() {
    return cleanUp;
  }, []), function(callback) {
    cleanUp(), idRef.current = wrapperRaf(function() {
      callback();
    });
  };
}, "useFrame");
var _excluded$d = ["prefixCls", "className", "style", "min", "max", "step", "defaultValue", "value", "disabled", "readOnly", "upHandler", "downHandler", "keyboard", "changeOnWheel", "controls", "classNames", "stringMode", "parser", "formatter", "precision", "decimalSeparator", "onChange", "onInput", "onPressEnter", "onStep", "changeOnBlur", "domRef"], _excluded2$1 = ["disabled", "style", "prefixCls", "value", "prefix", "suffix", "addonBefore", "addonAfter", "className", "classNames"], getDecimalValue = /* @__PURE__ */ __name(function(stringMode, decimalValue) {
  return stringMode || decimalValue.isEmpty() ? decimalValue.toString() : decimalValue.toNumber();
}, "getDecimalValue"), getDecimalIfValidate = /* @__PURE__ */ __name(function(value) {
  var decimal = getMiniDecimal(value);
  return decimal.isInvalidate() ? null : decimal;
}, "getDecimalIfValidate"), InternalInputNumber = /* @__PURE__ */ React.forwardRef(function(props, ref) {
  var prefixCls = props.prefixCls, className = props.className, style2 = props.style, min = props.min, max = props.max, _props$step = props.step, step = _props$step === void 0 ? 1 : _props$step, defaultValue = props.defaultValue, value = props.value, disabled = props.disabled, readOnly = props.readOnly, upHandler = props.upHandler, downHandler = props.downHandler, keyboard = props.keyboard, _props$changeOnWheel = props.changeOnWheel, changeOnWheel = _props$changeOnWheel === void 0 ? !1 : _props$changeOnWheel, _props$controls = props.controls, controls = _props$controls === void 0 ? !0 : _props$controls;
  props.classNames;
  var stringMode = props.stringMode, parser = props.parser, formatter = props.formatter, precision = props.precision, decimalSeparator = props.decimalSeparator, onChange = props.onChange, onInput = props.onInput, onPressEnter = props.onPressEnter, onStep = props.onStep, _props$changeOnBlur = props.changeOnBlur, changeOnBlur = _props$changeOnBlur === void 0 ? !0 : _props$changeOnBlur, domRef = props.domRef, inputProps = _objectWithoutProperties(props, _excluded$d), inputClassName = "".concat(prefixCls, "-input"), inputRef = React.useRef(null), _React$useState = React.useState(!1), _React$useState2 = _slicedToArray(_React$useState, 2), focus = _React$useState2[0], setFocus = _React$useState2[1], userTypingRef = React.useRef(!1), compositionRef = React.useRef(!1), shiftKeyRef = React.useRef(!1), _React$useState3 = React.useState(function() {
    return getMiniDecimal(value ?? defaultValue);
  }), _React$useState4 = _slicedToArray(_React$useState3, 2), decimalValue = _React$useState4[0], setDecimalValue = _React$useState4[1];
  function setUncontrolledDecimalValue(newDecimal) {
    value === void 0 && setDecimalValue(newDecimal);
  }
  __name(setUncontrolledDecimalValue, "setUncontrolledDecimalValue");
  var getPrecision = React.useCallback(function(numStr, userTyping) {
    if (!userTyping)
      return precision >= 0 ? precision : Math.max(getNumberPrecision(numStr), getNumberPrecision(step));
  }, [precision, step]), mergedParser = React.useCallback(function(num) {
    var numStr = String(num);
    if (parser)
      return parser(numStr);
    var parsedStr = numStr;
    return decimalSeparator && (parsedStr = parsedStr.replace(decimalSeparator, ".")), parsedStr.replace(/[^\w.-]+/g, "");
  }, [parser, decimalSeparator]), inputValueRef = React.useRef(""), mergedFormatter = React.useCallback(function(number4, userTyping) {
    if (formatter)
      return formatter(number4, {
        userTyping,
        input: String(inputValueRef.current)
      });
    var str = typeof number4 == "number" ? num2str(number4) : number4;
    if (!userTyping) {
      var mergedPrecision = getPrecision(str, userTyping);
      if (validateNumber(str) && (decimalSeparator || mergedPrecision >= 0)) {
        var separatorStr = decimalSeparator || ".";
        str = toFixed(str, separatorStr, mergedPrecision);
      }
    }
    return str;
  }, [formatter, getPrecision, decimalSeparator]), _React$useState5 = React.useState(function() {
    var initValue = defaultValue ?? value;
    return decimalValue.isInvalidate() && ["string", "number"].includes(_typeof$4(initValue)) ? Number.isNaN(initValue) ? "" : initValue : mergedFormatter(decimalValue.toString(), !1);
  }), _React$useState6 = _slicedToArray(_React$useState5, 2), inputValue = _React$useState6[0], setInternalInputValue = _React$useState6[1];
  inputValueRef.current = inputValue;
  function setInputValue(newValue, userTyping) {
    setInternalInputValue(mergedFormatter(
      // Invalidate number is sometime passed by external control, we should let it go
      // Otherwise is controlled by internal interactive logic which check by userTyping
      // You can ref 'show limited value when input is not focused' test for more info.
      newValue.isInvalidate() ? newValue.toString(!1) : newValue.toString(!userTyping),
      userTyping
    ));
  }
  __name(setInputValue, "setInputValue");
  var maxDecimal = React.useMemo(function() {
    return getDecimalIfValidate(max);
  }, [max, precision]), minDecimal = React.useMemo(function() {
    return getDecimalIfValidate(min);
  }, [min, precision]), upDisabled = React.useMemo(function() {
    return !maxDecimal || !decimalValue || decimalValue.isInvalidate() ? !1 : maxDecimal.lessEquals(decimalValue);
  }, [maxDecimal, decimalValue]), downDisabled = React.useMemo(function() {
    return !minDecimal || !decimalValue || decimalValue.isInvalidate() ? !1 : decimalValue.lessEquals(minDecimal);
  }, [minDecimal, decimalValue]), _useCursor = useCursor(inputRef.current, focus), _useCursor2 = _slicedToArray(_useCursor, 2), recordCursor = _useCursor2[0], restoreCursor = _useCursor2[1], getRangeValue = /* @__PURE__ */ __name(function(target) {
    return maxDecimal && !target.lessEquals(maxDecimal) ? maxDecimal : minDecimal && !minDecimal.lessEquals(target) ? minDecimal : null;
  }, "getRangeValue"), isInRange2 = /* @__PURE__ */ __name(function(target) {
    return !getRangeValue(target);
  }, "isInRange"), triggerValueUpdate = /* @__PURE__ */ __name(function(newValue, userTyping) {
    var updateValue = newValue, isRangeValidate = isInRange2(updateValue) || updateValue.isEmpty();
    if (!updateValue.isEmpty() && !userTyping && (updateValue = getRangeValue(updateValue) || updateValue, isRangeValidate = !0), !readOnly && !disabled && isRangeValidate) {
      var numStr = updateValue.toString(), mergedPrecision = getPrecision(numStr, userTyping);
      return mergedPrecision >= 0 && (updateValue = getMiniDecimal(toFixed(numStr, ".", mergedPrecision)), isInRange2(updateValue) || (updateValue = getMiniDecimal(toFixed(numStr, ".", mergedPrecision, !0)))), updateValue.equals(decimalValue) || (setUncontrolledDecimalValue(updateValue), onChange == null || onChange(updateValue.isEmpty() ? null : getDecimalValue(stringMode, updateValue)), value === void 0 && setInputValue(updateValue, userTyping)), updateValue;
    }
    return decimalValue;
  }, "triggerValueUpdate"), onNextPromise = useFrame(), collectInputValue = /* @__PURE__ */ __name(function collectInputValue2(inputStr) {
    if (recordCursor(), inputValueRef.current = inputStr, setInternalInputValue(inputStr), !compositionRef.current) {
      var finalValue = mergedParser(inputStr), finalDecimal = getMiniDecimal(finalValue);
      finalDecimal.isNaN() || triggerValueUpdate(finalDecimal, !0);
    }
    onInput == null || onInput(inputStr), onNextPromise(function() {
      var nextInputStr = inputStr;
      parser || (nextInputStr = inputStr.replace(/。/g, ".")), nextInputStr !== inputStr && collectInputValue2(nextInputStr);
    });
  }, "collectInputValue"), onCompositionStart = /* @__PURE__ */ __name(function() {
    compositionRef.current = !0;
  }, "onCompositionStart"), onCompositionEnd = /* @__PURE__ */ __name(function() {
    compositionRef.current = !1, collectInputValue(inputRef.current.value);
  }, "onCompositionEnd"), onInternalInput = /* @__PURE__ */ __name(function(e2) {
    collectInputValue(e2.target.value);
  }, "onInternalInput"), onInternalStep = /* @__PURE__ */ __name(function(up) {
    var _inputRef$current;
    if (!(up && upDisabled || !up && downDisabled)) {
      userTypingRef.current = !1;
      var stepDecimal = getMiniDecimal(shiftKeyRef.current ? getDecupleSteps(step) : step);
      up || (stepDecimal = stepDecimal.negate());
      var target = (decimalValue || getMiniDecimal(0)).add(stepDecimal.toString()), updatedValue = triggerValueUpdate(target, !1);
      onStep == null || onStep(getDecimalValue(stringMode, updatedValue), {
        offset: shiftKeyRef.current ? getDecupleSteps(step) : step,
        type: up ? "up" : "down"
      }), (_inputRef$current = inputRef.current) === null || _inputRef$current === void 0 || _inputRef$current.focus();
    }
  }, "onInternalStep"), flushInputValue = /* @__PURE__ */ __name(function(userTyping) {
    var parsedValue = getMiniDecimal(mergedParser(inputValue)), formatValue2;
    parsedValue.isNaN() ? formatValue2 = triggerValueUpdate(decimalValue, userTyping) : formatValue2 = triggerValueUpdate(parsedValue, userTyping), value !== void 0 ? setInputValue(decimalValue, !1) : formatValue2.isNaN() || setInputValue(formatValue2, !1);
  }, "flushInputValue"), onBeforeInput = /* @__PURE__ */ __name(function() {
    userTypingRef.current = !0;
  }, "onBeforeInput"), onKeyDown2 = /* @__PURE__ */ __name(function(event) {
    var key = event.key, shiftKey = event.shiftKey;
    userTypingRef.current = !0, shiftKeyRef.current = shiftKey, key === "Enter" && (compositionRef.current || (userTypingRef.current = !1), flushInputValue(!1), onPressEnter == null || onPressEnter(event)), keyboard !== !1 && !compositionRef.current && ["Up", "ArrowUp", "Down", "ArrowDown"].includes(key) && (onInternalStep(key === "Up" || key === "ArrowUp"), event.preventDefault());
  }, "onKeyDown"), onKeyUp = /* @__PURE__ */ __name(function() {
    userTypingRef.current = !1, shiftKeyRef.current = !1;
  }, "onKeyUp");
  React.useEffect(function() {
    if (changeOnWheel && focus) {
      var onWheel = /* @__PURE__ */ __name(function(event) {
        onInternalStep(event.deltaY < 0), event.preventDefault();
      }, "onWheel"), input = inputRef.current;
      if (input)
        return input.addEventListener("wheel", onWheel, {
          passive: !1
        }), function() {
          return input.removeEventListener("wheel", onWheel);
        };
    }
  });
  var onBlur = /* @__PURE__ */ __name(function() {
    changeOnBlur && flushInputValue(!1), setFocus(!1), userTypingRef.current = !1;
  }, "onBlur");
  return useLayoutUpdateEffect(function() {
    decimalValue.isInvalidate() || setInputValue(decimalValue, !1);
  }, [precision, formatter]), useLayoutUpdateEffect(function() {
    var newValue = getMiniDecimal(value);
    setDecimalValue(newValue);
    var currentParsedValue = getMiniDecimal(mergedParser(inputValue));
    (!newValue.equals(currentParsedValue) || !userTypingRef.current || formatter) && setInputValue(newValue, userTypingRef.current);
  }, [value]), useLayoutUpdateEffect(function() {
    formatter && restoreCursor();
  }, [inputValue]), /* @__PURE__ */ React.createElement("div", {
    ref: domRef,
    className: cn(prefixCls, className, _defineProperty$2(_defineProperty$2(_defineProperty$2(_defineProperty$2(_defineProperty$2({}, "".concat(prefixCls, "-focused"), focus), "".concat(prefixCls, "-disabled"), disabled), "".concat(prefixCls, "-readonly"), readOnly), "".concat(prefixCls, "-not-a-number"), decimalValue.isNaN()), "".concat(prefixCls, "-out-of-range"), !decimalValue.isInvalidate() && !isInRange2(decimalValue))),
    style: style2,
    onFocus: /* @__PURE__ */ __name(function() {
      setFocus(!0);
    }, "onFocus"),
    onBlur,
    onKeyDown: onKeyDown2,
    onKeyUp,
    onCompositionStart,
    onCompositionEnd,
    onBeforeInput
  }, controls && /* @__PURE__ */ React.createElement(StepHandler, {
    prefixCls,
    upNode: upHandler,
    downNode: downHandler,
    upDisabled,
    downDisabled,
    onStep: onInternalStep
  }), /* @__PURE__ */ React.createElement("div", {
    className: "".concat(inputClassName, "-wrap")
  }, /* @__PURE__ */ React.createElement("input", _extends({
    autoComplete: "off",
    role: "spinbutton",
    "aria-valuemin": min,
    "aria-valuemax": max,
    "aria-valuenow": decimalValue.isInvalidate() ? null : decimalValue.toString(),
    step
  }, inputProps, {
    ref: composeRef(inputRef, ref),
    className: inputClassName,
    value: inputValue,
    onChange: onInternalInput,
    disabled,
    readOnly
  }))));
}), InputNumber$2 = /* @__PURE__ */ React.forwardRef(function(props, ref) {
  var disabled = props.disabled, style2 = props.style, _props$prefixCls = props.prefixCls, prefixCls = _props$prefixCls === void 0 ? "rc-input-number" : _props$prefixCls, value = props.value, prefix = props.prefix, suffix = props.suffix, addonBefore = props.addonBefore, addonAfter = props.addonAfter, className = props.className, classNames = props.classNames, rest = _objectWithoutProperties(props, _excluded2$1), holderRef = React.useRef(null), inputNumberDomRef = React.useRef(null), inputFocusRef = React.useRef(null), focus = /* @__PURE__ */ __name(function(option) {
    inputFocusRef.current && triggerFocus(inputFocusRef.current, option);
  }, "focus");
  return React.useImperativeHandle(ref, function() {
    return proxyObject(inputFocusRef.current, {
      focus,
      nativeElement: holderRef.current.nativeElement || inputNumberDomRef.current
    });
  }), /* @__PURE__ */ React.createElement(BaseInput, {
    className,
    triggerFocus: focus,
    prefixCls,
    value,
    disabled,
    style: style2,
    prefix,
    suffix,
    addonAfter,
    addonBefore,
    classNames,
    components: {
      affixWrapper: "div",
      groupWrapper: "div",
      wrapper: "div",
      groupAddon: "div"
    },
    ref: holderRef
  }, /* @__PURE__ */ React.createElement(InternalInputNumber, _extends({
    prefixCls,
    disabled,
    ref: inputFocusRef,
    domRef: inputNumberDomRef,
    className: classNames == null ? void 0 : classNames.input
  }, rest)));
});
process.env.NODE_ENV !== "production" && (InputNumber$2.displayName = "InputNumber");
const prepareComponentToken$9 = /* @__PURE__ */ __name((token2) => {
  var _a;
  const handleVisible = (_a = token2.handleVisible) !== null && _a !== void 0 ? _a : "auto", handleWidth = token2.controlHeightSM - token2.lineWidth * 2;
  return Object.assign(Object.assign({}, initComponentToken$1(token2)), {
    controlWidth: 90,
    handleWidth,
    handleFontSize: token2.fontSize / 2,
    handleVisible,
    handleActiveBg: token2.colorFillAlter,
    handleBg: token2.colorBgContainer,
    filledHandleBg: new TinyColor(token2.colorFillSecondary).onBackground(token2.colorBgContainer).toHexString(),
    handleHoverColor: token2.colorPrimary,
    handleBorderColor: token2.colorBorder,
    handleOpacity: handleVisible === !0 ? 1 : 0,
    handleVisibleWidth: handleVisible === !0 ? handleWidth : 0
  });
}, "prepareComponentToken$9"), genRadiusStyle$1 = /* @__PURE__ */ __name((_ref, size) => {
  let {
    componentCls,
    borderRadiusSM,
    borderRadiusLG
  } = _ref;
  const borderRadius = size === "lg" ? borderRadiusLG : borderRadiusSM;
  return {
    [`&-${size}`]: {
      [`${componentCls}-handler-wrap`]: {
        borderStartEndRadius: borderRadius,
        borderEndEndRadius: borderRadius
      },
      [`${componentCls}-handler-up`]: {
        borderStartEndRadius: borderRadius
      },
      [`${componentCls}-handler-down`]: {
        borderEndEndRadius: borderRadius
      }
    }
  };
}, "genRadiusStyle$1"), genInputNumberStyles = /* @__PURE__ */ __name((token2) => {
  const {
    componentCls,
    lineWidth,
    lineType,
    borderRadius,
    inputFontSizeSM,
    inputFontSizeLG,
    controlHeightLG,
    controlHeightSM,
    colorError,
    paddingInlineSM,
    paddingBlockSM,
    paddingBlockLG,
    paddingInlineLG,
    colorTextDescription,
    motionDurationMid,
    handleHoverColor,
    handleOpacity,
    paddingInline,
    paddingBlock,
    handleBg,
    handleActiveBg,
    colorTextDisabled,
    borderRadiusSM,
    borderRadiusLG,
    controlWidth,
    handleBorderColor,
    filledHandleBg,
    lineHeightLG,
    calc
  } = token2;
  return [
    {
      [componentCls]: Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, resetComponent(token2)), genBasicInputStyle(token2)), {
        display: "inline-block",
        width: controlWidth,
        margin: 0,
        padding: 0,
        borderRadius
      }), genOutlinedStyle(token2, {
        [`${componentCls}-handler-wrap`]: {
          background: handleBg,
          [`${componentCls}-handler-down`]: {
            borderBlockStart: `${unit$1(lineWidth)} ${lineType} ${handleBorderColor}`
          }
        }
      })), genFilledStyle(token2, {
        [`${componentCls}-handler-wrap`]: {
          background: filledHandleBg,
          [`${componentCls}-handler-down`]: {
            borderBlockStart: `${unit$1(lineWidth)} ${lineType} ${handleBorderColor}`
          }
        },
        "&:focus-within": {
          [`${componentCls}-handler-wrap`]: {
            background: handleBg
          }
        }
      })), genBorderlessStyle(token2)), {
        "&-rtl": {
          direction: "rtl",
          [`${componentCls}-input`]: {
            direction: "rtl"
          }
        },
        "&-lg": {
          padding: 0,
          fontSize: inputFontSizeLG,
          lineHeight: lineHeightLG,
          borderRadius: borderRadiusLG,
          [`input${componentCls}-input`]: {
            height: calc(controlHeightLG).sub(calc(lineWidth).mul(2)).equal(),
            padding: `${unit$1(paddingBlockLG)} ${unit$1(paddingInlineLG)}`
          }
        },
        "&-sm": {
          padding: 0,
          fontSize: inputFontSizeSM,
          borderRadius: borderRadiusSM,
          [`input${componentCls}-input`]: {
            height: calc(controlHeightSM).sub(calc(lineWidth).mul(2)).equal(),
            padding: `${unit$1(paddingBlockSM)} ${unit$1(paddingInlineSM)}`
          }
        },
        // ===================== Out Of Range =====================
        "&-out-of-range": {
          [`${componentCls}-input-wrap`]: {
            input: {
              color: colorError
            }
          }
        },
        // Style for input-group: input with label, with button or dropdown...
        "&-group": Object.assign(Object.assign(Object.assign({}, resetComponent(token2)), genInputGroupStyle(token2)), {
          "&-wrapper": Object.assign(Object.assign(Object.assign({
            display: "inline-block",
            textAlign: "start",
            verticalAlign: "top",
            [`${componentCls}-affix-wrapper`]: {
              width: "100%"
            },
            // Size
            "&-lg": {
              [`${componentCls}-group-addon`]: {
                borderRadius: borderRadiusLG,
                fontSize: token2.fontSizeLG
              }
            },
            "&-sm": {
              [`${componentCls}-group-addon`]: {
                borderRadius: borderRadiusSM
              }
            }
          }, genOutlinedGroupStyle(token2)), genFilledGroupStyle(token2)), {
            // Fix the issue of using icons in Space Compact mode
            // https://github.com/ant-design/ant-design/issues/45764
            [`&:not(${componentCls}-compact-first-item):not(${componentCls}-compact-last-item)${componentCls}-compact-item`]: {
              [`${componentCls}, ${componentCls}-group-addon`]: {
                borderRadius: 0
              }
            },
            [`&:not(${componentCls}-compact-last-item)${componentCls}-compact-first-item`]: {
              [`${componentCls}, ${componentCls}-group-addon`]: {
                borderStartEndRadius: 0,
                borderEndEndRadius: 0
              }
            },
            [`&:not(${componentCls}-compact-first-item)${componentCls}-compact-last-item`]: {
              [`${componentCls}, ${componentCls}-group-addon`]: {
                borderStartStartRadius: 0,
                borderEndStartRadius: 0
              }
            }
          })
        }),
        [`&-disabled ${componentCls}-input`]: {
          cursor: "not-allowed"
        },
        [componentCls]: {
          "&-input": Object.assign(Object.assign(Object.assign(Object.assign({}, resetComponent(token2)), {
            width: "100%",
            padding: `${unit$1(paddingBlock)} ${unit$1(paddingInline)}`,
            textAlign: "start",
            backgroundColor: "transparent",
            border: 0,
            borderRadius,
            outline: 0,
            transition: `all ${motionDurationMid} linear`,
            appearance: "textfield",
            fontSize: "inherit"
          }), genPlaceholderStyle(token2.colorTextPlaceholder)), {
            '&[type="number"]::-webkit-inner-spin-button, &[type="number"]::-webkit-outer-spin-button': {
              margin: 0,
              webkitAppearance: "none",
              appearance: "none"
            }
          })
        },
        [`&:hover ${componentCls}-handler-wrap, &-focused ${componentCls}-handler-wrap`]: {
          width: token2.handleWidth,
          opacity: 1
        }
      })
    },
    // Handler
    {
      [componentCls]: Object.assign(Object.assign(Object.assign({
        [`${componentCls}-handler-wrap`]: {
          position: "absolute",
          insetBlockStart: 0,
          insetInlineEnd: 0,
          width: token2.handleVisibleWidth,
          opacity: handleOpacity,
          height: "100%",
          borderStartStartRadius: 0,
          borderStartEndRadius: borderRadius,
          borderEndEndRadius: borderRadius,
          borderEndStartRadius: 0,
          display: "flex",
          flexDirection: "column",
          alignItems: "stretch",
          transition: `all ${motionDurationMid}`,
          overflow: "hidden",
          // Fix input number inside Menu makes icon too large
          // We arise the selector priority by nest selector here
          // https://github.com/ant-design/ant-design/issues/14367
          [`${componentCls}-handler`]: {
            display: "flex",
            alignItems: "center",
            justifyContent: "center",
            flex: "auto",
            height: "40%",
            [`
              ${componentCls}-handler-up-inner,
              ${componentCls}-handler-down-inner
            `]: {
              marginInlineEnd: 0,
              fontSize: token2.handleFontSize
            }
          }
        },
        [`${componentCls}-handler`]: {
          height: "50%",
          overflow: "hidden",
          color: colorTextDescription,
          fontWeight: "bold",
          lineHeight: 0,
          textAlign: "center",
          cursor: "pointer",
          borderInlineStart: `${unit$1(lineWidth)} ${lineType} ${handleBorderColor}`,
          transition: `all ${motionDurationMid} linear`,
          "&:active": {
            background: handleActiveBg
          },
          // Hover
          "&:hover": {
            height: "60%",
            [`
              ${componentCls}-handler-up-inner,
              ${componentCls}-handler-down-inner
            `]: {
              color: handleHoverColor
            }
          },
          "&-up-inner, &-down-inner": Object.assign(Object.assign({}, resetIcon()), {
            color: colorTextDescription,
            transition: `all ${motionDurationMid} linear`,
            userSelect: "none"
          })
        },
        [`${componentCls}-handler-up`]: {
          borderStartEndRadius: borderRadius
        },
        [`${componentCls}-handler-down`]: {
          borderEndEndRadius: borderRadius
        }
      }, genRadiusStyle$1(token2, "lg")), genRadiusStyle$1(token2, "sm")), {
        // Disabled
        "&-disabled, &-readonly": {
          [`${componentCls}-handler-wrap`]: {
            display: "none"
          },
          [`${componentCls}-input`]: {
            color: "inherit"
          }
        },
        [`
          ${componentCls}-handler-up-disabled,
          ${componentCls}-handler-down-disabled
        `]: {
          cursor: "not-allowed"
        },
        [`
          ${componentCls}-handler-up-disabled:hover &-handler-up-inner,
          ${componentCls}-handler-down-disabled:hover &-handler-down-inner
        `]: {
          color: colorTextDisabled
        }
      })
    }
  ];
}, "genInputNumberStyles"), genAffixWrapperStyles = /* @__PURE__ */ __name((token2) => {
  const {
    componentCls,
    paddingBlock,
    paddingInline,
    inputAffixPadding,
    controlWidth,
    borderRadiusLG,
    borderRadiusSM,
    paddingInlineLG,
    paddingInlineSM,
    paddingBlockLG,
    paddingBlockSM,
    motionDurationMid
  } = token2;
  return {
    [`${componentCls}-affix-wrapper`]: Object.assign(Object.assign({
      [`input${componentCls}-input`]: {
        padding: `${unit$1(paddingBlock)} 0`
      }
    }, genBasicInputStyle(token2)), {
      // or number handler will cover form status
      position: "relative",
      display: "inline-flex",
      alignItems: "center",
      width: controlWidth,
      padding: 0,
      paddingInlineStart: paddingInline,
      "&-lg": {
        borderRadius: borderRadiusLG,
        paddingInlineStart: paddingInlineLG,
        [`input${componentCls}-input`]: {
          padding: `${unit$1(paddingBlockLG)} 0`
        }
      },
      "&-sm": {
        borderRadius: borderRadiusSM,
        paddingInlineStart: paddingInlineSM,
        [`input${componentCls}-input`]: {
          padding: `${unit$1(paddingBlockSM)} 0`
        }
      },
      [`&:not(${componentCls}-disabled):hover`]: {
        zIndex: 1
      },
      "&-focused, &:focus": {
        zIndex: 1
      },
      [`&-disabled > ${componentCls}-disabled`]: {
        background: "transparent"
      },
      [`> div${componentCls}`]: {
        width: "100%",
        border: "none",
        outline: "none",
        [`&${componentCls}-focused`]: {
          boxShadow: "none !important"
        }
      },
      "&::before": {
        display: "inline-block",
        width: 0,
        visibility: "hidden",
        content: '"\\a0"'
      },
      [`${componentCls}-handler-wrap`]: {
        zIndex: 2
      },
      [componentCls]: {
        position: "static",
        color: "inherit",
        "&-prefix, &-suffix": {
          display: "flex",
          flex: "none",
          alignItems: "center",
          pointerEvents: "none"
        },
        "&-prefix": {
          marginInlineEnd: inputAffixPadding
        },
        "&-suffix": {
          insetBlockStart: 0,
          insetInlineEnd: 0,
          height: "100%",
          marginInlineEnd: paddingInline,
          marginInlineStart: inputAffixPadding,
          transition: `margin ${motionDurationMid}`
        }
      },
      [`&:hover ${componentCls}-handler-wrap, &-focused ${componentCls}-handler-wrap`]: {
        width: token2.handleWidth,
        opacity: 1
      },
      [`&:not(${componentCls}-affix-wrapper-without-controls):hover ${componentCls}-suffix`]: {
        marginInlineEnd: token2.calc(token2.handleWidth).add(paddingInline).equal()
      }
    })
  };
}, "genAffixWrapperStyles"), useStyle$a = genStyleHooks("InputNumber", (token2) => {
  const inputNumberToken = merge(token2, initInputToken(token2));
  return [
    genInputNumberStyles(inputNumberToken),
    genAffixWrapperStyles(inputNumberToken),
    // =====================================================
    // ==             Space Compact                       ==
    // =====================================================
    genCompactItemStyle(inputNumberToken)
  ];
}, prepareComponentToken$9, {
  unitless: {
    handleOpacity: !0
  }
});
var __rest$t = function(s, e2) {
  var t2 = {};
  for (var p in s) Object.prototype.hasOwnProperty.call(s, p) && e2.indexOf(p) < 0 && (t2[p] = s[p]);
  if (s != null && typeof Object.getOwnPropertySymbols == "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++)
    e2.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]) && (t2[p[i]] = s[p[i]]);
  return t2;
};
const InputNumber$1 = /* @__PURE__ */ React.forwardRef((props, ref) => {
  if (process.env.NODE_ENV !== "production") {
    const typeWarning = devUseWarning("InputNumber");
    typeWarning.deprecated(!("bordered" in props), "bordered", "variant"), typeWarning(!(props.type === "number" && props.changeOnWheel), "usage", "When `type=number` is used together with `changeOnWheel`, changeOnWheel may not work properly. Please delete `type=number` if it is not necessary.");
  }
  const {
    getPrefixCls,
    direction
  } = React.useContext(ConfigContext), inputRef = React.useRef(null);
  React.useImperativeHandle(ref, () => inputRef.current);
  const {
    className,
    rootClassName,
    size: customizeSize,
    disabled: customDisabled,
    prefixCls: customizePrefixCls,
    addonBefore,
    addonAfter,
    prefix,
    suffix,
    bordered,
    readOnly,
    status: customStatus,
    controls,
    variant: customVariant
  } = props, others = __rest$t(props, ["className", "rootClassName", "size", "disabled", "prefixCls", "addonBefore", "addonAfter", "prefix", "suffix", "bordered", "readOnly", "status", "controls", "variant"]), prefixCls = getPrefixCls("input-number", customizePrefixCls), rootCls = useCSSVarCls(prefixCls), [wrapCSSVar, hashId, cssVarCls] = useStyle$a(prefixCls, rootCls), {
    compactSize,
    compactItemClassnames
  } = useCompactItemContext(prefixCls, direction);
  let upIcon = /* @__PURE__ */ React.createElement(RefIcon$q, {
    className: `${prefixCls}-handler-up-inner`
  }), downIcon = /* @__PURE__ */ React.createElement(RefIcon$w, {
    className: `${prefixCls}-handler-down-inner`
  });
  const controlsTemp = typeof controls == "boolean" ? controls : void 0;
  typeof controls == "object" && (upIcon = typeof controls.upIcon > "u" ? upIcon : /* @__PURE__ */ React.createElement("span", {
    className: `${prefixCls}-handler-up-inner`
  }, controls.upIcon), downIcon = typeof controls.downIcon > "u" ? downIcon : /* @__PURE__ */ React.createElement("span", {
    className: `${prefixCls}-handler-down-inner`
  }, controls.downIcon));
  const {
    hasFeedback,
    status: contextStatus,
    isFormItemInput,
    feedbackIcon
  } = React.useContext(FormItemInputContext), mergedStatus = getMergedStatus(contextStatus, customStatus), mergedSize = useSize((ctx) => {
    var _a;
    return (_a = customizeSize ?? compactSize) !== null && _a !== void 0 ? _a : ctx;
  }), disabled = React.useContext(DisabledContext), mergedDisabled = customDisabled ?? disabled, [variant, enableVariantCls] = useVariant("inputNumber", customVariant, bordered), suffixNode = hasFeedback && /* @__PURE__ */ React.createElement(React.Fragment, null, feedbackIcon), inputNumberClass = cn({
    [`${prefixCls}-lg`]: mergedSize === "large",
    [`${prefixCls}-sm`]: mergedSize === "small",
    [`${prefixCls}-rtl`]: direction === "rtl",
    [`${prefixCls}-in-form-item`]: isFormItemInput
  }, hashId), wrapperClassName = `${prefixCls}-group`, element = /* @__PURE__ */ React.createElement(InputNumber$2, Object.assign({
    ref: inputRef,
    disabled: mergedDisabled,
    className: cn(cssVarCls, rootCls, className, rootClassName, compactItemClassnames),
    upHandler: upIcon,
    downHandler: downIcon,
    prefixCls,
    readOnly,
    controls: controlsTemp,
    prefix,
    suffix: suffixNode || suffix,
    addonBefore: addonBefore && /* @__PURE__ */ React.createElement(ContextIsolator, {
      form: !0,
      space: !0
    }, addonBefore),
    addonAfter: addonAfter && /* @__PURE__ */ React.createElement(ContextIsolator, {
      form: !0,
      space: !0
    }, addonAfter),
    classNames: {
      input: inputNumberClass,
      variant: cn({
        [`${prefixCls}-${variant}`]: enableVariantCls
      }, getStatusClassNames(prefixCls, mergedStatus, hasFeedback)),
      affixWrapper: cn({
        [`${prefixCls}-affix-wrapper-sm`]: mergedSize === "small",
        [`${prefixCls}-affix-wrapper-lg`]: mergedSize === "large",
        [`${prefixCls}-affix-wrapper-rtl`]: direction === "rtl",
        [`${prefixCls}-affix-wrapper-without-controls`]: controls === !1
      }, hashId),
      wrapper: cn({
        [`${wrapperClassName}-rtl`]: direction === "rtl"
      }, hashId),
      groupWrapper: cn({
        [`${prefixCls}-group-wrapper-sm`]: mergedSize === "small",
        [`${prefixCls}-group-wrapper-lg`]: mergedSize === "large",
        [`${prefixCls}-group-wrapper-rtl`]: direction === "rtl",
        [`${prefixCls}-group-wrapper-${variant}`]: enableVariantCls
      }, getStatusClassNames(`${prefixCls}-group-wrapper`, mergedStatus, hasFeedback), hashId)
    }
  }, others));
  return wrapCSSVar(element);
}), TypedInputNumber = InputNumber$1, PureInputNumber = /* @__PURE__ */ __name((props) => /* @__PURE__ */ React.createElement(ConfigProvider, {
  theme: {
    components: {
      InputNumber: {
        handleVisible: !0
      }
    }
  }
}, /* @__PURE__ */ React.createElement(InputNumber$1, Object.assign({}, props))), "PureInputNumber");
process.env.NODE_ENV !== "production" && (TypedInputNumber.displayName = "InputNumber");
TypedInputNumber._InternalPanelDoNotUseOrYouWillBeFired = PureInputNumber;
const Group = /* @__PURE__ */ __name((props) => {
  const {
    getPrefixCls,
    direction
  } = useContext$1(ConfigContext), {
    prefixCls: customizePrefixCls,
    className
  } = props, prefixCls = getPrefixCls("input-group", customizePrefixCls), inputPrefixCls = getPrefixCls("input"), [wrapCSSVar, hashId] = useStyle$g(inputPrefixCls), cls = cn(prefixCls, {
    [`${prefixCls}-lg`]: props.size === "large",
    [`${prefixCls}-sm`]: props.size === "small",
    [`${prefixCls}-compact`]: props.compact,
    [`${prefixCls}-rtl`]: direction === "rtl"
  }, hashId, className), formItemContext = useContext$1(FormItemInputContext), groupFormItemContext = useMemo$1(() => Object.assign(Object.assign({}, formItemContext), {
    isFormItemInput: !1
  }), [formItemContext]);
  return process.env.NODE_ENV !== "production" && devUseWarning("Input.Group").deprecated(!1, "Input.Group", "Space.Compact"), wrapCSSVar(/* @__PURE__ */ React.createElement("span", {
    className: cls,
    style: props.style,
    onMouseEnter: props.onMouseEnter,
    onMouseLeave: props.onMouseLeave,
    onFocus: props.onFocus,
    onBlur: props.onBlur
  }, /* @__PURE__ */ React.createElement(FormItemInputContext.Provider, {
    value: groupFormItemContext
  }, props.children)));
}, "Group"), getAllowClear = /* @__PURE__ */ __name((allowClear) => {
  let mergedAllowClear;
  return typeof allowClear == "object" && (allowClear != null && allowClear.clearIcon) ? mergedAllowClear = allowClear : allowClear && (mergedAllowClear = {
    clearIcon: /* @__PURE__ */ React__default.createElement(RefIcon$C, null)
  }), mergedAllowClear;
}, "getAllowClear");
function useRemovePasswordTimeout(inputRef, triggerOnMount) {
  const removePasswordTimeoutRef = useRef([]), removePasswordTimeout = /* @__PURE__ */ __name(() => {
    removePasswordTimeoutRef.current.push(setTimeout(() => {
      var _a, _b, _c, _d;
      !((_a = inputRef.current) === null || _a === void 0) && _a.input && ((_b = inputRef.current) === null || _b === void 0 ? void 0 : _b.input.getAttribute("type")) === "password" && (!((_c = inputRef.current) === null || _c === void 0) && _c.input.hasAttribute("value")) && ((_d = inputRef.current) === null || _d === void 0 || _d.input.removeAttribute("value"));
    }));
  }, "removePasswordTimeout");
  return useEffect(() => (triggerOnMount && removePasswordTimeout(), () => removePasswordTimeoutRef.current.forEach((timer) => {
    timer && clearTimeout(timer);
  })), []), removePasswordTimeout;
}
__name(useRemovePasswordTimeout, "useRemovePasswordTimeout");
function hasPrefixSuffix(props) {
  return !!(props.prefix || props.suffix || props.allowClear || props.showCount);
}
__name(hasPrefixSuffix, "hasPrefixSuffix");
var __rest$s = function(s, e2) {
  var t2 = {};
  for (var p in s) Object.prototype.hasOwnProperty.call(s, p) && e2.indexOf(p) < 0 && (t2[p] = s[p]);
  if (s != null && typeof Object.getOwnPropertySymbols == "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++)
    e2.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]) && (t2[p[i]] = s[p[i]]);
  return t2;
};
const Input$2 = /* @__PURE__ */ forwardRef((props, ref) => {
  var _a;
  const {
    prefixCls: customizePrefixCls,
    bordered = !0,
    status: customStatus,
    size: customSize,
    disabled: customDisabled,
    onBlur,
    onFocus,
    suffix,
    allowClear,
    addonAfter,
    addonBefore,
    className,
    style: style2,
    styles: styles2,
    rootClassName,
    onChange,
    classNames: classes,
    variant: customVariant
  } = props, rest = __rest$s(props, ["prefixCls", "bordered", "status", "size", "disabled", "onBlur", "onFocus", "suffix", "allowClear", "addonAfter", "addonBefore", "className", "style", "styles", "rootClassName", "onChange", "classNames", "variant"]);
  if (process.env.NODE_ENV !== "production") {
    const {
      deprecated
    } = devUseWarning("Input");
    deprecated(!("bordered" in props), "bordered", "variant");
  }
  const {
    getPrefixCls,
    direction,
    input
  } = React__default.useContext(ConfigContext), prefixCls = getPrefixCls("input", customizePrefixCls), inputRef = useRef(null), rootCls = useCSSVarCls(prefixCls), [wrapCSSVar, hashId, cssVarCls] = useStyle$g(prefixCls, rootCls), {
    compactSize,
    compactItemClassnames
  } = useCompactItemContext(prefixCls, direction), mergedSize = useSize((ctx) => {
    var _a2;
    return (_a2 = customSize ?? compactSize) !== null && _a2 !== void 0 ? _a2 : ctx;
  }), disabled = React__default.useContext(DisabledContext), mergedDisabled = customDisabled ?? disabled, {
    status: contextStatus,
    hasFeedback,
    feedbackIcon
  } = useContext$1(FormItemInputContext), mergedStatus = getMergedStatus(contextStatus, customStatus), inputHasPrefixSuffix = hasPrefixSuffix(props) || !!hasFeedback, prevHasPrefixSuffix = useRef(inputHasPrefixSuffix);
  if (process.env.NODE_ENV !== "production") {
    const warning3 = devUseWarning("Input");
    useEffect(() => {
      var _a2;
      inputHasPrefixSuffix && !prevHasPrefixSuffix.current && process.env.NODE_ENV !== "production" && warning3(document.activeElement === ((_a2 = inputRef.current) === null || _a2 === void 0 ? void 0 : _a2.input), "usage", "When Input is focused, dynamic add or remove prefix / suffix will make it lose focus caused by dom structure change. Read more: https://ant.design/components/input/#FAQ"), prevHasPrefixSuffix.current = inputHasPrefixSuffix;
    }, [inputHasPrefixSuffix]);
  }
  const removePasswordTimeout = useRemovePasswordTimeout(inputRef, !0), handleBlur = /* @__PURE__ */ __name((e2) => {
    removePasswordTimeout(), onBlur == null || onBlur(e2);
  }, "handleBlur"), handleFocus = /* @__PURE__ */ __name((e2) => {
    removePasswordTimeout(), onFocus == null || onFocus(e2);
  }, "handleFocus"), handleChange = /* @__PURE__ */ __name((e2) => {
    removePasswordTimeout(), onChange == null || onChange(e2);
  }, "handleChange"), suffixNode = (hasFeedback || suffix) && /* @__PURE__ */ React__default.createElement(React__default.Fragment, null, suffix, hasFeedback && feedbackIcon), mergedAllowClear = getAllowClear(allowClear ?? (input == null ? void 0 : input.allowClear)), [variant, enableVariantCls] = useVariant("input", customVariant, bordered);
  return wrapCSSVar(/* @__PURE__ */ React__default.createElement(Input$3, Object.assign({
    ref: composeRef(ref, inputRef),
    prefixCls,
    autoComplete: input == null ? void 0 : input.autoComplete
  }, rest, {
    disabled: mergedDisabled,
    onBlur: handleBlur,
    onFocus: handleFocus,
    style: Object.assign(Object.assign({}, input == null ? void 0 : input.style), style2),
    styles: Object.assign(Object.assign({}, input == null ? void 0 : input.styles), styles2),
    suffix: suffixNode,
    allowClear: mergedAllowClear,
    className: cn(className, rootClassName, cssVarCls, rootCls, compactItemClassnames, input == null ? void 0 : input.className),
    onChange: handleChange,
    addonBefore: addonBefore && /* @__PURE__ */ React__default.createElement(ContextIsolator, {
      form: !0,
      space: !0
    }, addonBefore),
    addonAfter: addonAfter && /* @__PURE__ */ React__default.createElement(ContextIsolator, {
      form: !0,
      space: !0
    }, addonAfter),
    classNames: Object.assign(Object.assign(Object.assign({}, classes), input == null ? void 0 : input.classNames), {
      input: cn({
        [`${prefixCls}-sm`]: mergedSize === "small",
        [`${prefixCls}-lg`]: mergedSize === "large",
        [`${prefixCls}-rtl`]: direction === "rtl"
      }, classes == null ? void 0 : classes.input, (_a = input == null ? void 0 : input.classNames) === null || _a === void 0 ? void 0 : _a.input, hashId),
      variant: cn({
        [`${prefixCls}-${variant}`]: enableVariantCls
      }, getStatusClassNames(prefixCls, mergedStatus)),
      affixWrapper: cn({
        [`${prefixCls}-affix-wrapper-sm`]: mergedSize === "small",
        [`${prefixCls}-affix-wrapper-lg`]: mergedSize === "large",
        [`${prefixCls}-affix-wrapper-rtl`]: direction === "rtl"
      }, hashId),
      wrapper: cn({
        [`${prefixCls}-group-rtl`]: direction === "rtl"
      }, hashId),
      groupWrapper: cn({
        [`${prefixCls}-group-wrapper-sm`]: mergedSize === "small",
        [`${prefixCls}-group-wrapper-lg`]: mergedSize === "large",
        [`${prefixCls}-group-wrapper-rtl`]: direction === "rtl",
        [`${prefixCls}-group-wrapper-${variant}`]: enableVariantCls
      }, getStatusClassNames(`${prefixCls}-group-wrapper`, mergedStatus, hasFeedback), hashId)
    })
  })));
});
process.env.NODE_ENV !== "production" && (Input$2.displayName = "Input");
const genOTPStyle = /* @__PURE__ */ __name((token2) => {
  const {
    componentCls,
    paddingXS
  } = token2;
  return {
    [componentCls]: {
      display: "inline-flex",
      alignItems: "center",
      flexWrap: "nowrap",
      columnGap: paddingXS,
      "&-rtl": {
        direction: "rtl"
      },
      [`${componentCls}-input`]: {
        textAlign: "center",
        paddingInline: token2.paddingXXS
      },
      // ================= Size =================
      [`&${componentCls}-sm ${componentCls}-input`]: {
        paddingInline: token2.calc(token2.paddingXXS).div(2).equal()
      },
      [`&${componentCls}-lg ${componentCls}-input`]: {
        paddingInline: token2.paddingXS
      }
    }
  };
}, "genOTPStyle"), useStyle$9 = genStyleHooks(["Input", "OTP"], (token2) => {
  const inputToken = merge(token2, initInputToken(token2));
  return [genOTPStyle(inputToken)];
}, initComponentToken$1);
var __rest$r = function(s, e2) {
  var t2 = {};
  for (var p in s) Object.prototype.hasOwnProperty.call(s, p) && e2.indexOf(p) < 0 && (t2[p] = s[p]);
  if (s != null && typeof Object.getOwnPropertySymbols == "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++)
    e2.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]) && (t2[p[i]] = s[p[i]]);
  return t2;
};
const OTPInput = /* @__PURE__ */ React.forwardRef((props, ref) => {
  const {
    value,
    onChange,
    onActiveChange,
    index: index2,
    mask
  } = props, restProps = __rest$r(props, ["value", "onChange", "onActiveChange", "index", "mask"]), internalValue = value && typeof mask == "string" ? mask : value, onInternalChange = /* @__PURE__ */ __name((e2) => {
    onChange(index2, e2.target.value);
  }, "onInternalChange"), inputRef = React.useRef(null);
  React.useImperativeHandle(ref, () => inputRef.current);
  const syncSelection = /* @__PURE__ */ __name(() => {
    wrapperRaf(() => {
      var _a;
      const inputEle = (_a = inputRef.current) === null || _a === void 0 ? void 0 : _a.input;
      document.activeElement === inputEle && inputEle && inputEle.select();
    });
  }, "syncSelection"), onInternalKeyDown = /* @__PURE__ */ __name((event) => {
    const {
      key,
      ctrlKey,
      metaKey
    } = event;
    key === "ArrowLeft" ? onActiveChange(index2 - 1) : key === "ArrowRight" ? onActiveChange(index2 + 1) : key === "z" && (ctrlKey || metaKey) && event.preventDefault(), syncSelection();
  }, "onInternalKeyDown"), onInternalKeyUp = /* @__PURE__ */ __name((e2) => {
    e2.key === "Backspace" && !value && onActiveChange(index2 - 1), syncSelection();
  }, "onInternalKeyUp");
  return /* @__PURE__ */ React.createElement(Input$2, Object.assign({
    type: mask === !0 ? "password" : "text"
  }, restProps, {
    ref: inputRef,
    value: internalValue,
    onInput: onInternalChange,
    onFocus: syncSelection,
    onKeyDown: onInternalKeyDown,
    onKeyUp: onInternalKeyUp,
    onMouseDown: syncSelection,
    onMouseUp: syncSelection
  }));
});
var __rest$q = function(s, e2) {
  var t2 = {};
  for (var p in s) Object.prototype.hasOwnProperty.call(s, p) && e2.indexOf(p) < 0 && (t2[p] = s[p]);
  if (s != null && typeof Object.getOwnPropertySymbols == "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++)
    e2.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]) && (t2[p[i]] = s[p[i]]);
  return t2;
};
function strToArr(str) {
  return (str || "").split("");
}
__name(strToArr, "strToArr");
const OTP = /* @__PURE__ */ React.forwardRef((props, ref) => {
  const {
    prefixCls: customizePrefixCls,
    length: length2 = 6,
    size: customSize,
    defaultValue,
    value,
    onChange,
    formatter,
    variant,
    disabled,
    status: customStatus,
    autoFocus,
    mask,
    type: type4,
    onInput,
    inputMode
  } = props, restProps = __rest$q(props, ["prefixCls", "length", "size", "defaultValue", "value", "onChange", "formatter", "variant", "disabled", "status", "autoFocus", "mask", "type", "onInput", "inputMode"]);
  if (process.env.NODE_ENV !== "production") {
    const warning3 = devUseWarning("Input.OTP");
    process.env.NODE_ENV !== "production" && warning3(!(typeof mask == "string" && mask.length > 1), "usage", "`mask` prop should be a single character.");
  }
  const {
    getPrefixCls,
    direction
  } = React.useContext(ConfigContext), prefixCls = getPrefixCls("otp", customizePrefixCls), domAttrs = pickAttrs(restProps, {
    aria: !0,
    data: !0,
    attr: !0
  }), rootCls = useCSSVarCls(prefixCls), [wrapCSSVar, hashId, cssVarCls] = useStyle$9(prefixCls, rootCls), mergedSize = useSize((ctx) => customSize ?? ctx), formContext = React.useContext(FormItemInputContext), mergedStatus = getMergedStatus(formContext.status, customStatus), proxyFormContext = React.useMemo(() => Object.assign(Object.assign({}, formContext), {
    status: mergedStatus,
    hasFeedback: !1,
    feedbackIcon: null
  }), [formContext, mergedStatus]), containerRef = React.useRef(null), refs = React.useRef({});
  React.useImperativeHandle(ref, () => ({
    focus: /* @__PURE__ */ __name(() => {
      var _a;
      (_a = refs.current[0]) === null || _a === void 0 || _a.focus();
    }, "focus"),
    blur: /* @__PURE__ */ __name(() => {
      var _a;
      for (let i = 0; i < length2; i += 1)
        (_a = refs.current[i]) === null || _a === void 0 || _a.blur();
    }, "blur"),
    nativeElement: containerRef.current
  }));
  const internalFormatter = /* @__PURE__ */ __name((txt) => formatter ? formatter(txt) : txt, "internalFormatter"), [valueCells, setValueCells] = React.useState(strToArr(internalFormatter(defaultValue || "")));
  React.useEffect(() => {
    value !== void 0 && setValueCells(strToArr(value));
  }, [value]);
  const triggerValueCellsChange = useEvent((nextValueCells) => {
    setValueCells(nextValueCells), onInput && onInput(nextValueCells), onChange && nextValueCells.length === length2 && nextValueCells.every((c) => c) && nextValueCells.some((c, index2) => valueCells[index2] !== c) && onChange(nextValueCells.join(""));
  }), patchValue = useEvent((index2, txt) => {
    let nextCells = _toConsumableArray(valueCells);
    for (let i = 0; i < index2; i += 1)
      nextCells[i] || (nextCells[i] = "");
    txt.length <= 1 ? nextCells[index2] = txt : nextCells = nextCells.slice(0, index2).concat(strToArr(txt)), nextCells = nextCells.slice(0, length2);
    for (let i = nextCells.length - 1; i >= 0 && !nextCells[i]; i -= 1)
      nextCells.pop();
    const formattedValue = internalFormatter(nextCells.map((c) => c || " ").join(""));
    return nextCells = strToArr(formattedValue).map((c, i) => c === " " && !nextCells[i] ? nextCells[i] : c), nextCells;
  }), onInputChange = /* @__PURE__ */ __name((index2, txt) => {
    var _a;
    const nextCells = patchValue(index2, txt), nextIndex = Math.min(index2 + txt.length, length2 - 1);
    nextIndex !== index2 && nextCells[index2] !== void 0 && ((_a = refs.current[nextIndex]) === null || _a === void 0 || _a.focus()), triggerValueCellsChange(nextCells);
  }, "onInputChange"), onInputActiveChange = /* @__PURE__ */ __name((nextIndex) => {
    var _a;
    (_a = refs.current[nextIndex]) === null || _a === void 0 || _a.focus();
  }, "onInputActiveChange"), inputSharedProps = {
    variant,
    disabled,
    status: mergedStatus,
    mask,
    type: type4,
    inputMode
  };
  return wrapCSSVar(/* @__PURE__ */ React.createElement("div", Object.assign({}, domAttrs, {
    ref: containerRef,
    className: cn(prefixCls, {
      [`${prefixCls}-sm`]: mergedSize === "small",
      [`${prefixCls}-lg`]: mergedSize === "large",
      [`${prefixCls}-rtl`]: direction === "rtl"
    }, cssVarCls, hashId)
  }), /* @__PURE__ */ React.createElement(FormItemInputContext.Provider, {
    value: proxyFormContext
  }, Array.from({
    length: length2
  }).map((_2, index2) => {
    const key = `otp-${index2}`, singleValue = valueCells[index2] || "";
    return /* @__PURE__ */ React.createElement(OTPInput, Object.assign({
      ref: /* @__PURE__ */ __name((inputEle) => {
        refs.current[index2] = inputEle;
      }, "ref"),
      key,
      index: index2,
      size: mergedSize,
      htmlSize: 1,
      className: `${prefixCls}-input`,
      onChange: onInputChange,
      value: singleValue,
      onActiveChange: onInputActiveChange,
      autoFocus: index2 === 0 && autoFocus
    }, inputSharedProps));
  }))));
});
var EyeInvisibleOutlined$1 = { icon: { tag: "svg", attrs: { viewBox: "64 64 896 896", focusable: "false" }, children: [{ tag: "path", attrs: { d: "M942.2 486.2Q889.47 375.11 816.7 305l-50.88 50.88C807.31 395.53 843.45 447.4 874.7 512 791.5 684.2 673.4 766 512 766q-72.67 0-133.87-22.38L323 798.75Q408 838 512 838q288.3 0 430.2-300.3a60.29 60.29 0 000-51.5zm-63.57-320.64L836 122.88a8 8 0 00-11.32 0L715.31 232.2Q624.86 186 512 186q-288.3 0-430.2 300.3a60.3 60.3 0 000 51.5q56.69 119.4 136.5 191.41L112.48 835a8 8 0 000 11.31L155.17 889a8 8 0 0011.31 0l712.15-712.12a8 8 0 000-11.32zM149.3 512C232.6 339.8 350.7 258 512 258c54.54 0 104.13 9.36 149.12 28.39l-70.3 70.3a176 176 0 00-238.13 238.13l-83.42 83.42C223.1 637.49 183.3 582.28 149.3 512zm246.7 0a112.11 112.11 0 01146.2-106.69L401.31 546.2A112 112 0 01396 512z" } }, { tag: "path", attrs: { d: "M508 624c-3.46 0-6.87-.16-10.25-.47l-52.82 52.82a176.09 176.09 0 00227.42-227.42l-52.82 52.82c.31 3.38.47 6.79.47 10.25a111.94 111.94 0 01-112 112z" } }] }, name: "eye-invisible", theme: "outlined" }, EyeInvisibleOutlined = /* @__PURE__ */ __name(function(props, ref) {
  return /* @__PURE__ */ React.createElement(Icon$3, _extends({}, props, {
    ref,
    icon: EyeInvisibleOutlined$1
  }));
}, "EyeInvisibleOutlined"), RefIcon$p = /* @__PURE__ */ React.forwardRef(EyeInvisibleOutlined);
process.env.NODE_ENV !== "production" && (RefIcon$p.displayName = "EyeInvisibleOutlined");
var EyeOutlined$1 = { icon: { tag: "svg", attrs: { viewBox: "64 64 896 896", focusable: "false" }, children: [{ tag: "path", attrs: { d: "M942.2 486.2C847.4 286.5 704.1 186 512 186c-192.2 0-335.4 100.5-430.2 300.3a60.3 60.3 0 000 51.5C176.6 737.5 319.9 838 512 838c192.2 0 335.4-100.5 430.2-300.3 7.7-16.2 7.7-35 0-51.5zM512 766c-161.3 0-279.4-81.8-362.7-254C232.6 339.8 350.7 258 512 258c161.3 0 279.4 81.8 362.7 254C791.5 684.2 673.4 766 512 766zm-4-430c-97.2 0-176 78.8-176 176s78.8 176 176 176 176-78.8 176-176-78.8-176-176-176zm0 288c-61.9 0-112-50.1-112-112s50.1-112 112-112 112 50.1 112 112-50.1 112-112 112z" } }] }, name: "eye", theme: "outlined" }, EyeOutlined = /* @__PURE__ */ __name(function(props, ref) {
  return /* @__PURE__ */ React.createElement(Icon$3, _extends({}, props, {
    ref,
    icon: EyeOutlined$1
  }));
}, "EyeOutlined"), RefIcon$o = /* @__PURE__ */ React.forwardRef(EyeOutlined);
process.env.NODE_ENV !== "production" && (RefIcon$o.displayName = "EyeOutlined");
var __rest$p = function(s, e2) {
  var t2 = {};
  for (var p in s) Object.prototype.hasOwnProperty.call(s, p) && e2.indexOf(p) < 0 && (t2[p] = s[p]);
  if (s != null && typeof Object.getOwnPropertySymbols == "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++)
    e2.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]) && (t2[p[i]] = s[p[i]]);
  return t2;
};
const defaultIconRender = /* @__PURE__ */ __name((visible) => visible ? /* @__PURE__ */ React.createElement(RefIcon$o, null) : /* @__PURE__ */ React.createElement(RefIcon$p, null), "defaultIconRender"), actionMap = {
  click: "onClick",
  hover: "onMouseOver"
}, Password = /* @__PURE__ */ React.forwardRef((props, ref) => {
  const {
    disabled: customDisabled,
    action = "click",
    visibilityToggle = !0,
    iconRender = defaultIconRender
  } = props, disabled = React.useContext(DisabledContext), mergedDisabled = customDisabled ?? disabled, visibilityControlled = typeof visibilityToggle == "object" && visibilityToggle.visible !== void 0, [visible, setVisible] = useState(() => visibilityControlled ? visibilityToggle.visible : !1), inputRef = useRef(null);
  React.useEffect(() => {
    visibilityControlled && setVisible(visibilityToggle.visible);
  }, [visibilityControlled, visibilityToggle]);
  const removePasswordTimeout = useRemovePasswordTimeout(inputRef), onVisibleChange = /* @__PURE__ */ __name(() => {
    var _a;
    if (mergedDisabled)
      return;
    visible && removePasswordTimeout();
    const nextVisible = !visible;
    setVisible(nextVisible), typeof visibilityToggle == "object" && ((_a = visibilityToggle.onVisibleChange) === null || _a === void 0 || _a.call(visibilityToggle, nextVisible));
  }, "onVisibleChange"), getIcon2 = /* @__PURE__ */ __name((prefixCls2) => {
    const iconTrigger = actionMap[action] || "", icon = iconRender(visible), iconProps = {
      [iconTrigger]: onVisibleChange,
      className: `${prefixCls2}-icon`,
      key: "passwordIcon",
      onMouseDown: /* @__PURE__ */ __name((e2) => {
        e2.preventDefault();
      }, "onMouseDown"),
      onMouseUp: /* @__PURE__ */ __name((e2) => {
        e2.preventDefault();
      }, "onMouseUp")
    };
    return /* @__PURE__ */ React.cloneElement(/* @__PURE__ */ React.isValidElement(icon) ? icon : /* @__PURE__ */ React.createElement("span", null, icon), iconProps);
  }, "getIcon"), {
    className,
    prefixCls: customizePrefixCls,
    inputPrefixCls: customizeInputPrefixCls,
    size
  } = props, restProps = __rest$p(props, ["className", "prefixCls", "inputPrefixCls", "size"]), {
    getPrefixCls
  } = React.useContext(ConfigContext), inputPrefixCls = getPrefixCls("input", customizeInputPrefixCls), prefixCls = getPrefixCls("input-password", customizePrefixCls), suffixIcon = visibilityToggle && getIcon2(prefixCls), inputClassName = cn(prefixCls, className, {
    [`${prefixCls}-${size}`]: !!size
  }), omittedProps = Object.assign(Object.assign({}, omit(restProps, ["suffix", "iconRender", "visibilityToggle"])), {
    type: visible ? "text" : "password",
    className: inputClassName,
    prefixCls: inputPrefixCls,
    suffix: suffixIcon
  });
  return size && (omittedProps.size = size), /* @__PURE__ */ React.createElement(Input$2, Object.assign({
    ref: composeRef(ref, inputRef)
  }, omittedProps));
});
process.env.NODE_ENV !== "production" && (Password.displayName = "Input.Password");
var __rest$o = function(s, e2) {
  var t2 = {};
  for (var p in s) Object.prototype.hasOwnProperty.call(s, p) && e2.indexOf(p) < 0 && (t2[p] = s[p]);
  if (s != null && typeof Object.getOwnPropertySymbols == "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++)
    e2.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]) && (t2[p[i]] = s[p[i]]);
  return t2;
};
const Search$1 = /* @__PURE__ */ React.forwardRef((props, ref) => {
  const {
    prefixCls: customizePrefixCls,
    inputPrefixCls: customizeInputPrefixCls,
    className,
    size: customizeSize,
    suffix,
    enterButton = !1,
    addonAfter,
    loading,
    disabled,
    onSearch: customOnSearch,
    onChange: customOnChange,
    onCompositionStart,
    onCompositionEnd
  } = props, restProps = __rest$o(props, ["prefixCls", "inputPrefixCls", "className", "size", "suffix", "enterButton", "addonAfter", "loading", "disabled", "onSearch", "onChange", "onCompositionStart", "onCompositionEnd"]), {
    getPrefixCls,
    direction
  } = React.useContext(ConfigContext), composedRef = React.useRef(!1), prefixCls = getPrefixCls("input-search", customizePrefixCls), inputPrefixCls = getPrefixCls("input", customizeInputPrefixCls), {
    compactSize
  } = useCompactItemContext(prefixCls, direction), size = useSize((ctx) => {
    var _a;
    return (_a = customizeSize ?? compactSize) !== null && _a !== void 0 ? _a : ctx;
  }), inputRef = React.useRef(null), onChange = /* @__PURE__ */ __name((e2) => {
    e2 != null && e2.target && e2.type === "click" && customOnSearch && customOnSearch(e2.target.value, e2, {
      source: "clear"
    }), customOnChange == null || customOnChange(e2);
  }, "onChange"), onMouseDown = /* @__PURE__ */ __name((e2) => {
    var _a;
    document.activeElement === ((_a = inputRef.current) === null || _a === void 0 ? void 0 : _a.input) && e2.preventDefault();
  }, "onMouseDown"), onSearch = /* @__PURE__ */ __name((e2) => {
    var _a, _b;
    customOnSearch && customOnSearch((_b = (_a = inputRef.current) === null || _a === void 0 ? void 0 : _a.input) === null || _b === void 0 ? void 0 : _b.value, e2, {
      source: "input"
    });
  }, "onSearch"), onPressEnter = /* @__PURE__ */ __name((e2) => {
    composedRef.current || loading || onSearch(e2);
  }, "onPressEnter"), searchIcon = typeof enterButton == "boolean" ? /* @__PURE__ */ React.createElement(RefIcon$v, null) : null, btnClassName = `${prefixCls}-button`;
  let button2;
  const enterButtonAsElement = enterButton || {}, isAntdButton = enterButtonAsElement.type && enterButtonAsElement.type.__ANT_BUTTON === !0;
  isAntdButton || enterButtonAsElement.type === "button" ? button2 = cloneElement(enterButtonAsElement, Object.assign({
    onMouseDown,
    onClick: /* @__PURE__ */ __name((e2) => {
      var _a, _b;
      (_b = (_a = enterButtonAsElement == null ? void 0 : enterButtonAsElement.props) === null || _a === void 0 ? void 0 : _a.onClick) === null || _b === void 0 || _b.call(_a, e2), onSearch(e2);
    }, "onClick"),
    key: "enterButton"
  }, isAntdButton ? {
    className: btnClassName,
    size
  } : {})) : button2 = /* @__PURE__ */ React.createElement(Button$2, {
    className: btnClassName,
    type: enterButton ? "primary" : void 0,
    size,
    disabled,
    key: "enterButton",
    onMouseDown,
    onClick: onSearch,
    loading,
    icon: searchIcon
  }, enterButton), addonAfter && (button2 = [button2, cloneElement(addonAfter, {
    key: "addonAfter"
  })]);
  const cls = cn(prefixCls, {
    [`${prefixCls}-rtl`]: direction === "rtl",
    [`${prefixCls}-${size}`]: !!size,
    [`${prefixCls}-with-button`]: !!enterButton
  }, className), handleOnCompositionStart = /* @__PURE__ */ __name((e2) => {
    composedRef.current = !0, onCompositionStart == null || onCompositionStart(e2);
  }, "handleOnCompositionStart"), handleOnCompositionEnd = /* @__PURE__ */ __name((e2) => {
    composedRef.current = !1, onCompositionEnd == null || onCompositionEnd(e2);
  }, "handleOnCompositionEnd");
  return /* @__PURE__ */ React.createElement(Input$2, Object.assign({
    ref: composeRef(inputRef, ref),
    onPressEnter
  }, restProps, {
    size,
    onCompositionStart: handleOnCompositionStart,
    onCompositionEnd: handleOnCompositionEnd,
    prefixCls: inputPrefixCls,
    addonAfter: button2,
    suffix,
    onChange,
    className: cls,
    disabled
  }));
});
process.env.NODE_ENV !== "production" && (Search$1.displayName = "Search");
var HIDDEN_TEXTAREA_STYLE = `
  min-height:0 !important;
  max-height:none !important;
  height:0 !important;
  visibility:hidden !important;
  overflow:hidden !important;
  position:absolute !important;
  z-index:-1000 !important;
  top:0 !important;
  right:0 !important;
  pointer-events: none !important;
`, SIZING_STYLE = ["letter-spacing", "line-height", "padding-top", "padding-bottom", "font-family", "font-weight", "font-size", "font-variant", "text-rendering", "text-transform", "width", "text-indent", "padding-left", "padding-right", "border-width", "box-sizing", "word-break", "white-space"], computedStyleCache = {}, hiddenTextarea;
function calculateNodeStyling(node2) {
  var useCache2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1, nodeRef = node2.getAttribute("id") || node2.getAttribute("data-reactid") || node2.getAttribute("name");
  if (useCache2 && computedStyleCache[nodeRef])
    return computedStyleCache[nodeRef];
  var style2 = window.getComputedStyle(node2), boxSizing = style2.getPropertyValue("box-sizing") || style2.getPropertyValue("-moz-box-sizing") || style2.getPropertyValue("-webkit-box-sizing"), paddingSize = parseFloat(style2.getPropertyValue("padding-bottom")) + parseFloat(style2.getPropertyValue("padding-top")), borderSize = parseFloat(style2.getPropertyValue("border-bottom-width")) + parseFloat(style2.getPropertyValue("border-top-width")), sizingStyle = SIZING_STYLE.map(function(name) {
    return "".concat(name, ":").concat(style2.getPropertyValue(name));
  }).join(";"), nodeInfo = {
    sizingStyle,
    paddingSize,
    borderSize,
    boxSizing
  };
  return useCache2 && nodeRef && (computedStyleCache[nodeRef] = nodeInfo), nodeInfo;
}
__name(calculateNodeStyling, "calculateNodeStyling");
function calculateAutoSizeStyle(uiTextNode) {
  var useCache2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1, minRows = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null, maxRows = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : null;
  hiddenTextarea || (hiddenTextarea = document.createElement("textarea"), hiddenTextarea.setAttribute("tab-index", "-1"), hiddenTextarea.setAttribute("aria-hidden", "true"), hiddenTextarea.setAttribute("name", "hiddenTextarea"), document.body.appendChild(hiddenTextarea)), uiTextNode.getAttribute("wrap") ? hiddenTextarea.setAttribute("wrap", uiTextNode.getAttribute("wrap")) : hiddenTextarea.removeAttribute("wrap");
  var _calculateNodeStyling = calculateNodeStyling(uiTextNode, useCache2), paddingSize = _calculateNodeStyling.paddingSize, borderSize = _calculateNodeStyling.borderSize, boxSizing = _calculateNodeStyling.boxSizing, sizingStyle = _calculateNodeStyling.sizingStyle;
  hiddenTextarea.setAttribute("style", "".concat(sizingStyle, ";").concat(HIDDEN_TEXTAREA_STYLE)), hiddenTextarea.value = uiTextNode.value || uiTextNode.placeholder || "";
  var minHeight = void 0, maxHeight = void 0, overflowY, height = hiddenTextarea.scrollHeight;
  if (boxSizing === "border-box" ? height += borderSize : boxSizing === "content-box" && (height -= paddingSize), minRows !== null || maxRows !== null) {
    hiddenTextarea.value = " ";
    var singleRowHeight = hiddenTextarea.scrollHeight - paddingSize;
    minRows !== null && (minHeight = singleRowHeight * minRows, boxSizing === "border-box" && (minHeight = minHeight + paddingSize + borderSize), height = Math.max(minHeight, height)), maxRows !== null && (maxHeight = singleRowHeight * maxRows, boxSizing === "border-box" && (maxHeight = maxHeight + paddingSize + borderSize), overflowY = height > maxHeight ? "" : "hidden", height = Math.min(maxHeight, height));
  }
  var style2 = {
    height,
    overflowY,
    resize: "none"
  };
  return minHeight && (style2.minHeight = minHeight), maxHeight && (style2.maxHeight = maxHeight), style2;
}
__name(calculateAutoSizeStyle, "calculateAutoSizeStyle");
var _excluded$c = ["prefixCls", "defaultValue", "value", "autoSize", "onResize", "className", "style", "disabled", "onChange", "onInternalAutoSize"], RESIZE_START = 0, RESIZE_MEASURING = 1, RESIZE_STABLE = 2, ResizableTextArea = /* @__PURE__ */ React.forwardRef(function(props, ref) {
  var _ref = props, prefixCls = _ref.prefixCls, defaultValue = _ref.defaultValue, value = _ref.value, autoSize = _ref.autoSize, onResize2 = _ref.onResize, className = _ref.className, style2 = _ref.style, disabled = _ref.disabled, onChange = _ref.onChange, onInternalAutoSize = _ref.onInternalAutoSize, restProps = _objectWithoutProperties(_ref, _excluded$c), _useMergedState = useMergedState(defaultValue, {
    value,
    postState: /* @__PURE__ */ __name(function(val) {
      return val ?? "";
    }, "postState")
  }), _useMergedState2 = _slicedToArray(_useMergedState, 2), mergedValue = _useMergedState2[0], setMergedValue = _useMergedState2[1], onInternalChange = /* @__PURE__ */ __name(function(event) {
    setMergedValue(event.target.value), onChange == null || onChange(event);
  }, "onInternalChange"), textareaRef = React.useRef();
  React.useImperativeHandle(ref, function() {
    return {
      textArea: textareaRef.current
    };
  });
  var _React$useMemo = React.useMemo(function() {
    return autoSize && _typeof$4(autoSize) === "object" ? [autoSize.minRows, autoSize.maxRows] : [];
  }, [autoSize]), _React$useMemo2 = _slicedToArray(_React$useMemo, 2), minRows = _React$useMemo2[0], maxRows = _React$useMemo2[1], needAutoSize = !!autoSize, fixFirefoxAutoScroll = /* @__PURE__ */ __name(function() {
    try {
      if (document.activeElement === textareaRef.current) {
        var _textareaRef$current = textareaRef.current, selectionStart = _textareaRef$current.selectionStart, selectionEnd = _textareaRef$current.selectionEnd, scrollTop = _textareaRef$current.scrollTop;
        textareaRef.current.setSelectionRange(selectionStart, selectionEnd), textareaRef.current.scrollTop = scrollTop;
      }
    } catch {
    }
  }, "fixFirefoxAutoScroll"), _React$useState = React.useState(RESIZE_STABLE), _React$useState2 = _slicedToArray(_React$useState, 2), resizeState = _React$useState2[0], setResizeState = _React$useState2[1], _React$useState3 = React.useState(), _React$useState4 = _slicedToArray(_React$useState3, 2), autoSizeStyle = _React$useState4[0], setAutoSizeStyle = _React$useState4[1], startResize = /* @__PURE__ */ __name(function() {
    setResizeState(RESIZE_START), process.env.NODE_ENV === "test" && (onInternalAutoSize == null || onInternalAutoSize());
  }, "startResize");
  useLayoutEffect$1(function() {
    needAutoSize && startResize();
  }, [value, minRows, maxRows, needAutoSize]), useLayoutEffect$1(function() {
    if (resizeState === RESIZE_START)
      setResizeState(RESIZE_MEASURING);
    else if (resizeState === RESIZE_MEASURING) {
      var textareaStyles = calculateAutoSizeStyle(textareaRef.current, !1, minRows, maxRows);
      setResizeState(RESIZE_STABLE), setAutoSizeStyle(textareaStyles);
    } else
      fixFirefoxAutoScroll();
  }, [resizeState]);
  var resizeRafRef = React.useRef(), cleanRaf = /* @__PURE__ */ __name(function() {
    wrapperRaf.cancel(resizeRafRef.current);
  }, "cleanRaf"), onInternalResize = /* @__PURE__ */ __name(function(size) {
    resizeState === RESIZE_STABLE && (onResize2 == null || onResize2(size), autoSize && (cleanRaf(), resizeRafRef.current = wrapperRaf(function() {
      startResize();
    })));
  }, "onInternalResize");
  React.useEffect(function() {
    return cleanRaf;
  }, []);
  var mergedAutoSizeStyle = needAutoSize ? autoSizeStyle : null, mergedStyle = _objectSpread2$1(_objectSpread2$1({}, style2), mergedAutoSizeStyle);
  return (resizeState === RESIZE_START || resizeState === RESIZE_MEASURING) && (mergedStyle.overflowY = "hidden", mergedStyle.overflowX = "hidden"), /* @__PURE__ */ React.createElement(RefResizeObserver, {
    onResize: onInternalResize,
    disabled: !(autoSize || onResize2)
  }, /* @__PURE__ */ React.createElement("textarea", _extends({}, restProps, {
    ref: textareaRef,
    style: mergedStyle,
    className: cn(prefixCls, className, _defineProperty$2({}, "".concat(prefixCls, "-disabled"), disabled)),
    disabled,
    value: mergedValue,
    onChange: onInternalChange
  })));
}), _excluded$b = ["defaultValue", "value", "onFocus", "onBlur", "onChange", "allowClear", "maxLength", "onCompositionStart", "onCompositionEnd", "suffix", "prefixCls", "showCount", "count", "className", "style", "disabled", "hidden", "classNames", "styles", "onResize", "onClear", "onPressEnter", "readOnly", "autoSize", "onKeyDown"], TextArea$2 = /* @__PURE__ */ React__default.forwardRef(function(_ref, ref) {
  var _countConfig$max, defaultValue = _ref.defaultValue, customValue = _ref.value, onFocus = _ref.onFocus, onBlur = _ref.onBlur, onChange = _ref.onChange, allowClear = _ref.allowClear, maxLength = _ref.maxLength, onCompositionStart = _ref.onCompositionStart, onCompositionEnd = _ref.onCompositionEnd, suffix = _ref.suffix, _ref$prefixCls = _ref.prefixCls, prefixCls = _ref$prefixCls === void 0 ? "rc-textarea" : _ref$prefixCls, showCount = _ref.showCount, count = _ref.count, className = _ref.className, style2 = _ref.style, disabled = _ref.disabled, hidden2 = _ref.hidden, classNames = _ref.classNames, styles2 = _ref.styles, onResize2 = _ref.onResize, onClear = _ref.onClear, onPressEnter = _ref.onPressEnter, readOnly = _ref.readOnly, autoSize = _ref.autoSize, onKeyDown2 = _ref.onKeyDown, rest = _objectWithoutProperties(_ref, _excluded$b), _useMergedState = useMergedState(defaultValue, {
    value: customValue,
    defaultValue
  }), _useMergedState2 = _slicedToArray(_useMergedState, 2), value = _useMergedState2[0], setValue = _useMergedState2[1], formatValue2 = value == null ? "" : String(value), _React$useState = React__default.useState(!1), _React$useState2 = _slicedToArray(_React$useState, 2), focused = _React$useState2[0], setFocused = _React$useState2[1], compositionRef = React__default.useRef(!1), _React$useState3 = React__default.useState(null), _React$useState4 = _slicedToArray(_React$useState3, 2), textareaResized = _React$useState4[0], setTextareaResized = _React$useState4[1], holderRef = useRef(null), resizableTextAreaRef = useRef(null), getTextArea = /* @__PURE__ */ __name(function() {
    var _resizableTextAreaRef;
    return (_resizableTextAreaRef = resizableTextAreaRef.current) === null || _resizableTextAreaRef === void 0 ? void 0 : _resizableTextAreaRef.textArea;
  }, "getTextArea"), focus = /* @__PURE__ */ __name(function() {
    getTextArea().focus();
  }, "focus");
  useImperativeHandle(ref, function() {
    var _holderRef$current;
    return {
      resizableTextArea: resizableTextAreaRef.current,
      focus,
      blur: /* @__PURE__ */ __name(function() {
        getTextArea().blur();
      }, "blur"),
      nativeElement: ((_holderRef$current = holderRef.current) === null || _holderRef$current === void 0 ? void 0 : _holderRef$current.nativeElement) || getTextArea()
    };
  }), useEffect(function() {
    setFocused(function(prev2) {
      return !disabled && prev2;
    });
  }, [disabled]);
  var _React$useState5 = React__default.useState(null), _React$useState6 = _slicedToArray(_React$useState5, 2), selection = _React$useState6[0], setSelection = _React$useState6[1];
  React__default.useEffect(function() {
    if (selection) {
      var _getTextArea;
      (_getTextArea = getTextArea()).setSelectionRange.apply(_getTextArea, _toConsumableArray(selection));
    }
  }, [selection]);
  var countConfig = useCount(count, showCount), mergedMax = (_countConfig$max = countConfig.max) !== null && _countConfig$max !== void 0 ? _countConfig$max : maxLength, hasMaxLength = Number(mergedMax) > 0, valueLength = countConfig.strategy(formatValue2), isOutOfRange = !!mergedMax && valueLength > mergedMax, triggerChange = /* @__PURE__ */ __name(function(e2, currentValue) {
    var cutValue = currentValue;
    !compositionRef.current && countConfig.exceedFormatter && countConfig.max && countConfig.strategy(currentValue) > countConfig.max && (cutValue = countConfig.exceedFormatter(currentValue, {
      max: countConfig.max
    }), currentValue !== cutValue && setSelection([getTextArea().selectionStart || 0, getTextArea().selectionEnd || 0])), setValue(cutValue), resolveOnChange(e2.currentTarget, e2, onChange, cutValue);
  }, "triggerChange"), onInternalCompositionStart = /* @__PURE__ */ __name(function(e2) {
    compositionRef.current = !0, onCompositionStart == null || onCompositionStart(e2);
  }, "onInternalCompositionStart"), onInternalCompositionEnd = /* @__PURE__ */ __name(function(e2) {
    compositionRef.current = !1, triggerChange(e2, e2.currentTarget.value), onCompositionEnd == null || onCompositionEnd(e2);
  }, "onInternalCompositionEnd"), onInternalChange = /* @__PURE__ */ __name(function(e2) {
    triggerChange(e2, e2.target.value);
  }, "onInternalChange"), handleKeyDown = /* @__PURE__ */ __name(function(e2) {
    e2.key === "Enter" && onPressEnter && onPressEnter(e2), onKeyDown2 == null || onKeyDown2(e2);
  }, "handleKeyDown"), handleFocus = /* @__PURE__ */ __name(function(e2) {
    setFocused(!0), onFocus == null || onFocus(e2);
  }, "handleFocus"), handleBlur = /* @__PURE__ */ __name(function(e2) {
    setFocused(!1), onBlur == null || onBlur(e2);
  }, "handleBlur"), handleReset = /* @__PURE__ */ __name(function(e2) {
    setValue(""), focus(), resolveOnChange(getTextArea(), e2, onChange);
  }, "handleReset"), suffixNode = suffix, dataCount;
  countConfig.show && (countConfig.showFormatter ? dataCount = countConfig.showFormatter({
    value: formatValue2,
    count: valueLength,
    maxLength: mergedMax
  }) : dataCount = "".concat(valueLength).concat(hasMaxLength ? " / ".concat(mergedMax) : ""), suffixNode = /* @__PURE__ */ React__default.createElement(React__default.Fragment, null, suffixNode, /* @__PURE__ */ React__default.createElement("span", {
    className: cn("".concat(prefixCls, "-data-count"), classNames == null ? void 0 : classNames.count),
    style: styles2 == null ? void 0 : styles2.count
  }, dataCount)));
  var handleResize = /* @__PURE__ */ __name(function(size) {
    var _getTextArea2;
    onResize2 == null || onResize2(size), (_getTextArea2 = getTextArea()) !== null && _getTextArea2 !== void 0 && _getTextArea2.style.height && setTextareaResized(!0);
  }, "handleResize"), isPureTextArea = !autoSize && !showCount && !allowClear;
  return /* @__PURE__ */ React__default.createElement(BaseInput, {
    ref: holderRef,
    value: formatValue2,
    allowClear,
    handleReset,
    suffix: suffixNode,
    prefixCls,
    classNames: _objectSpread2$1(_objectSpread2$1({}, classNames), {}, {
      affixWrapper: cn(classNames == null ? void 0 : classNames.affixWrapper, _defineProperty$2(_defineProperty$2({}, "".concat(prefixCls, "-show-count"), showCount), "".concat(prefixCls, "-textarea-allow-clear"), allowClear))
    }),
    disabled,
    focused,
    className: cn(className, isOutOfRange && "".concat(prefixCls, "-out-of-range")),
    style: _objectSpread2$1(_objectSpread2$1({}, style2), textareaResized && !isPureTextArea ? {
      height: "auto"
    } : {}),
    dataAttrs: {
      affixWrapper: {
        "data-count": typeof dataCount == "string" ? dataCount : void 0
      }
    },
    hidden: hidden2,
    readOnly,
    onClear
  }, /* @__PURE__ */ React__default.createElement(ResizableTextArea, _extends({}, rest, {
    autoSize,
    maxLength,
    onKeyDown: handleKeyDown,
    onChange: onInternalChange,
    onFocus: handleFocus,
    onBlur: handleBlur,
    onCompositionStart: onInternalCompositionStart,
    onCompositionEnd: onInternalCompositionEnd,
    className: cn(classNames == null ? void 0 : classNames.textarea),
    style: _objectSpread2$1(_objectSpread2$1({}, styles2 == null ? void 0 : styles2.textarea), {}, {
      resize: style2 == null ? void 0 : style2.resize
    }),
    disabled,
    prefixCls,
    onResize: handleResize,
    ref: resizableTextAreaRef,
    readOnly
  })));
}), __rest$n = function(s, e2) {
  var t2 = {};
  for (var p in s) Object.prototype.hasOwnProperty.call(s, p) && e2.indexOf(p) < 0 && (t2[p] = s[p]);
  if (s != null && typeof Object.getOwnPropertySymbols == "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++)
    e2.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]) && (t2[p[i]] = s[p[i]]);
  return t2;
};
const TextArea$1 = /* @__PURE__ */ forwardRef((props, ref) => {
  var _a, _b;
  const {
    prefixCls: customizePrefixCls,
    bordered = !0,
    size: customizeSize,
    disabled: customDisabled,
    status: customStatus,
    allowClear,
    classNames: classes,
    rootClassName,
    className,
    style: style2,
    styles: styles2,
    variant: customVariant
  } = props, rest = __rest$n(props, ["prefixCls", "bordered", "size", "disabled", "status", "allowClear", "classNames", "rootClassName", "className", "style", "styles", "variant"]);
  if (process.env.NODE_ENV !== "production") {
    const {
      deprecated
    } = devUseWarning("TextArea");
    deprecated(!("bordered" in props), "bordered", "variant");
  }
  const {
    getPrefixCls,
    direction,
    textArea
  } = React.useContext(ConfigContext), mergedSize = useSize(customizeSize), disabled = React.useContext(DisabledContext), mergedDisabled = customDisabled ?? disabled, {
    status: contextStatus,
    hasFeedback,
    feedbackIcon
  } = React.useContext(FormItemInputContext), mergedStatus = getMergedStatus(contextStatus, customStatus), innerRef = React.useRef(null);
  React.useImperativeHandle(ref, () => {
    var _a2;
    return {
      resizableTextArea: (_a2 = innerRef.current) === null || _a2 === void 0 ? void 0 : _a2.resizableTextArea,
      focus: /* @__PURE__ */ __name((option) => {
        var _a3, _b2;
        triggerFocus((_b2 = (_a3 = innerRef.current) === null || _a3 === void 0 ? void 0 : _a3.resizableTextArea) === null || _b2 === void 0 ? void 0 : _b2.textArea, option);
      }, "focus"),
      blur: /* @__PURE__ */ __name(() => {
        var _a3;
        return (_a3 = innerRef.current) === null || _a3 === void 0 ? void 0 : _a3.blur();
      }, "blur")
    };
  });
  const prefixCls = getPrefixCls("input", customizePrefixCls), rootCls = useCSSVarCls(prefixCls), [wrapCSSVar, hashId, cssVarCls] = useStyle$g(prefixCls, rootCls), [variant, enableVariantCls] = useVariant("textArea", customVariant, bordered), mergedAllowClear = getAllowClear(allowClear ?? (textArea == null ? void 0 : textArea.allowClear));
  return wrapCSSVar(/* @__PURE__ */ React.createElement(TextArea$2, Object.assign({
    autoComplete: textArea == null ? void 0 : textArea.autoComplete
  }, rest, {
    style: Object.assign(Object.assign({}, textArea == null ? void 0 : textArea.style), style2),
    styles: Object.assign(Object.assign({}, textArea == null ? void 0 : textArea.styles), styles2),
    disabled: mergedDisabled,
    allowClear: mergedAllowClear,
    className: cn(cssVarCls, rootCls, className, rootClassName, textArea == null ? void 0 : textArea.className),
    classNames: Object.assign(Object.assign(Object.assign({}, classes), textArea == null ? void 0 : textArea.classNames), {
      textarea: cn({
        [`${prefixCls}-sm`]: mergedSize === "small",
        [`${prefixCls}-lg`]: mergedSize === "large"
      }, hashId, classes == null ? void 0 : classes.textarea, (_a = textArea == null ? void 0 : textArea.classNames) === null || _a === void 0 ? void 0 : _a.textarea),
      variant: cn({
        [`${prefixCls}-${variant}`]: enableVariantCls
      }, getStatusClassNames(prefixCls, mergedStatus)),
      affixWrapper: cn(`${prefixCls}-textarea-affix-wrapper`, {
        [`${prefixCls}-affix-wrapper-rtl`]: direction === "rtl",
        [`${prefixCls}-affix-wrapper-sm`]: mergedSize === "small",
        [`${prefixCls}-affix-wrapper-lg`]: mergedSize === "large",
        [`${prefixCls}-textarea-show-count`]: props.showCount || ((_b = props.count) === null || _b === void 0 ? void 0 : _b.show)
      }, hashId)
    }),
    prefixCls,
    suffix: hasFeedback && /* @__PURE__ */ React.createElement("span", {
      className: `${prefixCls}-textarea-suffix`
    }, feedbackIcon),
    ref: innerRef
  })));
}), Input$1 = Input$2;
Input$1.Group = Group;
Input$1.Search = Search$1;
Input$1.TextArea = TextArea$1;
Input$1.Password = Password;
Input$1.OTP = OTP;
var CalendarOutlined$1 = { icon: { tag: "svg", attrs: { viewBox: "64 64 896 896", focusable: "false" }, children: [{ tag: "path", attrs: { d: "M880 184H712v-64c0-4.4-3.6-8-8-8h-56c-4.4 0-8 3.6-8 8v64H384v-64c0-4.4-3.6-8-8-8h-56c-4.4 0-8 3.6-8 8v64H144c-17.7 0-32 14.3-32 32v664c0 17.7 14.3 32 32 32h736c17.7 0 32-14.3 32-32V216c0-17.7-14.3-32-32-32zm-40 656H184V460h656v380zM184 392V256h128v48c0 4.4 3.6 8 8 8h56c4.4 0 8-3.6 8-8v-48h256v48c0 4.4 3.6 8 8 8h56c4.4 0 8-3.6 8-8v-48h128v136H184z" } }] }, name: "calendar", theme: "outlined" }, CalendarOutlined = /* @__PURE__ */ __name(function(props, ref) {
  return /* @__PURE__ */ React.createElement(Icon$3, _extends({}, props, {
    ref,
    icon: CalendarOutlined$1
  }));
}, "CalendarOutlined"), RefIcon$n = /* @__PURE__ */ React.forwardRef(CalendarOutlined);
process.env.NODE_ENV !== "production" && (RefIcon$n.displayName = "CalendarOutlined");
var ClockCircleOutlined$1 = { icon: { tag: "svg", attrs: { viewBox: "64 64 896 896", focusable: "false" }, children: [{ tag: "path", attrs: { d: "M512 64C264.6 64 64 264.6 64 512s200.6 448 448 448 448-200.6 448-448S759.4 64 512 64zm0 820c-205.4 0-372-166.6-372-372s166.6-372 372-372 372 166.6 372 372-166.6 372-372 372z" } }, { tag: "path", attrs: { d: "M686.7 638.6L544.1 535.5V288c0-4.4-3.6-8-8-8H488c-4.4 0-8 3.6-8 8v275.4c0 2.6 1.2 5 3.3 6.5l165.4 120.6c3.6 2.6 8.6 1.8 11.2-1.7l28.6-39c2.6-3.7 1.8-8.7-1.8-11.2z" } }] }, name: "clock-circle", theme: "outlined" }, ClockCircleOutlined = /* @__PURE__ */ __name(function(props, ref) {
  return /* @__PURE__ */ React.createElement(Icon$3, _extends({}, props, {
    ref,
    icon: ClockCircleOutlined$1
  }));
}, "ClockCircleOutlined"), RefIcon$m = /* @__PURE__ */ React.forwardRef(ClockCircleOutlined);
process.env.NODE_ENV !== "production" && (RefIcon$m.displayName = "ClockCircleOutlined");
var SwapRightOutlined$1 = { icon: { tag: "svg", attrs: { viewBox: "0 0 1024 1024", focusable: "false" }, children: [{ tag: "path", attrs: { d: "M873.1 596.2l-164-208A32 32 0 00684 376h-64.8c-6.7 0-10.4 7.7-6.3 13l144.3 183H152c-4.4 0-8 3.6-8 8v60c0 4.4 3.6 8 8 8h695.9c26.8 0 41.7-30.8 25.2-51.8z" } }] }, name: "swap-right", theme: "outlined" }, SwapRightOutlined = /* @__PURE__ */ __name(function(props, ref) {
  return /* @__PURE__ */ React.createElement(Icon$3, _extends({}, props, {
    ref,
    icon: SwapRightOutlined$1
  }));
}, "SwapRightOutlined"), RefIcon$l = /* @__PURE__ */ React.forwardRef(SwapRightOutlined);
process.env.NODE_ENV !== "production" && (RefIcon$l.displayName = "SwapRightOutlined");
function getPlaceholder(locale2, picker, customizePlaceholder) {
  return customizePlaceholder !== void 0 ? customizePlaceholder : picker === "year" && locale2.lang.yearPlaceholder ? locale2.lang.yearPlaceholder : picker === "quarter" && locale2.lang.quarterPlaceholder ? locale2.lang.quarterPlaceholder : picker === "month" && locale2.lang.monthPlaceholder ? locale2.lang.monthPlaceholder : picker === "week" && locale2.lang.weekPlaceholder ? locale2.lang.weekPlaceholder : picker === "time" && locale2.timePickerLocale.placeholder ? locale2.timePickerLocale.placeholder : locale2.lang.placeholder;
}
__name(getPlaceholder, "getPlaceholder");
function getRangePlaceholder(locale2, picker, customizePlaceholder) {
  return customizePlaceholder !== void 0 ? customizePlaceholder : picker === "year" && locale2.lang.yearPlaceholder ? locale2.lang.rangeYearPlaceholder : picker === "quarter" && locale2.lang.quarterPlaceholder ? locale2.lang.rangeQuarterPlaceholder : picker === "month" && locale2.lang.monthPlaceholder ? locale2.lang.rangeMonthPlaceholder : picker === "week" && locale2.lang.weekPlaceholder ? locale2.lang.rangeWeekPlaceholder : picker === "time" && locale2.timePickerLocale.placeholder ? locale2.timePickerLocale.rangePlaceholder : locale2.lang.rangePlaceholder;
}
__name(getRangePlaceholder, "getRangePlaceholder");
function useIcons(props, prefixCls) {
  const {
    allowClear = !0
  } = props, {
    clearIcon,
    removeIcon
  } = useIcons$1(Object.assign(Object.assign({}, props), {
    prefixCls,
    componentName: "DatePicker"
  }));
  return [React.useMemo(() => allowClear === !1 ? !1 : Object.assign({
    clearIcon
  }, allowClear === !0 ? {} : allowClear), [allowClear, clearIcon]), removeIcon];
}
__name(useIcons, "useIcons");
const [WEEK, WEEKPICKER] = ["week", "WeekPicker"], [MONTH, MONTHPICKER] = ["month", "MonthPicker"], [YEAR, YEARPICKER] = ["year", "YearPicker"], [QUARTER, QUARTERPICKER] = ["quarter", "QuarterPicker"], [TIME, TIMEPICKER] = ["time", "TimePicker"], PickerButton = /* @__PURE__ */ __name((props) => /* @__PURE__ */ React.createElement(Button$2, Object.assign({
  size: "small",
  type: "primary"
}, props)), "PickerButton");
function useComponents(components2) {
  return useMemo$1(() => Object.assign({
    button: PickerButton
  }, components2), [components2]);
}
__name(useComponents, "useComponents");
var __rest$m = function(s, e2) {
  var t2 = {};
  for (var p in s) Object.prototype.hasOwnProperty.call(s, p) && e2.indexOf(p) < 0 && (t2[p] = s[p]);
  if (s != null && typeof Object.getOwnPropertySymbols == "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++)
    e2.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]) && (t2[p[i]] = s[p[i]]);
  return t2;
};
const generateRangePicker = /* @__PURE__ */ __name((generateConfig2) => {
  const RangePicker2 = /* @__PURE__ */ forwardRef((props, ref) => {
    var _a;
    const {
      prefixCls: customizePrefixCls,
      getPopupContainer: customGetPopupContainer,
      components: components2,
      className,
      style: style2,
      placement,
      size: customizeSize,
      disabled: customDisabled,
      bordered = !0,
      placeholder,
      popupClassName,
      dropdownClassName,
      status: customStatus,
      rootClassName,
      variant: customVariant,
      picker
    } = props, restProps = __rest$m(props, ["prefixCls", "getPopupContainer", "components", "className", "style", "placement", "size", "disabled", "bordered", "placeholder", "popupClassName", "dropdownClassName", "status", "rootClassName", "variant", "picker"]), innerRef = React.useRef(null), {
      getPrefixCls,
      direction,
      getPopupContainer,
      rangePicker
    } = useContext$1(ConfigContext), prefixCls = getPrefixCls("picker", customizePrefixCls), {
      compactSize,
      compactItemClassnames
    } = useCompactItemContext(prefixCls, direction), rootPrefixCls = getPrefixCls(), [variant, enableVariantCls] = useVariant("rangePicker", customVariant, bordered), rootCls = useCSSVarCls(prefixCls), [wrapCSSVar, hashId, cssVarCls] = useStyle$f(prefixCls, rootCls);
    if (process.env.NODE_ENV !== "production") {
      const warning3 = devUseWarning("DatePicker.RangePicker");
      warning3.deprecated(!dropdownClassName, "dropdownClassName", "popupClassName"), warning3.deprecated(!("bordered" in props), "bordered", "variant");
    }
    const [mergedAllowClear] = useIcons(props, prefixCls), mergedComponents = useComponents(components2), mergedSize = useSize((ctx) => {
      var _a2;
      return (_a2 = customizeSize ?? compactSize) !== null && _a2 !== void 0 ? _a2 : ctx;
    }), disabled = React.useContext(DisabledContext), mergedDisabled = customDisabled ?? disabled, formItemContext = useContext$1(FormItemInputContext), {
      hasFeedback,
      status: contextStatus,
      feedbackIcon
    } = formItemContext, suffixNode = /* @__PURE__ */ React.createElement(React.Fragment, null, picker === TIME ? /* @__PURE__ */ React.createElement(RefIcon$m, null) : /* @__PURE__ */ React.createElement(RefIcon$n, null), hasFeedback && feedbackIcon);
    useImperativeHandle(ref, () => innerRef.current);
    const [contextLocale] = useLocale$1("Calendar", locale$5), locale2 = Object.assign(Object.assign({}, contextLocale), props.locale), [zIndex] = useZIndex("DatePicker", (_a = props.popupStyle) === null || _a === void 0 ? void 0 : _a.zIndex);
    return wrapCSSVar(/* @__PURE__ */ React.createElement(ContextIsolator, {
      space: !0
    }, /* @__PURE__ */ React.createElement(RefRangePicker, Object.assign({
      separator: /* @__PURE__ */ React.createElement("span", {
        "aria-label": "to",
        className: `${prefixCls}-separator`
      }, /* @__PURE__ */ React.createElement(RefIcon$l, null)),
      disabled: mergedDisabled,
      ref: innerRef,
      placement,
      placeholder: getRangePlaceholder(locale2, picker, placeholder),
      suffixIcon: suffixNode,
      prevIcon: /* @__PURE__ */ React.createElement("span", {
        className: `${prefixCls}-prev-icon`
      }),
      nextIcon: /* @__PURE__ */ React.createElement("span", {
        className: `${prefixCls}-next-icon`
      }),
      superPrevIcon: /* @__PURE__ */ React.createElement("span", {
        className: `${prefixCls}-super-prev-icon`
      }),
      superNextIcon: /* @__PURE__ */ React.createElement("span", {
        className: `${prefixCls}-super-next-icon`
      }),
      transitionName: `${rootPrefixCls}-slide-up`,
      picker
    }, restProps, {
      className: cn({
        [`${prefixCls}-${mergedSize}`]: mergedSize,
        [`${prefixCls}-${variant}`]: enableVariantCls
      }, getStatusClassNames(prefixCls, getMergedStatus(contextStatus, customStatus), hasFeedback), hashId, compactItemClassnames, className, rangePicker == null ? void 0 : rangePicker.className, cssVarCls, rootCls, rootClassName),
      style: Object.assign(Object.assign({}, rangePicker == null ? void 0 : rangePicker.style), style2),
      locale: locale2.lang,
      prefixCls,
      getPopupContainer: customGetPopupContainer || getPopupContainer,
      generateConfig: generateConfig2,
      components: mergedComponents,
      direction,
      classNames: {
        popup: cn(hashId, popupClassName || dropdownClassName, cssVarCls, rootCls, rootClassName)
      },
      styles: {
        popup: Object.assign(Object.assign({}, props.popupStyle), {
          zIndex
        })
      },
      allowClear: mergedAllowClear
    }))));
  });
  return process.env.NODE_ENV !== "production" && (RangePicker2.displayName = "RangePicker"), RangePicker2;
}, "generateRangePicker");
var __rest$l = function(s, e2) {
  var t2 = {};
  for (var p in s) Object.prototype.hasOwnProperty.call(s, p) && e2.indexOf(p) < 0 && (t2[p] = s[p]);
  if (s != null && typeof Object.getOwnPropertySymbols == "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++)
    e2.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]) && (t2[p[i]] = s[p[i]]);
  return t2;
};
const generatePicker$1 = /* @__PURE__ */ __name((generateConfig2) => {
  const getPicker = /* @__PURE__ */ __name((picker, displayName) => {
    const consumerName = displayName === TIMEPICKER ? "timePicker" : "datePicker", Picker3 = /* @__PURE__ */ forwardRef((props, ref) => {
      var _a;
      const {
        prefixCls: customizePrefixCls,
        getPopupContainer: customizeGetPopupContainer,
        components: components2,
        style: style2,
        className,
        rootClassName,
        size: customizeSize,
        bordered,
        placement,
        placeholder,
        popupClassName,
        dropdownClassName,
        disabled: customDisabled,
        status: customStatus,
        variant: customVariant,
        onCalendarChange
      } = props, restProps = __rest$l(props, ["prefixCls", "getPopupContainer", "components", "style", "className", "rootClassName", "size", "bordered", "placement", "placeholder", "popupClassName", "dropdownClassName", "disabled", "status", "variant", "onCalendarChange"]), {
        getPrefixCls,
        direction,
        getPopupContainer,
        // Consume different styles according to different names
        [consumerName]: consumerStyle
      } = useContext$1(ConfigContext), prefixCls = getPrefixCls("picker", customizePrefixCls), {
        compactSize,
        compactItemClassnames
      } = useCompactItemContext(prefixCls, direction), innerRef = React.useRef(null), [variant, enableVariantCls] = useVariant("datePicker", customVariant, bordered), rootCls = useCSSVarCls(prefixCls), [wrapCSSVar, hashId, cssVarCls] = useStyle$f(prefixCls, rootCls);
      useImperativeHandle(ref, () => innerRef.current);
      const additionalProps = {
        showToday: !0
      }, mergedPicker = picker || props.picker, rootPrefixCls = getPrefixCls(), {
        onSelect,
        multiple
      } = restProps, hasLegacyOnSelect = onSelect && picker === "time" && !multiple, onInternalCalendarChange = /* @__PURE__ */ __name((date4, dateStr, info) => {
        onCalendarChange == null || onCalendarChange(date4, dateStr, info), hasLegacyOnSelect && onSelect(date4);
      }, "onInternalCalendarChange");
      if (process.env.NODE_ENV !== "production") {
        const warning3 = devUseWarning(displayName || "DatePicker");
        process.env.NODE_ENV !== "production" && warning3(picker !== "quarter", "deprecated", `DatePicker.${displayName} is legacy usage. Please use DatePicker[picker='${picker}'] directly.`), warning3.deprecated(!dropdownClassName, "dropdownClassName", "popupClassName"), warning3.deprecated(!("bordered" in props), "bordered", "variant"), warning3.deprecated(!hasLegacyOnSelect, "onSelect", "onCalendarChange");
      }
      const [mergedAllowClear, removeIcon] = useIcons(props, prefixCls), mergedComponents = useComponents(components2), mergedSize = useSize((ctx) => {
        var _a2;
        return (_a2 = customizeSize ?? compactSize) !== null && _a2 !== void 0 ? _a2 : ctx;
      }), disabled = React.useContext(DisabledContext), mergedDisabled = customDisabled ?? disabled, formItemContext = useContext$1(FormItemInputContext), {
        hasFeedback,
        status: contextStatus,
        feedbackIcon
      } = formItemContext, suffixNode = /* @__PURE__ */ React.createElement(React.Fragment, null, mergedPicker === "time" ? /* @__PURE__ */ React.createElement(RefIcon$m, null) : /* @__PURE__ */ React.createElement(RefIcon$n, null), hasFeedback && feedbackIcon), [contextLocale] = useLocale$1("DatePicker", locale$5), locale2 = Object.assign(Object.assign({}, contextLocale), props.locale), [zIndex] = useZIndex("DatePicker", (_a = props.popupStyle) === null || _a === void 0 ? void 0 : _a.zIndex);
      return wrapCSSVar(/* @__PURE__ */ React.createElement(ContextIsolator, {
        space: !0
      }, /* @__PURE__ */ React.createElement(RefPicker, Object.assign({
        ref: innerRef,
        placeholder: getPlaceholder(locale2, mergedPicker, placeholder),
        suffixIcon: suffixNode,
        placement,
        prevIcon: /* @__PURE__ */ React.createElement("span", {
          className: `${prefixCls}-prev-icon`
        }),
        nextIcon: /* @__PURE__ */ React.createElement("span", {
          className: `${prefixCls}-next-icon`
        }),
        superPrevIcon: /* @__PURE__ */ React.createElement("span", {
          className: `${prefixCls}-super-prev-icon`
        }),
        superNextIcon: /* @__PURE__ */ React.createElement("span", {
          className: `${prefixCls}-super-next-icon`
        }),
        transitionName: `${rootPrefixCls}-slide-up`,
        picker,
        onCalendarChange: onInternalCalendarChange
      }, additionalProps, restProps, {
        locale: locale2.lang,
        className: cn({
          [`${prefixCls}-${mergedSize}`]: mergedSize,
          [`${prefixCls}-${variant}`]: enableVariantCls
        }, getStatusClassNames(prefixCls, getMergedStatus(contextStatus, customStatus), hasFeedback), hashId, compactItemClassnames, consumerStyle == null ? void 0 : consumerStyle.className, className, cssVarCls, rootCls, rootClassName),
        style: Object.assign(Object.assign({}, consumerStyle == null ? void 0 : consumerStyle.style), style2),
        prefixCls,
        getPopupContainer: customizeGetPopupContainer || getPopupContainer,
        generateConfig: generateConfig2,
        components: mergedComponents,
        direction,
        disabled: mergedDisabled,
        classNames: {
          popup: cn(hashId, cssVarCls, rootCls, rootClassName, popupClassName || dropdownClassName)
        },
        styles: {
          popup: Object.assign(Object.assign({}, props.popupStyle), {
            zIndex
          })
        },
        allowClear: mergedAllowClear,
        removeIcon
      }))));
    });
    return process.env.NODE_ENV !== "production" && displayName && (Picker3.displayName = displayName), Picker3;
  }, "getPicker"), DatePicker2 = getPicker(), WeekPicker = getPicker(WEEK, WEEKPICKER), MonthPicker = getPicker(MONTH, MONTHPICKER), YearPicker = getPicker(YEAR, YEARPICKER), QuarterPicker = getPicker(QUARTER, QUARTERPICKER), TimePicker2 = getPicker(TIME, TIMEPICKER);
  return {
    DatePicker: DatePicker2,
    WeekPicker,
    MonthPicker,
    YearPicker,
    TimePicker: TimePicker2,
    QuarterPicker
  };
}, "generatePicker$1"), generatePicker = /* @__PURE__ */ __name((generateConfig2) => {
  const {
    DatePicker: DatePicker2,
    WeekPicker,
    MonthPicker,
    YearPicker,
    TimePicker: TimePicker2,
    QuarterPicker
  } = generatePicker$1(generateConfig2), RangePicker2 = generateRangePicker(generateConfig2), MergedDatePicker = DatePicker2;
  return MergedDatePicker.WeekPicker = WeekPicker, MergedDatePicker.MonthPicker = MonthPicker, MergedDatePicker.YearPicker = YearPicker, MergedDatePicker.RangePicker = RangePicker2, MergedDatePicker.TimePicker = TimePicker2, MergedDatePicker.QuarterPicker = QuarterPicker, process.env.NODE_ENV !== "production" && (MergedDatePicker.displayName = "DatePicker"), MergedDatePicker;
}, "generatePicker"), DatePicker$1 = generatePicker(generateConfig), PurePanel$1 = genPurePanel(DatePicker$1, "picker", null);
DatePicker$1._InternalPanelDoNotUseOrYouWillBeFired = PurePanel$1;
const PureRangePanel = genPurePanel(DatePicker$1.RangePicker, "picker", null);
DatePicker$1._InternalRangePanelDoNotUseOrYouWillBeFired = PureRangePanel;
DatePicker$1.generatePicker = generatePicker;
function isPresetSize(size) {
  return ["small", "middle", "large"].includes(size);
}
__name(isPresetSize, "isPresetSize");
function isValidGapNumber(size) {
  return size ? typeof size == "number" && !Number.isNaN(size) : !1;
}
__name(isValidGapNumber, "isValidGapNumber");
const SpaceContext = /* @__PURE__ */ React__default.createContext({
  latestIndex: 0
}), SpaceContextProvider = SpaceContext.Provider, Item = /* @__PURE__ */ __name((_ref) => {
  let {
    className,
    index: index2,
    children,
    split,
    style: style2
  } = _ref;
  const {
    latestIndex
  } = React.useContext(SpaceContext);
  return children == null ? null : /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement("div", {
    className,
    style: style2
  }, children), index2 < latestIndex && split && /* @__PURE__ */ React.createElement("span", {
    className: `${className}-split`
  }, split));
}, "Item");
var __rest$k = function(s, e2) {
  var t2 = {};
  for (var p in s) Object.prototype.hasOwnProperty.call(s, p) && e2.indexOf(p) < 0 && (t2[p] = s[p]);
  if (s != null && typeof Object.getOwnPropertySymbols == "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++)
    e2.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]) && (t2[p[i]] = s[p[i]]);
  return t2;
};
const InternalSpace = /* @__PURE__ */ React.forwardRef((props, ref) => {
  var _a, _b, _c;
  const {
    getPrefixCls,
    space,
    direction: directionConfig
  } = React.useContext(ConfigContext), {
    size = (_a = space == null ? void 0 : space.size) !== null && _a !== void 0 ? _a : "small",
    align,
    className,
    rootClassName,
    children,
    direction = "horizontal",
    prefixCls: customizePrefixCls,
    split,
    style: style2,
    wrap = !1,
    classNames: customClassNames,
    styles: styles2
  } = props, otherProps = __rest$k(props, ["size", "align", "className", "rootClassName", "children", "direction", "prefixCls", "split", "style", "wrap", "classNames", "styles"]), [horizontalSize, verticalSize] = Array.isArray(size) ? size : [size, size], isPresetVerticalSize = isPresetSize(verticalSize), isPresetHorizontalSize = isPresetSize(horizontalSize), isValidVerticalSize = isValidGapNumber(verticalSize), isValidHorizontalSize = isValidGapNumber(horizontalSize), childNodes = toArray$7(children, {
    keepEmpty: !0
  }), mergedAlign = align === void 0 && direction === "horizontal" ? "center" : align, prefixCls = getPrefixCls("space", customizePrefixCls), [wrapCSSVar, hashId, cssVarCls] = useStyle$t(prefixCls), cls = cn(prefixCls, space == null ? void 0 : space.className, hashId, `${prefixCls}-${direction}`, {
    [`${prefixCls}-rtl`]: directionConfig === "rtl",
    [`${prefixCls}-align-${mergedAlign}`]: mergedAlign,
    [`${prefixCls}-gap-row-${verticalSize}`]: isPresetVerticalSize,
    [`${prefixCls}-gap-col-${horizontalSize}`]: isPresetHorizontalSize
  }, className, rootClassName, cssVarCls), itemClassName = cn(`${prefixCls}-item`, (_b = customClassNames == null ? void 0 : customClassNames.item) !== null && _b !== void 0 ? _b : (_c = space == null ? void 0 : space.classNames) === null || _c === void 0 ? void 0 : _c.item);
  let latestIndex = 0;
  const nodes = childNodes.map((child, i) => {
    var _a2, _b2;
    child != null && (latestIndex = i);
    const key = (child == null ? void 0 : child.key) || `${itemClassName}-${i}`;
    return /* @__PURE__ */ React.createElement(Item, {
      className: itemClassName,
      key,
      index: i,
      split,
      style: (_a2 = styles2 == null ? void 0 : styles2.item) !== null && _a2 !== void 0 ? _a2 : (_b2 = space == null ? void 0 : space.styles) === null || _b2 === void 0 ? void 0 : _b2.item
    }, child);
  }), spaceContext = React.useMemo(() => ({
    latestIndex
  }), [latestIndex]);
  if (childNodes.length === 0)
    return null;
  const gapStyle = {};
  return wrap && (gapStyle.flexWrap = "wrap"), !isPresetHorizontalSize && isValidHorizontalSize && (gapStyle.columnGap = horizontalSize), !isPresetVerticalSize && isValidVerticalSize && (gapStyle.rowGap = verticalSize), wrapCSSVar(/* @__PURE__ */ React.createElement("div", Object.assign({
    ref,
    className: cls,
    style: Object.assign(Object.assign(Object.assign({}, gapStyle), space == null ? void 0 : space.style), style2)
  }, otherProps), /* @__PURE__ */ React.createElement(SpaceContextProvider, {
    value: spaceContext
  }, nodes)));
}), Space$1 = InternalSpace;
Space$1.Compact = Compact$1;
process.env.NODE_ENV !== "production" && (Space$1.displayName = "Space");
var __rest$j = function(s, e2) {
  var t2 = {};
  for (var p in s) Object.prototype.hasOwnProperty.call(s, p) && e2.indexOf(p) < 0 && (t2[p] = s[p]);
  if (s != null && typeof Object.getOwnPropertySymbols == "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++)
    e2.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]) && (t2[p[i]] = s[p[i]]);
  return t2;
};
const DropdownButton = /* @__PURE__ */ __name((props) => {
  const {
    getPopupContainer: getContextPopupContainer,
    getPrefixCls,
    direction
  } = React.useContext(ConfigContext), {
    prefixCls: customizePrefixCls,
    type: type4 = "default",
    danger,
    disabled,
    loading,
    onClick,
    htmlType,
    children,
    className,
    menu,
    arrow,
    autoFocus,
    overlay: overlay2,
    trigger,
    align,
    open,
    onOpenChange,
    placement,
    getPopupContainer,
    href,
    icon = /* @__PURE__ */ React.createElement(RefIcon$s, null),
    title: title2,
    buttonsRender = /* @__PURE__ */ __name((buttons) => buttons, "buttonsRender"),
    mouseEnterDelay,
    mouseLeaveDelay,
    overlayClassName,
    overlayStyle,
    destroyPopupOnHide,
    dropdownRender
  } = props, restProps = __rest$j(props, ["prefixCls", "type", "danger", "disabled", "loading", "onClick", "htmlType", "children", "className", "menu", "arrow", "autoFocus", "overlay", "trigger", "align", "open", "onOpenChange", "placement", "getPopupContainer", "href", "icon", "title", "buttonsRender", "mouseEnterDelay", "mouseLeaveDelay", "overlayClassName", "overlayStyle", "destroyPopupOnHide", "dropdownRender"]), prefixCls = getPrefixCls("dropdown", customizePrefixCls), buttonPrefixCls = `${prefixCls}-button`, dropdownProps = {
    menu,
    arrow,
    autoFocus,
    align,
    disabled,
    trigger: disabled ? [] : trigger,
    onOpenChange,
    getPopupContainer: getPopupContainer || getContextPopupContainer,
    mouseEnterDelay,
    mouseLeaveDelay,
    overlayClassName,
    overlayStyle,
    destroyPopupOnHide,
    dropdownRender
  }, {
    compactSize,
    compactItemClassnames
  } = useCompactItemContext(prefixCls, direction), classes = cn(buttonPrefixCls, compactItemClassnames, className);
  "overlay" in props && (dropdownProps.overlay = overlay2), "open" in props && (dropdownProps.open = open), "placement" in props ? dropdownProps.placement = placement : dropdownProps.placement = direction === "rtl" ? "bottomLeft" : "bottomRight";
  const leftButton = /* @__PURE__ */ React.createElement(Button$2, {
    type: type4,
    danger,
    disabled,
    loading,
    onClick,
    htmlType,
    href,
    title: title2
  }, children), rightButton = /* @__PURE__ */ React.createElement(Button$2, {
    type: type4,
    danger,
    icon
  }), [leftButtonToRender, rightButtonToRender] = buttonsRender([leftButton, rightButton]);
  return /* @__PURE__ */ React.createElement(Space$1.Compact, Object.assign({
    className: classes,
    size: compactSize,
    block: !0
  }, restProps), leftButtonToRender, /* @__PURE__ */ React.createElement(Dropdown$1, Object.assign({}, dropdownProps), rightButtonToRender));
}, "DropdownButton");
DropdownButton.__ANT_BUTTON = !0;
const Dropdown = Dropdown$1;
Dropdown.Button = DropdownButton;
function useDebounce(value) {
  const [cacheValue, setCacheValue] = React.useState(value);
  return React.useEffect(() => {
    const timeout = setTimeout(() => {
      setCacheValue(value);
    }, value.length ? 0 : 10);
    return () => {
      clearTimeout(timeout);
    };
  }, [value]), cacheValue;
}
__name(useDebounce, "useDebounce");
const genFormValidateMotionStyle = /* @__PURE__ */ __name((token2) => {
  const {
    componentCls
  } = token2, helpCls = `${componentCls}-show-help`, helpItemCls = `${componentCls}-show-help-item`;
  return {
    [helpCls]: {
      // Explain holder
      transition: `opacity ${token2.motionDurationFast} ${token2.motionEaseInOut}`,
      "&-appear, &-enter": {
        opacity: 0,
        "&-active": {
          opacity: 1
        }
      },
      "&-leave": {
        opacity: 1,
        "&-active": {
          opacity: 0
        }
      },
      // Explain
      [helpItemCls]: {
        overflow: "hidden",
        transition: `height ${token2.motionDurationFast} ${token2.motionEaseInOut},
                     opacity ${token2.motionDurationFast} ${token2.motionEaseInOut},
                     transform ${token2.motionDurationFast} ${token2.motionEaseInOut} !important`,
        [`&${helpItemCls}-appear, &${helpItemCls}-enter`]: {
          transform: "translateY(-5px)",
          opacity: 0,
          "&-active": {
            transform: "translateY(0)",
            opacity: 1
          }
        },
        [`&${helpItemCls}-leave-active`]: {
          transform: "translateY(-5px)"
        }
      }
    }
  };
}, "genFormValidateMotionStyle"), resetForm = /* @__PURE__ */ __name((token2) => ({
  legend: {
    display: "block",
    width: "100%",
    marginBottom: token2.marginLG,
    padding: 0,
    color: token2.colorTextDescription,
    fontSize: token2.fontSizeLG,
    lineHeight: "inherit",
    border: 0,
    borderBottom: `${unit$1(token2.lineWidth)} ${token2.lineType} ${token2.colorBorder}`
  },
  'input[type="search"]': {
    boxSizing: "border-box"
  },
  // Position radios and checkboxes better
  'input[type="radio"], input[type="checkbox"]': {
    lineHeight: "normal"
  },
  'input[type="file"]': {
    display: "block"
  },
  // Make range inputs behave like textual form controls
  'input[type="range"]': {
    display: "block",
    width: "100%"
  },
  // Make multiple select elements height not fixed
  "select[multiple], select[size]": {
    height: "auto"
  },
  // Focus for file, radio, and checkbox
  "input[type='file']:focus,\n  input[type='radio']:focus,\n  input[type='checkbox']:focus": {
    outline: 0,
    boxShadow: `0 0 0 ${unit$1(token2.controlOutlineWidth)} ${token2.controlOutline}`
  },
  // Adjust output element
  output: {
    display: "block",
    paddingTop: 15,
    color: token2.colorText,
    fontSize: token2.fontSize,
    lineHeight: token2.lineHeight
  }
}), "resetForm"), genFormSize = /* @__PURE__ */ __name((token2, height) => {
  const {
    formItemCls
  } = token2;
  return {
    [formItemCls]: {
      [`${formItemCls}-label > label`]: {
        height
      },
      [`${formItemCls}-control-input`]: {
        minHeight: height
      }
    }
  };
}, "genFormSize"), genFormStyle = /* @__PURE__ */ __name((token2) => {
  const {
    componentCls
  } = token2;
  return {
    [token2.componentCls]: Object.assign(Object.assign(Object.assign({}, resetComponent(token2)), resetForm(token2)), {
      [`${componentCls}-text`]: {
        display: "inline-block",
        paddingInlineEnd: token2.paddingSM
      },
      // ================================================================
      // =                             Size                             =
      // ================================================================
      "&-small": Object.assign({}, genFormSize(token2, token2.controlHeightSM)),
      "&-large": Object.assign({}, genFormSize(token2, token2.controlHeightLG))
    })
  };
}, "genFormStyle"), genFormItemStyle = /* @__PURE__ */ __name((token2) => {
  const {
    formItemCls,
    iconCls,
    componentCls,
    rootPrefixCls,
    antCls,
    labelRequiredMarkColor,
    labelColor,
    labelFontSize,
    labelHeight,
    labelColonMarginInlineStart,
    labelColonMarginInlineEnd,
    itemMarginBottom
  } = token2;
  return {
    [formItemCls]: Object.assign(Object.assign({}, resetComponent(token2)), {
      marginBottom: itemMarginBottom,
      verticalAlign: "top",
      "&-with-help": {
        transition: "none"
      },
      [`&-hidden,
        &-hidden${antCls}-row`]: {
        // https://github.com/ant-design/ant-design/issues/26141
        display: "none"
      },
      "&-has-warning": {
        [`${formItemCls}-split`]: {
          color: token2.colorError
        }
      },
      "&-has-error": {
        [`${formItemCls}-split`]: {
          color: token2.colorWarning
        }
      },
      // ==============================================================
      // =                            Label                           =
      // ==============================================================
      [`${formItemCls}-label`]: {
        flexGrow: 0,
        overflow: "hidden",
        whiteSpace: "nowrap",
        textAlign: "end",
        verticalAlign: "middle",
        "&-left": {
          textAlign: "start"
        },
        "&-wrap": {
          overflow: "unset",
          lineHeight: token2.lineHeight,
          whiteSpace: "unset"
        },
        "> label": {
          position: "relative",
          display: "inline-flex",
          alignItems: "center",
          maxWidth: "100%",
          height: labelHeight,
          color: labelColor,
          fontSize: labelFontSize,
          [`> ${iconCls}`]: {
            fontSize: token2.fontSize,
            verticalAlign: "top"
          },
          // Required mark
          [`&${formItemCls}-required:not(${formItemCls}-required-mark-optional)::before`]: {
            display: "inline-block",
            marginInlineEnd: token2.marginXXS,
            color: labelRequiredMarkColor,
            fontSize: token2.fontSize,
            fontFamily: "SimSun, sans-serif",
            lineHeight: 1,
            content: '"*"',
            [`${componentCls}-hide-required-mark &`]: {
              display: "none"
            }
          },
          // Optional mark
          [`${formItemCls}-optional`]: {
            display: "inline-block",
            marginInlineStart: token2.marginXXS,
            color: token2.colorTextDescription,
            [`${componentCls}-hide-required-mark &`]: {
              display: "none"
            }
          },
          // Optional mark
          [`${formItemCls}-tooltip`]: {
            color: token2.colorTextDescription,
            cursor: "help",
            writingMode: "horizontal-tb",
            marginInlineStart: token2.marginXXS
          },
          "&::after": {
            content: '":"',
            position: "relative",
            marginBlock: 0,
            marginInlineStart: labelColonMarginInlineStart,
            marginInlineEnd: labelColonMarginInlineEnd
          },
          [`&${formItemCls}-no-colon::after`]: {
            content: '"\\a0"'
          }
        }
      },
      // ==============================================================
      // =                            Input                           =
      // ==============================================================
      [`${formItemCls}-control`]: {
        "--ant-display": "flex",
        flexDirection: "column",
        flexGrow: 1,
        [`&:first-child:not([class^="'${rootPrefixCls}-col-'"]):not([class*="' ${rootPrefixCls}-col-'"])`]: {
          width: "100%"
        },
        "&-input": {
          position: "relative",
          display: "flex",
          alignItems: "center",
          minHeight: token2.controlHeight,
          "&-content": {
            flex: "auto",
            maxWidth: "100%"
          }
        }
      },
      // ==============================================================
      // =                           Explain                          =
      // ==============================================================
      [formItemCls]: {
        "&-additional": {
          display: "flex",
          flexDirection: "column"
        },
        "&-explain, &-extra": {
          clear: "both",
          color: token2.colorTextDescription,
          fontSize: token2.fontSize,
          lineHeight: token2.lineHeight
        },
        "&-explain-connected": {
          width: "100%"
        },
        "&-extra": {
          minHeight: token2.controlHeightSM,
          transition: `color ${token2.motionDurationMid} ${token2.motionEaseOut}`
          // sync input color transition
        },
        "&-explain": {
          "&-error": {
            color: token2.colorError
          },
          "&-warning": {
            color: token2.colorWarning
          }
        }
      },
      [`&-with-help ${formItemCls}-explain`]: {
        height: "auto",
        opacity: 1
      },
      // ==============================================================
      // =                        Feedback Icon                       =
      // ==============================================================
      [`${formItemCls}-feedback-icon`]: {
        fontSize: token2.fontSize,
        textAlign: "center",
        visibility: "visible",
        animationName: zoomIn,
        animationDuration: token2.motionDurationMid,
        animationTimingFunction: token2.motionEaseOutBack,
        pointerEvents: "none",
        "&-success": {
          color: token2.colorSuccess
        },
        "&-error": {
          color: token2.colorError
        },
        "&-warning": {
          color: token2.colorWarning
        },
        "&-validating": {
          color: token2.colorPrimary
        }
      }
    })
  };
}, "genFormItemStyle"), genHorizontalStyle = /* @__PURE__ */ __name((token2, className) => {
  const {
    formItemCls
  } = token2;
  return {
    [`${className}-horizontal`]: {
      [`${formItemCls}-label`]: {
        flexGrow: 0
      },
      [`${formItemCls}-control`]: {
        flex: "1 1 0",
        // https://github.com/ant-design/ant-design/issues/32777
        // https://github.com/ant-design/ant-design/issues/33773
        minWidth: 0
      },
      // Do not change this to `ant-col-24`! `-24` match all the responsive rules
      // https://github.com/ant-design/ant-design/issues/32980
      // https://github.com/ant-design/ant-design/issues/34903
      // https://github.com/ant-design/ant-design/issues/44538
      [`${formItemCls}-label[class$='-24'], ${formItemCls}-label[class*='-24 ']`]: {
        [`& + ${formItemCls}-control`]: {
          minWidth: "unset"
        }
      }
    }
  };
}, "genHorizontalStyle"), genInlineStyle = /* @__PURE__ */ __name((token2) => {
  const {
    componentCls,
    formItemCls,
    inlineItemMarginBottom
  } = token2;
  return {
    [`${componentCls}-inline`]: {
      display: "flex",
      flexWrap: "wrap",
      [formItemCls]: {
        flex: "none",
        marginInlineEnd: token2.margin,
        marginBottom: inlineItemMarginBottom,
        "&-row": {
          flexWrap: "nowrap"
        },
        [`> ${formItemCls}-label,
        > ${formItemCls}-control`]: {
          display: "inline-block",
          verticalAlign: "top"
        },
        [`> ${formItemCls}-label`]: {
          flex: "none"
        },
        [`${componentCls}-text`]: {
          display: "inline-block"
        },
        [`${formItemCls}-has-feedback`]: {
          display: "inline-block"
        }
      }
    }
  };
}, "genInlineStyle"), makeVerticalLayoutLabel = /* @__PURE__ */ __name((token2) => ({
  padding: token2.verticalLabelPadding,
  margin: token2.verticalLabelMargin,
  whiteSpace: "initial",
  textAlign: "start",
  "> label": {
    margin: 0,
    "&::after": {
      // https://github.com/ant-design/ant-design/issues/43538
      visibility: "hidden"
    }
  }
}), "makeVerticalLayoutLabel"), makeVerticalLayout = /* @__PURE__ */ __name((token2) => {
  const {
    componentCls,
    formItemCls,
    rootPrefixCls
  } = token2;
  return {
    [`${formItemCls} ${formItemCls}-label`]: makeVerticalLayoutLabel(token2),
    // ref: https://github.com/ant-design/ant-design/issues/45122
    [`${componentCls}:not(${componentCls}-inline)`]: {
      [formItemCls]: {
        flexWrap: "wrap",
        [`${formItemCls}-label, ${formItemCls}-control`]: {
          // When developer pass `xs: { span }`,
          // It should follow the `xs` screen config
          // ref: https://github.com/ant-design/ant-design/issues/44386
          [`&:not([class*=" ${rootPrefixCls}-col-xs"])`]: {
            flex: "0 0 100%",
            maxWidth: "100%"
          }
        }
      }
    }
  };
}, "makeVerticalLayout"), genVerticalStyle = /* @__PURE__ */ __name((token2) => {
  const {
    componentCls,
    formItemCls,
    antCls
  } = token2;
  return {
    [`${componentCls}-vertical`]: {
      [`${formItemCls}:not(${formItemCls}-horizontal)`]: {
        [`${formItemCls}-row`]: {
          flexDirection: "column"
        },
        [`${formItemCls}-label > label`]: {
          height: "auto"
        },
        [`${formItemCls}-control`]: {
          width: "100%"
        },
        [`${formItemCls}-label,
        ${antCls}-col-24${formItemCls}-label,
        ${antCls}-col-xl-24${formItemCls}-label`]: makeVerticalLayoutLabel(token2)
      }
    },
    [`@media (max-width: ${unit$1(token2.screenXSMax)})`]: [makeVerticalLayout(token2), {
      [componentCls]: {
        [`${formItemCls}:not(${formItemCls}-horizontal)`]: {
          [`${antCls}-col-xs-24${formItemCls}-label`]: makeVerticalLayoutLabel(token2)
        }
      }
    }],
    [`@media (max-width: ${unit$1(token2.screenSMMax)})`]: {
      [componentCls]: {
        [`${formItemCls}:not(${formItemCls}-horizontal)`]: {
          [`${antCls}-col-sm-24${formItemCls}-label`]: makeVerticalLayoutLabel(token2)
        }
      }
    },
    [`@media (max-width: ${unit$1(token2.screenMDMax)})`]: {
      [componentCls]: {
        [`${formItemCls}:not(${formItemCls}-horizontal)`]: {
          [`${antCls}-col-md-24${formItemCls}-label`]: makeVerticalLayoutLabel(token2)
        }
      }
    },
    [`@media (max-width: ${unit$1(token2.screenLGMax)})`]: {
      [componentCls]: {
        [`${formItemCls}:not(${formItemCls}-horizontal)`]: {
          [`${antCls}-col-lg-24${formItemCls}-label`]: makeVerticalLayoutLabel(token2)
        }
      }
    }
  };
}, "genVerticalStyle"), genItemVerticalStyle = /* @__PURE__ */ __name((token2) => {
  const {
    formItemCls,
    antCls
  } = token2;
  return {
    [`${formItemCls}-vertical`]: {
      [`${formItemCls}-row`]: {
        flexDirection: "column"
      },
      [`${formItemCls}-label > label`]: {
        height: "auto"
      },
      [`${formItemCls}-control`]: {
        width: "100%"
      }
    },
    [`${formItemCls}-vertical ${formItemCls}-label,
      ${antCls}-col-24${formItemCls}-label,
      ${antCls}-col-xl-24${formItemCls}-label`]: makeVerticalLayoutLabel(token2),
    [`@media (max-width: ${unit$1(token2.screenXSMax)})`]: [makeVerticalLayout(token2), {
      [formItemCls]: {
        [`${antCls}-col-xs-24${formItemCls}-label`]: makeVerticalLayoutLabel(token2)
      }
    }],
    [`@media (max-width: ${unit$1(token2.screenSMMax)})`]: {
      [formItemCls]: {
        [`${antCls}-col-sm-24${formItemCls}-label`]: makeVerticalLayoutLabel(token2)
      }
    },
    [`@media (max-width: ${unit$1(token2.screenMDMax)})`]: {
      [formItemCls]: {
        [`${antCls}-col-md-24${formItemCls}-label`]: makeVerticalLayoutLabel(token2)
      }
    },
    [`@media (max-width: ${unit$1(token2.screenLGMax)})`]: {
      [formItemCls]: {
        [`${antCls}-col-lg-24${formItemCls}-label`]: makeVerticalLayoutLabel(token2)
      }
    }
  };
}, "genItemVerticalStyle"), prepareComponentToken$8 = /* @__PURE__ */ __name((token2) => ({
  labelRequiredMarkColor: token2.colorError,
  labelColor: token2.colorTextHeading,
  labelFontSize: token2.fontSize,
  labelHeight: token2.controlHeight,
  labelColonMarginInlineStart: token2.marginXXS / 2,
  labelColonMarginInlineEnd: token2.marginXS,
  itemMarginBottom: token2.marginLG,
  verticalLabelPadding: `0 0 ${token2.paddingXS}px`,
  verticalLabelMargin: 0,
  inlineItemMarginBottom: 0
}), "prepareComponentToken$8"), prepareToken$1 = /* @__PURE__ */ __name((token2, rootPrefixCls) => merge(token2, {
  formItemCls: `${token2.componentCls}-item`,
  rootPrefixCls
}), "prepareToken$1"), useStyle$8 = genStyleHooks("Form", (token2, _ref) => {
  let {
    rootPrefixCls
  } = _ref;
  const formToken = prepareToken$1(token2, rootPrefixCls);
  return [genFormStyle(formToken), genFormItemStyle(formToken), genFormValidateMotionStyle(formToken), genHorizontalStyle(formToken, formToken.componentCls), genHorizontalStyle(formToken, formToken.formItemCls), genInlineStyle(formToken), genVerticalStyle(formToken), genItemVerticalStyle(formToken), genCollapseMotion(formToken), zoomIn];
}, prepareComponentToken$8, {
  // Let From style before the Grid
  // ref https://github.com/ant-design/ant-design/issues/44386
  order: -1e3
}), EMPTY_LIST$2 = [];
function toErrorEntity(error, prefix, errorStatus) {
  let index2 = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 0;
  return {
    key: typeof error == "string" ? error : `${prefix}-${index2}`,
    error,
    errorStatus
  };
}
__name(toErrorEntity, "toErrorEntity");
const ErrorList = /* @__PURE__ */ __name((_ref) => {
  let {
    help,
    helpStatus,
    errors = EMPTY_LIST$2,
    warnings = EMPTY_LIST$2,
    className: rootClassName,
    fieldId,
    onVisibleChanged
  } = _ref;
  const {
    prefixCls
  } = React.useContext(FormItemPrefixContext), baseClassName = `${prefixCls}-item-explain`, rootCls = useCSSVarCls(prefixCls), [wrapCSSVar, hashId, cssVarCls] = useStyle$8(prefixCls, rootCls), collapseMotion = React.useMemo(() => initCollapseMotion(prefixCls), [prefixCls]), debounceErrors = useDebounce(errors), debounceWarnings = useDebounce(warnings), fullKeyList = React.useMemo(() => help != null ? [toErrorEntity(help, "help", helpStatus)] : [].concat(_toConsumableArray(debounceErrors.map((error, index2) => toErrorEntity(error, "error", "error", index2))), _toConsumableArray(debounceWarnings.map((warning3, index2) => toErrorEntity(warning3, "warning", "warning", index2)))), [help, helpStatus, debounceErrors, debounceWarnings]), filledKeyFullKeyList = React.useMemo(() => {
    const keysCount = {};
    return fullKeyList.forEach((_ref2) => {
      let {
        key
      } = _ref2;
      keysCount[key] = (keysCount[key] || 0) + 1;
    }), fullKeyList.map((entity, index2) => Object.assign(Object.assign({}, entity), {
      key: keysCount[entity.key] > 1 ? `${entity.key}-fallback-${index2}` : entity.key
    }));
  }, [fullKeyList]), helpProps = {};
  return fieldId && (helpProps.id = `${fieldId}_help`), wrapCSSVar(/* @__PURE__ */ React.createElement(CSSMotion, {
    motionDeadline: collapseMotion.motionDeadline,
    motionName: `${prefixCls}-show-help`,
    visible: !!filledKeyFullKeyList.length,
    onVisibleChanged
  }, (holderProps) => {
    const {
      className: holderClassName,
      style: holderStyle
    } = holderProps;
    return /* @__PURE__ */ React.createElement("div", Object.assign({}, helpProps, {
      className: cn(baseClassName, holderClassName, cssVarCls, rootCls, rootClassName, hashId),
      style: holderStyle,
      role: "alert"
    }), /* @__PURE__ */ React.createElement(CSSMotionList, Object.assign({
      keys: filledKeyFullKeyList
    }, initCollapseMotion(prefixCls), {
      motionName: `${prefixCls}-show-help-item`,
      component: !1
    }), (itemProps) => {
      const {
        key,
        error,
        errorStatus,
        className: itemClassName,
        style: itemStyle
      } = itemProps;
      return /* @__PURE__ */ React.createElement("div", {
        key,
        className: cn(itemClassName, {
          [`${baseClassName}-${errorStatus}`]: errorStatus
        }),
        style: itemStyle
      }, error);
    }));
  }));
}, "ErrorList"), formItemNameBlackList = ["parentNode"], defaultItemNamePrefixCls = "form_item";
function toArray$2(candidate) {
  return candidate === void 0 || candidate === !1 ? [] : Array.isArray(candidate) ? candidate : [candidate];
}
__name(toArray$2, "toArray$2");
function getFieldId(namePath, formName) {
  if (!namePath.length)
    return;
  const mergedId = namePath.join("_");
  return formName ? `${formName}_${mergedId}` : formItemNameBlackList.includes(mergedId) ? `${defaultItemNamePrefixCls}_${mergedId}` : mergedId;
}
__name(getFieldId, "getFieldId");
function getStatus(errors, warnings, meta, defaultValidateStatus, hasFeedback, validateStatus) {
  let status = defaultValidateStatus;
  return validateStatus !== void 0 ? status = validateStatus : meta.validating ? status = "validating" : errors.length ? status = "error" : warnings.length ? status = "warning" : (meta.touched || hasFeedback && meta.validated) && (status = "success"), status;
}
__name(getStatus, "getStatus");
function toNamePathStr(name) {
  return toArray$2(name).join("_");
}
__name(toNamePathStr, "toNamePathStr");
function getFieldDOMNode(name, wrapForm) {
  const field = wrapForm.getFieldInstance(name), fieldDom = getDOM(field);
  if (fieldDom)
    return fieldDom;
  const fieldId = getFieldId(toArray$2(name), wrapForm.__INTERNAL__.name);
  if (fieldId)
    return document.getElementById(fieldId);
}
__name(getFieldDOMNode, "getFieldDOMNode");
function useForm(form) {
  const [rcForm] = useForm$1(), itemsRef = React.useRef({}), wrapForm = React.useMemo(() => form ?? Object.assign(Object.assign({}, rcForm), {
    __INTERNAL__: {
      itemRef: /* @__PURE__ */ __name((name) => (node2) => {
        const namePathStr = toNamePathStr(name);
        node2 ? itemsRef.current[namePathStr] = node2 : delete itemsRef.current[namePathStr];
      }, "itemRef")
    },
    scrollToField: /* @__PURE__ */ __name(function(name) {
      let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      const node2 = getFieldDOMNode(name, wrapForm);
      node2 && e(node2, Object.assign({
        scrollMode: "if-needed",
        block: "nearest"
      }, options));
    }, "scrollToField"),
    focusField: /* @__PURE__ */ __name((name) => {
      var _a;
      const node2 = getFieldDOMNode(name, wrapForm);
      node2 && ((_a = node2.focus) === null || _a === void 0 || _a.call(node2));
    }, "focusField"),
    getFieldInstance: /* @__PURE__ */ __name((name) => {
      const namePathStr = toNamePathStr(name);
      return itemsRef.current[namePathStr];
    }, "getFieldInstance")
  }), [form, rcForm]);
  return [wrapForm];
}
__name(useForm, "useForm");
const names = {};
function useFormWarning(_ref) {
  let {
    name
  } = _ref;
  const warning3 = devUseWarning("Form");
  React.useEffect(() => {
    if (name)
      return names[name] = (names[name] || 0) + 1, process.env.NODE_ENV !== "production" && warning3(names[name] <= 1, "usage", "There exist multiple Form with same `name`."), () => {
        names[name] -= 1;
      };
  }, [name]);
}
__name(useFormWarning, "useFormWarning");
var __rest$i = function(s, e2) {
  var t2 = {};
  for (var p in s) Object.prototype.hasOwnProperty.call(s, p) && e2.indexOf(p) < 0 && (t2[p] = s[p]);
  if (s != null && typeof Object.getOwnPropertySymbols == "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++)
    e2.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]) && (t2[p[i]] = s[p[i]]);
  return t2;
};
const InternalForm = /* @__PURE__ */ __name((props, ref) => {
  const contextDisabled = React.useContext(DisabledContext), {
    getPrefixCls,
    direction,
    form: contextForm
  } = React.useContext(ConfigContext), {
    prefixCls: customizePrefixCls,
    className,
    rootClassName,
    size,
    disabled = contextDisabled,
    form,
    colon,
    labelAlign,
    labelWrap,
    labelCol,
    wrapperCol,
    hideRequiredMark,
    layout = "horizontal",
    scrollToFirstError,
    requiredMark,
    onFinishFailed,
    name,
    style: style2,
    feedbackIcons,
    variant
  } = props, restFormProps = __rest$i(props, ["prefixCls", "className", "rootClassName", "size", "disabled", "form", "colon", "labelAlign", "labelWrap", "labelCol", "wrapperCol", "hideRequiredMark", "layout", "scrollToFirstError", "requiredMark", "onFinishFailed", "name", "style", "feedbackIcons", "variant"]), mergedSize = useSize(size), contextValidateMessages = React.useContext(ValidateMessagesContext);
  process.env.NODE_ENV !== "production" && useFormWarning(props);
  const mergedRequiredMark = React.useMemo(() => requiredMark !== void 0 ? requiredMark : hideRequiredMark ? !1 : contextForm && contextForm.requiredMark !== void 0 ? contextForm.requiredMark : !0, [hideRequiredMark, requiredMark, contextForm]), mergedColon = colon ?? (contextForm == null ? void 0 : contextForm.colon), prefixCls = getPrefixCls("form", customizePrefixCls), rootCls = useCSSVarCls(prefixCls), [wrapCSSVar, hashId, cssVarCls] = useStyle$8(prefixCls, rootCls), formClassName = cn(prefixCls, `${prefixCls}-${layout}`, {
    [`${prefixCls}-hide-required-mark`]: mergedRequiredMark === !1,
    [`${prefixCls}-rtl`]: direction === "rtl",
    [`${prefixCls}-${mergedSize}`]: mergedSize
  }, cssVarCls, rootCls, hashId, contextForm == null ? void 0 : contextForm.className, className, rootClassName), [wrapForm] = useForm(form), {
    __INTERNAL__
  } = wrapForm;
  __INTERNAL__.name = name;
  const formContextValue = React.useMemo(() => ({
    name,
    labelAlign,
    labelCol,
    labelWrap,
    wrapperCol,
    vertical: layout === "vertical",
    colon: mergedColon,
    requiredMark: mergedRequiredMark,
    itemRef: __INTERNAL__.itemRef,
    form: wrapForm,
    feedbackIcons
  }), [name, labelAlign, labelCol, wrapperCol, layout, mergedColon, mergedRequiredMark, wrapForm, feedbackIcons]), nativeElementRef = React.useRef(null);
  React.useImperativeHandle(ref, () => {
    var _a;
    return Object.assign(Object.assign({}, wrapForm), {
      nativeElement: (_a = nativeElementRef.current) === null || _a === void 0 ? void 0 : _a.nativeElement
    });
  });
  const scrollToField = /* @__PURE__ */ __name((options, fieldName) => {
    if (options) {
      let defaultScrollToFirstError = {
        block: "nearest"
      };
      typeof options == "object" && (defaultScrollToFirstError = Object.assign(Object.assign({}, defaultScrollToFirstError), options)), wrapForm.scrollToField(fieldName, defaultScrollToFirstError), defaultScrollToFirstError.focus && wrapForm.focusField(fieldName);
    }
  }, "scrollToField"), onInternalFinishFailed = /* @__PURE__ */ __name((errorInfo) => {
    if (onFinishFailed == null || onFinishFailed(errorInfo), errorInfo.errorFields.length) {
      const fieldName = errorInfo.errorFields[0].name;
      if (scrollToFirstError !== void 0) {
        scrollToField(scrollToFirstError, fieldName);
        return;
      }
      contextForm && contextForm.scrollToFirstError !== void 0 && scrollToField(contextForm.scrollToFirstError, fieldName);
    }
  }, "onInternalFinishFailed");
  return wrapCSSVar(/* @__PURE__ */ React.createElement(VariantContext.Provider, {
    value: variant
  }, /* @__PURE__ */ React.createElement(DisabledContextProvider, {
    disabled
  }, /* @__PURE__ */ React.createElement(SizeContext.Provider, {
    value: mergedSize
  }, /* @__PURE__ */ React.createElement(FormProvider2, {
    // This is not list in API, we pass with spread
    validateMessages: contextValidateMessages
  }, /* @__PURE__ */ React.createElement(FormContext.Provider, {
    value: formContextValue
  }, /* @__PURE__ */ React.createElement(RefForm, Object.assign({
    id: name
  }, restFormProps, {
    name,
    onFinishFailed: onInternalFinishFailed,
    form: wrapForm,
    ref: nativeElementRef,
    style: Object.assign(Object.assign({}, contextForm == null ? void 0 : contextForm.style), style2),
    className: formClassName
  }))))))));
}, "InternalForm"), Form$2 = /* @__PURE__ */ React.forwardRef(InternalForm);
process.env.NODE_ENV !== "production" && (Form$2.displayName = "Form");
function useChildren(children) {
  if (typeof children == "function")
    return children;
  const childList = toArray$7(children);
  return childList.length <= 1 ? childList[0] : childList;
}
__name(useChildren, "useChildren");
const useFormItemStatus = /* @__PURE__ */ __name(() => {
  const {
    status,
    errors = [],
    warnings = []
  } = React.useContext(FormItemInputContext);
  if (process.env.NODE_ENV !== "production") {
    const warning3 = devUseWarning("Form.Item");
    process.env.NODE_ENV !== "production" && warning3(status !== void 0, "usage", "Form.Item.useStatus should be used under Form.Item component. For more information: https://u.ant.design/form-item-usestatus");
  }
  return {
    status,
    errors,
    warnings
  };
}, "useFormItemStatus");
useFormItemStatus.Context = FormItemInputContext;
function useFrameState(defaultValue) {
  const [value, setValue] = React.useState(defaultValue), frameRef = React.useRef(null), batchRef = React.useRef([]), destroyRef = React.useRef(!1);
  React.useEffect(() => (destroyRef.current = !1, () => {
    destroyRef.current = !0, wrapperRaf.cancel(frameRef.current), frameRef.current = null;
  }), []);
  function setFrameValue(updater) {
    destroyRef.current || (frameRef.current === null && (batchRef.current = [], frameRef.current = wrapperRaf(() => {
      frameRef.current = null, setValue((prevValue) => {
        let current = prevValue;
        return batchRef.current.forEach((func) => {
          current = func(current);
        }), current;
      });
    })), batchRef.current.push(updater));
  }
  return __name(setFrameValue, "setFrameValue"), [value, setFrameValue];
}
__name(useFrameState, "useFrameState");
function useItemRef() {
  const {
    itemRef
  } = React.useContext(FormContext), cacheRef = React.useRef({});
  function getRef(name, children) {
    const childrenRef = children && typeof children == "object" && getNodeRef(children), nameStr = name.join("_");
    return (cacheRef.current.name !== nameStr || cacheRef.current.originRef !== childrenRef) && (cacheRef.current.name = nameStr, cacheRef.current.originRef = childrenRef, cacheRef.current.ref = composeRef(itemRef(name), childrenRef)), cacheRef.current.ref;
  }
  return __name(getRef, "getRef"), getRef;
}
__name(useItemRef, "useItemRef");
const genFallbackStyle = /* @__PURE__ */ __name((token2) => {
  const {
    formItemCls
  } = token2;
  return {
    "@media screen and (-ms-high-contrast: active), (-ms-high-contrast: none)": {
      // Fallback for IE, safe to remove we not support it anymore
      [`${formItemCls}-control`]: {
        display: "flex"
      }
    }
  };
}, "genFallbackStyle"), FallbackCmp = genSubStyleComponent(["Form", "item-item"], (token2, _ref) => {
  let {
    rootPrefixCls
  } = _ref;
  const formToken = prepareToken$1(token2, rootPrefixCls);
  return [genFallbackStyle(formToken)];
});
var __rest$h = function(s, e2) {
  var t2 = {};
  for (var p in s) Object.prototype.hasOwnProperty.call(s, p) && e2.indexOf(p) < 0 && (t2[p] = s[p]);
  if (s != null && typeof Object.getOwnPropertySymbols == "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++)
    e2.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]) && (t2[p[i]] = s[p[i]]);
  return t2;
};
const GRID_MAX = 24, FormItemInput = /* @__PURE__ */ __name((props) => {
  const {
    prefixCls,
    status,
    labelCol,
    wrapperCol,
    children,
    errors,
    warnings,
    _internalItemRender: formItemRender,
    extra,
    help,
    fieldId,
    marginBottom,
    onErrorVisibleChanged,
    label: label2
  } = props, baseClassName = `${prefixCls}-item`, formContext = React.useContext(FormContext), mergedWrapperCol = React.useMemo(() => {
    let mergedWrapper = Object.assign({}, wrapperCol || formContext.wrapperCol || {});
    return label2 === null && !labelCol && !wrapperCol && formContext.labelCol && [void 0, "xs", "sm", "md", "lg", "xl", "xxl"].forEach((size) => {
      const _size = size ? [size] : [], formLabel = get(formContext.labelCol, _size), formLabelObj = typeof formLabel == "object" ? formLabel : {}, wrapper = get(mergedWrapper, _size), wrapperObj = typeof wrapper == "object" ? wrapper : {};
      "span" in formLabelObj && !("offset" in wrapperObj) && formLabelObj.span < GRID_MAX && (mergedWrapper = set(mergedWrapper, [].concat(_size, ["offset"]), formLabelObj.span));
    }), mergedWrapper;
  }, [wrapperCol, formContext]), className = cn(`${baseClassName}-control`, mergedWrapperCol.className), subFormContext = React.useMemo(() => {
    const {
      labelCol: labelCol2,
      wrapperCol: wrapperCol2
    } = formContext;
    return __rest$h(formContext, ["labelCol", "wrapperCol"]);
  }, [formContext]), extraRef = React.useRef(null), [extraHeight, setExtraHeight] = React.useState(0);
  useLayoutEffect$1(() => {
    extra && extraRef.current ? setExtraHeight(extraRef.current.clientHeight) : setExtraHeight(0);
  }, [extra]);
  const inputDom = /* @__PURE__ */ React.createElement("div", {
    className: `${baseClassName}-control-input`
  }, /* @__PURE__ */ React.createElement("div", {
    className: `${baseClassName}-control-input-content`
  }, children)), formItemContext = React.useMemo(() => ({
    prefixCls,
    status
  }), [prefixCls, status]), errorListDom = marginBottom !== null || errors.length || warnings.length ? /* @__PURE__ */ React.createElement(FormItemPrefixContext.Provider, {
    value: formItemContext
  }, /* @__PURE__ */ React.createElement(ErrorList, {
    fieldId,
    errors,
    warnings,
    help,
    helpStatus: status,
    className: `${baseClassName}-explain-connected`,
    onVisibleChanged: onErrorVisibleChanged
  })) : null, extraProps = {};
  fieldId && (extraProps.id = `${fieldId}_extra`);
  const extraDom = extra ? /* @__PURE__ */ React.createElement("div", Object.assign({}, extraProps, {
    className: `${baseClassName}-extra`,
    ref: extraRef
  }), extra) : null, additionalDom = errorListDom || extraDom ? /* @__PURE__ */ React.createElement("div", {
    className: `${baseClassName}-additional`,
    style: marginBottom ? {
      minHeight: marginBottom + extraHeight
    } : {}
  }, errorListDom, extraDom) : null, dom = formItemRender && formItemRender.mark === "pro_table_render" && formItemRender.render ? formItemRender.render(props, {
    input: inputDom,
    errorList: errorListDom,
    extra: extraDom
  }) : /* @__PURE__ */ React.createElement(React.Fragment, null, inputDom, additionalDom);
  return /* @__PURE__ */ React.createElement(FormContext.Provider, {
    value: subFormContext
  }, /* @__PURE__ */ React.createElement(Col, Object.assign({}, mergedWrapperCol, {
    className
  }), dom), /* @__PURE__ */ React.createElement(FallbackCmp, {
    prefixCls
  }));
}, "FormItemInput");
var QuestionCircleOutlined$1 = { icon: { tag: "svg", attrs: { viewBox: "64 64 896 896", focusable: "false" }, children: [{ tag: "path", attrs: { d: "M512 64C264.6 64 64 264.6 64 512s200.6 448 448 448 448-200.6 448-448S759.4 64 512 64zm0 820c-205.4 0-372-166.6-372-372s166.6-372 372-372 372 166.6 372 372-166.6 372-372 372z" } }, { tag: "path", attrs: { d: "M623.6 316.7C593.6 290.4 554 276 512 276s-81.6 14.5-111.6 40.7C369.2 344 352 380.7 352 420v7.6c0 4.4 3.6 8 8 8h48c4.4 0 8-3.6 8-8V420c0-44.1 43.1-80 96-80s96 35.9 96 80c0 31.1-22 59.6-56.1 72.7-21.2 8.1-39.2 22.3-52.1 40.9-13.1 19-19.9 41.8-19.9 64.9V620c0 4.4 3.6 8 8 8h48c4.4 0 8-3.6 8-8v-22.7a48.3 48.3 0 0130.9-44.8c59-22.7 97.1-74.7 97.1-132.5.1-39.3-17.1-76-48.3-103.3zM472 732a40 40 0 1080 0 40 40 0 10-80 0z" } }] }, name: "question-circle", theme: "outlined" }, QuestionCircleOutlined = /* @__PURE__ */ __name(function(props, ref) {
  return /* @__PURE__ */ React.createElement(Icon$3, _extends({}, props, {
    ref,
    icon: QuestionCircleOutlined$1
  }));
}, "QuestionCircleOutlined"), RefIcon$k = /* @__PURE__ */ React.forwardRef(QuestionCircleOutlined);
process.env.NODE_ENV !== "production" && (RefIcon$k.displayName = "QuestionCircleOutlined");
var __rest$g = function(s, e2) {
  var t2 = {};
  for (var p in s) Object.prototype.hasOwnProperty.call(s, p) && e2.indexOf(p) < 0 && (t2[p] = s[p]);
  if (s != null && typeof Object.getOwnPropertySymbols == "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++)
    e2.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]) && (t2[p[i]] = s[p[i]]);
  return t2;
};
function toTooltipProps(tooltip) {
  return tooltip ? typeof tooltip == "object" && !/* @__PURE__ */ React.isValidElement(tooltip) ? tooltip : {
    title: tooltip
  } : null;
}
__name(toTooltipProps, "toTooltipProps");
const FormItemLabel = /* @__PURE__ */ __name((_ref) => {
  let {
    prefixCls,
    label: label2,
    htmlFor,
    labelCol,
    labelAlign,
    colon,
    required: required4,
    requiredMark,
    tooltip,
    vertical
  } = _ref;
  var _a;
  const [formLocale] = useLocale$1("Form"), {
    labelAlign: contextLabelAlign,
    labelCol: contextLabelCol,
    labelWrap,
    colon: contextColon
  } = React.useContext(FormContext);
  if (!label2)
    return null;
  const mergedLabelCol = labelCol || contextLabelCol || {}, mergedLabelAlign = labelAlign || contextLabelAlign, labelClsBasic = `${prefixCls}-item-label`, labelColClassName = cn(labelClsBasic, mergedLabelAlign === "left" && `${labelClsBasic}-left`, mergedLabelCol.className, {
    [`${labelClsBasic}-wrap`]: !!labelWrap
  });
  let labelChildren = label2;
  const computedColon = colon === !0 || contextColon !== !1 && colon !== !1;
  computedColon && !vertical && typeof label2 == "string" && label2.trim() && (labelChildren = label2.replace(/[:|：]\s*$/, ""));
  const tooltipProps = toTooltipProps(tooltip);
  if (tooltipProps) {
    const {
      icon = /* @__PURE__ */ React.createElement(RefIcon$k, null)
    } = tooltipProps, restTooltipProps = __rest$g(tooltipProps, ["icon"]), tooltipNode = /* @__PURE__ */ React.createElement(Tooltip$1, Object.assign({}, restTooltipProps), /* @__PURE__ */ React.cloneElement(icon, {
      className: `${prefixCls}-item-tooltip`,
      title: "",
      onClick: /* @__PURE__ */ __name((e2) => {
        e2.preventDefault();
      }, "onClick"),
      tabIndex: null
    }));
    labelChildren = /* @__PURE__ */ React.createElement(React.Fragment, null, labelChildren, tooltipNode);
  }
  const isOptionalMark = requiredMark === "optional", isRenderMark = typeof requiredMark == "function";
  isRenderMark ? labelChildren = requiredMark(labelChildren, {
    required: !!required4
  }) : isOptionalMark && !required4 && (labelChildren = /* @__PURE__ */ React.createElement(React.Fragment, null, labelChildren, /* @__PURE__ */ React.createElement("span", {
    className: `${prefixCls}-item-optional`,
    title: ""
  }, (formLocale == null ? void 0 : formLocale.optional) || ((_a = localeValues$1.Form) === null || _a === void 0 ? void 0 : _a.optional))));
  const labelClassName = cn({
    [`${prefixCls}-item-required`]: required4,
    [`${prefixCls}-item-required-mark-optional`]: isOptionalMark || isRenderMark,
    [`${prefixCls}-item-no-colon`]: !computedColon
  });
  return /* @__PURE__ */ React.createElement(Col, Object.assign({}, mergedLabelCol, {
    className: labelColClassName
  }), /* @__PURE__ */ React.createElement("label", {
    htmlFor,
    className: labelClassName,
    title: typeof label2 == "string" ? label2 : ""
  }, labelChildren));
}, "FormItemLabel"), iconMap = {
  success: RefIcon$D,
  warning: RefIcon$A,
  error: RefIcon$C,
  validating: RefIcon$z
};
function StatusProvider(_ref) {
  let {
    children,
    errors,
    warnings,
    hasFeedback,
    validateStatus,
    prefixCls,
    meta,
    noStyle
  } = _ref;
  const itemPrefixCls = `${prefixCls}-item`, {
    feedbackIcons
  } = React.useContext(FormContext), mergedValidateStatus = getStatus(errors, warnings, meta, null, !!hasFeedback, validateStatus), {
    isFormItemInput: parentIsFormItemInput,
    status: parentStatus,
    hasFeedback: parentHasFeedback,
    feedbackIcon: parentFeedbackIcon
  } = React.useContext(FormItemInputContext), formItemStatusContext = React.useMemo(() => {
    var _a;
    let feedbackIcon;
    if (hasFeedback) {
      const customIcons = hasFeedback !== !0 && hasFeedback.icons || feedbackIcons, customIconNode = mergedValidateStatus && ((_a = customIcons == null ? void 0 : customIcons({
        status: mergedValidateStatus,
        errors,
        warnings
      })) === null || _a === void 0 ? void 0 : _a[mergedValidateStatus]), IconNode = mergedValidateStatus && iconMap[mergedValidateStatus];
      feedbackIcon = customIconNode !== !1 && IconNode ? /* @__PURE__ */ React.createElement("span", {
        className: cn(`${itemPrefixCls}-feedback-icon`, `${itemPrefixCls}-feedback-icon-${mergedValidateStatus}`)
      }, customIconNode || /* @__PURE__ */ React.createElement(IconNode, null)) : null;
    }
    const context = {
      status: mergedValidateStatus || "",
      errors,
      warnings,
      hasFeedback: !!hasFeedback,
      feedbackIcon,
      isFormItemInput: !0
    };
    return noStyle && (context.status = (mergedValidateStatus ?? parentStatus) || "", context.isFormItemInput = parentIsFormItemInput, context.hasFeedback = !!(hasFeedback ?? parentHasFeedback), context.feedbackIcon = hasFeedback !== void 0 ? context.feedbackIcon : parentFeedbackIcon), context;
  }, [mergedValidateStatus, hasFeedback, noStyle, parentIsFormItemInput, parentStatus]);
  return /* @__PURE__ */ React.createElement(FormItemInputContext.Provider, {
    value: formItemStatusContext
  }, children);
}
__name(StatusProvider, "StatusProvider");
var __rest$f = function(s, e2) {
  var t2 = {};
  for (var p in s) Object.prototype.hasOwnProperty.call(s, p) && e2.indexOf(p) < 0 && (t2[p] = s[p]);
  if (s != null && typeof Object.getOwnPropertySymbols == "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++)
    e2.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]) && (t2[p[i]] = s[p[i]]);
  return t2;
};
function ItemHolder(props) {
  const {
    prefixCls,
    className,
    rootClassName,
    style: style2,
    help,
    errors,
    warnings,
    validateStatus,
    meta,
    hasFeedback,
    hidden: hidden2,
    children,
    fieldId,
    required: required4,
    isRequired,
    onSubItemMetaChange,
    layout
  } = props, restProps = __rest$f(props, ["prefixCls", "className", "rootClassName", "style", "help", "errors", "warnings", "validateStatus", "meta", "hasFeedback", "hidden", "children", "fieldId", "required", "isRequired", "onSubItemMetaChange", "layout"]), itemPrefixCls = `${prefixCls}-item`, {
    requiredMark,
    vertical: formVertical
  } = React.useContext(FormContext), vertical = formVertical || layout === "vertical", itemRef = React.useRef(null), debounceErrors = useDebounce(errors), debounceWarnings = useDebounce(warnings), hasHelp = help != null, hasError = !!(hasHelp || errors.length || warnings.length), isOnScreen = !!itemRef.current && isVisible(itemRef.current), [marginBottom, setMarginBottom] = React.useState(null);
  useLayoutEffect$1(() => {
    if (hasError && itemRef.current) {
      const itemStyle = getComputedStyle(itemRef.current);
      setMarginBottom(parseInt(itemStyle.marginBottom, 10));
    }
  }, [hasError, isOnScreen]);
  const onErrorVisibleChanged = /* @__PURE__ */ __name((nextVisible) => {
    nextVisible || setMarginBottom(null);
  }, "onErrorVisibleChanged"), mergedValidateStatus = (/* @__PURE__ */ __name(function() {
    let isDebounce = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : !1;
    const _errors = isDebounce ? debounceErrors : meta.errors, _warnings = isDebounce ? debounceWarnings : meta.warnings;
    return getStatus(_errors, _warnings, meta, "", !!hasFeedback, validateStatus);
  }, "getValidateState"))(), itemClassName = cn(itemPrefixCls, className, rootClassName, {
    [`${itemPrefixCls}-with-help`]: hasHelp || debounceErrors.length || debounceWarnings.length,
    // Status
    [`${itemPrefixCls}-has-feedback`]: mergedValidateStatus && hasFeedback,
    [`${itemPrefixCls}-has-success`]: mergedValidateStatus === "success",
    [`${itemPrefixCls}-has-warning`]: mergedValidateStatus === "warning",
    [`${itemPrefixCls}-has-error`]: mergedValidateStatus === "error",
    [`${itemPrefixCls}-is-validating`]: mergedValidateStatus === "validating",
    [`${itemPrefixCls}-hidden`]: hidden2,
    // Layout
    [`${itemPrefixCls}-${layout}`]: layout
  });
  return /* @__PURE__ */ React.createElement("div", {
    className: itemClassName,
    style: style2,
    ref: itemRef
  }, /* @__PURE__ */ React.createElement(Row, Object.assign({
    className: `${itemPrefixCls}-row`
  }, omit(restProps, [
    "_internalItemRender",
    "colon",
    "dependencies",
    "extra",
    "fieldKey",
    "getValueFromEvent",
    "getValueProps",
    "htmlFor",
    "id",
    // It is deprecated because `htmlFor` is its replacement.
    "initialValue",
    "isListField",
    "label",
    "labelAlign",
    "labelCol",
    "labelWrap",
    "messageVariables",
    "name",
    "normalize",
    "noStyle",
    "preserve",
    "requiredMark",
    "rules",
    "shouldUpdate",
    "trigger",
    "tooltip",
    "validateFirst",
    "validateTrigger",
    "valuePropName",
    "wrapperCol",
    "validateDebounce"
  ])), /* @__PURE__ */ React.createElement(FormItemLabel, Object.assign({
    htmlFor: fieldId
  }, props, {
    requiredMark,
    required: required4 ?? isRequired,
    prefixCls,
    vertical
  })), /* @__PURE__ */ React.createElement(FormItemInput, Object.assign({}, props, meta, {
    errors: debounceErrors,
    warnings: debounceWarnings,
    prefixCls,
    status: mergedValidateStatus,
    help,
    marginBottom,
    onErrorVisibleChanged
  }), /* @__PURE__ */ React.createElement(NoStyleItemContext.Provider, {
    value: onSubItemMetaChange
  }, /* @__PURE__ */ React.createElement(StatusProvider, {
    prefixCls,
    meta,
    errors: meta.errors,
    warnings: meta.warnings,
    hasFeedback,
    // Already calculated
    validateStatus: mergedValidateStatus
  }, children)))), !!marginBottom && /* @__PURE__ */ React.createElement("div", {
    className: `${itemPrefixCls}-margin-offset`,
    style: {
      marginBottom: -marginBottom
    }
  }));
}
__name(ItemHolder, "ItemHolder");
const NAME_SPLIT = "__SPLIT__";
function isSimilarControl(a, b) {
  const keysA = Object.keys(a), keysB = Object.keys(b);
  return keysA.length === keysB.length && keysA.every((key) => {
    const propValueA = a[key], propValueB = b[key];
    return propValueA === propValueB || typeof propValueA == "function" || typeof propValueB == "function";
  });
}
__name(isSimilarControl, "isSimilarControl");
const MemoInput = /* @__PURE__ */ React.memo((_ref) => {
  let {
    children
  } = _ref;
  return children;
}, (prev2, next2) => isSimilarControl(prev2.control, next2.control) && prev2.update === next2.update && prev2.childProps.length === next2.childProps.length && prev2.childProps.every((value, index2) => value === next2.childProps[index2]));
function genEmptyMeta() {
  return {
    errors: [],
    warnings: [],
    touched: !1,
    validating: !1,
    name: [],
    validated: !1
  };
}
__name(genEmptyMeta, "genEmptyMeta");
function InternalFormItem(props) {
  const {
    name,
    noStyle,
    className,
    dependencies,
    prefixCls: customizePrefixCls,
    shouldUpdate,
    rules: rules2,
    children,
    required: required4,
    label: label2,
    messageVariables,
    trigger = "onChange",
    validateTrigger,
    hidden: hidden2,
    help,
    layout
  } = props, {
    getPrefixCls
  } = React.useContext(ConfigContext), {
    name: formName
  } = React.useContext(FormContext), mergedChildren = useChildren(children), isRenderProps = typeof mergedChildren == "function", notifyParentMetaChange = React.useContext(NoStyleItemContext), {
    validateTrigger: contextValidateTrigger
  } = React.useContext(Context), mergedValidateTrigger = validateTrigger !== void 0 ? validateTrigger : contextValidateTrigger, hasName = name != null, prefixCls = getPrefixCls("form", customizePrefixCls), rootCls = useCSSVarCls(prefixCls), [wrapCSSVar, hashId, cssVarCls] = useStyle$8(prefixCls, rootCls), warning3 = devUseWarning("Form.Item");
  process.env.NODE_ENV !== "production" && process.env.NODE_ENV !== "production" && warning3(name !== null, "usage", "`null` is passed as `name` property");
  const listContext = React.useContext(ListContext), fieldKeyPathRef = React.useRef(null), [subFieldErrors, setSubFieldErrors] = useFrameState({}), [meta, setMeta] = useSafeState(() => genEmptyMeta()), onMetaChange = /* @__PURE__ */ __name((nextMeta) => {
    const keyInfo = listContext == null ? void 0 : listContext.getKey(nextMeta.name);
    if (setMeta(nextMeta.destroy ? genEmptyMeta() : nextMeta, !0), noStyle && help !== !1 && notifyParentMetaChange) {
      let namePath = nextMeta.name;
      if (nextMeta.destroy)
        namePath = fieldKeyPathRef.current || namePath;
      else if (keyInfo !== void 0) {
        const [fieldKey, restPath] = keyInfo;
        namePath = [fieldKey].concat(_toConsumableArray(restPath)), fieldKeyPathRef.current = namePath;
      }
      notifyParentMetaChange(nextMeta, namePath);
    }
  }, "onMetaChange"), onSubItemMetaChange = /* @__PURE__ */ __name((subMeta, uniqueKeys) => {
    setSubFieldErrors((prevSubFieldErrors) => {
      const clone = Object.assign({}, prevSubFieldErrors), mergedNameKey = [].concat(_toConsumableArray(subMeta.name.slice(0, -1)), _toConsumableArray(uniqueKeys)).join(NAME_SPLIT);
      return subMeta.destroy ? delete clone[mergedNameKey] : clone[mergedNameKey] = subMeta, clone;
    });
  }, "onSubItemMetaChange"), [mergedErrors, mergedWarnings] = React.useMemo(() => {
    const errorList = _toConsumableArray(meta.errors), warningList = _toConsumableArray(meta.warnings);
    return Object.values(subFieldErrors).forEach((subFieldError) => {
      errorList.push.apply(errorList, _toConsumableArray(subFieldError.errors || [])), warningList.push.apply(warningList, _toConsumableArray(subFieldError.warnings || []));
    }), [errorList, warningList];
  }, [subFieldErrors, meta.errors, meta.warnings]), getItemRef = useItemRef();
  function renderLayout(baseChildren, fieldId, isRequired) {
    return noStyle && !hidden2 ? /* @__PURE__ */ React.createElement(StatusProvider, {
      prefixCls,
      hasFeedback: props.hasFeedback,
      validateStatus: props.validateStatus,
      meta,
      errors: mergedErrors,
      warnings: mergedWarnings,
      noStyle: !0
    }, baseChildren) : /* @__PURE__ */ React.createElement(ItemHolder, Object.assign({
      key: "row"
    }, props, {
      className: cn(className, cssVarCls, rootCls, hashId),
      prefixCls,
      fieldId,
      isRequired,
      errors: mergedErrors,
      warnings: mergedWarnings,
      meta,
      onSubItemMetaChange,
      layout
    }), baseChildren);
  }
  if (__name(renderLayout, "renderLayout"), !hasName && !isRenderProps && !dependencies)
    return wrapCSSVar(renderLayout(mergedChildren));
  let variables = {};
  return typeof label2 == "string" ? variables.label = label2 : name && (variables.label = String(name)), messageVariables && (variables = Object.assign(Object.assign({}, variables), messageVariables)), wrapCSSVar(/* @__PURE__ */ React.createElement(WrapperField, Object.assign({}, props, {
    messageVariables: variables,
    trigger,
    validateTrigger: mergedValidateTrigger,
    onMetaChange
  }), (control, renderMeta, context) => {
    const mergedName = toArray$2(name).length && renderMeta ? renderMeta.name : [], fieldId = getFieldId(mergedName, formName), isRequired = required4 !== void 0 ? required4 : !!(rules2 != null && rules2.some((rule) => {
      if (rule && typeof rule == "object" && rule.required && !rule.warningOnly)
        return !0;
      if (typeof rule == "function") {
        const ruleEntity = rule(context);
        return (ruleEntity == null ? void 0 : ruleEntity.required) && !(ruleEntity != null && ruleEntity.warningOnly);
      }
      return !1;
    })), mergedControl = Object.assign({}, control);
    let childNode = null;
    if (process.env.NODE_ENV !== "production" && warning3(!(shouldUpdate && dependencies), "usage", "`shouldUpdate` and `dependencies` shouldn't be used together. See https://u.ant.design/form-deps."), Array.isArray(mergedChildren) && hasName)
      process.env.NODE_ENV !== "production" && warning3(!1, "usage", "A `Form.Item` with a `name` prop must have a single child element. For information on how to render more complex form items, see https://u.ant.design/complex-form-item."), childNode = mergedChildren;
    else if (isRenderProps && (!(shouldUpdate || dependencies) || hasName))
      process.env.NODE_ENV !== "production" && warning3(!!(shouldUpdate || dependencies), "usage", "A `Form.Item` with a render function must have either `shouldUpdate` or `dependencies`."), process.env.NODE_ENV !== "production" && warning3(!hasName, "usage", "A `Form.Item` with a render function cannot be a field, and thus cannot have a `name` prop.");
    else if (dependencies && !isRenderProps && !hasName)
      process.env.NODE_ENV !== "production" && warning3(!1, "usage", "Must set `name` or use a render function when `dependencies` is set.");
    else if (/* @__PURE__ */ React.isValidElement(mergedChildren)) {
      process.env.NODE_ENV !== "production" && warning3(mergedChildren.props.defaultValue === void 0, "usage", "`defaultValue` will not work on controlled Field. You should use `initialValues` of Form instead.");
      const childProps = Object.assign(Object.assign({}, mergedChildren.props), mergedControl);
      if (childProps.id || (childProps.id = fieldId), help || mergedErrors.length > 0 || mergedWarnings.length > 0 || props.extra) {
        const describedbyArr = [];
        (help || mergedErrors.length > 0) && describedbyArr.push(`${fieldId}_help`), props.extra && describedbyArr.push(`${fieldId}_extra`), childProps["aria-describedby"] = describedbyArr.join(" ");
      }
      mergedErrors.length > 0 && (childProps["aria-invalid"] = "true"), isRequired && (childProps["aria-required"] = "true"), supportRef(mergedChildren) && (childProps.ref = getItemRef(mergedName, mergedChildren)), new Set([].concat(_toConsumableArray(toArray$2(trigger)), _toConsumableArray(toArray$2(mergedValidateTrigger)))).forEach((eventName) => {
        childProps[eventName] = function() {
          for (var _a2, _c2, _a, _b, _c, _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++)
            args[_key] = arguments[_key];
          (_a = mergedControl[eventName]) === null || _a === void 0 || (_a2 = _a).call.apply(_a2, [mergedControl].concat(args)), (_c = (_b = mergedChildren.props)[eventName]) === null || _c === void 0 || (_c2 = _c).call.apply(_c2, [_b].concat(args));
        };
      });
      const watchingChildProps = [childProps["aria-required"], childProps["aria-invalid"], childProps["aria-describedby"]];
      childNode = /* @__PURE__ */ React.createElement(MemoInput, {
        control: mergedControl,
        update: mergedChildren,
        childProps: watchingChildProps
      }, cloneElement(mergedChildren, childProps));
    } else isRenderProps && (shouldUpdate || dependencies) && !hasName ? childNode = mergedChildren(context) : (process.env.NODE_ENV !== "production" && warning3(!mergedName.length || !!noStyle, "usage", "`name` is only used for validate React element. If you are using Form.Item as layout display, please remove `name` instead."), childNode = mergedChildren);
    return renderLayout(childNode, fieldId, isRequired);
  }));
}
__name(InternalFormItem, "InternalFormItem");
const FormItem$1 = InternalFormItem;
FormItem$1.useStatus = useFormItemStatus;
var __rest$e = function(s, e2) {
  var t2 = {};
  for (var p in s) Object.prototype.hasOwnProperty.call(s, p) && e2.indexOf(p) < 0 && (t2[p] = s[p]);
  if (s != null && typeof Object.getOwnPropertySymbols == "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++)
    e2.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]) && (t2[p[i]] = s[p[i]]);
  return t2;
};
const FormList = /* @__PURE__ */ __name((_a) => {
  var {
    prefixCls: customizePrefixCls,
    children
  } = _a, props = __rest$e(_a, ["prefixCls", "children"]);
  if (process.env.NODE_ENV !== "production") {
    const warning3 = devUseWarning("Form.List");
    process.env.NODE_ENV !== "production" && warning3(typeof props.name == "number" || (Array.isArray(props.name) ? !!props.name.length : !!props.name), "usage", "Miss `name` prop.");
  }
  const {
    getPrefixCls
  } = React.useContext(ConfigContext), prefixCls = getPrefixCls("form", customizePrefixCls), contextValue = React.useMemo(() => ({
    prefixCls,
    status: "error"
  }), [prefixCls]);
  return /* @__PURE__ */ React.createElement(List$1, Object.assign({}, props), (fields, operation, meta) => /* @__PURE__ */ React.createElement(FormItemPrefixContext.Provider, {
    value: contextValue
  }, children(fields.map((field) => Object.assign(Object.assign({}, field), {
    fieldKey: field.key
  })), operation, {
    errors: meta.errors,
    warnings: meta.warnings
  })));
}, "FormList");
function useFormInstance() {
  const {
    form
  } = React.useContext(FormContext);
  return form;
}
__name(useFormInstance, "useFormInstance");
const Form$1 = Form$2;
Form$1.Item = FormItem$1;
Form$1.List = FormList;
Form$1.ErrorList = ErrorList;
Form$1.useForm = useForm;
Form$1.useFormInstance = useFormInstance;
Form$1.useWatch = useWatch$1;
Form$1.Provider = FormProvider2;
Form$1.create = () => {
  process.env.NODE_ENV !== "production" && warning$2(!1, "Form", "antd v4 removed `Form.create`. Please remove or use `@ant-design/compatible` instead.");
};
function getClientSize() {
  var width = document.documentElement.clientWidth, height = window.innerHeight || document.documentElement.clientHeight;
  return {
    width,
    height
  };
}
__name(getClientSize, "getClientSize");
function getOffset(node2) {
  var box = node2.getBoundingClientRect(), docElem = document.documentElement;
  return {
    left: box.left + (window.pageXOffset || docElem.scrollLeft) - (docElem.clientLeft || document.body.clientLeft || 0),
    top: box.top + (window.pageYOffset || docElem.scrollTop) - (docElem.clientTop || document.body.clientTop || 0)
  };
}
__name(getOffset, "getOffset");
function addEventListenerWrap(target, eventType, cb, option) {
  var callback = ReactDOM__default.unstable_batchedUpdates ? /* @__PURE__ */ __name(function(e2) {
    ReactDOM__default.unstable_batchedUpdates(cb, e2);
  }, "run") : cb;
  return target != null && target.addEventListener && target.addEventListener(eventType, callback, option), {
    remove: /* @__PURE__ */ __name(function() {
      target != null && target.removeEventListener && target.removeEventListener(eventType, callback, option);
    }, "remove")
  };
}
__name(addEventListenerWrap, "addEventListenerWrap");
function useHasSider(siders, children, hasSider) {
  return typeof hasSider == "boolean" ? hasSider : siders.length ? !0 : toArray$7(children).some((node2) => node2.type === Sider);
}
__name(useHasSider, "useHasSider");
var __rest$d = function(s, e2) {
  var t2 = {};
  for (var p in s) Object.prototype.hasOwnProperty.call(s, p) && e2.indexOf(p) < 0 && (t2[p] = s[p]);
  if (s != null && typeof Object.getOwnPropertySymbols == "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++)
    e2.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]) && (t2[p[i]] = s[p[i]]);
  return t2;
};
function generator(_ref) {
  let {
    suffixCls,
    tagName,
    displayName
  } = _ref;
  return (BasicComponent) => {
    const Adapter = /* @__PURE__ */ React.forwardRef((props, ref) => /* @__PURE__ */ React.createElement(BasicComponent, Object.assign({
      ref,
      suffixCls,
      tagName
    }, props)));
    return process.env.NODE_ENV !== "production" && (Adapter.displayName = displayName), Adapter;
  };
}
__name(generator, "generator");
const Basic = /* @__PURE__ */ React.forwardRef((props, ref) => {
  const {
    prefixCls: customizePrefixCls,
    suffixCls,
    className,
    tagName: TagName
  } = props, others = __rest$d(props, ["prefixCls", "suffixCls", "className", "tagName"]), {
    getPrefixCls
  } = React.useContext(ConfigContext), prefixCls = getPrefixCls("layout", customizePrefixCls), [wrapSSR, hashId, cssVarCls] = useStyle$l(prefixCls), prefixWithSuffixCls = suffixCls ? `${prefixCls}-${suffixCls}` : prefixCls;
  return wrapSSR(/* @__PURE__ */ React.createElement(TagName, Object.assign({
    className: cn(customizePrefixCls || prefixWithSuffixCls, className, hashId, cssVarCls),
    ref
  }, others)));
}), BasicLayout = /* @__PURE__ */ React.forwardRef((props, ref) => {
  const {
    direction
  } = React.useContext(ConfigContext), [siders, setSiders] = React.useState([]), {
    prefixCls: customizePrefixCls,
    className,
    rootClassName,
    children,
    hasSider,
    tagName: Tag,
    style: style2
  } = props, others = __rest$d(props, ["prefixCls", "className", "rootClassName", "children", "hasSider", "tagName", "style"]), passedProps = omit(others, ["suffixCls"]), {
    getPrefixCls,
    layout
  } = React.useContext(ConfigContext), prefixCls = getPrefixCls("layout", customizePrefixCls), mergedHasSider = useHasSider(siders, children, hasSider), [wrapCSSVar, hashId, cssVarCls] = useStyle$l(prefixCls), classString = cn(prefixCls, {
    [`${prefixCls}-has-sider`]: mergedHasSider,
    [`${prefixCls}-rtl`]: direction === "rtl"
  }, layout == null ? void 0 : layout.className, className, rootClassName, hashId, cssVarCls), contextValue = React.useMemo(() => ({
    siderHook: {
      addSider: /* @__PURE__ */ __name((id2) => {
        setSiders((prev2) => [].concat(_toConsumableArray(prev2), [id2]));
      }, "addSider"),
      removeSider: /* @__PURE__ */ __name((id2) => {
        setSiders((prev2) => prev2.filter((currentId) => currentId !== id2));
      }, "removeSider")
    }
  }), []);
  return wrapCSSVar(/* @__PURE__ */ React.createElement(LayoutContext.Provider, {
    value: contextValue
  }, /* @__PURE__ */ React.createElement(Tag, Object.assign({
    ref,
    className: classString,
    style: Object.assign(Object.assign({}, layout == null ? void 0 : layout.style), style2)
  }, passedProps), children)));
}), Layout$1 = generator({
  tagName: "div",
  displayName: "Layout"
})(BasicLayout), Header$3 = generator({
  suffixCls: "header",
  tagName: "header",
  displayName: "Header"
})(Basic), Footer$2 = generator({
  suffixCls: "footer",
  tagName: "footer",
  displayName: "Footer"
})(Basic), Content = generator({
  suffixCls: "content",
  tagName: "main",
  displayName: "Content"
})(Basic), Layout = Layout$1;
Layout.Header = Header$3;
Layout.Footer = Footer$2;
Layout.Content = Content;
Layout.Sider = Sider;
Layout._InternalSiderContext = SiderContext;
const extendsObject = /* @__PURE__ */ __name(function() {
  const result = Object.assign({}, arguments.length <= 0 ? void 0 : arguments[0]);
  for (let i = 1; i < arguments.length; i++) {
    const obj = i < 0 || arguments.length <= i ? void 0 : arguments[i];
    obj && Object.keys(obj).forEach((key) => {
      const val = obj[key];
      val !== void 0 && (result[key] = val);
    });
  }
  return result;
}, "extendsObject");
var DoubleLeftOutlined$1 = { icon: { tag: "svg", attrs: { viewBox: "64 64 896 896", focusable: "false" }, children: [{ tag: "path", attrs: { d: "M272.9 512l265.4-339.1c4.1-5.2.4-12.9-6.3-12.9h-77.3c-4.9 0-9.6 2.3-12.6 6.1L186.8 492.3a31.99 31.99 0 000 39.5l255.3 326.1c3 3.9 7.7 6.1 12.6 6.1H532c6.7 0 10.4-7.7 6.3-12.9L272.9 512zm304 0l265.4-339.1c4.1-5.2.4-12.9-6.3-12.9h-77.3c-4.9 0-9.6 2.3-12.6 6.1L490.8 492.3a31.99 31.99 0 000 39.5l255.3 326.1c3 3.9 7.7 6.1 12.6 6.1H836c6.7 0 10.4-7.7 6.3-12.9L576.9 512z" } }] }, name: "double-left", theme: "outlined" }, DoubleLeftOutlined = /* @__PURE__ */ __name(function(props, ref) {
  return /* @__PURE__ */ React.createElement(Icon$3, _extends({}, props, {
    ref,
    icon: DoubleLeftOutlined$1
  }));
}, "DoubleLeftOutlined"), RefIcon$j = /* @__PURE__ */ React.forwardRef(DoubleLeftOutlined);
process.env.NODE_ENV !== "production" && (RefIcon$j.displayName = "DoubleLeftOutlined");
var DoubleRightOutlined$1 = { icon: { tag: "svg", attrs: { viewBox: "64 64 896 896", focusable: "false" }, children: [{ tag: "path", attrs: { d: "M533.2 492.3L277.9 166.1c-3-3.9-7.7-6.1-12.6-6.1H188c-6.7 0-10.4 7.7-6.3 12.9L447.1 512 181.7 851.1A7.98 7.98 0 00188 864h77.3c4.9 0 9.6-2.3 12.6-6.1l255.3-326.1c9.1-11.7 9.1-27.9 0-39.5zm304 0L581.9 166.1c-3-3.9-7.7-6.1-12.6-6.1H492c-6.7 0-10.4 7.7-6.3 12.9L751.1 512 485.7 851.1A7.98 7.98 0 00492 864h77.3c4.9 0 9.6-2.3 12.6-6.1l255.3-326.1c9.1-11.7 9.1-27.9 0-39.5z" } }] }, name: "double-right", theme: "outlined" }, DoubleRightOutlined = /* @__PURE__ */ __name(function(props, ref) {
  return /* @__PURE__ */ React.createElement(Icon$3, _extends({}, props, {
    ref,
    icon: DoubleRightOutlined$1
  }));
}, "DoubleRightOutlined"), RefIcon$i = /* @__PURE__ */ React.forwardRef(DoubleRightOutlined);
process.env.NODE_ENV !== "production" && (RefIcon$i.displayName = "DoubleRightOutlined");
var locale$4 = {
  // Options
  items_per_page: "条/页",
  jump_to: "跳至",
  jump_to_confirm: "确定",
  page: "页",
  // Pagination
  prev_page: "上一页",
  next_page: "下一页",
  prev_5: "向前 5 页",
  next_5: "向后 5 页",
  prev_3: "向前 3 页",
  next_3: "向后 3 页",
  page_size: "页码"
}, defaultPageSizeOptions = [10, 20, 50, 100], Options = /* @__PURE__ */ __name(function(props) {
  var _props$pageSizeOption = props.pageSizeOptions, pageSizeOptions = _props$pageSizeOption === void 0 ? defaultPageSizeOptions : _props$pageSizeOption, locale2 = props.locale, changeSize = props.changeSize, pageSize = props.pageSize, goButton = props.goButton, quickGo = props.quickGo, rootPrefixCls = props.rootPrefixCls, disabled = props.disabled, buildOptionText = props.buildOptionText, showSizeChanger = props.showSizeChanger, sizeChangerRender = props.sizeChangerRender, _React$useState = React__default.useState(""), _React$useState2 = _slicedToArray(_React$useState, 2), goInputText = _React$useState2[0], setGoInputText = _React$useState2[1], getValidValue = /* @__PURE__ */ __name(function() {
    return !goInputText || Number.isNaN(goInputText) ? void 0 : Number(goInputText);
  }, "getValidValue"), mergeBuildOptionText = typeof buildOptionText == "function" ? buildOptionText : function(value) {
    return "".concat(value, " ").concat(locale2.items_per_page);
  }, handleChange = /* @__PURE__ */ __name(function(e2) {
    setGoInputText(e2.target.value);
  }, "handleChange"), handleBlur = /* @__PURE__ */ __name(function(e2) {
    goButton || goInputText === "" || (setGoInputText(""), !(e2.relatedTarget && (e2.relatedTarget.className.indexOf("".concat(rootPrefixCls, "-item-link")) >= 0 || e2.relatedTarget.className.indexOf("".concat(rootPrefixCls, "-item")) >= 0)) && (quickGo == null || quickGo(getValidValue())));
  }, "handleBlur"), go = /* @__PURE__ */ __name(function(e2) {
    goInputText !== "" && (e2.keyCode === KeyCode.ENTER || e2.type === "click") && (setGoInputText(""), quickGo == null || quickGo(getValidValue()));
  }, "go"), getPageSizeOptions = /* @__PURE__ */ __name(function() {
    return pageSizeOptions.some(function(option) {
      return option.toString() === pageSize.toString();
    }) ? pageSizeOptions : pageSizeOptions.concat([pageSize]).sort(function(a, b) {
      var numberA = Number.isNaN(Number(a)) ? 0 : Number(a), numberB = Number.isNaN(Number(b)) ? 0 : Number(b);
      return numberA - numberB;
    });
  }, "getPageSizeOptions"), prefixCls = "".concat(rootPrefixCls, "-options");
  if (!showSizeChanger && !quickGo)
    return null;
  var changeSelect = null, goInput = null, gotoButton = null;
  return showSizeChanger && sizeChangerRender && (changeSelect = sizeChangerRender({
    disabled,
    size: pageSize,
    onSizeChange: /* @__PURE__ */ __name(function(nextValue) {
      changeSize == null || changeSize(Number(nextValue));
    }, "onSizeChange"),
    "aria-label": locale2.page_size,
    className: "".concat(prefixCls, "-size-changer"),
    options: getPageSizeOptions().map(function(opt) {
      return {
        label: mergeBuildOptionText(opt),
        value: opt
      };
    })
  })), quickGo && (goButton && (gotoButton = typeof goButton == "boolean" ? /* @__PURE__ */ React__default.createElement("button", {
    type: "button",
    onClick: go,
    onKeyUp: go,
    disabled,
    className: "".concat(prefixCls, "-quick-jumper-button")
  }, locale2.jump_to_confirm) : /* @__PURE__ */ React__default.createElement("span", {
    onClick: go,
    onKeyUp: go
  }, goButton)), goInput = /* @__PURE__ */ React__default.createElement("div", {
    className: "".concat(prefixCls, "-quick-jumper")
  }, locale2.jump_to, /* @__PURE__ */ React__default.createElement("input", {
    disabled,
    type: "text",
    value: goInputText,
    onChange: handleChange,
    onKeyUp: go,
    onBlur: handleBlur,
    "aria-label": locale2.page
  }), locale2.page, gotoButton)), /* @__PURE__ */ React__default.createElement("li", {
    className: prefixCls
  }, changeSelect, goInput);
}, "Options");
process.env.NODE_ENV !== "production" && (Options.displayName = "Options");
var Pager = /* @__PURE__ */ __name(function(props) {
  var _classNames, rootPrefixCls = props.rootPrefixCls, page = props.page, active = props.active, className = props.className, showTitle = props.showTitle, onClick = props.onClick, onKeyPress = props.onKeyPress, itemRender = props.itemRender, prefixCls = "".concat(rootPrefixCls, "-item"), cls = cn(prefixCls, "".concat(prefixCls, "-").concat(page), (_classNames = {}, _defineProperty$2(_classNames, "".concat(prefixCls, "-active"), active), _defineProperty$2(_classNames, "".concat(prefixCls, "-disabled"), !page), _classNames), className), handleClick = /* @__PURE__ */ __name(function() {
    onClick(page);
  }, "handleClick"), handleKeyPress = /* @__PURE__ */ __name(function(e2) {
    onKeyPress(e2, onClick, page);
  }, "handleKeyPress"), pager = itemRender(page, "page", /* @__PURE__ */ React__default.createElement("a", {
    rel: "nofollow"
  }, page));
  return pager ? /* @__PURE__ */ React__default.createElement("li", {
    title: showTitle ? String(page) : null,
    className: cls,
    onClick: handleClick,
    onKeyDown: handleKeyPress,
    tabIndex: 0
  }, pager) : null;
}, "Pager");
process.env.NODE_ENV !== "production" && (Pager.displayName = "Pager");
var defaultItemRender = /* @__PURE__ */ __name(function(page, type4, element) {
  return element;
}, "defaultItemRender");
function noop$1() {
}
__name(noop$1, "noop$1");
function isInteger(v) {
  var value = Number(v);
  return typeof value == "number" && !Number.isNaN(value) && isFinite(value) && Math.floor(value) === value;
}
__name(isInteger, "isInteger");
function calculatePage(p, pageSize, total) {
  var _pageSize = typeof p > "u" ? pageSize : p;
  return Math.floor((total - 1) / _pageSize) + 1;
}
__name(calculatePage, "calculatePage");
var Pagination$1 = /* @__PURE__ */ __name(function(props) {
  var _classNames5, _props$prefixCls = props.prefixCls, prefixCls = _props$prefixCls === void 0 ? "rc-pagination" : _props$prefixCls, _props$selectPrefixCl = props.selectPrefixCls, selectPrefixCls = _props$selectPrefixCl === void 0 ? "rc-select" : _props$selectPrefixCl, className = props.className, currentProp = props.current, _props$defaultCurrent = props.defaultCurrent, defaultCurrent = _props$defaultCurrent === void 0 ? 1 : _props$defaultCurrent, _props$total = props.total, total = _props$total === void 0 ? 0 : _props$total, pageSizeProp = props.pageSize, _props$defaultPageSiz = props.defaultPageSize, defaultPageSize = _props$defaultPageSiz === void 0 ? 10 : _props$defaultPageSiz, _props$onChange = props.onChange, onChange = _props$onChange === void 0 ? noop$1 : _props$onChange, hideOnSinglePage = props.hideOnSinglePage, align = props.align, _props$showPrevNextJu = props.showPrevNextJumpers, showPrevNextJumpers = _props$showPrevNextJu === void 0 ? !0 : _props$showPrevNextJu, showQuickJumper = props.showQuickJumper, showLessItems = props.showLessItems, _props$showTitle = props.showTitle, showTitle = _props$showTitle === void 0 ? !0 : _props$showTitle, _props$onShowSizeChan = props.onShowSizeChange, onShowSizeChange = _props$onShowSizeChan === void 0 ? noop$1 : _props$onShowSizeChan, _props$locale = props.locale, locale2 = _props$locale === void 0 ? locale$4 : _props$locale, style2 = props.style, _props$totalBoundaryS = props.totalBoundaryShowSizeChanger, totalBoundaryShowSizeChanger = _props$totalBoundaryS === void 0 ? 50 : _props$totalBoundaryS, disabled = props.disabled, simple = props.simple, showTotal = props.showTotal, _props$showSizeChange = props.showSizeChanger, showSizeChanger = _props$showSizeChange === void 0 ? total > totalBoundaryShowSizeChanger : _props$showSizeChange, sizeChangerRender = props.sizeChangerRender, pageSizeOptions = props.pageSizeOptions, _props$itemRender = props.itemRender, itemRender = _props$itemRender === void 0 ? defaultItemRender : _props$itemRender, jumpPrevIcon = props.jumpPrevIcon, jumpNextIcon = props.jumpNextIcon, prevIcon = props.prevIcon, nextIcon = props.nextIcon, paginationRef = React__default.useRef(null), _useMergedState = useMergedState(10, {
    value: pageSizeProp,
    defaultValue: defaultPageSize
  }), _useMergedState2 = _slicedToArray(_useMergedState, 2), pageSize = _useMergedState2[0], setPageSize = _useMergedState2[1], _useMergedState3 = useMergedState(1, {
    value: currentProp,
    defaultValue: defaultCurrent,
    postState: /* @__PURE__ */ __name(function(c) {
      return Math.max(1, Math.min(c, calculatePage(void 0, pageSize, total)));
    }, "postState")
  }), _useMergedState4 = _slicedToArray(_useMergedState3, 2), current = _useMergedState4[0], setCurrent = _useMergedState4[1], _React$useState = React__default.useState(current), _React$useState2 = _slicedToArray(_React$useState, 2), internalInputVal = _React$useState2[0], setInternalInputVal = _React$useState2[1];
  useEffect(function() {
    setInternalInputVal(current);
  }, [current]);
  var hasOnChange = onChange !== noop$1, hasCurrent = "current" in props;
  process.env.NODE_ENV !== "production" && warningOnce(hasCurrent ? hasOnChange : !0, "You provided a `current` prop to a Pagination component without an `onChange` handler. This will render a read-only component.");
  var jumpPrevPage = Math.max(1, current - (showLessItems ? 3 : 5)), jumpNextPage = Math.min(calculatePage(void 0, pageSize, total), current + (showLessItems ? 3 : 5));
  function getItemIcon(icon, label2) {
    var iconNode = icon || /* @__PURE__ */ React__default.createElement("button", {
      type: "button",
      "aria-label": label2,
      className: "".concat(prefixCls, "-item-link")
    });
    return typeof icon == "function" && (iconNode = /* @__PURE__ */ React__default.createElement(icon, _objectSpread2$1({}, props))), iconNode;
  }
  __name(getItemIcon, "getItemIcon");
  function getValidValue(e2) {
    var inputValue = e2.target.value, allPages2 = calculatePage(void 0, pageSize, total), value;
    return inputValue === "" ? value = inputValue : Number.isNaN(Number(inputValue)) ? value = internalInputVal : inputValue >= allPages2 ? value = allPages2 : value = Number(inputValue), value;
  }
  __name(getValidValue, "getValidValue");
  function isValid(page) {
    return isInteger(page) && page !== current && isInteger(total) && total > 0;
  }
  __name(isValid, "isValid");
  var shouldDisplayQuickJumper = total > pageSize ? showQuickJumper : !1;
  function handleKeyDown(event) {
    (event.keyCode === KeyCode.UP || event.keyCode === KeyCode.DOWN) && event.preventDefault();
  }
  __name(handleKeyDown, "handleKeyDown");
  function handleKeyUp(event) {
    var value = getValidValue(event);
    switch (value !== internalInputVal && setInternalInputVal(value), event.keyCode) {
      case KeyCode.ENTER:
        handleChange(value);
        break;
      case KeyCode.UP:
        handleChange(value - 1);
        break;
      case KeyCode.DOWN:
        handleChange(value + 1);
        break;
    }
  }
  __name(handleKeyUp, "handleKeyUp");
  function handleBlur(event) {
    handleChange(getValidValue(event));
  }
  __name(handleBlur, "handleBlur");
  function changePageSize(size) {
    var newCurrent = calculatePage(size, pageSize, total), nextCurrent = current > newCurrent && newCurrent !== 0 ? newCurrent : current;
    setPageSize(size), setInternalInputVal(nextCurrent), onShowSizeChange == null || onShowSizeChange(current, size), setCurrent(nextCurrent), onChange == null || onChange(nextCurrent, size);
  }
  __name(changePageSize, "changePageSize");
  function handleChange(page) {
    if (isValid(page) && !disabled) {
      var currentPage = calculatePage(void 0, pageSize, total), newPage = page;
      return page > currentPage ? newPage = currentPage : page < 1 && (newPage = 1), newPage !== internalInputVal && setInternalInputVal(newPage), setCurrent(newPage), onChange == null || onChange(newPage, pageSize), newPage;
    }
    return current;
  }
  __name(handleChange, "handleChange");
  var hasPrev = current > 1, hasNext = current < calculatePage(void 0, pageSize, total);
  function prevHandle() {
    hasPrev && handleChange(current - 1);
  }
  __name(prevHandle, "prevHandle");
  function nextHandle() {
    hasNext && handleChange(current + 1);
  }
  __name(nextHandle, "nextHandle");
  function jumpPrevHandle() {
    handleChange(jumpPrevPage);
  }
  __name(jumpPrevHandle, "jumpPrevHandle");
  function jumpNextHandle() {
    handleChange(jumpNextPage);
  }
  __name(jumpNextHandle, "jumpNextHandle");
  function runIfEnter(event, callback) {
    if (event.key === "Enter" || event.charCode === KeyCode.ENTER || event.keyCode === KeyCode.ENTER) {
      for (var _len = arguments.length, restParams = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++)
        restParams[_key - 2] = arguments[_key];
      callback.apply(void 0, restParams);
    }
  }
  __name(runIfEnter, "runIfEnter");
  function runIfEnterPrev(event) {
    runIfEnter(event, prevHandle);
  }
  __name(runIfEnterPrev, "runIfEnterPrev");
  function runIfEnterNext(event) {
    runIfEnter(event, nextHandle);
  }
  __name(runIfEnterNext, "runIfEnterNext");
  function runIfEnterJumpPrev(event) {
    runIfEnter(event, jumpPrevHandle);
  }
  __name(runIfEnterJumpPrev, "runIfEnterJumpPrev");
  function runIfEnterJumpNext(event) {
    runIfEnter(event, jumpNextHandle);
  }
  __name(runIfEnterJumpNext, "runIfEnterJumpNext");
  function renderPrev(prevPage2) {
    var prevButton = itemRender(prevPage2, "prev", getItemIcon(prevIcon, "prev page"));
    return /* @__PURE__ */ React__default.isValidElement(prevButton) ? /* @__PURE__ */ React__default.cloneElement(prevButton, {
      disabled: !hasPrev
    }) : prevButton;
  }
  __name(renderPrev, "renderPrev");
  function renderNext(nextPage2) {
    var nextButton = itemRender(nextPage2, "next", getItemIcon(nextIcon, "next page"));
    return /* @__PURE__ */ React__default.isValidElement(nextButton) ? /* @__PURE__ */ React__default.cloneElement(nextButton, {
      disabled: !hasNext
    }) : nextButton;
  }
  __name(renderNext, "renderNext");
  function handleGoTO(event) {
    (event.type === "click" || event.keyCode === KeyCode.ENTER) && handleChange(internalInputVal);
  }
  __name(handleGoTO, "handleGoTO");
  var jumpPrev = null, dataOrAriaAttributeProps = pickAttrs(props, {
    aria: !0,
    data: !0
  }), totalText = showTotal && /* @__PURE__ */ React__default.createElement("li", {
    className: "".concat(prefixCls, "-total-text")
  }, showTotal(total, [total === 0 ? 0 : (current - 1) * pageSize + 1, current * pageSize > total ? total : current * pageSize])), jumpNext = null, allPages = calculatePage(void 0, pageSize, total);
  if (hideOnSinglePage && total <= pageSize)
    return null;
  var pagerList = [], pagerProps = {
    rootPrefixCls: prefixCls,
    onClick: handleChange,
    onKeyPress: runIfEnter,
    showTitle,
    itemRender,
    page: -1
  }, prevPage = current - 1 > 0 ? current - 1 : 0, nextPage = current + 1 < allPages ? current + 1 : allPages, goButton = showQuickJumper && showQuickJumper.goButton, isReadOnly = _typeof$4(simple) === "object" ? simple.readOnly : !simple, gotoButton = goButton, simplePager = null;
  simple && (goButton && (typeof goButton == "boolean" ? gotoButton = /* @__PURE__ */ React__default.createElement("button", {
    type: "button",
    onClick: handleGoTO,
    onKeyUp: handleGoTO
  }, locale2.jump_to_confirm) : gotoButton = /* @__PURE__ */ React__default.createElement("span", {
    onClick: handleGoTO,
    onKeyUp: handleGoTO
  }, goButton), gotoButton = /* @__PURE__ */ React__default.createElement("li", {
    title: showTitle ? "".concat(locale2.jump_to).concat(current, "/").concat(allPages) : null,
    className: "".concat(prefixCls, "-simple-pager")
  }, gotoButton)), simplePager = /* @__PURE__ */ React__default.createElement("li", {
    title: showTitle ? "".concat(current, "/").concat(allPages) : null,
    className: "".concat(prefixCls, "-simple-pager")
  }, isReadOnly ? internalInputVal : /* @__PURE__ */ React__default.createElement("input", {
    type: "text",
    value: internalInputVal,
    disabled,
    onKeyDown: handleKeyDown,
    onKeyUp: handleKeyUp,
    onChange: handleKeyUp,
    onBlur: handleBlur,
    size: 3
  }), /* @__PURE__ */ React__default.createElement("span", {
    className: "".concat(prefixCls, "-slash")
  }, "/"), allPages));
  var pageBufferSize = showLessItems ? 1 : 2;
  if (allPages <= 3 + pageBufferSize * 2) {
    allPages || pagerList.push(/* @__PURE__ */ React__default.createElement(Pager, _extends({}, pagerProps, {
      key: "noPager",
      page: 1,
      className: "".concat(prefixCls, "-item-disabled")
    })));
    for (var i = 1; i <= allPages; i += 1)
      pagerList.push(/* @__PURE__ */ React__default.createElement(Pager, _extends({}, pagerProps, {
        key: i,
        page: i,
        active: current === i
      })));
  } else {
    var prevItemTitle = showLessItems ? locale2.prev_3 : locale2.prev_5, nextItemTitle = showLessItems ? locale2.next_3 : locale2.next_5, jumpPrevContent = itemRender(jumpPrevPage, "jump-prev", getItemIcon(jumpPrevIcon, "prev page")), jumpNextContent = itemRender(jumpNextPage, "jump-next", getItemIcon(jumpNextIcon, "next page"));
    showPrevNextJumpers && (jumpPrev = jumpPrevContent ? /* @__PURE__ */ React__default.createElement("li", {
      title: showTitle ? prevItemTitle : null,
      key: "prev",
      onClick: jumpPrevHandle,
      tabIndex: 0,
      onKeyDown: runIfEnterJumpPrev,
      className: cn("".concat(prefixCls, "-jump-prev"), _defineProperty$2({}, "".concat(prefixCls, "-jump-prev-custom-icon"), !!jumpPrevIcon))
    }, jumpPrevContent) : null, jumpNext = jumpNextContent ? /* @__PURE__ */ React__default.createElement("li", {
      title: showTitle ? nextItemTitle : null,
      key: "next",
      onClick: jumpNextHandle,
      tabIndex: 0,
      onKeyDown: runIfEnterJumpNext,
      className: cn("".concat(prefixCls, "-jump-next"), _defineProperty$2({}, "".concat(prefixCls, "-jump-next-custom-icon"), !!jumpNextIcon))
    }, jumpNextContent) : null);
    var left = Math.max(1, current - pageBufferSize), right = Math.min(current + pageBufferSize, allPages);
    current - 1 <= pageBufferSize && (right = 1 + pageBufferSize * 2), allPages - current <= pageBufferSize && (left = allPages - pageBufferSize * 2);
    for (var _i = left; _i <= right; _i += 1)
      pagerList.push(/* @__PURE__ */ React__default.createElement(Pager, _extends({}, pagerProps, {
        key: _i,
        page: _i,
        active: current === _i
      })));
    if (current - 1 >= pageBufferSize * 2 && current !== 3 && (pagerList[0] = /* @__PURE__ */ React__default.cloneElement(pagerList[0], {
      className: cn("".concat(prefixCls, "-item-after-jump-prev"), pagerList[0].props.className)
    }), pagerList.unshift(jumpPrev)), allPages - current >= pageBufferSize * 2 && current !== allPages - 2) {
      var lastOne = pagerList[pagerList.length - 1];
      pagerList[pagerList.length - 1] = /* @__PURE__ */ React__default.cloneElement(lastOne, {
        className: cn("".concat(prefixCls, "-item-before-jump-next"), lastOne.props.className)
      }), pagerList.push(jumpNext);
    }
    left !== 1 && pagerList.unshift(/* @__PURE__ */ React__default.createElement(Pager, _extends({}, pagerProps, {
      key: 1,
      page: 1
    }))), right !== allPages && pagerList.push(/* @__PURE__ */ React__default.createElement(Pager, _extends({}, pagerProps, {
      key: allPages,
      page: allPages
    })));
  }
  var prev2 = renderPrev(prevPage);
  if (prev2) {
    var prevDisabled = !hasPrev || !allPages;
    prev2 = /* @__PURE__ */ React__default.createElement("li", {
      title: showTitle ? locale2.prev_page : null,
      onClick: prevHandle,
      tabIndex: prevDisabled ? null : 0,
      onKeyDown: runIfEnterPrev,
      className: cn("".concat(prefixCls, "-prev"), _defineProperty$2({}, "".concat(prefixCls, "-disabled"), prevDisabled)),
      "aria-disabled": prevDisabled
    }, prev2);
  }
  var next2 = renderNext(nextPage);
  if (next2) {
    var nextDisabled, nextTabIndex;
    simple ? (nextDisabled = !hasNext, nextTabIndex = hasPrev ? 0 : null) : (nextDisabled = !hasNext || !allPages, nextTabIndex = nextDisabled ? null : 0), next2 = /* @__PURE__ */ React__default.createElement("li", {
      title: showTitle ? locale2.next_page : null,
      onClick: nextHandle,
      tabIndex: nextTabIndex,
      onKeyDown: runIfEnterNext,
      className: cn("".concat(prefixCls, "-next"), _defineProperty$2({}, "".concat(prefixCls, "-disabled"), nextDisabled)),
      "aria-disabled": nextDisabled
    }, next2);
  }
  var cls = cn(prefixCls, className, (_classNames5 = {}, _defineProperty$2(_classNames5, "".concat(prefixCls, "-start"), align === "start"), _defineProperty$2(_classNames5, "".concat(prefixCls, "-center"), align === "center"), _defineProperty$2(_classNames5, "".concat(prefixCls, "-end"), align === "end"), _defineProperty$2(_classNames5, "".concat(prefixCls, "-simple"), simple), _defineProperty$2(_classNames5, "".concat(prefixCls, "-disabled"), disabled), _classNames5));
  return /* @__PURE__ */ React__default.createElement("ul", _extends({
    className: cls,
    style: style2,
    ref: paginationRef
  }, dataOrAriaAttributeProps), totalText, prev2, simple ? simplePager : pagerList, next2, /* @__PURE__ */ React__default.createElement(Options, {
    locale: locale2,
    rootPrefixCls: prefixCls,
    disabled,
    selectPrefixCls,
    changeSize: changePageSize,
    pageSize,
    pageSizeOptions,
    quickGo: shouldDisplayQuickJumper ? handleChange : null,
    goButton: gotoButton,
    showSizeChanger,
    sizeChangerRender
  }));
}, "Pagination");
process.env.NODE_ENV !== "production" && (Pagination$1.displayName = "Pagination");
const genPaginationDisabledStyle = /* @__PURE__ */ __name((token2) => {
  const {
    componentCls
  } = token2;
  return {
    [`${componentCls}-disabled`]: {
      "&, &:hover": {
        cursor: "not-allowed",
        [`${componentCls}-item-link`]: {
          color: token2.colorTextDisabled,
          cursor: "not-allowed"
        }
      },
      "&:focus-visible": {
        cursor: "not-allowed",
        [`${componentCls}-item-link`]: {
          color: token2.colorTextDisabled,
          cursor: "not-allowed"
        }
      }
    },
    [`&${componentCls}-disabled`]: {
      cursor: "not-allowed",
      [`${componentCls}-item`]: {
        cursor: "not-allowed",
        "&:hover, &:active": {
          backgroundColor: "transparent"
        },
        a: {
          color: token2.colorTextDisabled,
          backgroundColor: "transparent",
          border: "none",
          cursor: "not-allowed"
        },
        "&-active": {
          borderColor: token2.colorBorder,
          backgroundColor: token2.itemActiveBgDisabled,
          "&:hover, &:active": {
            backgroundColor: token2.itemActiveBgDisabled
          },
          a: {
            color: token2.itemActiveColorDisabled
          }
        }
      },
      [`${componentCls}-item-link`]: {
        color: token2.colorTextDisabled,
        cursor: "not-allowed",
        "&:hover, &:active": {
          backgroundColor: "transparent"
        },
        [`${componentCls}-simple&`]: {
          backgroundColor: "transparent",
          "&:hover, &:active": {
            backgroundColor: "transparent"
          }
        }
      },
      [`${componentCls}-simple-pager`]: {
        color: token2.colorTextDisabled
      },
      [`${componentCls}-jump-prev, ${componentCls}-jump-next`]: {
        [`${componentCls}-item-link-icon`]: {
          opacity: 0
        },
        [`${componentCls}-item-ellipsis`]: {
          opacity: 1
        }
      }
    },
    [`&${componentCls}-simple`]: {
      [`${componentCls}-prev, ${componentCls}-next`]: {
        [`&${componentCls}-disabled ${componentCls}-item-link`]: {
          "&:hover, &:active": {
            backgroundColor: "transparent"
          }
        }
      }
    }
  };
}, "genPaginationDisabledStyle"), genPaginationMiniStyle = /* @__PURE__ */ __name((token2) => {
  const {
    componentCls
  } = token2;
  return {
    [`&${componentCls}-mini ${componentCls}-total-text, &${componentCls}-mini ${componentCls}-simple-pager`]: {
      height: token2.itemSizeSM,
      lineHeight: unit$1(token2.itemSizeSM)
    },
    [`&${componentCls}-mini ${componentCls}-item`]: {
      minWidth: token2.itemSizeSM,
      height: token2.itemSizeSM,
      margin: 0,
      lineHeight: unit$1(token2.calc(token2.itemSizeSM).sub(2).equal())
    },
    [`&${componentCls}-mini:not(${componentCls}-disabled) ${componentCls}-item:not(${componentCls}-item-active)`]: {
      backgroundColor: "transparent",
      borderColor: "transparent",
      "&:hover": {
        backgroundColor: token2.colorBgTextHover
      },
      "&:active": {
        backgroundColor: token2.colorBgTextActive
      }
    },
    [`&${componentCls}-mini ${componentCls}-prev, &${componentCls}-mini ${componentCls}-next`]: {
      minWidth: token2.itemSizeSM,
      height: token2.itemSizeSM,
      margin: 0,
      lineHeight: unit$1(token2.itemSizeSM)
    },
    [`&${componentCls}-mini:not(${componentCls}-disabled)`]: {
      [`${componentCls}-prev, ${componentCls}-next`]: {
        [`&:hover ${componentCls}-item-link`]: {
          backgroundColor: token2.colorBgTextHover
        },
        [`&:active ${componentCls}-item-link`]: {
          backgroundColor: token2.colorBgTextActive
        },
        [`&${componentCls}-disabled:hover ${componentCls}-item-link`]: {
          backgroundColor: "transparent"
        }
      }
    },
    [`
    &${componentCls}-mini ${componentCls}-prev ${componentCls}-item-link,
    &${componentCls}-mini ${componentCls}-next ${componentCls}-item-link
    `]: {
      backgroundColor: "transparent",
      borderColor: "transparent",
      "&::after": {
        height: token2.itemSizeSM,
        lineHeight: unit$1(token2.itemSizeSM)
      }
    },
    [`&${componentCls}-mini ${componentCls}-jump-prev, &${componentCls}-mini ${componentCls}-jump-next`]: {
      height: token2.itemSizeSM,
      marginInlineEnd: 0,
      lineHeight: unit$1(token2.itemSizeSM)
    },
    [`&${componentCls}-mini ${componentCls}-options`]: {
      marginInlineStart: token2.paginationMiniOptionsMarginInlineStart,
      "&-size-changer": {
        top: token2.miniOptionsSizeChangerTop
      },
      "&-quick-jumper": {
        height: token2.itemSizeSM,
        lineHeight: unit$1(token2.itemSizeSM),
        input: Object.assign(Object.assign({}, genInputSmallStyle(token2)), {
          width: token2.paginationMiniQuickJumperInputWidth,
          height: token2.controlHeightSM
        })
      }
    }
  };
}, "genPaginationMiniStyle"), genPaginationSimpleStyle = /* @__PURE__ */ __name((token2) => {
  const {
    componentCls
  } = token2;
  return {
    [`
    &${componentCls}-simple ${componentCls}-prev,
    &${componentCls}-simple ${componentCls}-next
    `]: {
      height: token2.itemSizeSM,
      lineHeight: unit$1(token2.itemSizeSM),
      verticalAlign: "top",
      [`${componentCls}-item-link`]: {
        height: token2.itemSizeSM,
        backgroundColor: "transparent",
        border: 0,
        "&:hover": {
          backgroundColor: token2.colorBgTextHover
        },
        "&:active": {
          backgroundColor: token2.colorBgTextActive
        },
        "&::after": {
          height: token2.itemSizeSM,
          lineHeight: unit$1(token2.itemSizeSM)
        }
      }
    },
    [`&${componentCls}-simple ${componentCls}-simple-pager`]: {
      display: "inline-block",
      height: token2.itemSizeSM,
      marginInlineEnd: token2.marginXS,
      input: {
        boxSizing: "border-box",
        height: "100%",
        padding: `0 ${unit$1(token2.paginationItemPaddingInline)}`,
        textAlign: "center",
        backgroundColor: token2.itemInputBg,
        border: `${unit$1(token2.lineWidth)} ${token2.lineType} ${token2.colorBorder}`,
        borderRadius: token2.borderRadius,
        outline: "none",
        transition: `border-color ${token2.motionDurationMid}`,
        color: "inherit",
        "&:hover": {
          borderColor: token2.colorPrimary
        },
        "&:focus": {
          borderColor: token2.colorPrimaryHover,
          boxShadow: `${unit$1(token2.inputOutlineOffset)} 0 ${unit$1(token2.controlOutlineWidth)} ${token2.controlOutline}`
        },
        "&[disabled]": {
          color: token2.colorTextDisabled,
          backgroundColor: token2.colorBgContainerDisabled,
          borderColor: token2.colorBorder,
          cursor: "not-allowed"
        }
      }
    }
  };
}, "genPaginationSimpleStyle"), genPaginationJumpStyle = /* @__PURE__ */ __name((token2) => {
  const {
    componentCls
  } = token2;
  return {
    [`${componentCls}-jump-prev, ${componentCls}-jump-next`]: {
      outline: 0,
      [`${componentCls}-item-container`]: {
        position: "relative",
        [`${componentCls}-item-link-icon`]: {
          color: token2.colorPrimary,
          fontSize: token2.fontSizeSM,
          opacity: 0,
          transition: `all ${token2.motionDurationMid}`,
          "&-svg": {
            top: 0,
            insetInlineEnd: 0,
            bottom: 0,
            insetInlineStart: 0,
            margin: "auto"
          }
        },
        [`${componentCls}-item-ellipsis`]: {
          position: "absolute",
          top: 0,
          insetInlineEnd: 0,
          bottom: 0,
          insetInlineStart: 0,
          display: "block",
          margin: "auto",
          color: token2.colorTextDisabled,
          letterSpacing: token2.paginationEllipsisLetterSpacing,
          textAlign: "center",
          textIndent: token2.paginationEllipsisTextIndent,
          opacity: 1,
          transition: `all ${token2.motionDurationMid}`
        }
      },
      "&:hover": {
        [`${componentCls}-item-link-icon`]: {
          opacity: 1
        },
        [`${componentCls}-item-ellipsis`]: {
          opacity: 0
        }
      }
    },
    [`
    ${componentCls}-prev,
    ${componentCls}-jump-prev,
    ${componentCls}-jump-next
    `]: {
      marginInlineEnd: token2.marginXS
    },
    [`
    ${componentCls}-prev,
    ${componentCls}-next,
    ${componentCls}-jump-prev,
    ${componentCls}-jump-next
    `]: {
      display: "inline-block",
      minWidth: token2.itemSize,
      height: token2.itemSize,
      color: token2.colorText,
      fontFamily: token2.fontFamily,
      lineHeight: unit$1(token2.itemSize),
      textAlign: "center",
      verticalAlign: "middle",
      listStyle: "none",
      borderRadius: token2.borderRadius,
      cursor: "pointer",
      transition: `all ${token2.motionDurationMid}`
    },
    [`${componentCls}-prev, ${componentCls}-next`]: {
      outline: 0,
      button: {
        color: token2.colorText,
        cursor: "pointer",
        userSelect: "none"
      },
      [`${componentCls}-item-link`]: {
        display: "block",
        width: "100%",
        height: "100%",
        padding: 0,
        fontSize: token2.fontSizeSM,
        textAlign: "center",
        backgroundColor: "transparent",
        border: `${unit$1(token2.lineWidth)} ${token2.lineType} transparent`,
        borderRadius: token2.borderRadius,
        outline: "none",
        transition: `all ${token2.motionDurationMid}`
      },
      [`&:hover ${componentCls}-item-link`]: {
        backgroundColor: token2.colorBgTextHover
      },
      [`&:active ${componentCls}-item-link`]: {
        backgroundColor: token2.colorBgTextActive
      },
      [`&${componentCls}-disabled:hover`]: {
        [`${componentCls}-item-link`]: {
          backgroundColor: "transparent"
        }
      }
    },
    [`${componentCls}-slash`]: {
      marginInlineEnd: token2.paginationSlashMarginInlineEnd,
      marginInlineStart: token2.paginationSlashMarginInlineStart
    },
    [`${componentCls}-options`]: {
      display: "inline-block",
      marginInlineStart: token2.margin,
      verticalAlign: "middle",
      "&-size-changer": {
        display: "inline-block",
        width: "auto"
      },
      "&-quick-jumper": {
        display: "inline-block",
        height: token2.controlHeight,
        marginInlineStart: token2.marginXS,
        lineHeight: unit$1(token2.controlHeight),
        verticalAlign: "top",
        input: Object.assign(Object.assign(Object.assign({}, genBasicInputStyle(token2)), genBaseOutlinedStyle(token2, {
          borderColor: token2.colorBorder,
          hoverBorderColor: token2.colorPrimaryHover,
          activeBorderColor: token2.colorPrimary,
          activeShadow: token2.activeShadow
        })), {
          "&[disabled]": Object.assign({}, genDisabledStyle(token2)),
          width: token2.calc(token2.controlHeightLG).mul(1.25).equal(),
          height: token2.controlHeight,
          boxSizing: "border-box",
          margin: 0,
          marginInlineStart: token2.marginXS,
          marginInlineEnd: token2.marginXS
        })
      }
    }
  };
}, "genPaginationJumpStyle"), genPaginationItemStyle = /* @__PURE__ */ __name((token2) => {
  const {
    componentCls
  } = token2;
  return {
    [`${componentCls}-item`]: {
      display: "inline-block",
      minWidth: token2.itemSize,
      height: token2.itemSize,
      marginInlineEnd: token2.marginXS,
      fontFamily: token2.fontFamily,
      lineHeight: unit$1(token2.calc(token2.itemSize).sub(2).equal()),
      textAlign: "center",
      verticalAlign: "middle",
      listStyle: "none",
      backgroundColor: token2.itemBg,
      border: `${unit$1(token2.lineWidth)} ${token2.lineType} transparent`,
      borderRadius: token2.borderRadius,
      outline: 0,
      cursor: "pointer",
      userSelect: "none",
      a: {
        display: "block",
        padding: `0 ${unit$1(token2.paginationItemPaddingInline)}`,
        color: token2.colorText,
        "&:hover": {
          textDecoration: "none"
        }
      },
      [`&:not(${componentCls}-item-active)`]: {
        "&:hover": {
          transition: `all ${token2.motionDurationMid}`,
          backgroundColor: token2.colorBgTextHover
        },
        "&:active": {
          backgroundColor: token2.colorBgTextActive
        }
      },
      "&-active": {
        fontWeight: token2.fontWeightStrong,
        backgroundColor: token2.itemActiveBg,
        borderColor: token2.colorPrimary,
        a: {
          color: token2.colorPrimary
        },
        "&:hover": {
          borderColor: token2.colorPrimaryHover
        },
        "&:hover a": {
          color: token2.colorPrimaryHover
        }
      }
    }
  };
}, "genPaginationItemStyle"), genPaginationStyle$1 = /* @__PURE__ */ __name((token2) => {
  const {
    componentCls
  } = token2;
  return {
    [componentCls]: Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, resetComponent(token2)), {
      display: "flex",
      "&-start": {
        justifyContent: "start"
      },
      "&-center": {
        justifyContent: "center"
      },
      "&-end": {
        justifyContent: "end"
      },
      "ul, ol": {
        margin: 0,
        padding: 0,
        listStyle: "none"
      },
      "&::after": {
        display: "block",
        clear: "both",
        height: 0,
        overflow: "hidden",
        visibility: "hidden",
        content: '""'
      },
      [`${componentCls}-total-text`]: {
        display: "inline-block",
        height: token2.itemSize,
        marginInlineEnd: token2.marginXS,
        lineHeight: unit$1(token2.calc(token2.itemSize).sub(2).equal()),
        verticalAlign: "middle"
      }
    }), genPaginationItemStyle(token2)), genPaginationJumpStyle(token2)), genPaginationSimpleStyle(token2)), genPaginationMiniStyle(token2)), genPaginationDisabledStyle(token2)), {
      // media query style
      [`@media only screen and (max-width: ${token2.screenLG}px)`]: {
        [`${componentCls}-item`]: {
          "&-after-jump-prev, &-before-jump-next": {
            display: "none"
          }
        }
      },
      [`@media only screen and (max-width: ${token2.screenSM}px)`]: {
        [`${componentCls}-options`]: {
          display: "none"
        }
      }
    }),
    // rtl style
    [`&${token2.componentCls}-rtl`]: {
      direction: "rtl"
    }
  };
}, "genPaginationStyle$1"), genPaginationFocusStyle = /* @__PURE__ */ __name((token2) => {
  const {
    componentCls
  } = token2;
  return {
    [`${componentCls}:not(${componentCls}-disabled)`]: {
      [`${componentCls}-item`]: Object.assign({}, genFocusStyle(token2)),
      [`${componentCls}-jump-prev, ${componentCls}-jump-next`]: {
        "&:focus-visible": Object.assign({
          [`${componentCls}-item-link-icon`]: {
            opacity: 1
          },
          [`${componentCls}-item-ellipsis`]: {
            opacity: 0
          }
        }, genFocusOutline(token2))
      },
      [`${componentCls}-prev, ${componentCls}-next`]: {
        [`&:focus-visible ${componentCls}-item-link`]: Object.assign({}, genFocusOutline(token2))
      }
    }
  };
}, "genPaginationFocusStyle"), prepareComponentToken$7 = /* @__PURE__ */ __name((token2) => Object.assign({
  itemBg: token2.colorBgContainer,
  itemSize: token2.controlHeight,
  itemSizeSM: token2.controlHeightSM,
  itemActiveBg: token2.colorBgContainer,
  itemLinkBg: token2.colorBgContainer,
  itemActiveColorDisabled: token2.colorTextDisabled,
  itemActiveBgDisabled: token2.controlItemBgActiveDisabled,
  itemInputBg: token2.colorBgContainer,
  miniOptionsSizeChangerTop: 0
}, initComponentToken$1(token2)), "prepareComponentToken$7"), prepareToken = /* @__PURE__ */ __name((token2) => merge(token2, {
  inputOutlineOffset: 0,
  paginationMiniOptionsMarginInlineStart: token2.calc(token2.marginXXS).div(2).equal(),
  paginationMiniQuickJumperInputWidth: token2.calc(token2.controlHeightLG).mul(1.1).equal(),
  paginationItemPaddingInline: token2.calc(token2.marginXXS).mul(1.5).equal(),
  paginationEllipsisLetterSpacing: token2.calc(token2.marginXXS).div(2).equal(),
  paginationSlashMarginInlineStart: token2.marginSM,
  paginationSlashMarginInlineEnd: token2.marginSM,
  paginationEllipsisTextIndent: "0.13em"
  // magic for ui experience
}, initInputToken(token2)), "prepareToken"), useStyle$7 = genStyleHooks("Pagination", (token2) => {
  const paginationToken = prepareToken(token2);
  return [genPaginationStyle$1(paginationToken), genPaginationFocusStyle(paginationToken)];
}, prepareComponentToken$7), genBorderedStyle$1 = /* @__PURE__ */ __name((token2) => {
  const {
    componentCls
  } = token2;
  return {
    [`${componentCls}${componentCls}-bordered${componentCls}-disabled:not(${componentCls}-mini)`]: {
      "&, &:hover": {
        [`${componentCls}-item-link`]: {
          borderColor: token2.colorBorder
        }
      },
      "&:focus-visible": {
        [`${componentCls}-item-link`]: {
          borderColor: token2.colorBorder
        }
      },
      [`${componentCls}-item, ${componentCls}-item-link`]: {
        backgroundColor: token2.colorBgContainerDisabled,
        borderColor: token2.colorBorder,
        [`&:hover:not(${componentCls}-item-active)`]: {
          backgroundColor: token2.colorBgContainerDisabled,
          borderColor: token2.colorBorder,
          a: {
            color: token2.colorTextDisabled
          }
        },
        [`&${componentCls}-item-active`]: {
          backgroundColor: token2.itemActiveBgDisabled
        }
      },
      [`${componentCls}-prev, ${componentCls}-next`]: {
        "&:hover button": {
          backgroundColor: token2.colorBgContainerDisabled,
          borderColor: token2.colorBorder,
          color: token2.colorTextDisabled
        },
        [`${componentCls}-item-link`]: {
          backgroundColor: token2.colorBgContainerDisabled,
          borderColor: token2.colorBorder
        }
      }
    },
    [`${componentCls}${componentCls}-bordered:not(${componentCls}-mini)`]: {
      [`${componentCls}-prev, ${componentCls}-next`]: {
        "&:hover button": {
          borderColor: token2.colorPrimaryHover,
          backgroundColor: token2.itemBg
        },
        [`${componentCls}-item-link`]: {
          backgroundColor: token2.itemLinkBg,
          borderColor: token2.colorBorder
        },
        [`&:hover ${componentCls}-item-link`]: {
          borderColor: token2.colorPrimary,
          backgroundColor: token2.itemBg,
          color: token2.colorPrimary
        },
        [`&${componentCls}-disabled`]: {
          [`${componentCls}-item-link`]: {
            borderColor: token2.colorBorder,
            color: token2.colorTextDisabled
          }
        }
      },
      [`${componentCls}-item`]: {
        backgroundColor: token2.itemBg,
        border: `${unit$1(token2.lineWidth)} ${token2.lineType} ${token2.colorBorder}`,
        [`&:hover:not(${componentCls}-item-active)`]: {
          borderColor: token2.colorPrimary,
          backgroundColor: token2.itemBg,
          a: {
            color: token2.colorPrimary
          }
        },
        "&-active": {
          borderColor: token2.colorPrimary
        }
      }
    }
  };
}, "genBorderedStyle$1"), BorderedStyle = genSubStyleComponent(["Pagination", "bordered"], (token2) => {
  const paginationToken = prepareToken(token2);
  return [genBorderedStyle$1(paginationToken)];
}, prepareComponentToken$7);
function useShowSizeChanger(showSizeChanger) {
  return useMemo$1(() => typeof showSizeChanger == "boolean" ? [showSizeChanger, {}] : showSizeChanger && typeof showSizeChanger == "object" ? [!0, showSizeChanger] : [void 0, void 0], [showSizeChanger]);
}
__name(useShowSizeChanger, "useShowSizeChanger");
var __rest$c = function(s, e2) {
  var t2 = {};
  for (var p in s) Object.prototype.hasOwnProperty.call(s, p) && e2.indexOf(p) < 0 && (t2[p] = s[p]);
  if (s != null && typeof Object.getOwnPropertySymbols == "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++)
    e2.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]) && (t2[p[i]] = s[p[i]]);
  return t2;
};
const Pagination2 = /* @__PURE__ */ __name((props) => {
  const {
    align,
    prefixCls: customizePrefixCls,
    selectPrefixCls: customizeSelectPrefixCls,
    className,
    rootClassName,
    style: style2,
    size: customizeSize,
    locale: customLocale,
    responsive,
    showSizeChanger,
    selectComponentClass,
    pageSizeOptions
  } = props, restProps = __rest$c(props, ["align", "prefixCls", "selectPrefixCls", "className", "rootClassName", "style", "size", "locale", "responsive", "showSizeChanger", "selectComponentClass", "pageSizeOptions"]), {
    xs
  } = useBreakpoint(responsive), [, token2] = useToken(), {
    getPrefixCls,
    direction,
    pagination = {}
  } = React.useContext(ConfigContext), prefixCls = getPrefixCls("pagination", customizePrefixCls), [wrapCSSVar, hashId, cssVarCls] = useStyle$7(prefixCls), mergedSize = useSize(customizeSize), isSmall = mergedSize === "small" || !!(xs && !mergedSize && responsive), [contextLocale] = useLocale$1("Pagination", locale$8), locale2 = Object.assign(Object.assign({}, contextLocale), customLocale), [propShowSizeChanger, propSizeChangerSelectProps] = useShowSizeChanger(showSizeChanger), [contextShowSizeChanger, contextSizeChangerSelectProps] = useShowSizeChanger(pagination.showSizeChanger), mergedShowSizeChanger = propShowSizeChanger ?? contextShowSizeChanger, mergedShowSizeChangerSelectProps = propSizeChangerSelectProps ?? contextSizeChangerSelectProps, SizeChanger = selectComponentClass || Select$1, mergedPageSizeOptions = React.useMemo(() => pageSizeOptions ? pageSizeOptions.map((option) => Number(option)) : void 0, [pageSizeOptions]), sizeChangerRender = /* @__PURE__ */ __name((info) => {
    var _a;
    const {
      disabled,
      size: pageSize,
      onSizeChange,
      "aria-label": ariaLabel,
      className: sizeChangerClassName,
      options
    } = info, {
      className: propSizeChangerClassName,
      onChange: propSizeChangerOnChange
    } = mergedShowSizeChangerSelectProps || {}, selectedValue = (_a = options.find((option) => String(option.value) === String(pageSize))) === null || _a === void 0 ? void 0 : _a.value;
    return /* @__PURE__ */ React.createElement(SizeChanger, Object.assign({
      disabled,
      showSearch: !0,
      popupMatchSelectWidth: !1,
      getPopupContainer: /* @__PURE__ */ __name((triggerNode) => triggerNode.parentNode, "getPopupContainer"),
      "aria-label": ariaLabel,
      options
    }, mergedShowSizeChangerSelectProps, {
      value: selectedValue,
      onChange: /* @__PURE__ */ __name((nextSize, option) => {
        onSizeChange == null || onSizeChange(nextSize), propSizeChangerOnChange == null || propSizeChangerOnChange(nextSize, option);
      }, "onChange"),
      size: isSmall ? "small" : "middle",
      className: cn(sizeChangerClassName, propSizeChangerClassName)
    }));
  }, "sizeChangerRender");
  if (process.env.NODE_ENV !== "production") {
    const warning3 = devUseWarning("Pagination");
    process.env.NODE_ENV !== "production" && warning3(!selectComponentClass, "usage", "`selectComponentClass` is not official api which will be removed.");
  }
  const iconsProps = React.useMemo(() => {
    const ellipsis = /* @__PURE__ */ React.createElement("span", {
      className: `${prefixCls}-item-ellipsis`
    }, "•••"), prevIcon = /* @__PURE__ */ React.createElement("button", {
      className: `${prefixCls}-item-link`,
      type: "button",
      tabIndex: -1
    }, direction === "rtl" ? /* @__PURE__ */ React.createElement(RefIcon$y, null) : /* @__PURE__ */ React.createElement(RefIcon$t, null)), nextIcon = /* @__PURE__ */ React.createElement("button", {
      className: `${prefixCls}-item-link`,
      type: "button",
      tabIndex: -1
    }, direction === "rtl" ? /* @__PURE__ */ React.createElement(RefIcon$t, null) : /* @__PURE__ */ React.createElement(RefIcon$y, null)), jumpPrevIcon = (
      // biome-ignore lint/a11y/useValidAnchor: it is hard to refactor
      /* @__PURE__ */ React.createElement("a", {
        className: `${prefixCls}-item-link`
      }, /* @__PURE__ */ React.createElement("div", {
        className: `${prefixCls}-item-container`
      }, direction === "rtl" ? /* @__PURE__ */ React.createElement(RefIcon$i, {
        className: `${prefixCls}-item-link-icon`
      }) : /* @__PURE__ */ React.createElement(RefIcon$j, {
        className: `${prefixCls}-item-link-icon`
      }), ellipsis))
    ), jumpNextIcon = (
      // biome-ignore lint/a11y/useValidAnchor: it is hard to refactor
      /* @__PURE__ */ React.createElement("a", {
        className: `${prefixCls}-item-link`
      }, /* @__PURE__ */ React.createElement("div", {
        className: `${prefixCls}-item-container`
      }, direction === "rtl" ? /* @__PURE__ */ React.createElement(RefIcon$j, {
        className: `${prefixCls}-item-link-icon`
      }) : /* @__PURE__ */ React.createElement(RefIcon$i, {
        className: `${prefixCls}-item-link-icon`
      }), ellipsis))
    );
    return {
      prevIcon,
      nextIcon,
      jumpPrevIcon,
      jumpNextIcon
    };
  }, [direction, prefixCls]), selectPrefixCls = getPrefixCls("select", customizeSelectPrefixCls), extendedClassName = cn({
    [`${prefixCls}-${align}`]: !!align,
    [`${prefixCls}-mini`]: isSmall,
    [`${prefixCls}-rtl`]: direction === "rtl",
    [`${prefixCls}-bordered`]: token2.wireframe
  }, pagination == null ? void 0 : pagination.className, className, rootClassName, hashId, cssVarCls), mergedStyle = Object.assign(Object.assign({}, pagination == null ? void 0 : pagination.style), style2);
  return wrapCSSVar(/* @__PURE__ */ React.createElement(React.Fragment, null, token2.wireframe && /* @__PURE__ */ React.createElement(BorderedStyle, {
    prefixCls
  }), /* @__PURE__ */ React.createElement(Pagination$1, Object.assign({}, iconsProps, restProps, {
    style: mergedStyle,
    prefixCls,
    selectPrefixCls,
    className: extendedClassName,
    locale: locale2,
    pageSizeOptions: mergedPageSizeOptions,
    showSizeChanger: mergedShowSizeChanger,
    sizeChangerRender
  }))));
}, "Pagination");
process.env.NODE_ENV !== "production" && (Pagination2.displayName = "Pagination");
const viewSize = 100, borderWidth = viewSize / 5, radius = viewSize / 2 - borderWidth / 2, circumference = radius * 2 * Math.PI, position = 50, CustomCircle = /* @__PURE__ */ __name((props) => {
  const {
    dotClassName,
    style: style2,
    hasCircleCls
  } = props;
  return /* @__PURE__ */ React.createElement("circle", {
    className: cn(`${dotClassName}-circle`, {
      [`${dotClassName}-circle-bg`]: hasCircleCls
    }),
    r: radius,
    cx: position,
    cy: position,
    strokeWidth: borderWidth,
    style: style2
  });
}, "CustomCircle"), Progress$1 = /* @__PURE__ */ __name((_ref) => {
  let {
    percent,
    prefixCls
  } = _ref;
  const dotClassName = `${prefixCls}-dot`, holderClassName = `${dotClassName}-holder`, hideClassName = `${holderClassName}-hidden`, [render4, setRender] = React.useState(!1);
  useLayoutEffect$1(() => {
    percent !== 0 && setRender(!0);
  }, [percent !== 0]);
  const safePtg = Math.max(Math.min(percent, 100), 0);
  if (!render4)
    return null;
  const circleStyle = {
    strokeDashoffset: `${circumference / 4}`,
    strokeDasharray: `${circumference * safePtg / 100} ${circumference * (100 - safePtg) / 100}`
  };
  return /* @__PURE__ */ React.createElement("span", {
    className: cn(holderClassName, `${dotClassName}-progress`, safePtg <= 0 && hideClassName)
  }, /* @__PURE__ */ React.createElement("svg", {
    viewBox: `0 0 ${viewSize} ${viewSize}`,
    // biome-ignore lint/a11y/noNoninteractiveElementToInteractiveRole: progressbar could be readonly
    role: "progressbar",
    "aria-valuemin": 0,
    "aria-valuemax": 100,
    "aria-valuenow": safePtg
  }, /* @__PURE__ */ React.createElement(CustomCircle, {
    dotClassName,
    hasCircleCls: !0
  }), /* @__PURE__ */ React.createElement(CustomCircle, {
    dotClassName,
    style: circleStyle
  })));
}, "Progress$1");
function Looper(props) {
  const {
    prefixCls,
    percent = 0
  } = props, dotClassName = `${prefixCls}-dot`, holderClassName = `${dotClassName}-holder`, hideClassName = `${holderClassName}-hidden`;
  return /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement("span", {
    className: cn(holderClassName, percent > 0 && hideClassName)
  }, /* @__PURE__ */ React.createElement("span", {
    className: cn(dotClassName, `${prefixCls}-dot-spin`)
  }, [1, 2, 3, 4].map((i) => /* @__PURE__ */ React.createElement("i", {
    className: `${prefixCls}-dot-item`,
    key: i
  })))), /* @__PURE__ */ React.createElement(Progress$1, {
    prefixCls,
    percent
  }));
}
__name(Looper, "Looper");
function Indicator(props) {
  const {
    prefixCls,
    indicator,
    percent
  } = props, dotClassName = `${prefixCls}-dot`;
  return indicator && /* @__PURE__ */ React.isValidElement(indicator) ? cloneElement(indicator, {
    className: cn(indicator.props.className, dotClassName),
    percent
  }) : /* @__PURE__ */ React.createElement(Looper, {
    prefixCls,
    percent
  });
}
__name(Indicator, "Indicator");
const antSpinMove = new Keyframe("antSpinMove", {
  to: {
    opacity: 1
  }
}), antRotate = new Keyframe("antRotate", {
  to: {
    transform: "rotate(405deg)"
  }
}), genSpinStyle = /* @__PURE__ */ __name((token2) => {
  const {
    componentCls,
    calc
  } = token2;
  return {
    [componentCls]: Object.assign(Object.assign({}, resetComponent(token2)), {
      position: "absolute",
      display: "none",
      color: token2.colorPrimary,
      fontSize: 0,
      textAlign: "center",
      verticalAlign: "middle",
      opacity: 0,
      transition: `transform ${token2.motionDurationSlow} ${token2.motionEaseInOutCirc}`,
      "&-spinning": {
        position: "relative",
        display: "inline-block",
        opacity: 1
      },
      [`${componentCls}-text`]: {
        fontSize: token2.fontSize,
        paddingTop: calc(calc(token2.dotSize).sub(token2.fontSize)).div(2).add(2).equal()
      },
      "&-fullscreen": {
        position: "fixed",
        width: "100vw",
        height: "100vh",
        backgroundColor: token2.colorBgMask,
        zIndex: token2.zIndexPopupBase,
        inset: 0,
        display: "flex",
        alignItems: "center",
        flexDirection: "column",
        justifyContent: "center",
        opacity: 0,
        visibility: "hidden",
        transition: `all ${token2.motionDurationMid}`,
        "&-show": {
          opacity: 1,
          visibility: "visible"
        },
        [componentCls]: {
          [`${componentCls}-dot-holder`]: {
            color: token2.colorWhite
          },
          [`${componentCls}-text`]: {
            color: token2.colorTextLightSolid
          }
        }
      },
      "&-nested-loading": {
        position: "relative",
        [`> div > ${componentCls}`]: {
          position: "absolute",
          top: 0,
          insetInlineStart: 0,
          zIndex: 4,
          display: "block",
          width: "100%",
          height: "100%",
          maxHeight: token2.contentHeight,
          [`${componentCls}-dot`]: {
            position: "absolute",
            top: "50%",
            insetInlineStart: "50%",
            margin: calc(token2.dotSize).mul(-1).div(2).equal()
          },
          [`${componentCls}-text`]: {
            position: "absolute",
            top: "50%",
            width: "100%",
            textShadow: `0 1px 2px ${token2.colorBgContainer}`
            // FIXME: shadow
          },
          [`&${componentCls}-show-text ${componentCls}-dot`]: {
            marginTop: calc(token2.dotSize).div(2).mul(-1).sub(10).equal()
          },
          "&-sm": {
            [`${componentCls}-dot`]: {
              margin: calc(token2.dotSizeSM).mul(-1).div(2).equal()
            },
            [`${componentCls}-text`]: {
              paddingTop: calc(calc(token2.dotSizeSM).sub(token2.fontSize)).div(2).add(2).equal()
            },
            [`&${componentCls}-show-text ${componentCls}-dot`]: {
              marginTop: calc(token2.dotSizeSM).div(2).mul(-1).sub(10).equal()
            }
          },
          "&-lg": {
            [`${componentCls}-dot`]: {
              margin: calc(token2.dotSizeLG).mul(-1).div(2).equal()
            },
            [`${componentCls}-text`]: {
              paddingTop: calc(calc(token2.dotSizeLG).sub(token2.fontSize)).div(2).add(2).equal()
            },
            [`&${componentCls}-show-text ${componentCls}-dot`]: {
              marginTop: calc(token2.dotSizeLG).div(2).mul(-1).sub(10).equal()
            }
          }
        },
        [`${componentCls}-container`]: {
          position: "relative",
          transition: `opacity ${token2.motionDurationSlow}`,
          "&::after": {
            position: "absolute",
            top: 0,
            insetInlineEnd: 0,
            bottom: 0,
            insetInlineStart: 0,
            zIndex: 10,
            width: "100%",
            height: "100%",
            background: token2.colorBgContainer,
            opacity: 0,
            transition: `all ${token2.motionDurationSlow}`,
            content: '""',
            pointerEvents: "none"
          }
        },
        [`${componentCls}-blur`]: {
          clear: "both",
          opacity: 0.5,
          userSelect: "none",
          pointerEvents: "none",
          "&::after": {
            opacity: 0.4,
            pointerEvents: "auto"
          }
        }
      },
      // tip
      // ------------------------------
      "&-tip": {
        color: token2.spinDotDefault
      },
      // holder
      // ------------------------------
      [`${componentCls}-dot-holder`]: {
        width: "1em",
        height: "1em",
        fontSize: token2.dotSize,
        display: "inline-block",
        transition: `transform ${token2.motionDurationSlow} ease, opacity ${token2.motionDurationSlow} ease`,
        transformOrigin: "50% 50%",
        lineHeight: 1,
        color: token2.colorPrimary,
        "&-hidden": {
          transform: "scale(0.3)",
          opacity: 0
        }
      },
      // progress
      // ------------------------------
      [`${componentCls}-dot-progress`]: {
        position: "absolute",
        top: "50%",
        transform: "translate(-50%, -50%)",
        insetInlineStart: "50%"
      },
      // dots
      // ------------------------------
      [`${componentCls}-dot`]: {
        position: "relative",
        display: "inline-block",
        fontSize: token2.dotSize,
        width: "1em",
        height: "1em",
        "&-item": {
          position: "absolute",
          display: "block",
          width: calc(token2.dotSize).sub(calc(token2.marginXXS).div(2)).div(2).equal(),
          height: calc(token2.dotSize).sub(calc(token2.marginXXS).div(2)).div(2).equal(),
          background: "currentColor",
          borderRadius: "100%",
          transform: "scale(0.75)",
          transformOrigin: "50% 50%",
          opacity: 0.3,
          animationName: antSpinMove,
          animationDuration: "1s",
          animationIterationCount: "infinite",
          animationTimingFunction: "linear",
          animationDirection: "alternate",
          "&:nth-child(1)": {
            top: 0,
            insetInlineStart: 0,
            animationDelay: "0s"
          },
          "&:nth-child(2)": {
            top: 0,
            insetInlineEnd: 0,
            animationDelay: "0.4s"
          },
          "&:nth-child(3)": {
            insetInlineEnd: 0,
            bottom: 0,
            animationDelay: "0.8s"
          },
          "&:nth-child(4)": {
            bottom: 0,
            insetInlineStart: 0,
            animationDelay: "1.2s"
          }
        },
        "&-spin": {
          transform: "rotate(45deg)",
          animationName: antRotate,
          animationDuration: "1.2s",
          animationIterationCount: "infinite",
          animationTimingFunction: "linear"
        },
        "&-circle": {
          strokeLinecap: "round",
          transition: ["stroke-dashoffset", "stroke-dasharray", "stroke", "stroke-width", "opacity"].map((item) => `${item} ${token2.motionDurationSlow} ease`).join(","),
          fillOpacity: 0,
          stroke: "currentcolor"
        },
        "&-circle-bg": {
          stroke: token2.colorFillSecondary
        }
      },
      // small
      [`&-sm ${componentCls}-dot`]: {
        "&, &-holder": {
          fontSize: token2.dotSizeSM
        }
      },
      [`&-sm ${componentCls}-dot-holder`]: {
        i: {
          width: calc(calc(token2.dotSizeSM).sub(calc(token2.marginXXS).div(2))).div(2).equal(),
          height: calc(calc(token2.dotSizeSM).sub(calc(token2.marginXXS).div(2))).div(2).equal()
        }
      },
      // large
      [`&-lg ${componentCls}-dot`]: {
        "&, &-holder": {
          fontSize: token2.dotSizeLG
        }
      },
      [`&-lg ${componentCls}-dot-holder`]: {
        i: {
          width: calc(calc(token2.dotSizeLG).sub(token2.marginXXS)).div(2).equal(),
          height: calc(calc(token2.dotSizeLG).sub(token2.marginXXS)).div(2).equal()
        }
      },
      [`&${componentCls}-show-text ${componentCls}-text`]: {
        display: "block"
      }
    })
  };
}, "genSpinStyle"), prepareComponentToken$6 = /* @__PURE__ */ __name((token2) => {
  const {
    controlHeightLG,
    controlHeight
  } = token2;
  return {
    contentHeight: 400,
    dotSize: controlHeightLG / 2,
    dotSizeSM: controlHeightLG * 0.35,
    dotSizeLG: controlHeight
  };
}, "prepareComponentToken$6"), useStyle$6 = genStyleHooks("Spin", (token2) => {
  const spinToken = merge(token2, {
    spinDotDefault: token2.colorTextDescription
  });
  return [genSpinStyle(spinToken)];
}, prepareComponentToken$6), AUTO_INTERVAL = 200, STEP_BUCKETS = [[30, 0.05], [70, 0.03], [96, 0.01]];
function usePercent(spinning, percent) {
  const [mockPercent, setMockPercent] = React.useState(0), mockIntervalRef = React.useRef(null), isAuto = percent === "auto";
  return React.useEffect(() => (isAuto && spinning && (setMockPercent(0), mockIntervalRef.current = setInterval(() => {
    setMockPercent((prev2) => {
      const restPTG = 100 - prev2;
      for (let i = 0; i < STEP_BUCKETS.length; i += 1) {
        const [limit, stepPtg] = STEP_BUCKETS[i];
        if (prev2 <= limit)
          return prev2 + restPTG * stepPtg;
      }
      return prev2;
    });
  }, AUTO_INTERVAL)), () => {
    clearInterval(mockIntervalRef.current);
  }), [isAuto, spinning]), isAuto ? mockPercent : percent;
}
__name(usePercent, "usePercent");
var __rest$b = function(s, e2) {
  var t2 = {};
  for (var p in s) Object.prototype.hasOwnProperty.call(s, p) && e2.indexOf(p) < 0 && (t2[p] = s[p]);
  if (s != null && typeof Object.getOwnPropertySymbols == "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++)
    e2.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]) && (t2[p[i]] = s[p[i]]);
  return t2;
};
let defaultIndicator;
function shouldDelay(spinning, delay) {
  return !!spinning && !!delay && !isNaN(Number(delay));
}
__name(shouldDelay, "shouldDelay");
const Spin = /* @__PURE__ */ __name((props) => {
  var _a;
  const {
    prefixCls: customizePrefixCls,
    spinning: customSpinning = !0,
    delay = 0,
    className,
    rootClassName,
    size = "default",
    tip,
    wrapperClassName,
    style: style2,
    children,
    fullscreen = !1,
    indicator,
    percent
  } = props, restProps = __rest$b(props, ["prefixCls", "spinning", "delay", "className", "rootClassName", "size", "tip", "wrapperClassName", "style", "children", "fullscreen", "indicator", "percent"]), {
    getPrefixCls,
    direction,
    spin
  } = React.useContext(ConfigContext), prefixCls = getPrefixCls("spin", customizePrefixCls), [wrapCSSVar, hashId, cssVarCls] = useStyle$6(prefixCls), [spinning, setSpinning] = React.useState(() => customSpinning && !shouldDelay(customSpinning, delay)), mergedPercent = usePercent(spinning, percent);
  React.useEffect(() => {
    if (customSpinning) {
      const showSpinning = debounce(delay, () => {
        setSpinning(!0);
      });
      return showSpinning(), () => {
        var _a2;
        (_a2 = showSpinning == null ? void 0 : showSpinning.cancel) === null || _a2 === void 0 || _a2.call(showSpinning);
      };
    }
    setSpinning(!1);
  }, [delay, customSpinning]);
  const isNestedPattern = React.useMemo(() => typeof children < "u" && !fullscreen, [children, fullscreen]);
  if (process.env.NODE_ENV !== "production") {
    const warning3 = devUseWarning("Spin");
    process.env.NODE_ENV !== "production" && warning3(!tip || isNestedPattern || fullscreen, "usage", "`tip` only work in nest or fullscreen pattern.");
  }
  const spinClassName = cn(prefixCls, spin == null ? void 0 : spin.className, {
    [`${prefixCls}-sm`]: size === "small",
    [`${prefixCls}-lg`]: size === "large",
    [`${prefixCls}-spinning`]: spinning,
    [`${prefixCls}-show-text`]: !!tip,
    [`${prefixCls}-rtl`]: direction === "rtl"
  }, className, !fullscreen && rootClassName, hashId, cssVarCls), containerClassName = cn(`${prefixCls}-container`, {
    [`${prefixCls}-blur`]: spinning
  }), mergedIndicator = (_a = indicator ?? (spin == null ? void 0 : spin.indicator)) !== null && _a !== void 0 ? _a : defaultIndicator, mergedStyle = Object.assign(Object.assign({}, spin == null ? void 0 : spin.style), style2), spinElement = /* @__PURE__ */ React.createElement("div", Object.assign({}, restProps, {
    style: mergedStyle,
    className: spinClassName,
    "aria-live": "polite",
    "aria-busy": spinning
  }), /* @__PURE__ */ React.createElement(Indicator, {
    prefixCls,
    indicator: mergedIndicator,
    percent: mergedPercent
  }), tip && (isNestedPattern || fullscreen) ? /* @__PURE__ */ React.createElement("div", {
    className: `${prefixCls}-text`
  }, tip) : null);
  return wrapCSSVar(isNestedPattern ? /* @__PURE__ */ React.createElement("div", Object.assign({}, restProps, {
    className: cn(`${prefixCls}-nested-loading`, wrapperClassName, hashId, cssVarCls)
  }), spinning && /* @__PURE__ */ React.createElement("div", {
    key: "loading"
  }, spinElement), /* @__PURE__ */ React.createElement("div", {
    className: containerClassName,
    key: "container"
  }, children)) : fullscreen ? /* @__PURE__ */ React.createElement("div", {
    className: cn(`${prefixCls}-fullscreen`, {
      [`${prefixCls}-fullscreen-show`]: spinning
    }, rootClassName, hashId, cssVarCls)
  }, spinElement) : spinElement);
}, "Spin");
Spin.setDefaultIndicator = (indicator) => {
  defaultIndicator = indicator;
};
process.env.NODE_ENV !== "production" && (Spin.displayName = "Spin");
function toList$1(candidate) {
  return (arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1) && candidate == null ? [] : Array.isArray(candidate) ? candidate : [candidate];
}
__name(toList$1, "toList$1");
var defaultProps = {
  percent: 0,
  prefixCls: "rc-progress",
  strokeColor: "#2db7f5",
  strokeLinecap: "round",
  strokeWidth: 1,
  trailColor: "#D9D9D9",
  trailWidth: 1,
  gapPosition: "bottom"
}, useTransitionDuration = /* @__PURE__ */ __name(function() {
  var pathsRef = useRef([]), prevTimeStamp = useRef(null);
  return useEffect(function() {
    var now2 = Date.now(), updated = !1;
    pathsRef.current.forEach(function(path2) {
      if (path2) {
        updated = !0;
        var pathStyle = path2.style;
        pathStyle.transitionDuration = ".3s, .3s, .3s, .06s", prevTimeStamp.current && now2 - prevTimeStamp.current < 100 && (pathStyle.transitionDuration = "0s, 0s");
      }
    }), updated && (prevTimeStamp.current = Date.now());
  }), pathsRef.current;
}, "useTransitionDuration");
process.env.NODE_ENV;
var uuid = 0, isBrowserClient = process.env.NODE_ENV !== "test" && canUseDom();
function getUUID() {
  var retId;
  return isBrowserClient ? (retId = uuid, uuid += 1) : retId = "TEST_OR_SSR", retId;
}
__name(getUUID, "getUUID");
const useId2 = /* @__PURE__ */ __name(function(id2) {
  var _React$useState = React.useState(), _React$useState2 = _slicedToArray(_React$useState, 2), innerId = _React$useState2[0], setInnerId = _React$useState2[1];
  return React.useEffect(function() {
    setInnerId("rc_progress_".concat(getUUID()));
  }, []), id2 || innerId;
}, "useId");
var Block = /* @__PURE__ */ __name(function(_ref) {
  var bg = _ref.bg, children = _ref.children;
  return /* @__PURE__ */ React.createElement("div", {
    style: {
      width: "100%",
      height: "100%",
      background: bg
    }
  }, children);
}, "Block");
function getPtgColors(color, scale) {
  return Object.keys(color).map(function(key) {
    var parsedKey = parseFloat(key), ptgKey = "".concat(Math.floor(parsedKey * scale), "%");
    return "".concat(color[key], " ").concat(ptgKey);
  });
}
__name(getPtgColors, "getPtgColors");
var PtgCircle = /* @__PURE__ */ React.forwardRef(function(props, ref) {
  var prefixCls = props.prefixCls, color = props.color, gradientId = props.gradientId, radius2 = props.radius, circleStyleForStack = props.style, ptg = props.ptg, strokeLinecap = props.strokeLinecap, strokeWidth = props.strokeWidth, size = props.size, gapDegree = props.gapDegree, isGradient = color && _typeof$4(color) === "object", stroke = isGradient ? "#FFF" : void 0, halfSize = size / 2, circleNode = /* @__PURE__ */ React.createElement("circle", {
    className: "".concat(prefixCls, "-circle-path"),
    r: radius2,
    cx: halfSize,
    cy: halfSize,
    stroke,
    strokeLinecap,
    strokeWidth,
    opacity: ptg === 0 ? 0 : 1,
    style: circleStyleForStack,
    ref
  });
  if (!isGradient)
    return circleNode;
  var maskId = "".concat(gradientId, "-conic"), fromDeg = gapDegree ? "".concat(180 + gapDegree / 2, "deg") : "0deg", conicColors = getPtgColors(color, (360 - gapDegree) / 360), linearColors = getPtgColors(color, 1), conicColorBg = "conic-gradient(from ".concat(fromDeg, ", ").concat(conicColors.join(", "), ")"), linearColorBg = "linear-gradient(to ".concat(gapDegree ? "bottom" : "top", ", ").concat(linearColors.join(", "), ")");
  return /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement("mask", {
    id: maskId
  }, circleNode), /* @__PURE__ */ React.createElement("foreignObject", {
    x: 0,
    y: 0,
    width: size,
    height: size,
    mask: "url(#".concat(maskId, ")")
  }, /* @__PURE__ */ React.createElement(Block, {
    bg: linearColorBg
  }, /* @__PURE__ */ React.createElement(Block, {
    bg: conicColorBg
  }))));
});
process.env.NODE_ENV !== "production" && (PtgCircle.displayName = "PtgCircle");
var VIEW_BOX_SIZE = 100, getCircleStyle = /* @__PURE__ */ __name(function(perimeter, perimeterWithoutGap, offset2, percent, rotateDeg, gapDegree, gapPosition, strokeColor, strokeLinecap, strokeWidth) {
  var stepSpace = arguments.length > 10 && arguments[10] !== void 0 ? arguments[10] : 0, offsetDeg = offset2 / 100 * 360 * ((360 - gapDegree) / 360), positionDeg = gapDegree === 0 ? 0 : {
    bottom: 0,
    top: 180,
    left: 90,
    right: -90
  }[gapPosition], strokeDashoffset = (100 - percent) / 100 * perimeterWithoutGap;
  strokeLinecap === "round" && percent !== 100 && (strokeDashoffset += strokeWidth / 2, strokeDashoffset >= perimeterWithoutGap && (strokeDashoffset = perimeterWithoutGap - 0.01));
  var halfSize = VIEW_BOX_SIZE / 2;
  return {
    stroke: typeof strokeColor == "string" ? strokeColor : void 0,
    strokeDasharray: "".concat(perimeterWithoutGap, "px ").concat(perimeter),
    strokeDashoffset: strokeDashoffset + stepSpace,
    transform: "rotate(".concat(rotateDeg + offsetDeg + positionDeg, "deg)"),
    transformOrigin: "".concat(halfSize, "px ").concat(halfSize, "px"),
    transition: "stroke-dashoffset .3s ease 0s, stroke-dasharray .3s ease 0s, stroke .3s, stroke-width .06s ease .3s, opacity .3s ease 0s",
    fillOpacity: 0
  };
}, "getCircleStyle"), _excluded$a = ["id", "prefixCls", "steps", "strokeWidth", "trailWidth", "gapDegree", "gapPosition", "trailColor", "strokeLinecap", "style", "className", "strokeColor", "percent"];
function toArray$1(value) {
  var mergedValue = value ?? [];
  return Array.isArray(mergedValue) ? mergedValue : [mergedValue];
}
__name(toArray$1, "toArray$1");
var Circle$1 = /* @__PURE__ */ __name(function(props) {
  var _defaultProps$props = _objectSpread2$1(_objectSpread2$1({}, defaultProps), props), id2 = _defaultProps$props.id, prefixCls = _defaultProps$props.prefixCls, steps = _defaultProps$props.steps, strokeWidth = _defaultProps$props.strokeWidth, trailWidth = _defaultProps$props.trailWidth, _defaultProps$props$g = _defaultProps$props.gapDegree, gapDegree = _defaultProps$props$g === void 0 ? 0 : _defaultProps$props$g, gapPosition = _defaultProps$props.gapPosition, trailColor = _defaultProps$props.trailColor, strokeLinecap = _defaultProps$props.strokeLinecap, style2 = _defaultProps$props.style, className = _defaultProps$props.className, strokeColor = _defaultProps$props.strokeColor, percent = _defaultProps$props.percent, restProps = _objectWithoutProperties(_defaultProps$props, _excluded$a), halfSize = VIEW_BOX_SIZE / 2, mergedId = useId2(id2), gradientId = "".concat(mergedId, "-gradient"), radius2 = halfSize - strokeWidth / 2, perimeter = Math.PI * 2 * radius2, rotateDeg = gapDegree > 0 ? 90 + gapDegree / 2 : -90, perimeterWithoutGap = perimeter * ((360 - gapDegree) / 360), _ref = _typeof$4(steps) === "object" ? steps : {
    count: steps,
    gap: 2
  }, stepCount = _ref.count, stepGap = _ref.gap, percentList = toArray$1(percent), strokeColorList = toArray$1(strokeColor), gradient = strokeColorList.find(function(color) {
    return color && _typeof$4(color) === "object";
  }), isConicGradient = gradient && _typeof$4(gradient) === "object", mergedStrokeLinecap = isConicGradient ? "butt" : strokeLinecap, circleStyle = getCircleStyle(perimeter, perimeterWithoutGap, 0, 100, rotateDeg, gapDegree, gapPosition, trailColor, mergedStrokeLinecap, strokeWidth), paths = useTransitionDuration(), getStokeList = /* @__PURE__ */ __name(function() {
    var stackPtg = 0;
    return percentList.map(function(ptg, index2) {
      var color = strokeColorList[index2] || strokeColorList[strokeColorList.length - 1], circleStyleForStack = getCircleStyle(perimeter, perimeterWithoutGap, stackPtg, ptg, rotateDeg, gapDegree, gapPosition, color, mergedStrokeLinecap, strokeWidth);
      return stackPtg += ptg, /* @__PURE__ */ React.createElement(PtgCircle, {
        key: index2,
        color,
        ptg,
        radius: radius2,
        prefixCls,
        gradientId,
        style: circleStyleForStack,
        strokeLinecap: mergedStrokeLinecap,
        strokeWidth,
        gapDegree,
        ref: /* @__PURE__ */ __name(function(elem) {
          paths[index2] = elem;
        }, "ref"),
        size: VIEW_BOX_SIZE
      });
    }).reverse();
  }, "getStokeList"), getStepStokeList = /* @__PURE__ */ __name(function() {
    var current = Math.round(stepCount * (percentList[0] / 100)), stepPtg = 100 / stepCount, stackPtg = 0;
    return new Array(stepCount).fill(null).map(function(_2, index2) {
      var color = index2 <= current - 1 ? strokeColorList[0] : trailColor, stroke = color && _typeof$4(color) === "object" ? "url(#".concat(gradientId, ")") : void 0, circleStyleForStack = getCircleStyle(perimeter, perimeterWithoutGap, stackPtg, stepPtg, rotateDeg, gapDegree, gapPosition, color, "butt", strokeWidth, stepGap);
      return stackPtg += (perimeterWithoutGap - circleStyleForStack.strokeDashoffset + stepGap) * 100 / perimeterWithoutGap, /* @__PURE__ */ React.createElement("circle", {
        key: index2,
        className: "".concat(prefixCls, "-circle-path"),
        r: radius2,
        cx: halfSize,
        cy: halfSize,
        stroke,
        strokeWidth,
        opacity: 1,
        style: circleStyleForStack,
        ref: /* @__PURE__ */ __name(function(elem) {
          paths[index2] = elem;
        }, "ref")
      });
    });
  }, "getStepStokeList");
  return /* @__PURE__ */ React.createElement("svg", _extends({
    className: cn("".concat(prefixCls, "-circle"), className),
    viewBox: "0 0 ".concat(VIEW_BOX_SIZE, " ").concat(VIEW_BOX_SIZE),
    style: style2,
    id: id2,
    role: "presentation"
  }, restProps), !stepCount && /* @__PURE__ */ React.createElement("circle", {
    className: "".concat(prefixCls, "-circle-trail"),
    r: radius2,
    cx: halfSize,
    cy: halfSize,
    stroke: trailColor,
    strokeLinecap: mergedStrokeLinecap,
    strokeWidth: trailWidth || strokeWidth,
    style: circleStyle
  }), stepCount ? getStepStokeList() : getStokeList());
}, "Circle");
process.env.NODE_ENV !== "production" && (Circle$1.displayName = "Circle");
function validProgress(progress) {
  return !progress || progress < 0 ? 0 : progress > 100 ? 100 : progress;
}
__name(validProgress, "validProgress");
function getSuccessPercent(_ref) {
  let {
    success,
    successPercent
  } = _ref, percent = successPercent;
  return success && "progress" in success && (percent = success.progress), success && "percent" in success && (percent = success.percent), percent;
}
__name(getSuccessPercent, "getSuccessPercent");
const getPercentage = /* @__PURE__ */ __name((_ref2) => {
  let {
    percent,
    success,
    successPercent
  } = _ref2;
  const realSuccessPercent = validProgress(getSuccessPercent({
    success,
    successPercent
  }));
  return [realSuccessPercent, validProgress(validProgress(percent) - realSuccessPercent)];
}, "getPercentage"), getStrokeColor = /* @__PURE__ */ __name((_ref3) => {
  let {
    success = {},
    strokeColor
  } = _ref3;
  const {
    strokeColor: successColor
  } = success;
  return [successColor || presetPrimaryColors.green, strokeColor || null];
}, "getStrokeColor"), getSize2 = /* @__PURE__ */ __name((size, type4, extra) => {
  var _a, _b, _c, _d;
  let width = -1, height = -1;
  if (type4 === "step") {
    const steps = extra.steps, strokeWidth = extra.strokeWidth;
    typeof size == "string" || typeof size > "u" ? (width = size === "small" ? 2 : 14, height = strokeWidth ?? 8) : typeof size == "number" ? [width, height] = [size, size] : [width = 14, height = 8] = Array.isArray(size) ? size : [size.width, size.height], width *= steps;
  } else if (type4 === "line") {
    const strokeWidth = extra == null ? void 0 : extra.strokeWidth;
    typeof size == "string" || typeof size > "u" ? height = strokeWidth || (size === "small" ? 6 : 8) : typeof size == "number" ? [width, height] = [size, size] : [width = -1, height = 8] = Array.isArray(size) ? size : [size.width, size.height];
  } else (type4 === "circle" || type4 === "dashboard") && (typeof size == "string" || typeof size > "u" ? [width, height] = size === "small" ? [60, 60] : [120, 120] : typeof size == "number" ? [width, height] = [size, size] : Array.isArray(size) && (width = (_b = (_a = size[0]) !== null && _a !== void 0 ? _a : size[1]) !== null && _b !== void 0 ? _b : 120, height = (_d = (_c = size[0]) !== null && _c !== void 0 ? _c : size[1]) !== null && _d !== void 0 ? _d : 120));
  return [width, height];
}, "getSize"), CIRCLE_MIN_STROKE_WIDTH = 3, getMinPercent = /* @__PURE__ */ __name((width) => CIRCLE_MIN_STROKE_WIDTH / width * 100, "getMinPercent"), Circle2 = /* @__PURE__ */ __name((props) => {
  const {
    prefixCls,
    trailColor = null,
    strokeLinecap = "round",
    gapPosition,
    gapDegree,
    width: originWidth = 120,
    type: type4,
    children,
    success,
    size = originWidth,
    steps
  } = props, [width, height] = getSize2(size, "circle");
  let {
    strokeWidth
  } = props;
  strokeWidth === void 0 && (strokeWidth = Math.max(getMinPercent(width), 6));
  const circleStyle = {
    width,
    height,
    fontSize: width * 0.15 + 6
  }, realGapDegree = React.useMemo(() => {
    if (gapDegree || gapDegree === 0)
      return gapDegree;
    if (type4 === "dashboard")
      return 75;
  }, [gapDegree, type4]), percentArray = getPercentage(props), gapPos = gapPosition || type4 === "dashboard" && "bottom" || void 0, isGradient = Object.prototype.toString.call(props.strokeColor) === "[object Object]", strokeColor = getStrokeColor({
    success,
    strokeColor: props.strokeColor
  }), wrapperClassName = cn(`${prefixCls}-inner`, {
    [`${prefixCls}-circle-gradient`]: isGradient
  }), circleContent = /* @__PURE__ */ React.createElement(Circle$1, {
    steps,
    percent: steps ? percentArray[1] : percentArray,
    strokeWidth,
    trailWidth: strokeWidth,
    strokeColor: steps ? strokeColor[1] : strokeColor,
    strokeLinecap,
    trailColor,
    prefixCls,
    gapDegree: realGapDegree,
    gapPosition: gapPos
  }), smallCircle = width <= 20, node2 = /* @__PURE__ */ React.createElement("div", {
    className: wrapperClassName,
    style: circleStyle
  }, circleContent, !smallCircle && children);
  return smallCircle ? /* @__PURE__ */ React.createElement(Tooltip$1, {
    title: children
  }, node2) : node2;
}, "Circle"), LineStrokeColorVar = "--progress-line-stroke-color", Percent = "--progress-percent", genAntProgressActive = /* @__PURE__ */ __name((isRtl) => {
  const direction = isRtl ? "100%" : "-100%";
  return new Keyframe(`antProgress${isRtl ? "RTL" : "LTR"}Active`, {
    "0%": {
      transform: `translateX(${direction}) scaleX(0)`,
      opacity: 0.1
    },
    "20%": {
      transform: `translateX(${direction}) scaleX(0)`,
      opacity: 0.5
    },
    to: {
      transform: "translateX(0) scaleX(1)",
      opacity: 0
    }
  });
}, "genAntProgressActive"), genBaseStyle$2 = /* @__PURE__ */ __name((token2) => {
  const {
    componentCls: progressCls,
    iconCls: iconPrefixCls
  } = token2;
  return {
    [progressCls]: Object.assign(Object.assign({}, resetComponent(token2)), {
      display: "inline-block",
      "&-rtl": {
        direction: "rtl"
      },
      "&-line": {
        position: "relative",
        width: "100%",
        fontSize: token2.fontSize
      },
      [`${progressCls}-outer`]: {
        display: "inline-flex",
        alignItems: "center",
        width: "100%"
      },
      [`${progressCls}-inner`]: {
        position: "relative",
        display: "inline-block",
        width: "100%",
        flex: 1,
        overflow: "hidden",
        verticalAlign: "middle",
        backgroundColor: token2.remainingColor,
        borderRadius: token2.lineBorderRadius
      },
      [`${progressCls}-inner:not(${progressCls}-circle-gradient)`]: {
        [`${progressCls}-circle-path`]: {
          stroke: token2.defaultColor
        }
      },
      [`${progressCls}-success-bg, ${progressCls}-bg`]: {
        position: "relative",
        background: token2.defaultColor,
        borderRadius: token2.lineBorderRadius,
        transition: `all ${token2.motionDurationSlow} ${token2.motionEaseInOutCirc}`
      },
      [`${progressCls}-layout-bottom`]: {
        display: "flex",
        flexDirection: "column",
        alignItems: "center",
        justifyContent: "center",
        [`${progressCls}-text`]: {
          width: "max-content",
          marginInlineStart: 0,
          marginTop: token2.marginXXS
        }
      },
      [`${progressCls}-bg`]: {
        overflow: "hidden",
        "&::after": {
          content: '""',
          background: {
            _multi_value_: !0,
            value: ["inherit", `var(${LineStrokeColorVar})`]
          },
          height: "100%",
          width: `calc(1 / var(${Percent}) * 100%)`,
          display: "block"
        },
        [`&${progressCls}-bg-inner`]: {
          minWidth: "max-content",
          "&::after": {
            content: "none"
          },
          [`${progressCls}-text-inner`]: {
            color: token2.colorWhite,
            [`&${progressCls}-text-bright`]: {
              color: "rgba(0, 0, 0, 0.45)"
            }
          }
        }
      },
      [`${progressCls}-success-bg`]: {
        position: "absolute",
        insetBlockStart: 0,
        insetInlineStart: 0,
        backgroundColor: token2.colorSuccess
      },
      [`${progressCls}-text`]: {
        display: "inline-block",
        marginInlineStart: token2.marginXS,
        color: token2.colorText,
        lineHeight: 1,
        width: "2em",
        whiteSpace: "nowrap",
        textAlign: "start",
        verticalAlign: "middle",
        wordBreak: "normal",
        [iconPrefixCls]: {
          fontSize: token2.fontSize
        },
        [`&${progressCls}-text-outer`]: {
          width: "max-content"
        },
        [`&${progressCls}-text-outer${progressCls}-text-start`]: {
          width: "max-content",
          marginInlineStart: 0,
          marginInlineEnd: token2.marginXS
        }
      },
      [`${progressCls}-text-inner`]: {
        display: "flex",
        justifyContent: "center",
        alignItems: "center",
        width: "100%",
        height: "100%",
        marginInlineStart: 0,
        padding: `0 ${unit$1(token2.paddingXXS)}`,
        [`&${progressCls}-text-start`]: {
          justifyContent: "start"
        },
        [`&${progressCls}-text-end`]: {
          justifyContent: "end"
        }
      },
      [`&${progressCls}-status-active`]: {
        [`${progressCls}-bg::before`]: {
          position: "absolute",
          inset: 0,
          backgroundColor: token2.colorBgContainer,
          borderRadius: token2.lineBorderRadius,
          opacity: 0,
          animationName: genAntProgressActive(),
          animationDuration: token2.progressActiveMotionDuration,
          animationTimingFunction: token2.motionEaseOutQuint,
          animationIterationCount: "infinite",
          content: '""'
        }
      },
      [`&${progressCls}-rtl${progressCls}-status-active`]: {
        [`${progressCls}-bg::before`]: {
          animationName: genAntProgressActive(!0)
        }
      },
      [`&${progressCls}-status-exception`]: {
        [`${progressCls}-bg`]: {
          backgroundColor: token2.colorError
        },
        [`${progressCls}-text`]: {
          color: token2.colorError
        }
      },
      [`&${progressCls}-status-exception ${progressCls}-inner:not(${progressCls}-circle-gradient)`]: {
        [`${progressCls}-circle-path`]: {
          stroke: token2.colorError
        }
      },
      [`&${progressCls}-status-success`]: {
        [`${progressCls}-bg`]: {
          backgroundColor: token2.colorSuccess
        },
        [`${progressCls}-text`]: {
          color: token2.colorSuccess
        }
      },
      [`&${progressCls}-status-success ${progressCls}-inner:not(${progressCls}-circle-gradient)`]: {
        [`${progressCls}-circle-path`]: {
          stroke: token2.colorSuccess
        }
      }
    })
  };
}, "genBaseStyle$2"), genCircleStyle = /* @__PURE__ */ __name((token2) => {
  const {
    componentCls: progressCls,
    iconCls: iconPrefixCls
  } = token2;
  return {
    [progressCls]: {
      [`${progressCls}-circle-trail`]: {
        stroke: token2.remainingColor
      },
      [`&${progressCls}-circle ${progressCls}-inner`]: {
        position: "relative",
        lineHeight: 1,
        backgroundColor: "transparent"
      },
      [`&${progressCls}-circle ${progressCls}-text`]: {
        position: "absolute",
        insetBlockStart: "50%",
        insetInlineStart: 0,
        width: "100%",
        margin: 0,
        padding: 0,
        color: token2.circleTextColor,
        fontSize: token2.circleTextFontSize,
        lineHeight: 1,
        whiteSpace: "normal",
        textAlign: "center",
        transform: "translateY(-50%)",
        [iconPrefixCls]: {
          fontSize: token2.circleIconFontSize
        }
      },
      [`${progressCls}-circle&-status-exception`]: {
        [`${progressCls}-text`]: {
          color: token2.colorError
        }
      },
      [`${progressCls}-circle&-status-success`]: {
        [`${progressCls}-text`]: {
          color: token2.colorSuccess
        }
      }
    },
    [`${progressCls}-inline-circle`]: {
      lineHeight: 1,
      [`${progressCls}-inner`]: {
        verticalAlign: "bottom"
      }
    }
  };
}, "genCircleStyle"), genStepStyle = /* @__PURE__ */ __name((token2) => {
  const {
    componentCls: progressCls
  } = token2;
  return {
    [progressCls]: {
      [`${progressCls}-steps`]: {
        display: "inline-block",
        "&-outer": {
          display: "flex",
          flexDirection: "row",
          alignItems: "center"
        },
        "&-item": {
          flexShrink: 0,
          minWidth: token2.progressStepMinWidth,
          marginInlineEnd: token2.progressStepMarginInlineEnd,
          backgroundColor: token2.remainingColor,
          transition: `all ${token2.motionDurationSlow}`,
          "&-active": {
            backgroundColor: token2.defaultColor
          }
        }
      }
    }
  };
}, "genStepStyle"), genSmallLine = /* @__PURE__ */ __name((token2) => {
  const {
    componentCls: progressCls,
    iconCls: iconPrefixCls
  } = token2;
  return {
    [progressCls]: {
      [`${progressCls}-small&-line, ${progressCls}-small&-line ${progressCls}-text ${iconPrefixCls}`]: {
        fontSize: token2.fontSizeSM
      }
    }
  };
}, "genSmallLine"), prepareComponentToken$5 = /* @__PURE__ */ __name((token2) => ({
  circleTextColor: token2.colorText,
  defaultColor: token2.colorInfo,
  remainingColor: token2.colorFillSecondary,
  lineBorderRadius: 100,
  // magic for capsule shape, should be a very large number
  circleTextFontSize: "1em",
  circleIconFontSize: `${token2.fontSize / token2.fontSizeSM}em`
}), "prepareComponentToken$5"), useStyle$5 = genStyleHooks("Progress", (token2) => {
  const progressStepMarginInlineEnd = token2.calc(token2.marginXXS).div(2).equal(), progressToken = merge(token2, {
    progressStepMarginInlineEnd,
    progressStepMinWidth: progressStepMarginInlineEnd,
    progressActiveMotionDuration: "2.4s"
  });
  return [genBaseStyle$2(progressToken), genCircleStyle(progressToken), genStepStyle(progressToken), genSmallLine(progressToken)];
}, prepareComponentToken$5);
var __rest$a = function(s, e2) {
  var t2 = {};
  for (var p in s) Object.prototype.hasOwnProperty.call(s, p) && e2.indexOf(p) < 0 && (t2[p] = s[p]);
  if (s != null && typeof Object.getOwnPropertySymbols == "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++)
    e2.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]) && (t2[p[i]] = s[p[i]]);
  return t2;
};
const sortGradient = /* @__PURE__ */ __name((gradients) => {
  let tempArr = [];
  return Object.keys(gradients).forEach((key) => {
    const formattedKey = parseFloat(key.replace(/%/g, ""));
    Number.isNaN(formattedKey) || tempArr.push({
      key: formattedKey,
      value: gradients[key]
    });
  }), tempArr = tempArr.sort((a, b) => a.key - b.key), tempArr.map((_ref) => {
    let {
      key,
      value
    } = _ref;
    return `${value} ${key}%`;
  }).join(", ");
}, "sortGradient"), handleGradient = /* @__PURE__ */ __name((strokeColor, directionConfig) => {
  const {
    from: from2 = presetPrimaryColors.blue,
    to = presetPrimaryColors.blue,
    direction = directionConfig === "rtl" ? "to left" : "to right"
  } = strokeColor, rest = __rest$a(strokeColor, ["from", "to", "direction"]);
  if (Object.keys(rest).length !== 0) {
    const sortedGradients = sortGradient(rest), background2 = `linear-gradient(${direction}, ${sortedGradients})`;
    return {
      background: background2,
      [LineStrokeColorVar]: background2
    };
  }
  const background = `linear-gradient(${direction}, ${from2}, ${to})`;
  return {
    background,
    [LineStrokeColorVar]: background
  };
}, "handleGradient"), Line = /* @__PURE__ */ __name((props) => {
  const {
    prefixCls,
    direction: directionConfig,
    percent,
    size,
    strokeWidth,
    strokeColor,
    strokeLinecap = "round",
    children,
    trailColor = null,
    percentPosition,
    success
  } = props, {
    align: infoAlign,
    type: infoPosition
  } = percentPosition, backgroundProps = strokeColor && typeof strokeColor != "string" ? handleGradient(strokeColor, directionConfig) : {
    [LineStrokeColorVar]: strokeColor,
    background: strokeColor
  }, borderRadius = strokeLinecap === "square" || strokeLinecap === "butt" ? 0 : void 0, mergedSize = size ?? [-1, strokeWidth || (size === "small" ? 6 : 8)], [width, height] = getSize2(mergedSize, "line", {
    strokeWidth
  });
  process.env.NODE_ENV !== "production" && devUseWarning("Progress").deprecated(!("strokeWidth" in props), "strokeWidth", "size");
  const trailStyle = {
    backgroundColor: trailColor || void 0,
    borderRadius
  }, percentStyle = Object.assign(Object.assign({
    width: `${validProgress(percent)}%`,
    height,
    borderRadius
  }, backgroundProps), {
    [Percent]: validProgress(percent) / 100
  }), successPercent = getSuccessPercent(props), successPercentStyle = {
    width: `${validProgress(successPercent)}%`,
    height,
    borderRadius,
    backgroundColor: success == null ? void 0 : success.strokeColor
  }, outerStyle = {
    width: width < 0 ? "100%" : width
  }, lineInner = /* @__PURE__ */ React.createElement("div", {
    className: `${prefixCls}-inner`,
    style: trailStyle
  }, /* @__PURE__ */ React.createElement("div", {
    className: cn(`${prefixCls}-bg`, `${prefixCls}-bg-${infoPosition}`),
    style: percentStyle
  }, infoPosition === "inner" && children), successPercent !== void 0 && /* @__PURE__ */ React.createElement("div", {
    className: `${prefixCls}-success-bg`,
    style: successPercentStyle
  })), isOuterStart = infoPosition === "outer" && infoAlign === "start", isOuterEnd = infoPosition === "outer" && infoAlign === "end";
  return infoPosition === "outer" && infoAlign === "center" ? /* @__PURE__ */ React.createElement("div", {
    className: `${prefixCls}-layout-bottom`
  }, lineInner, children) : /* @__PURE__ */ React.createElement("div", {
    className: `${prefixCls}-outer`,
    style: outerStyle
  }, isOuterStart && children, lineInner, isOuterEnd && children);
}, "Line"), Steps = /* @__PURE__ */ __name((props) => {
  const {
    size,
    steps,
    percent = 0,
    strokeWidth = 8,
    strokeColor,
    trailColor = null,
    prefixCls,
    children
  } = props, current = Math.round(steps * (percent / 100)), mergedSize = size ?? [size === "small" ? 2 : 14, strokeWidth], [width, height] = getSize2(mergedSize, "step", {
    steps,
    strokeWidth
  }), unitWidth = width / steps, styledSteps = new Array(steps);
  for (let i = 0; i < steps; i++) {
    const color = Array.isArray(strokeColor) ? strokeColor[i] : strokeColor;
    styledSteps[i] = /* @__PURE__ */ React.createElement("div", {
      key: i,
      className: cn(`${prefixCls}-steps-item`, {
        [`${prefixCls}-steps-item-active`]: i <= current - 1
      }),
      style: {
        backgroundColor: i <= current - 1 ? color : trailColor,
        width: unitWidth,
        height
      }
    });
  }
  return /* @__PURE__ */ React.createElement("div", {
    className: `${prefixCls}-steps-outer`
  }, styledSteps, children);
}, "Steps");
var __rest$9 = function(s, e2) {
  var t2 = {};
  for (var p in s) Object.prototype.hasOwnProperty.call(s, p) && e2.indexOf(p) < 0 && (t2[p] = s[p]);
  if (s != null && typeof Object.getOwnPropertySymbols == "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++)
    e2.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]) && (t2[p[i]] = s[p[i]]);
  return t2;
};
const ProgressStatuses = ["normal", "exception", "active", "success"], Progress = /* @__PURE__ */ React.forwardRef((props, ref) => {
  const {
    prefixCls: customizePrefixCls,
    className,
    rootClassName,
    steps,
    strokeColor,
    percent = 0,
    size = "default",
    showInfo = !0,
    type: type4 = "line",
    status,
    format: format3,
    style: style2,
    percentPosition = {}
  } = props, restProps = __rest$9(props, ["prefixCls", "className", "rootClassName", "steps", "strokeColor", "percent", "size", "showInfo", "type", "status", "format", "style", "percentPosition"]), {
    align: infoAlign = "end",
    type: infoPosition = "outer"
  } = percentPosition, strokeColorNotArray = Array.isArray(strokeColor) ? strokeColor[0] : strokeColor, strokeColorNotGradient = typeof strokeColor == "string" || Array.isArray(strokeColor) ? strokeColor : void 0, strokeColorIsBright = React.useMemo(() => {
    if (strokeColorNotArray) {
      const color = typeof strokeColorNotArray == "string" ? strokeColorNotArray : Object.values(strokeColorNotArray)[0];
      return new TinyColor(color).isLight();
    }
    return !1;
  }, [strokeColor]), percentNumber = React.useMemo(() => {
    var _a, _b;
    const successPercent = getSuccessPercent(props);
    return parseInt(successPercent !== void 0 ? (_a = successPercent ?? 0) === null || _a === void 0 ? void 0 : _a.toString() : (_b = percent ?? 0) === null || _b === void 0 ? void 0 : _b.toString(), 10);
  }, [percent, props.success, props.successPercent]), progressStatus = React.useMemo(() => !ProgressStatuses.includes(status) && percentNumber >= 100 ? "success" : status || "normal", [status, percentNumber]), {
    getPrefixCls,
    direction,
    progress: progressStyle
  } = React.useContext(ConfigContext), prefixCls = getPrefixCls("progress", customizePrefixCls), [wrapCSSVar, hashId, cssVarCls] = useStyle$5(prefixCls), isLineType = type4 === "line", isPureLineType = isLineType && !steps, progressInfo = React.useMemo(() => {
    if (!showInfo)
      return null;
    const successPercent = getSuccessPercent(props);
    let text;
    const textFormatter = format3 || ((number4) => `${number4}%`), isBrightInnerColor = isLineType && strokeColorIsBright && infoPosition === "inner";
    return infoPosition === "inner" || format3 || progressStatus !== "exception" && progressStatus !== "success" ? text = textFormatter(validProgress(percent), validProgress(successPercent)) : progressStatus === "exception" ? text = isLineType ? /* @__PURE__ */ React.createElement(RefIcon$C, null) : /* @__PURE__ */ React.createElement(RefIcon$B, null) : progressStatus === "success" && (text = isLineType ? /* @__PURE__ */ React.createElement(RefIcon$D, null) : /* @__PURE__ */ React.createElement(RefIcon$x, null)), /* @__PURE__ */ React.createElement("span", {
      className: cn(`${prefixCls}-text`, {
        [`${prefixCls}-text-bright`]: isBrightInnerColor,
        [`${prefixCls}-text-${infoAlign}`]: isPureLineType,
        [`${prefixCls}-text-${infoPosition}`]: isPureLineType
      }),
      title: typeof text == "string" ? text : void 0
    }, text);
  }, [showInfo, percent, percentNumber, progressStatus, type4, prefixCls, format3]);
  if (process.env.NODE_ENV !== "production") {
    const warning3 = devUseWarning("Progress");
    warning3.deprecated(!("successPercent" in props), "successPercent", "success.percent"), warning3.deprecated(!("width" in props), "width", "size"), (type4 === "circle" || type4 === "dashboard") && (Array.isArray(size) ? process.env.NODE_ENV !== "production" && warning3(!1, "usage", 'Type "circle" and "dashboard" do not accept array as `size`, please use number or preset size instead.') : typeof size == "object" && process.env.NODE_ENV !== "production" && warning3(!1, "usage", 'Type "circle" and "dashboard" do not accept object as `size`, please use number or preset size instead.')), props.success && "progress" in props.success && warning3.deprecated(!1, "success.progress", "success.percent");
  }
  let progress;
  type4 === "line" ? progress = steps ? /* @__PURE__ */ React.createElement(Steps, Object.assign({}, props, {
    strokeColor: strokeColorNotGradient,
    prefixCls,
    steps: typeof steps == "object" ? steps.count : steps
  }), progressInfo) : /* @__PURE__ */ React.createElement(Line, Object.assign({}, props, {
    strokeColor: strokeColorNotArray,
    prefixCls,
    direction,
    percentPosition: {
      align: infoAlign,
      type: infoPosition
    }
  }), progressInfo) : (type4 === "circle" || type4 === "dashboard") && (progress = /* @__PURE__ */ React.createElement(Circle2, Object.assign({}, props, {
    strokeColor: strokeColorNotArray,
    prefixCls,
    progressStatus
  }), progressInfo));
  const classString = cn(prefixCls, `${prefixCls}-status-${progressStatus}`, {
    [`${prefixCls}-${type4 === "dashboard" && "circle" || type4}`]: type4 !== "line",
    [`${prefixCls}-inline-circle`]: type4 === "circle" && getSize2(size, "circle")[0] <= 20,
    [`${prefixCls}-line`]: isPureLineType,
    [`${prefixCls}-line-align-${infoAlign}`]: isPureLineType,
    [`${prefixCls}-line-position-${infoPosition}`]: isPureLineType,
    [`${prefixCls}-steps`]: steps,
    [`${prefixCls}-show-info`]: showInfo,
    [`${prefixCls}-${size}`]: typeof size == "string",
    [`${prefixCls}-rtl`]: direction === "rtl"
  }, progressStyle == null ? void 0 : progressStyle.className, className, rootClassName, hashId, cssVarCls);
  return wrapCSSVar(/* @__PURE__ */ React.createElement("div", Object.assign({
    ref,
    style: Object.assign(Object.assign({}, progressStyle == null ? void 0 : progressStyle.style), style2),
    className: classString,
    role: "progressbar",
    "aria-valuenow": percentNumber,
    "aria-valuemin": 0,
    "aria-valuemax": 100
  }, omit(restProps, ["trailColor", "strokeWidth", "width", "gapDegree", "gapPosition", "strokeLinecap", "success", "successPercent"])), progress));
});
process.env.NODE_ENV !== "production" && (Progress.displayName = "Progress");
var CaretDownFilled$1 = { icon: { tag: "svg", attrs: { viewBox: "0 0 1024 1024", focusable: "false" }, children: [{ tag: "path", attrs: { d: "M840.4 300H183.6c-19.7 0-30.7 20.8-18.5 35l328.4 380.8c9.4 10.9 27.5 10.9 37 0L858.9 335c12.2-14.2 1.2-35-18.5-35z" } }] }, name: "caret-down", theme: "filled" }, CaretDownFilled = /* @__PURE__ */ __name(function(props, ref) {
  return /* @__PURE__ */ React.createElement(Icon$3, _extends({}, props, {
    ref,
    icon: CaretDownFilled$1
  }));
}, "CaretDownFilled"), RefIcon$h = /* @__PURE__ */ React.forwardRef(CaretDownFilled);
process.env.NODE_ENV !== "production" && (RefIcon$h.displayName = "CaretDownFilled");
var CaretDownOutlined$1 = { icon: { tag: "svg", attrs: { viewBox: "0 0 1024 1024", focusable: "false" }, children: [{ tag: "path", attrs: { d: "M840.4 300H183.6c-19.7 0-30.7 20.8-18.5 35l328.4 380.8c9.4 10.9 27.5 10.9 37 0L858.9 335c12.2-14.2 1.2-35-18.5-35z" } }] }, name: "caret-down", theme: "outlined" }, CaretDownOutlined = /* @__PURE__ */ __name(function(props, ref) {
  return /* @__PURE__ */ React.createElement(Icon$3, _extends({}, props, {
    ref,
    icon: CaretDownOutlined$1
  }));
}, "CaretDownOutlined"), RefIcon$g = /* @__PURE__ */ React.forwardRef(CaretDownOutlined);
process.env.NODE_ENV !== "production" && (RefIcon$g.displayName = "CaretDownOutlined");
var CaretUpOutlined$1 = { icon: { tag: "svg", attrs: { viewBox: "0 0 1024 1024", focusable: "false" }, children: [{ tag: "path", attrs: { d: "M858.9 689L530.5 308.2c-9.4-10.9-27.5-10.9-37 0L165.1 689c-12.2 14.2-1.2 35 18.5 35h656.8c19.7 0 30.7-20.8 18.5-35z" } }] }, name: "caret-up", theme: "outlined" }, CaretUpOutlined = /* @__PURE__ */ __name(function(props, ref) {
  return /* @__PURE__ */ React.createElement(Icon$3, _extends({}, props, {
    ref,
    icon: CaretUpOutlined$1
  }));
}, "CaretUpOutlined"), RefIcon$f = /* @__PURE__ */ React.forwardRef(CaretUpOutlined);
process.env.NODE_ENV !== "production" && (RefIcon$f.displayName = "CaretUpOutlined");
var CopyOutlined$1 = { icon: { tag: "svg", attrs: { viewBox: "64 64 896 896", focusable: "false" }, children: [{ tag: "path", attrs: { d: "M832 64H296c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h496v688c0 4.4 3.6 8 8 8h56c4.4 0 8-3.6 8-8V96c0-17.7-14.3-32-32-32zM704 192H192c-17.7 0-32 14.3-32 32v530.7c0 8.5 3.4 16.6 9.4 22.6l173.3 173.3c2.2 2.2 4.7 4 7.4 5.5v1.9h4.2c3.5 1.3 7.2 2 11 2H704c17.7 0 32-14.3 32-32V224c0-17.7-14.3-32-32-32zM350 856.2L263.9 770H350v86.2zM664 888H414V746c0-22.1-17.9-40-40-40H232V264h432v624z" } }] }, name: "copy", theme: "outlined" }, CopyOutlined = /* @__PURE__ */ __name(function(props, ref) {
  return /* @__PURE__ */ React.createElement(Icon$3, _extends({}, props, {
    ref,
    icon: CopyOutlined$1
  }));
}, "CopyOutlined"), RefIcon$e = /* @__PURE__ */ React.forwardRef(CopyOutlined);
process.env.NODE_ENV !== "production" && (RefIcon$e.displayName = "CopyOutlined");
var DeleteOutlined$1 = { icon: { tag: "svg", attrs: { viewBox: "64 64 896 896", focusable: "false" }, children: [{ tag: "path", attrs: { d: "M360 184h-8c4.4 0 8-3.6 8-8v8h304v-8c0 4.4 3.6 8 8 8h-8v72h72v-80c0-35.3-28.7-64-64-64H352c-35.3 0-64 28.7-64 64v80h72v-72zm504 72H160c-17.7 0-32 14.3-32 32v32c0 4.4 3.6 8 8 8h60.4l24.7 523c1.6 34.1 29.8 61 63.9 61h454c34.2 0 62.3-26.8 63.9-61l24.7-523H888c4.4 0 8-3.6 8-8v-32c0-17.7-14.3-32-32-32zM731.3 840H292.7l-24.2-512h487l-24.2 512z" } }] }, name: "delete", theme: "outlined" }, DeleteOutlined = /* @__PURE__ */ __name(function(props, ref) {
  return /* @__PURE__ */ React.createElement(Icon$3, _extends({}, props, {
    ref,
    icon: DeleteOutlined$1
  }));
}, "DeleteOutlined"), RefIcon$d = /* @__PURE__ */ React.forwardRef(DeleteOutlined);
process.env.NODE_ENV !== "production" && (RefIcon$d.displayName = "DeleteOutlined");
var DownloadOutlined$1 = { icon: { tag: "svg", attrs: { viewBox: "64 64 896 896", focusable: "false" }, children: [{ tag: "path", attrs: { d: "M505.7 661a8 8 0 0012.6 0l112-141.7c4.1-5.2.4-12.9-6.3-12.9h-74.1V168c0-4.4-3.6-8-8-8h-60c-4.4 0-8 3.6-8 8v338.3H400c-6.7 0-10.4 7.7-6.3 12.9l112 141.8zM878 626h-60c-4.4 0-8 3.6-8 8v154H214V634c0-4.4-3.6-8-8-8h-60c-4.4 0-8 3.6-8 8v198c0 17.7 14.3 32 32 32h684c17.7 0 32-14.3 32-32V634c0-4.4-3.6-8-8-8z" } }] }, name: "download", theme: "outlined" }, DownloadOutlined = /* @__PURE__ */ __name(function(props, ref) {
  return /* @__PURE__ */ React.createElement(Icon$3, _extends({}, props, {
    ref,
    icon: DownloadOutlined$1
  }));
}, "DownloadOutlined"), RefIcon$c = /* @__PURE__ */ React.forwardRef(DownloadOutlined);
process.env.NODE_ENV !== "production" && (RefIcon$c.displayName = "DownloadOutlined");
var EditOutlined$1 = { icon: { tag: "svg", attrs: { viewBox: "64 64 896 896", focusable: "false" }, children: [{ tag: "path", attrs: { d: "M257.7 752c2 0 4-.2 6-.5L431.9 722c2-.4 3.9-1.3 5.3-2.8l423.9-423.9a9.96 9.96 0 000-14.1L694.9 114.9c-1.9-1.9-4.4-2.9-7.1-2.9s-5.2 1-7.1 2.9L256.8 538.8c-1.5 1.5-2.4 3.3-2.8 5.3l-29.5 168.2a33.5 33.5 0 009.4 29.8c6.6 6.4 14.9 9.9 23.8 9.9zm67.4-174.4L687.8 215l73.3 73.3-362.7 362.6-88.9 15.7 15.6-89zM880 836H144c-17.7 0-32 14.3-32 32v36c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-36c0-17.7-14.3-32-32-32z" } }] }, name: "edit", theme: "outlined" }, EditOutlined = /* @__PURE__ */ __name(function(props, ref) {
  return /* @__PURE__ */ React.createElement(Icon$3, _extends({}, props, {
    ref,
    icon: EditOutlined$1
  }));
}, "EditOutlined"), RefIcon$b = /* @__PURE__ */ React.forwardRef(EditOutlined);
process.env.NODE_ENV !== "production" && (RefIcon$b.displayName = "EditOutlined");
var EnterOutlined$1 = { icon: { tag: "svg", attrs: { viewBox: "64 64 896 896", focusable: "false" }, children: [{ tag: "path", attrs: { d: "M864 170h-60c-4.4 0-8 3.6-8 8v518H310v-73c0-6.7-7.8-10.5-13-6.3l-141.9 112a8 8 0 000 12.6l141.9 112c5.3 4.2 13 .4 13-6.3v-75h498c35.3 0 64-28.7 64-64V178c0-4.4-3.6-8-8-8z" } }] }, name: "enter", theme: "outlined" }, EnterOutlined = /* @__PURE__ */ __name(function(props, ref) {
  return /* @__PURE__ */ React.createElement(Icon$3, _extends({}, props, {
    ref,
    icon: EnterOutlined$1
  }));
}, "EnterOutlined"), RefIcon$a = /* @__PURE__ */ React.forwardRef(EnterOutlined);
process.env.NODE_ENV !== "production" && (RefIcon$a.displayName = "EnterOutlined");
var FileOutlined$1 = { icon: { tag: "svg", attrs: { viewBox: "64 64 896 896", focusable: "false" }, children: [{ tag: "path", attrs: { d: "M854.6 288.6L639.4 73.4c-6-6-14.1-9.4-22.6-9.4H192c-17.7 0-32 14.3-32 32v832c0 17.7 14.3 32 32 32h640c17.7 0 32-14.3 32-32V311.3c0-8.5-3.4-16.7-9.4-22.7zM790.2 326H602V137.8L790.2 326zm1.8 562H232V136h302v216a42 42 0 0042 42h216v494z" } }] }, name: "file", theme: "outlined" }, FileOutlined = /* @__PURE__ */ __name(function(props, ref) {
  return /* @__PURE__ */ React.createElement(Icon$3, _extends({}, props, {
    ref,
    icon: FileOutlined$1
  }));
}, "FileOutlined"), RefIcon$9 = /* @__PURE__ */ React.forwardRef(FileOutlined);
process.env.NODE_ENV !== "production" && (RefIcon$9.displayName = "FileOutlined");
var FileTwoTone$1 = { icon: /* @__PURE__ */ __name(function(primaryColor, secondaryColor) {
  return { tag: "svg", attrs: { viewBox: "64 64 896 896", focusable: "false" }, children: [{ tag: "path", attrs: { d: "M534 352V136H232v752h560V394H576a42 42 0 01-42-42z", fill: secondaryColor } }, { tag: "path", attrs: { d: "M854.6 288.6L639.4 73.4c-6-6-14.1-9.4-22.6-9.4H192c-17.7 0-32 14.3-32 32v832c0 17.7 14.3 32 32 32h640c17.7 0 32-14.3 32-32V311.3c0-8.5-3.4-16.7-9.4-22.7zM602 137.8L790.2 326H602V137.8zM792 888H232V136h302v216a42 42 0 0042 42h216v494z", fill: primaryColor } }] };
}, "render"), name: "file", theme: "twotone" }, FileTwoTone = /* @__PURE__ */ __name(function(props, ref) {
  return /* @__PURE__ */ React.createElement(Icon$3, _extends({}, props, {
    ref,
    icon: FileTwoTone$1
  }));
}, "FileTwoTone"), RefIcon$8 = /* @__PURE__ */ React.forwardRef(FileTwoTone);
process.env.NODE_ENV !== "production" && (RefIcon$8.displayName = "FileTwoTone");
var FilterFilled$1 = { icon: { tag: "svg", attrs: { viewBox: "64 64 896 896", focusable: "false" }, children: [{ tag: "path", attrs: { d: "M349 838c0 17.7 14.2 32 31.8 32h262.4c17.6 0 31.8-14.3 31.8-32V642H349v196zm531.1-684H143.9c-24.5 0-39.8 26.7-27.5 48l221.3 376h348.8l221.3-376c12.1-21.3-3.2-48-27.7-48z" } }] }, name: "filter", theme: "filled" }, FilterFilled = /* @__PURE__ */ __name(function(props, ref) {
  return /* @__PURE__ */ React.createElement(Icon$3, _extends({}, props, {
    ref,
    icon: FilterFilled$1
  }));
}, "FilterFilled"), RefIcon$7 = /* @__PURE__ */ React.forwardRef(FilterFilled);
process.env.NODE_ENV !== "production" && (RefIcon$7.displayName = "FilterFilled");
var FolderOpenOutlined$1 = { icon: { tag: "svg", attrs: { viewBox: "64 64 896 896", focusable: "false" }, children: [{ tag: "path", attrs: { d: "M928 444H820V330.4c0-17.7-14.3-32-32-32H473L355.7 186.2a8.15 8.15 0 00-5.5-2.2H96c-17.7 0-32 14.3-32 32v592c0 17.7 14.3 32 32 32h698c13 0 24.8-7.9 29.7-20l134-332c1.5-3.8 2.3-7.9 2.3-12 0-17.7-14.3-32-32-32zM136 256h188.5l119.6 114.4H748V444H238c-13 0-24.8 7.9-29.7 20L136 643.2V256zm635.3 512H159l103.3-256h612.4L771.3 768z" } }] }, name: "folder-open", theme: "outlined" }, FolderOpenOutlined = /* @__PURE__ */ __name(function(props, ref) {
  return /* @__PURE__ */ React.createElement(Icon$3, _extends({}, props, {
    ref,
    icon: FolderOpenOutlined$1
  }));
}, "FolderOpenOutlined"), RefIcon$6 = /* @__PURE__ */ React.forwardRef(FolderOpenOutlined);
process.env.NODE_ENV !== "production" && (RefIcon$6.displayName = "FolderOpenOutlined");
var FolderOutlined$1 = { icon: { tag: "svg", attrs: { viewBox: "64 64 896 896", focusable: "false" }, children: [{ tag: "path", attrs: { d: "M880 298.4H521L403.7 186.2a8.15 8.15 0 00-5.5-2.2H144c-17.7 0-32 14.3-32 32v592c0 17.7 14.3 32 32 32h736c17.7 0 32-14.3 32-32V330.4c0-17.7-14.3-32-32-32zM840 768H184V256h188.5l119.6 114.4H840V768z" } }] }, name: "folder", theme: "outlined" }, FolderOutlined = /* @__PURE__ */ __name(function(props, ref) {
  return /* @__PURE__ */ React.createElement(Icon$3, _extends({}, props, {
    ref,
    icon: FolderOutlined$1
  }));
}, "FolderOutlined"), RefIcon$5 = /* @__PURE__ */ React.forwardRef(FolderOutlined);
process.env.NODE_ENV !== "production" && (RefIcon$5.displayName = "FolderOutlined");
var HolderOutlined$1 = { icon: { tag: "svg", attrs: { viewBox: "64 64 896 896", focusable: "false" }, children: [{ tag: "path", attrs: { d: "M300 276.5a56 56 0 1056-97 56 56 0 00-56 97zm0 284a56 56 0 1056-97 56 56 0 00-56 97zM640 228a56 56 0 10112 0 56 56 0 00-112 0zm0 284a56 56 0 10112 0 56 56 0 00-112 0zM300 844.5a56 56 0 1056-97 56 56 0 00-56 97zM640 796a56 56 0 10112 0 56 56 0 00-112 0z" } }] }, name: "holder", theme: "outlined" }, HolderOutlined = /* @__PURE__ */ __name(function(props, ref) {
  return /* @__PURE__ */ React.createElement(Icon$3, _extends({}, props, {
    ref,
    icon: HolderOutlined$1
  }));
}, "HolderOutlined"), RefIcon$4 = /* @__PURE__ */ React.forwardRef(HolderOutlined);
process.env.NODE_ENV !== "production" && (RefIcon$4.displayName = "HolderOutlined");
var MinusSquareOutlined$1 = { icon: { tag: "svg", attrs: { viewBox: "64 64 896 896", focusable: "false" }, children: [{ tag: "path", attrs: { d: "M328 544h368c4.4 0 8-3.6 8-8v-48c0-4.4-3.6-8-8-8H328c-4.4 0-8 3.6-8 8v48c0 4.4 3.6 8 8 8z" } }, { tag: "path", attrs: { d: "M880 112H144c-17.7 0-32 14.3-32 32v736c0 17.7 14.3 32 32 32h736c17.7 0 32-14.3 32-32V144c0-17.7-14.3-32-32-32zm-40 728H184V184h656v656z" } }] }, name: "minus-square", theme: "outlined" }, MinusSquareOutlined = /* @__PURE__ */ __name(function(props, ref) {
  return /* @__PURE__ */ React.createElement(Icon$3, _extends({}, props, {
    ref,
    icon: MinusSquareOutlined$1
  }));
}, "MinusSquareOutlined"), RefIcon$3 = /* @__PURE__ */ React.forwardRef(MinusSquareOutlined);
process.env.NODE_ENV !== "production" && (RefIcon$3.displayName = "MinusSquareOutlined");
var PaperClipOutlined$1 = { icon: { tag: "svg", attrs: { viewBox: "64 64 896 896", focusable: "false" }, children: [{ tag: "path", attrs: { d: "M779.3 196.6c-94.2-94.2-247.6-94.2-341.7 0l-261 260.8c-1.7 1.7-2.6 4-2.6 6.4s.9 4.7 2.6 6.4l36.9 36.9a9 9 0 0012.7 0l261-260.8c32.4-32.4 75.5-50.2 121.3-50.2s88.9 17.8 121.2 50.2c32.4 32.4 50.2 75.5 50.2 121.2 0 45.8-17.8 88.8-50.2 121.2l-266 265.9-43.1 43.1c-40.3 40.3-105.8 40.3-146.1 0-19.5-19.5-30.2-45.4-30.2-73s10.7-53.5 30.2-73l263.9-263.8c6.7-6.6 15.5-10.3 24.9-10.3h.1c9.4 0 18.1 3.7 24.7 10.3 6.7 6.7 10.3 15.5 10.3 24.9 0 9.3-3.7 18.1-10.3 24.7L372.4 653c-1.7 1.7-2.6 4-2.6 6.4s.9 4.7 2.6 6.4l36.9 36.9a9 9 0 0012.7 0l215.6-215.6c19.9-19.9 30.8-46.3 30.8-74.4s-11-54.6-30.8-74.4c-41.1-41.1-107.9-41-149 0L463 364 224.8 602.1A172.22 172.22 0 00174 724.8c0 46.3 18.1 89.8 50.8 122.5 33.9 33.8 78.3 50.7 122.7 50.7 44.4 0 88.8-16.9 122.6-50.7l309.2-309C824.8 492.7 850 432 850 367.5c.1-64.6-25.1-125.3-70.7-170.9z" } }] }, name: "paper-clip", theme: "outlined" }, PaperClipOutlined = /* @__PURE__ */ __name(function(props, ref) {
  return /* @__PURE__ */ React.createElement(Icon$3, _extends({}, props, {
    ref,
    icon: PaperClipOutlined$1
  }));
}, "PaperClipOutlined"), RefIcon$2 = /* @__PURE__ */ React.forwardRef(PaperClipOutlined);
process.env.NODE_ENV !== "production" && (RefIcon$2.displayName = "PaperClipOutlined");
var PictureTwoTone$1 = { icon: /* @__PURE__ */ __name(function(primaryColor, secondaryColor) {
  return { tag: "svg", attrs: { viewBox: "64 64 896 896", focusable: "false" }, children: [{ tag: "path", attrs: { d: "M928 160H96c-17.7 0-32 14.3-32 32v640c0 17.7 14.3 32 32 32h832c17.7 0 32-14.3 32-32V192c0-17.7-14.3-32-32-32zm-40 632H136v-39.9l138.5-164.3 150.1 178L658.1 489 888 761.6V792zm0-129.8L664.2 396.8c-3.2-3.8-9-3.8-12.2 0L424.6 666.4l-144-170.7c-3.2-3.8-9-3.8-12.2 0L136 652.7V232h752v430.2z", fill: primaryColor } }, { tag: "path", attrs: { d: "M424.6 765.8l-150.1-178L136 752.1V792h752v-30.4L658.1 489z", fill: secondaryColor } }, { tag: "path", attrs: { d: "M136 652.7l132.4-157c3.2-3.8 9-3.8 12.2 0l144 170.7L652 396.8c3.2-3.8 9-3.8 12.2 0L888 662.2V232H136v420.7zM304 280a88 88 0 110 176 88 88 0 010-176z", fill: secondaryColor } }, { tag: "path", attrs: { d: "M276 368a28 28 0 1056 0 28 28 0 10-56 0z", fill: secondaryColor } }, { tag: "path", attrs: { d: "M304 456a88 88 0 100-176 88 88 0 000 176zm0-116c15.5 0 28 12.5 28 28s-12.5 28-28 28-28-12.5-28-28 12.5-28 28-28z", fill: primaryColor } }] };
}, "render"), name: "picture", theme: "twotone" }, PictureTwoTone = /* @__PURE__ */ __name(function(props, ref) {
  return /* @__PURE__ */ React.createElement(Icon$3, _extends({}, props, {
    ref,
    icon: PictureTwoTone$1
  }));
}, "PictureTwoTone"), RefIcon$1 = /* @__PURE__ */ React.forwardRef(PictureTwoTone);
process.env.NODE_ENV !== "production" && (RefIcon$1.displayName = "PictureTwoTone");
var PlusSquareOutlined$1 = { icon: { tag: "svg", attrs: { viewBox: "64 64 896 896", focusable: "false" }, children: [{ tag: "path", attrs: { d: "M328 544h152v152c0 4.4 3.6 8 8 8h48c4.4 0 8-3.6 8-8V544h152c4.4 0 8-3.6 8-8v-48c0-4.4-3.6-8-8-8H544V328c0-4.4-3.6-8-8-8h-48c-4.4 0-8 3.6-8 8v152H328c-4.4 0-8 3.6-8 8v48c0 4.4 3.6 8 8 8z" } }, { tag: "path", attrs: { d: "M880 112H144c-17.7 0-32 14.3-32 32v736c0 17.7 14.3 32 32 32h736c17.7 0 32-14.3 32-32V144c0-17.7-14.3-32-32-32zm-40 728H184V184h656v656z" } }] }, name: "plus-square", theme: "outlined" }, PlusSquareOutlined = /* @__PURE__ */ __name(function(props, ref) {
  return /* @__PURE__ */ React.createElement(Icon$3, _extends({}, props, {
    ref,
    icon: PlusSquareOutlined$1
  }));
}, "PlusSquareOutlined"), RefIcon = /* @__PURE__ */ React.forwardRef(PlusSquareOutlined);
process.env.NODE_ENV !== "production" && (RefIcon.displayName = "PlusSquareOutlined");
var EXPAND_COLUMN = {}, INTERNAL_HOOKS = "rc-table-internal-hook";
function createContext(defaultValue) {
  var Context2 = /* @__PURE__ */ React.createContext(void 0), Provider = /* @__PURE__ */ __name(function(_ref) {
    var value = _ref.value, children = _ref.children, valueRef = React.useRef(value);
    valueRef.current = value;
    var _React$useState = React.useState(function() {
      return {
        getValue: /* @__PURE__ */ __name(function() {
          return valueRef.current;
        }, "getValue"),
        listeners: /* @__PURE__ */ new Set()
      };
    }), _React$useState2 = _slicedToArray(_React$useState, 1), context = _React$useState2[0];
    return useLayoutEffect$1(function() {
      unstable_batchedUpdates(function() {
        context.listeners.forEach(function(listener) {
          listener(value);
        });
      });
    }, [value]), /* @__PURE__ */ React.createElement(Context2.Provider, {
      value: context
    }, children);
  }, "Provider");
  return {
    Context: Context2,
    Provider,
    defaultValue
  };
}
__name(createContext, "createContext");
function useContext(holder, selector) {
  var eventSelector = useEvent(typeof selector == "function" ? selector : function(ctx) {
    if (selector === void 0)
      return ctx;
    if (!Array.isArray(selector))
      return ctx[selector];
    var obj = {};
    return selector.forEach(function(key) {
      obj[key] = ctx[key];
    }), obj;
  }), context = React.useContext(holder == null ? void 0 : holder.Context), _ref2 = context || {}, listeners = _ref2.listeners, getValue2 = _ref2.getValue, valueRef = React.useRef();
  valueRef.current = eventSelector(context ? getValue2() : holder == null ? void 0 : holder.defaultValue);
  var _React$useState3 = React.useState({}), _React$useState4 = _slicedToArray(_React$useState3, 2), forceUpdate = _React$useState4[1];
  return useLayoutEffect$1(function() {
    if (!context)
      return;
    function trigger(nextValue) {
      var nextSelectorValue = eventSelector(nextValue);
      isEqual(valueRef.current, nextSelectorValue, !0) || forceUpdate({});
    }
    return __name(trigger, "trigger"), listeners.add(trigger), function() {
      listeners.delete(trigger);
    };
  }, [context]), valueRef.current;
}
__name(useContext, "useContext");
function createImmutable() {
  var ImmutableContext = /* @__PURE__ */ React.createContext(null);
  function useImmutableMark2() {
    return React.useContext(ImmutableContext);
  }
  __name(useImmutableMark2, "useImmutableMark");
  function makeImmutable2(Component2, shouldTriggerRender) {
    var refAble = supportRef(Component2), ImmutableComponent = /* @__PURE__ */ __name(function(props, ref) {
      var refProps = refAble ? {
        ref
      } : {}, renderTimesRef = React.useRef(0), prevProps = React.useRef(props), mark = useImmutableMark2();
      return mark !== null ? /* @__PURE__ */ React.createElement(Component2, _extends({}, props, refProps)) : (
        // Always trigger re-render if not provide `notTriggerRender`
        ((!shouldTriggerRender || shouldTriggerRender(prevProps.current, props)) && (renderTimesRef.current += 1), prevProps.current = props, /* @__PURE__ */ React.createElement(ImmutableContext.Provider, {
          value: renderTimesRef.current
        }, /* @__PURE__ */ React.createElement(Component2, _extends({}, props, refProps))))
      );
    }, "ImmutableComponent");
    return process.env.NODE_ENV !== "production" && (ImmutableComponent.displayName = "ImmutableRoot(".concat(Component2.displayName || Component2.name, ")")), refAble ? /* @__PURE__ */ React.forwardRef(ImmutableComponent) : ImmutableComponent;
  }
  __name(makeImmutable2, "makeImmutable");
  function responseImmutable2(Component2, propsAreEqual) {
    var refAble = supportRef(Component2), ImmutableComponent = /* @__PURE__ */ __name(function(props, ref) {
      var refProps = refAble ? {
        ref
      } : {};
      return useImmutableMark2(), /* @__PURE__ */ React.createElement(Component2, _extends({}, props, refProps));
    }, "ImmutableComponent");
    return process.env.NODE_ENV !== "production" && (ImmutableComponent.displayName = "ImmutableResponse(".concat(Component2.displayName || Component2.name, ")")), refAble ? /* @__PURE__ */ React.memo(/* @__PURE__ */ React.forwardRef(ImmutableComponent), propsAreEqual) : /* @__PURE__ */ React.memo(ImmutableComponent, propsAreEqual);
  }
  return __name(responseImmutable2, "responseImmutable"), {
    makeImmutable: makeImmutable2,
    responseImmutable: responseImmutable2,
    useImmutableMark: useImmutableMark2
  };
}
__name(createImmutable, "createImmutable");
var _createImmutable = createImmutable(), makeImmutable = _createImmutable.makeImmutable, responseImmutable = _createImmutable.responseImmutable, useImmutableMark = _createImmutable.useImmutableMark, TableContext = createContext();
function useRenderTimes(props, debug) {
  var timesRef = React.useRef(0);
  timesRef.current += 1;
  var propsRef = React.useRef(props), keys2 = [];
  Object.keys(props || {}).map(function(key) {
    var _propsRef$current;
    (props == null ? void 0 : props[key]) !== ((_propsRef$current = propsRef.current) === null || _propsRef$current === void 0 ? void 0 : _propsRef$current[key]) && keys2.push(key);
  }), propsRef.current = props;
  var keysRef = React.useRef([]);
  return keys2.length && (keysRef.current = keys2), React.useDebugValue(timesRef.current), React.useDebugValue(keysRef.current.join(", ")), debug && console.log("".concat(debug, ":"), timesRef.current, keysRef.current), timesRef.current;
}
__name(useRenderTimes, "useRenderTimes");
const devRenderTimes = process.env.NODE_ENV !== "production" ? useRenderTimes : function() {
};
var RenderBlock = /* @__PURE__ */ React.memo(function() {
  var times = useRenderTimes();
  return /* @__PURE__ */ React.createElement("h1", null, "Render Times: ", times);
});
process.env.NODE_ENV !== "production" && (RenderBlock.displayName = "RenderBlock");
var PerfContext = /* @__PURE__ */ React.createContext({
  renderWithProps: !1
}), INTERNAL_KEY_PREFIX = "RC_TABLE_KEY";
function toArray(arr) {
  return arr == null ? [] : Array.isArray(arr) ? arr : [arr];
}
__name(toArray, "toArray");
function getColumnsKey(columns) {
  var columnKeys = [], keys2 = {};
  return columns.forEach(function(column2) {
    for (var _ref = column2 || {}, key = _ref.key, dataIndex = _ref.dataIndex, mergedKey = key || toArray(dataIndex).join("-") || INTERNAL_KEY_PREFIX; keys2[mergedKey]; )
      mergedKey = "".concat(mergedKey, "_next");
    keys2[mergedKey] = !0, columnKeys.push(mergedKey);
  }), columnKeys;
}
__name(getColumnsKey, "getColumnsKey");
function validateValue(val) {
  return val != null;
}
__name(validateValue, "validateValue");
function validNumberValue(value) {
  return typeof value == "number" && !Number.isNaN(value);
}
__name(validNumberValue, "validNumberValue");
function isRenderCell(data) {
  return data && _typeof$4(data) === "object" && !Array.isArray(data) && !/* @__PURE__ */ React.isValidElement(data);
}
__name(isRenderCell, "isRenderCell");
function useCellRender(record, dataIndex, renderIndex, children, render4, shouldCellUpdate) {
  var perfRecord = React.useContext(PerfContext), mark = useImmutableMark(), retData = useMemo(function() {
    if (validateValue(children))
      return [children];
    var path2 = dataIndex == null || dataIndex === "" ? [] : Array.isArray(dataIndex) ? dataIndex : [dataIndex], value = get(record, path2), returnChildNode = value, returnCellProps = void 0;
    if (render4) {
      var renderData = render4(value, record, renderIndex);
      isRenderCell(renderData) ? (process.env.NODE_ENV !== "production" && warningOnce(!1, "`columns.render` return cell props is deprecated with perf issue, please use `onCell` instead."), returnChildNode = renderData.children, returnCellProps = renderData.props, perfRecord.renderWithProps = !0) : returnChildNode = renderData;
    }
    return [returnChildNode, returnCellProps];
  }, [
    // Force update deps
    mark,
    // Normal deps
    record,
    children,
    dataIndex,
    render4,
    renderIndex
  ], function(prev2, next2) {
    if (shouldCellUpdate) {
      var _prev = _slicedToArray(prev2, 2), prevRecord = _prev[1], _next = _slicedToArray(next2, 2), nextRecord = _next[1];
      return shouldCellUpdate(nextRecord, prevRecord);
    }
    return perfRecord.renderWithProps ? !0 : !isEqual(prev2, next2, !0);
  });
  return retData;
}
__name(useCellRender, "useCellRender");
function inHoverRange(cellStartRow, cellRowSpan, startRow, endRow) {
  var cellEndRow = cellStartRow + cellRowSpan - 1;
  return cellStartRow <= endRow && cellEndRow >= startRow;
}
__name(inHoverRange, "inHoverRange");
function useHoverState(rowIndex, rowSpan) {
  return useContext(TableContext, function(ctx) {
    var hovering = inHoverRange(rowIndex, rowSpan || 1, ctx.hoverStartRow, ctx.hoverEndRow);
    return [hovering, ctx.onHover];
  });
}
__name(useHoverState, "useHoverState");
var getTitleFromCellRenderChildren = /* @__PURE__ */ __name(function(_ref) {
  var ellipsis = _ref.ellipsis, rowType = _ref.rowType, children = _ref.children, title2, ellipsisConfig = ellipsis === !0 ? {
    showTitle: !0
  } : ellipsis;
  return ellipsisConfig && (ellipsisConfig.showTitle || rowType === "header") && (typeof children == "string" || typeof children == "number" ? title2 = children.toString() : /* @__PURE__ */ React.isValidElement(children) && typeof children.props.children == "string" && (title2 = children.props.children)), title2;
}, "getTitleFromCellRenderChildren");
function Cell(props) {
  var _ref2, _ref3, _legacyCellProps$colS, _ref4, _ref5, _legacyCellProps$rowS, _additionalProps$titl, _classNames;
  process.env.NODE_ENV !== "production" && devRenderTimes(props);
  var Component2 = props.component, children = props.children, ellipsis = props.ellipsis, scope = props.scope, prefixCls = props.prefixCls, className = props.className, align = props.align, record = props.record, render4 = props.render, dataIndex = props.dataIndex, renderIndex = props.renderIndex, shouldCellUpdate = props.shouldCellUpdate, index2 = props.index, rowType = props.rowType, colSpan = props.colSpan, rowSpan = props.rowSpan, fixLeft = props.fixLeft, fixRight = props.fixRight, firstFixLeft = props.firstFixLeft, lastFixLeft = props.lastFixLeft, firstFixRight = props.firstFixRight, lastFixRight = props.lastFixRight, appendNode = props.appendNode, _props$additionalProp = props.additionalProps, additionalProps = _props$additionalProp === void 0 ? {} : _props$additionalProp, isSticky = props.isSticky, cellPrefixCls = "".concat(prefixCls, "-cell"), _useContext = useContext(TableContext, ["supportSticky", "allColumnsFixedLeft", "rowHoverable"]), supportSticky = _useContext.supportSticky, allColumnsFixedLeft = _useContext.allColumnsFixedLeft, rowHoverable = _useContext.rowHoverable, _useCellRender = useCellRender(record, dataIndex, renderIndex, children, render4, shouldCellUpdate), _useCellRender2 = _slicedToArray(_useCellRender, 2), childNode = _useCellRender2[0], legacyCellProps = _useCellRender2[1], fixedStyle = {}, isFixLeft = typeof fixLeft == "number" && supportSticky, isFixRight = typeof fixRight == "number" && supportSticky;
  isFixLeft && (fixedStyle.position = "sticky", fixedStyle.left = fixLeft), isFixRight && (fixedStyle.position = "sticky", fixedStyle.right = fixRight);
  var mergedColSpan = (_ref2 = (_ref3 = (_legacyCellProps$colS = legacyCellProps == null ? void 0 : legacyCellProps.colSpan) !== null && _legacyCellProps$colS !== void 0 ? _legacyCellProps$colS : additionalProps.colSpan) !== null && _ref3 !== void 0 ? _ref3 : colSpan) !== null && _ref2 !== void 0 ? _ref2 : 1, mergedRowSpan = (_ref4 = (_ref5 = (_legacyCellProps$rowS = legacyCellProps == null ? void 0 : legacyCellProps.rowSpan) !== null && _legacyCellProps$rowS !== void 0 ? _legacyCellProps$rowS : additionalProps.rowSpan) !== null && _ref5 !== void 0 ? _ref5 : rowSpan) !== null && _ref4 !== void 0 ? _ref4 : 1, _useHoverState = useHoverState(index2, mergedRowSpan), _useHoverState2 = _slicedToArray(_useHoverState, 2), hovering = _useHoverState2[0], onHover = _useHoverState2[1], onMouseEnter = useEvent(function(event) {
    var _additionalProps$onMo;
    record && onHover(index2, index2 + mergedRowSpan - 1), additionalProps == null || (_additionalProps$onMo = additionalProps.onMouseEnter) === null || _additionalProps$onMo === void 0 || _additionalProps$onMo.call(additionalProps, event);
  }), onMouseLeave = useEvent(function(event) {
    var _additionalProps$onMo2;
    record && onHover(-1, -1), additionalProps == null || (_additionalProps$onMo2 = additionalProps.onMouseLeave) === null || _additionalProps$onMo2 === void 0 || _additionalProps$onMo2.call(additionalProps, event);
  });
  if (mergedColSpan === 0 || mergedRowSpan === 0)
    return null;
  var title2 = (_additionalProps$titl = additionalProps.title) !== null && _additionalProps$titl !== void 0 ? _additionalProps$titl : getTitleFromCellRenderChildren({
    rowType,
    ellipsis,
    children: childNode
  }), mergedClassName = cn(cellPrefixCls, className, (_classNames = {}, _defineProperty$2(_defineProperty$2(_defineProperty$2(_defineProperty$2(_defineProperty$2(_defineProperty$2(_defineProperty$2(_defineProperty$2(_defineProperty$2(_defineProperty$2(_classNames, "".concat(cellPrefixCls, "-fix-left"), isFixLeft && supportSticky), "".concat(cellPrefixCls, "-fix-left-first"), firstFixLeft && supportSticky), "".concat(cellPrefixCls, "-fix-left-last"), lastFixLeft && supportSticky), "".concat(cellPrefixCls, "-fix-left-all"), lastFixLeft && allColumnsFixedLeft && supportSticky), "".concat(cellPrefixCls, "-fix-right"), isFixRight && supportSticky), "".concat(cellPrefixCls, "-fix-right-first"), firstFixRight && supportSticky), "".concat(cellPrefixCls, "-fix-right-last"), lastFixRight && supportSticky), "".concat(cellPrefixCls, "-ellipsis"), ellipsis), "".concat(cellPrefixCls, "-with-append"), appendNode), "".concat(cellPrefixCls, "-fix-sticky"), (isFixLeft || isFixRight) && isSticky && supportSticky), _defineProperty$2(_classNames, "".concat(cellPrefixCls, "-row-hover"), !legacyCellProps && hovering)), additionalProps.className, legacyCellProps == null ? void 0 : legacyCellProps.className), alignStyle = {};
  align && (alignStyle.textAlign = align);
  var mergedStyle = _objectSpread2$1(_objectSpread2$1(_objectSpread2$1(_objectSpread2$1({}, legacyCellProps == null ? void 0 : legacyCellProps.style), fixedStyle), alignStyle), additionalProps.style), mergedChildNode = childNode;
  return _typeof$4(mergedChildNode) === "object" && !Array.isArray(mergedChildNode) && !/* @__PURE__ */ React.isValidElement(mergedChildNode) && (mergedChildNode = null), ellipsis && (lastFixLeft || firstFixRight) && (mergedChildNode = /* @__PURE__ */ React.createElement("span", {
    className: "".concat(cellPrefixCls, "-content")
  }, mergedChildNode)), /* @__PURE__ */ React.createElement(Component2, _extends({}, legacyCellProps, additionalProps, {
    className: mergedClassName,
    style: mergedStyle,
    title: title2,
    scope,
    onMouseEnter: rowHoverable ? onMouseEnter : void 0,
    onMouseLeave: rowHoverable ? onMouseLeave : void 0,
    colSpan: mergedColSpan !== 1 ? mergedColSpan : null,
    rowSpan: mergedRowSpan !== 1 ? mergedRowSpan : null
  }), appendNode, mergedChildNode);
}
__name(Cell, "Cell");
const Cell$1 = /* @__PURE__ */ React.memo(Cell);
function getCellFixedInfo(colStart, colEnd, columns, stickyOffsets, direction) {
  var startColumn = columns[colStart] || {}, endColumn = columns[colEnd] || {}, fixLeft, fixRight;
  startColumn.fixed === "left" ? fixLeft = stickyOffsets.left[direction === "rtl" ? colEnd : colStart] : endColumn.fixed === "right" && (fixRight = stickyOffsets.right[direction === "rtl" ? colStart : colEnd]);
  var lastFixLeft = !1, firstFixRight = !1, lastFixRight = !1, firstFixLeft = !1, nextColumn = columns[colEnd + 1], prevColumn = columns[colStart - 1], canLastFix = nextColumn && !nextColumn.fixed || prevColumn && !prevColumn.fixed || columns.every(function(col) {
    return col.fixed === "left";
  });
  if (direction === "rtl") {
    if (fixLeft !== void 0) {
      var prevFixLeft = prevColumn && prevColumn.fixed === "left";
      firstFixLeft = !prevFixLeft && canLastFix;
    } else if (fixRight !== void 0) {
      var nextFixRight = nextColumn && nextColumn.fixed === "right";
      lastFixRight = !nextFixRight && canLastFix;
    }
  } else if (fixLeft !== void 0) {
    var nextFixLeft = nextColumn && nextColumn.fixed === "left";
    lastFixLeft = !nextFixLeft && canLastFix;
  } else if (fixRight !== void 0) {
    var prevFixRight = prevColumn && prevColumn.fixed === "right";
    firstFixRight = !prevFixRight && canLastFix;
  }
  return {
    fixLeft,
    fixRight,
    lastFixLeft,
    firstFixRight,
    lastFixRight,
    firstFixLeft,
    isSticky: stickyOffsets.isSticky
  };
}
__name(getCellFixedInfo, "getCellFixedInfo");
var SummaryContext = /* @__PURE__ */ React.createContext({});
function SummaryCell(_ref) {
  var className = _ref.className, index2 = _ref.index, children = _ref.children, _ref$colSpan = _ref.colSpan, colSpan = _ref$colSpan === void 0 ? 1 : _ref$colSpan, rowSpan = _ref.rowSpan, align = _ref.align, _useContext = useContext(TableContext, ["prefixCls", "direction"]), prefixCls = _useContext.prefixCls, direction = _useContext.direction, _React$useContext = React.useContext(SummaryContext), scrollColumnIndex = _React$useContext.scrollColumnIndex, stickyOffsets = _React$useContext.stickyOffsets, flattenColumns = _React$useContext.flattenColumns, lastIndex = index2 + colSpan - 1, mergedColSpan = lastIndex + 1 === scrollColumnIndex ? colSpan + 1 : colSpan, fixedInfo = getCellFixedInfo(index2, index2 + mergedColSpan - 1, flattenColumns, stickyOffsets, direction);
  return /* @__PURE__ */ React.createElement(Cell$1, _extends({
    className,
    index: index2,
    component: "td",
    prefixCls,
    record: null,
    dataIndex: null,
    align,
    colSpan: mergedColSpan,
    rowSpan,
    render: /* @__PURE__ */ __name(function() {
      return children;
    }, "render")
  }, fixedInfo));
}
__name(SummaryCell, "SummaryCell");
var _excluded$9 = ["children"];
function FooterRow(_ref) {
  var children = _ref.children, props = _objectWithoutProperties(_ref, _excluded$9);
  return /* @__PURE__ */ React.createElement("tr", props, children);
}
__name(FooterRow, "FooterRow");
function Summary(_ref) {
  var children = _ref.children;
  return children;
}
__name(Summary, "Summary");
Summary.Row = FooterRow;
Summary.Cell = SummaryCell;
function Footer(props) {
  process.env.NODE_ENV !== "production" && devRenderTimes(props);
  var children = props.children, stickyOffsets = props.stickyOffsets, flattenColumns = props.flattenColumns, prefixCls = useContext(TableContext, "prefixCls"), lastColumnIndex = flattenColumns.length - 1, scrollColumn = flattenColumns[lastColumnIndex], summaryContext = React.useMemo(function() {
    return {
      stickyOffsets,
      flattenColumns,
      scrollColumnIndex: scrollColumn != null && scrollColumn.scrollbar ? lastColumnIndex : null
    };
  }, [scrollColumn, flattenColumns, lastColumnIndex, stickyOffsets]);
  return /* @__PURE__ */ React.createElement(SummaryContext.Provider, {
    value: summaryContext
  }, /* @__PURE__ */ React.createElement("tfoot", {
    className: "".concat(prefixCls, "-summary")
  }, children));
}
__name(Footer, "Footer");
const Footer$1 = responseImmutable(Footer);
var FooterComponents = Summary;
function Column$1(_2) {
  return null;
}
__name(Column$1, "Column$1");
function ColumnGroup$1(_2) {
  return null;
}
__name(ColumnGroup$1, "ColumnGroup$1");
function fillRecords(list, record, indent, childrenColumnName, expandedKeys, getRowKey, index2) {
  list.push({
    record,
    indent,
    index: index2
  });
  var key = getRowKey(record), expanded = expandedKeys == null ? void 0 : expandedKeys.has(key);
  if (record && Array.isArray(record[childrenColumnName]) && expanded)
    for (var i = 0; i < record[childrenColumnName].length; i += 1)
      fillRecords(list, record[childrenColumnName][i], indent + 1, childrenColumnName, expandedKeys, getRowKey, i);
}
__name(fillRecords, "fillRecords");
function useFlattenRecords(data, childrenColumnName, expandedKeys, getRowKey) {
  var arr = React.useMemo(function() {
    if (expandedKeys != null && expandedKeys.size) {
      for (var list = [], i = 0; i < (data == null ? void 0 : data.length); i += 1) {
        var record = data[i];
        fillRecords(list, record, 0, childrenColumnName, expandedKeys, getRowKey, i);
      }
      return list;
    }
    return data == null ? void 0 : data.map(function(item, index2) {
      return {
        record: item,
        indent: 0,
        index: index2
      };
    });
  }, [data, childrenColumnName, expandedKeys, getRowKey]);
  return arr;
}
__name(useFlattenRecords, "useFlattenRecords");
function useRowInfo(record, rowKey, recordIndex, indent) {
  var context = useContext(TableContext, ["prefixCls", "fixedInfoList", "flattenColumns", "expandableType", "expandRowByClick", "onTriggerExpand", "rowClassName", "expandedRowClassName", "indentSize", "expandIcon", "expandedRowRender", "expandIconColumnIndex", "expandedKeys", "childrenColumnName", "rowExpandable", "onRow"]), flattenColumns = context.flattenColumns, expandableType = context.expandableType, expandedKeys = context.expandedKeys, childrenColumnName = context.childrenColumnName, onTriggerExpand = context.onTriggerExpand, rowExpandable = context.rowExpandable, onRow = context.onRow, expandRowByClick = context.expandRowByClick, rowClassName = context.rowClassName, nestExpandable = expandableType === "nest", rowSupportExpand = expandableType === "row" && (!rowExpandable || rowExpandable(record)), mergedExpandable = rowSupportExpand || nestExpandable, expanded = expandedKeys && expandedKeys.has(rowKey), hasNestChildren = childrenColumnName && record && record[childrenColumnName], onInternalTriggerExpand = useEvent(onTriggerExpand), rowProps = onRow == null ? void 0 : onRow(record, recordIndex), onRowClick = rowProps == null ? void 0 : rowProps.onClick, onClick = /* @__PURE__ */ __name(function(event) {
    expandRowByClick && mergedExpandable && onTriggerExpand(record, event);
    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++)
      args[_key - 1] = arguments[_key];
    onRowClick == null || onRowClick.apply(void 0, [event].concat(args));
  }, "onClick"), computeRowClassName;
  typeof rowClassName == "string" ? computeRowClassName = rowClassName : typeof rowClassName == "function" && (computeRowClassName = rowClassName(record, recordIndex, indent));
  var columnsKey = getColumnsKey(flattenColumns);
  return _objectSpread2$1(_objectSpread2$1({}, context), {}, {
    columnsKey,
    nestExpandable,
    expanded,
    hasNestChildren,
    record,
    onTriggerExpand: onInternalTriggerExpand,
    rowSupportExpand,
    expandable: mergedExpandable,
    rowProps: _objectSpread2$1(_objectSpread2$1({}, rowProps), {}, {
      className: cn(computeRowClassName, rowProps == null ? void 0 : rowProps.className),
      onClick
    })
  });
}
__name(useRowInfo, "useRowInfo");
function ExpandedRow(props) {
  process.env.NODE_ENV !== "production" && devRenderTimes(props);
  var prefixCls = props.prefixCls, children = props.children, Component2 = props.component, cellComponent = props.cellComponent, className = props.className, expanded = props.expanded, colSpan = props.colSpan, isEmpty2 = props.isEmpty, _useContext = useContext(TableContext, ["scrollbarSize", "fixHeader", "fixColumn", "componentWidth", "horizonScroll"]), scrollbarSize = _useContext.scrollbarSize, fixHeader = _useContext.fixHeader, fixColumn = _useContext.fixColumn, componentWidth = _useContext.componentWidth, horizonScroll = _useContext.horizonScroll, contentNode = children;
  return (isEmpty2 ? horizonScroll && componentWidth : fixColumn) && (contentNode = /* @__PURE__ */ React.createElement("div", {
    style: {
      width: componentWidth - (fixHeader && !isEmpty2 ? scrollbarSize : 0),
      position: "sticky",
      left: 0,
      overflow: "hidden"
    },
    className: "".concat(prefixCls, "-expanded-row-fixed")
  }, contentNode)), /* @__PURE__ */ React.createElement(Component2, {
    className,
    style: {
      display: expanded ? null : "none"
    }
  }, /* @__PURE__ */ React.createElement(Cell$1, {
    component: cellComponent,
    prefixCls,
    colSpan
  }, contentNode));
}
__name(ExpandedRow, "ExpandedRow");
function renderExpandIcon$1(_ref) {
  var prefixCls = _ref.prefixCls, record = _ref.record, onExpand = _ref.onExpand, expanded = _ref.expanded, expandable = _ref.expandable, expandClassName = "".concat(prefixCls, "-row-expand-icon");
  if (!expandable)
    return /* @__PURE__ */ React.createElement("span", {
      className: cn(expandClassName, "".concat(prefixCls, "-row-spaced"))
    });
  var onClick = /* @__PURE__ */ __name(function(event) {
    onExpand(record, event), event.stopPropagation();
  }, "onClick");
  return /* @__PURE__ */ React.createElement("span", {
    className: cn(expandClassName, _defineProperty$2(_defineProperty$2({}, "".concat(prefixCls, "-row-expanded"), expanded), "".concat(prefixCls, "-row-collapsed"), !expanded)),
    onClick
  });
}
__name(renderExpandIcon$1, "renderExpandIcon$1");
function findAllChildrenKeys(data, getRowKey, childrenColumnName) {
  var keys2 = [];
  function dig(list) {
    (list || []).forEach(function(item, index2) {
      keys2.push(getRowKey(item, index2)), dig(item[childrenColumnName]);
    });
  }
  return __name(dig, "dig"), dig(data), keys2;
}
__name(findAllChildrenKeys, "findAllChildrenKeys");
function computedExpandedClassName(cls, record, index2, indent) {
  return typeof cls == "string" ? cls : typeof cls == "function" ? cls(record, index2, indent) : "";
}
__name(computedExpandedClassName, "computedExpandedClassName");
function getCellProps(rowInfo, column2, colIndex, indent, index2) {
  var record = rowInfo.record, prefixCls = rowInfo.prefixCls, columnsKey = rowInfo.columnsKey, fixedInfoList = rowInfo.fixedInfoList, expandIconColumnIndex = rowInfo.expandIconColumnIndex, nestExpandable = rowInfo.nestExpandable, indentSize = rowInfo.indentSize, expandIcon = rowInfo.expandIcon, expanded = rowInfo.expanded, hasNestChildren = rowInfo.hasNestChildren, onTriggerExpand = rowInfo.onTriggerExpand, key = columnsKey[colIndex], fixedInfo = fixedInfoList[colIndex], appendCellNode;
  colIndex === (expandIconColumnIndex || 0) && nestExpandable && (appendCellNode = /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement("span", {
    style: {
      paddingLeft: "".concat(indentSize * indent, "px")
    },
    className: "".concat(prefixCls, "-row-indent indent-level-").concat(indent)
  }), expandIcon({
    prefixCls,
    expanded,
    expandable: hasNestChildren,
    record,
    onExpand: onTriggerExpand
  })));
  var additionalCellProps;
  return column2.onCell && (additionalCellProps = column2.onCell(record, index2)), {
    key,
    fixedInfo,
    appendCellNode,
    additionalCellProps: additionalCellProps || {}
  };
}
__name(getCellProps, "getCellProps");
function BodyRow(props) {
  process.env.NODE_ENV !== "production" && devRenderTimes(props);
  var className = props.className, style2 = props.style, record = props.record, index2 = props.index, renderIndex = props.renderIndex, rowKey = props.rowKey, _props$indent = props.indent, indent = _props$indent === void 0 ? 0 : _props$indent, RowComponent = props.rowComponent, cellComponent = props.cellComponent, scopeCellComponent = props.scopeCellComponent, rowInfo = useRowInfo(record, rowKey, index2, indent), prefixCls = rowInfo.prefixCls, flattenColumns = rowInfo.flattenColumns, expandedRowClassName = rowInfo.expandedRowClassName, expandedRowRender = rowInfo.expandedRowRender, rowProps = rowInfo.rowProps, expanded = rowInfo.expanded, rowSupportExpand = rowInfo.rowSupportExpand, expandedRef = React.useRef(!1);
  expandedRef.current || (expandedRef.current = expanded), process.env.NODE_ENV !== "production" && devRenderTimes(props);
  var expandedClsName = computedExpandedClassName(expandedRowClassName, record, index2, indent), baseRowNode = /* @__PURE__ */ React.createElement(RowComponent, _extends({}, rowProps, {
    "data-row-key": rowKey,
    className: cn(className, "".concat(prefixCls, "-row"), "".concat(prefixCls, "-row-level-").concat(indent), rowProps == null ? void 0 : rowProps.className, _defineProperty$2({}, expandedClsName, indent >= 1)),
    style: _objectSpread2$1(_objectSpread2$1({}, style2), rowProps == null ? void 0 : rowProps.style)
  }), flattenColumns.map(function(column2, colIndex) {
    var render4 = column2.render, dataIndex = column2.dataIndex, columnClassName = column2.className, _getCellProps = getCellProps(rowInfo, column2, colIndex, indent, index2), key = _getCellProps.key, fixedInfo = _getCellProps.fixedInfo, appendCellNode = _getCellProps.appendCellNode, additionalCellProps = _getCellProps.additionalCellProps;
    return /* @__PURE__ */ React.createElement(Cell$1, _extends({
      className: columnClassName,
      ellipsis: column2.ellipsis,
      align: column2.align,
      scope: column2.rowScope,
      component: column2.rowScope ? scopeCellComponent : cellComponent,
      prefixCls,
      key,
      record,
      index: index2,
      renderIndex,
      dataIndex,
      render: render4,
      shouldCellUpdate: column2.shouldCellUpdate
    }, fixedInfo, {
      appendNode: appendCellNode,
      additionalProps: additionalCellProps
    }));
  })), expandRowNode;
  if (rowSupportExpand && (expandedRef.current || expanded)) {
    var expandContent = expandedRowRender(record, index2, indent + 1, expanded);
    expandRowNode = /* @__PURE__ */ React.createElement(ExpandedRow, {
      expanded,
      className: cn("".concat(prefixCls, "-expanded-row"), "".concat(prefixCls, "-expanded-row-level-").concat(indent + 1), expandedClsName),
      prefixCls,
      component: RowComponent,
      cellComponent,
      colSpan: flattenColumns.length,
      isEmpty: !1
    }, expandContent);
  }
  return /* @__PURE__ */ React.createElement(React.Fragment, null, baseRowNode, expandRowNode);
}
__name(BodyRow, "BodyRow");
process.env.NODE_ENV !== "production" && (BodyRow.displayName = "BodyRow");
const BodyRow$1 = responseImmutable(BodyRow);
function MeasureCell(_ref) {
  var columnKey = _ref.columnKey, onColumnResize = _ref.onColumnResize, cellRef = React.useRef();
  return React.useEffect(function() {
    cellRef.current && onColumnResize(columnKey, cellRef.current.offsetWidth);
  }, []), /* @__PURE__ */ React.createElement(RefResizeObserver, {
    data: columnKey
  }, /* @__PURE__ */ React.createElement("td", {
    ref: cellRef,
    style: {
      padding: 0,
      border: 0,
      height: 0
    }
  }, /* @__PURE__ */ React.createElement("div", {
    style: {
      height: 0,
      overflow: "hidden"
    }
  }, " ")));
}
__name(MeasureCell, "MeasureCell");
function MeasureRow(_ref) {
  var prefixCls = _ref.prefixCls, columnsKey = _ref.columnsKey, onColumnResize = _ref.onColumnResize;
  return /* @__PURE__ */ React.createElement("tr", {
    "aria-hidden": "true",
    className: "".concat(prefixCls, "-measure-row"),
    style: {
      height: 0,
      fontSize: 0
    }
  }, /* @__PURE__ */ React.createElement(RefResizeObserver.Collection, {
    onBatchResize: /* @__PURE__ */ __name(function(infoList) {
      infoList.forEach(function(_ref2) {
        var columnKey = _ref2.data, size = _ref2.size;
        onColumnResize(columnKey, size.offsetWidth);
      });
    }, "onBatchResize")
  }, columnsKey.map(function(columnKey) {
    return /* @__PURE__ */ React.createElement(MeasureCell, {
      key: columnKey,
      columnKey,
      onColumnResize
    });
  })));
}
__name(MeasureRow, "MeasureRow");
function Body(props) {
  process.env.NODE_ENV !== "production" && devRenderTimes(props);
  var data = props.data, measureColumnWidth = props.measureColumnWidth, _useContext = useContext(TableContext, ["prefixCls", "getComponent", "onColumnResize", "flattenColumns", "getRowKey", "expandedKeys", "childrenColumnName", "emptyNode"]), prefixCls = _useContext.prefixCls, getComponent = _useContext.getComponent, onColumnResize = _useContext.onColumnResize, flattenColumns = _useContext.flattenColumns, getRowKey = _useContext.getRowKey, expandedKeys = _useContext.expandedKeys, childrenColumnName = _useContext.childrenColumnName, emptyNode = _useContext.emptyNode, flattenData2 = useFlattenRecords(data, childrenColumnName, expandedKeys, getRowKey), perfRef = React.useRef({
    renderWithProps: !1
  }), WrapperComponent = getComponent(["body", "wrapper"], "tbody"), trComponent = getComponent(["body", "row"], "tr"), tdComponent = getComponent(["body", "cell"], "td"), thComponent = getComponent(["body", "cell"], "th"), rows;
  data.length ? rows = flattenData2.map(function(item, idx) {
    var record = item.record, indent = item.indent, renderIndex = item.index, key = getRowKey(record, idx);
    return /* @__PURE__ */ React.createElement(BodyRow$1, {
      key,
      rowKey: key,
      record,
      index: idx,
      renderIndex,
      rowComponent: trComponent,
      cellComponent: tdComponent,
      scopeCellComponent: thComponent,
      getRowKey,
      indent
    });
  }) : rows = /* @__PURE__ */ React.createElement(ExpandedRow, {
    expanded: !0,
    className: "".concat(prefixCls, "-placeholder"),
    prefixCls,
    component: trComponent,
    cellComponent: tdComponent,
    colSpan: flattenColumns.length,
    isEmpty: !0
  }, emptyNode);
  var columnsKey = getColumnsKey(flattenColumns);
  return /* @__PURE__ */ React.createElement(PerfContext.Provider, {
    value: perfRef.current
  }, /* @__PURE__ */ React.createElement(WrapperComponent, {
    className: "".concat(prefixCls, "-tbody")
  }, measureColumnWidth && /* @__PURE__ */ React.createElement(MeasureRow, {
    prefixCls,
    columnsKey,
    onColumnResize
  }), rows));
}
__name(Body, "Body");
process.env.NODE_ENV !== "production" && (Body.displayName = "Body");
const Body$1 = responseImmutable(Body);
var _excluded$8 = ["expandable"], INTERNAL_COL_DEFINE = "RC_TABLE_INTERNAL_COL_DEFINE";
function getExpandableProps(props) {
  var expandable = props.expandable, legacyExpandableConfig = _objectWithoutProperties(props, _excluded$8), config;
  return "expandable" in props ? config = _objectSpread2$1(_objectSpread2$1({}, legacyExpandableConfig), expandable) : (process.env.NODE_ENV !== "production" && ["indentSize", "expandedRowKeys", "defaultExpandedRowKeys", "defaultExpandAllRows", "expandedRowRender", "expandRowByClick", "expandIcon", "onExpand", "onExpandedRowsChange", "expandedRowClassName", "expandIconColumnIndex", "showExpandColumn", "title"].some(function(prop) {
    return prop in props;
  }) && warningOnce(!1, "expanded related props have been moved into `expandable`."), config = legacyExpandableConfig), config.showExpandColumn === !1 && (config.expandIconColumnIndex = -1), config;
}
__name(getExpandableProps, "getExpandableProps");
var _excluded$7 = ["columnType"];
function ColGroup(_ref) {
  for (var colWidths = _ref.colWidths, columns = _ref.columns, columCount = _ref.columCount, _useContext = useContext(TableContext, ["tableLayout"]), tableLayout = _useContext.tableLayout, cols = [], len = columCount || columns.length, mustInsert = !1, i = len - 1; i >= 0; i -= 1) {
    var width = colWidths[i], column2 = columns && columns[i], additionalProps = void 0, minWidth = void 0;
    if (column2 && (additionalProps = column2[INTERNAL_COL_DEFINE], tableLayout === "auto" && (minWidth = column2.minWidth)), width || minWidth || additionalProps || mustInsert) {
      var _ref2 = additionalProps || {};
      _ref2.columnType;
      var restAdditionalProps = _objectWithoutProperties(_ref2, _excluded$7);
      cols.unshift(/* @__PURE__ */ React.createElement("col", _extends({
        key: i,
        style: {
          width,
          minWidth
        }
      }, restAdditionalProps))), mustInsert = !0;
    }
  }
  return /* @__PURE__ */ React.createElement("colgroup", null, cols);
}
__name(ColGroup, "ColGroup");
var _excluded$6 = ["className", "noData", "columns", "flattenColumns", "colWidths", "columCount", "stickyOffsets", "direction", "fixHeader", "stickyTopOffset", "stickyBottomOffset", "stickyClassName", "onScroll", "maxContentScroll", "children"];
function useColumnWidth(colWidths, columCount) {
  return useMemo$1(function() {
    for (var cloneColumns = [], i = 0; i < columCount; i += 1) {
      var val = colWidths[i];
      if (val !== void 0)
        cloneColumns[i] = val;
      else
        return null;
    }
    return cloneColumns;
  }, [colWidths.join("_"), columCount]);
}
__name(useColumnWidth, "useColumnWidth");
var FixedHolder = /* @__PURE__ */ React.forwardRef(function(props, ref) {
  process.env.NODE_ENV !== "production" && devRenderTimes(props);
  var className = props.className, noData = props.noData, columns = props.columns, flattenColumns = props.flattenColumns, colWidths = props.colWidths, columCount = props.columCount, stickyOffsets = props.stickyOffsets, direction = props.direction, fixHeader = props.fixHeader, stickyTopOffset = props.stickyTopOffset, stickyBottomOffset = props.stickyBottomOffset, stickyClassName = props.stickyClassName, onScroll = props.onScroll, maxContentScroll = props.maxContentScroll, children = props.children, restProps = _objectWithoutProperties(props, _excluded$6), _useContext = useContext(TableContext, ["prefixCls", "scrollbarSize", "isSticky", "getComponent"]), prefixCls = _useContext.prefixCls, scrollbarSize = _useContext.scrollbarSize, isSticky = _useContext.isSticky, getComponent = _useContext.getComponent, TableComponent = getComponent(["header", "table"], "table"), combinationScrollBarSize = isSticky && !fixHeader ? 0 : scrollbarSize, scrollRef = React.useRef(null), setScrollRef = React.useCallback(function(element) {
    fillRef(ref, element), fillRef(scrollRef, element);
  }, []);
  React.useEffect(function() {
    var _scrollRef$current;
    function onWheel(e2) {
      var _ref = e2, currentTarget = _ref.currentTarget, deltaX = _ref.deltaX;
      deltaX && (onScroll({
        currentTarget,
        scrollLeft: currentTarget.scrollLeft + deltaX
      }), e2.preventDefault());
    }
    return __name(onWheel, "onWheel"), (_scrollRef$current = scrollRef.current) === null || _scrollRef$current === void 0 || _scrollRef$current.addEventListener("wheel", onWheel, {
      passive: !1
    }), function() {
      var _scrollRef$current2;
      (_scrollRef$current2 = scrollRef.current) === null || _scrollRef$current2 === void 0 || _scrollRef$current2.removeEventListener("wheel", onWheel);
    };
  }, []);
  var allFlattenColumnsWithWidth = React.useMemo(function() {
    return flattenColumns.every(function(column2) {
      return column2.width;
    });
  }, [flattenColumns]), lastColumn = flattenColumns[flattenColumns.length - 1], ScrollBarColumn = {
    fixed: lastColumn ? lastColumn.fixed : null,
    scrollbar: !0,
    onHeaderCell: /* @__PURE__ */ __name(function() {
      return {
        className: "".concat(prefixCls, "-cell-scrollbar")
      };
    }, "onHeaderCell")
  }, columnsWithScrollbar = useMemo$1(function() {
    return combinationScrollBarSize ? [].concat(_toConsumableArray(columns), [ScrollBarColumn]) : columns;
  }, [combinationScrollBarSize, columns]), flattenColumnsWithScrollbar = useMemo$1(function() {
    return combinationScrollBarSize ? [].concat(_toConsumableArray(flattenColumns), [ScrollBarColumn]) : flattenColumns;
  }, [combinationScrollBarSize, flattenColumns]), headerStickyOffsets = useMemo$1(function() {
    var right = stickyOffsets.right, left = stickyOffsets.left;
    return _objectSpread2$1(_objectSpread2$1({}, stickyOffsets), {}, {
      left: direction === "rtl" ? [].concat(_toConsumableArray(left.map(function(width) {
        return width + combinationScrollBarSize;
      })), [0]) : left,
      right: direction === "rtl" ? right : [].concat(_toConsumableArray(right.map(function(width) {
        return width + combinationScrollBarSize;
      })), [0]),
      isSticky
    });
  }, [combinationScrollBarSize, stickyOffsets, isSticky]), mergedColumnWidth = useColumnWidth(colWidths, columCount);
  return /* @__PURE__ */ React.createElement("div", {
    style: _objectSpread2$1({
      overflow: "hidden"
    }, isSticky ? {
      top: stickyTopOffset,
      bottom: stickyBottomOffset
    } : {}),
    ref: setScrollRef,
    className: cn(className, _defineProperty$2({}, stickyClassName, !!stickyClassName))
  }, /* @__PURE__ */ React.createElement(TableComponent, {
    style: {
      tableLayout: "fixed",
      visibility: noData || mergedColumnWidth ? null : "hidden"
    }
  }, (!noData || !maxContentScroll || allFlattenColumnsWithWidth) && /* @__PURE__ */ React.createElement(ColGroup, {
    colWidths: mergedColumnWidth ? [].concat(_toConsumableArray(mergedColumnWidth), [combinationScrollBarSize]) : [],
    columCount: columCount + 1,
    columns: flattenColumnsWithScrollbar
  }), children(_objectSpread2$1(_objectSpread2$1({}, restProps), {}, {
    stickyOffsets: headerStickyOffsets,
    columns: columnsWithScrollbar,
    flattenColumns: flattenColumnsWithScrollbar
  }))));
});
process.env.NODE_ENV !== "production" && (FixedHolder.displayName = "FixedHolder");
const FixedHolder$1 = /* @__PURE__ */ React.memo(FixedHolder);
var HeaderRow = /* @__PURE__ */ __name(function(props) {
  var cells = props.cells, stickyOffsets = props.stickyOffsets, flattenColumns = props.flattenColumns, RowComponent = props.rowComponent, CellComponent = props.cellComponent, onHeaderRow = props.onHeaderRow, index2 = props.index, _useContext = useContext(TableContext, ["prefixCls", "direction"]), prefixCls = _useContext.prefixCls, direction = _useContext.direction, rowProps;
  onHeaderRow && (rowProps = onHeaderRow(cells.map(function(cell) {
    return cell.column;
  }), index2));
  var columnsKey = getColumnsKey(cells.map(function(cell) {
    return cell.column;
  }));
  return /* @__PURE__ */ React.createElement(RowComponent, rowProps, cells.map(function(cell, cellIndex) {
    var column2 = cell.column, fixedInfo = getCellFixedInfo(cell.colStart, cell.colEnd, flattenColumns, stickyOffsets, direction), additionalProps;
    return column2 && column2.onHeaderCell && (additionalProps = cell.column.onHeaderCell(column2)), /* @__PURE__ */ React.createElement(Cell$1, _extends({}, cell, {
      scope: column2.title ? cell.colSpan > 1 ? "colgroup" : "col" : null,
      ellipsis: column2.ellipsis,
      align: column2.align,
      component: CellComponent,
      prefixCls,
      key: columnsKey[cellIndex]
    }, fixedInfo, {
      additionalProps,
      rowType: "header"
    }));
  }));
}, "HeaderRow");
process.env.NODE_ENV !== "production" && (HeaderRow.displayName = "HeaderRow");
function parseHeaderRows(rootColumns) {
  var rows = [];
  function fillRowCells(columns, colIndex) {
    var rowIndex2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
    rows[rowIndex2] = rows[rowIndex2] || [];
    var currentColIndex = colIndex, colSpans = columns.filter(Boolean).map(function(column2) {
      var cell = {
        key: column2.key,
        className: column2.className || "",
        children: column2.title,
        column: column2,
        colStart: currentColIndex
      }, colSpan = 1, subColumns = column2.children;
      return subColumns && subColumns.length > 0 && (colSpan = fillRowCells(subColumns, currentColIndex, rowIndex2 + 1).reduce(function(total, count) {
        return total + count;
      }, 0), cell.hasSubColumns = !0), "colSpan" in column2 && (colSpan = column2.colSpan), "rowSpan" in column2 && (cell.rowSpan = column2.rowSpan), cell.colSpan = colSpan, cell.colEnd = cell.colStart + colSpan - 1, rows[rowIndex2].push(cell), currentColIndex += colSpan, colSpan;
    });
    return colSpans;
  }
  __name(fillRowCells, "fillRowCells"), fillRowCells(rootColumns, 0);
  for (var rowCount = rows.length, _loop = /* @__PURE__ */ __name(function(rowIndex2) {
    rows[rowIndex2].forEach(function(cell) {
      !("rowSpan" in cell) && !cell.hasSubColumns && (cell.rowSpan = rowCount - rowIndex2);
    });
  }, "_loop"), rowIndex = 0; rowIndex < rowCount; rowIndex += 1)
    _loop(rowIndex);
  return rows;
}
__name(parseHeaderRows, "parseHeaderRows");
var Header$1 = /* @__PURE__ */ __name(function(props) {
  process.env.NODE_ENV !== "production" && devRenderTimes(props);
  var stickyOffsets = props.stickyOffsets, columns = props.columns, flattenColumns = props.flattenColumns, onHeaderRow = props.onHeaderRow, _useContext = useContext(TableContext, ["prefixCls", "getComponent"]), prefixCls = _useContext.prefixCls, getComponent = _useContext.getComponent, rows = React.useMemo(function() {
    return parseHeaderRows(columns);
  }, [columns]), WrapperComponent = getComponent(["header", "wrapper"], "thead"), trComponent = getComponent(["header", "row"], "tr"), thComponent = getComponent(["header", "cell"], "th");
  return /* @__PURE__ */ React.createElement(WrapperComponent, {
    className: "".concat(prefixCls, "-thead")
  }, rows.map(function(row, rowIndex) {
    var rowNode = /* @__PURE__ */ React.createElement(HeaderRow, {
      key: rowIndex,
      flattenColumns,
      cells: row,
      stickyOffsets,
      rowComponent: trComponent,
      cellComponent: thComponent,
      onHeaderRow,
      index: rowIndex
    });
    return rowNode;
  }));
}, "Header");
const Header$2 = responseImmutable(Header$1);
function parseColWidth(totalWidth) {
  var width = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
  return typeof width == "number" ? width : width.endsWith("%") ? totalWidth * parseFloat(width) / 100 : null;
}
__name(parseColWidth, "parseColWidth");
function useWidthColumns(flattenColumns, scrollWidth, clientWidth) {
  return React.useMemo(function() {
    if (scrollWidth && scrollWidth > 0) {
      var totalWidth = 0, missWidthCount = 0;
      flattenColumns.forEach(function(col) {
        var colWidth = parseColWidth(scrollWidth, col.width);
        colWidth ? totalWidth += colWidth : missWidthCount += 1;
      });
      var maxFitWidth = Math.max(scrollWidth, clientWidth), restWidth = Math.max(maxFitWidth - totalWidth, missWidthCount), restCount = missWidthCount, avgWidth = restWidth / missWidthCount, realTotal = 0, filledColumns = flattenColumns.map(function(col) {
        var clone = _objectSpread2$1({}, col), colWidth = parseColWidth(scrollWidth, clone.width);
        if (colWidth)
          clone.width = colWidth;
        else {
          var colAvgWidth = Math.floor(avgWidth);
          clone.width = restCount === 1 ? restWidth : colAvgWidth, restWidth -= colAvgWidth, restCount -= 1;
        }
        return realTotal += clone.width, clone;
      });
      if (realTotal < maxFitWidth) {
        var scale = maxFitWidth / realTotal;
        restWidth = maxFitWidth, filledColumns.forEach(function(col, index2) {
          var colWidth = Math.floor(col.width * scale);
          col.width = index2 === filledColumns.length - 1 ? restWidth : colWidth, restWidth -= colWidth;
        });
      }
      return [filledColumns, Math.max(realTotal, maxFitWidth)];
    }
    return [flattenColumns, scrollWidth];
  }, [flattenColumns, scrollWidth, clientWidth]);
}
__name(useWidthColumns, "useWidthColumns");
var _excluded$5 = ["children"], _excluded2 = ["fixed"];
function convertChildrenToColumns(children) {
  return toArray$7(children).filter(function(node2) {
    return /* @__PURE__ */ React.isValidElement(node2);
  }).map(function(_ref) {
    var key = _ref.key, props = _ref.props, nodeChildren = props.children, restProps = _objectWithoutProperties(props, _excluded$5), column2 = _objectSpread2$1({
      key
    }, restProps);
    return nodeChildren && (column2.children = convertChildrenToColumns(nodeChildren)), column2;
  });
}
__name(convertChildrenToColumns, "convertChildrenToColumns");
function filterHiddenColumns(columns) {
  return columns.filter(function(column2) {
    return column2 && _typeof$4(column2) === "object" && !column2.hidden;
  }).map(function(column2) {
    var subColumns = column2.children;
    return subColumns && subColumns.length > 0 ? _objectSpread2$1(_objectSpread2$1({}, column2), {}, {
      children: filterHiddenColumns(subColumns)
    }) : column2;
  });
}
__name(filterHiddenColumns, "filterHiddenColumns");
function flatColumns(columns) {
  var parentKey = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "key";
  return columns.filter(function(column2) {
    return column2 && _typeof$4(column2) === "object";
  }).reduce(function(list, column2, index2) {
    var fixed = column2.fixed, parsedFixed = fixed === !0 ? "left" : fixed, mergedKey = "".concat(parentKey, "-").concat(index2), subColumns = column2.children;
    return subColumns && subColumns.length > 0 ? [].concat(_toConsumableArray(list), _toConsumableArray(flatColumns(subColumns, mergedKey).map(function(subColum) {
      return _objectSpread2$1({
        fixed: parsedFixed
      }, subColum);
    }))) : [].concat(_toConsumableArray(list), [_objectSpread2$1(_objectSpread2$1({
      key: mergedKey
    }, column2), {}, {
      fixed: parsedFixed
    })]);
  }, []);
}
__name(flatColumns, "flatColumns");
function revertForRtl(columns) {
  return columns.map(function(column2) {
    var fixed = column2.fixed, restProps = _objectWithoutProperties(column2, _excluded2), parsedFixed = fixed;
    return fixed === "left" ? parsedFixed = "right" : fixed === "right" && (parsedFixed = "left"), _objectSpread2$1({
      fixed: parsedFixed
    }, restProps);
  });
}
__name(revertForRtl, "revertForRtl");
function useColumns(_ref2, transformColumns) {
  var prefixCls = _ref2.prefixCls, columns = _ref2.columns, children = _ref2.children, expandable = _ref2.expandable, expandedKeys = _ref2.expandedKeys, columnTitle = _ref2.columnTitle, getRowKey = _ref2.getRowKey, onTriggerExpand = _ref2.onTriggerExpand, expandIcon = _ref2.expandIcon, rowExpandable = _ref2.rowExpandable, expandIconColumnIndex = _ref2.expandIconColumnIndex, direction = _ref2.direction, expandRowByClick = _ref2.expandRowByClick, columnWidth = _ref2.columnWidth, fixed = _ref2.fixed, scrollWidth = _ref2.scrollWidth, clientWidth = _ref2.clientWidth, baseColumns = React.useMemo(function() {
    var newColumns = columns || convertChildrenToColumns(children) || [];
    return filterHiddenColumns(newColumns.slice());
  }, [columns, children]), withExpandColumns = React.useMemo(function() {
    if (expandable) {
      var cloneColumns = baseColumns.slice();
      if (process.env.NODE_ENV !== "production" && expandIconColumnIndex >= 0 && warningOnce(!1, "`expandIconColumnIndex` is deprecated. Please use `Table.EXPAND_COLUMN` in `columns` instead."), !cloneColumns.includes(EXPAND_COLUMN)) {
        var expandColIndex = expandIconColumnIndex || 0;
        expandColIndex >= 0 && cloneColumns.splice(expandColIndex, 0, EXPAND_COLUMN);
      }
      process.env.NODE_ENV !== "production" && cloneColumns.filter(function(c) {
        return c === EXPAND_COLUMN;
      }).length > 1 && warningOnce(!1, "There exist more than one `EXPAND_COLUMN` in `columns`.");
      var expandColumnIndex = cloneColumns.indexOf(EXPAND_COLUMN);
      cloneColumns = cloneColumns.filter(function(column2, index2) {
        return column2 !== EXPAND_COLUMN || index2 === expandColumnIndex;
      });
      var prevColumn = baseColumns[expandColumnIndex], fixedColumn;
      (fixed === "left" || fixed) && !expandIconColumnIndex ? fixedColumn = "left" : (fixed === "right" || fixed) && expandIconColumnIndex === baseColumns.length ? fixedColumn = "right" : fixedColumn = prevColumn ? prevColumn.fixed : null;
      var expandColumn = _defineProperty$2(_defineProperty$2(_defineProperty$2(_defineProperty$2(_defineProperty$2(_defineProperty$2({}, INTERNAL_COL_DEFINE, {
        className: "".concat(prefixCls, "-expand-icon-col"),
        columnType: "EXPAND_COLUMN"
      }), "title", columnTitle), "fixed", fixedColumn), "className", "".concat(prefixCls, "-row-expand-icon-cell")), "width", columnWidth), "render", /* @__PURE__ */ __name(function(_2, record, index2) {
        var rowKey = getRowKey(record, index2), expanded = expandedKeys.has(rowKey), recordExpandable = rowExpandable ? rowExpandable(record) : !0, icon = expandIcon({
          prefixCls,
          expanded,
          expandable: recordExpandable,
          record,
          onExpand: onTriggerExpand
        });
        return expandRowByClick ? /* @__PURE__ */ React.createElement("span", {
          onClick: /* @__PURE__ */ __name(function(e2) {
            return e2.stopPropagation();
          }, "onClick")
        }, icon) : icon;
      }, "render"));
      return cloneColumns.map(function(col) {
        return col === EXPAND_COLUMN ? expandColumn : col;
      });
    }
    return process.env.NODE_ENV !== "production" && baseColumns.includes(EXPAND_COLUMN) && warningOnce(!1, "`expandable` is not config but there exist `EXPAND_COLUMN` in `columns`."), baseColumns.filter(function(col) {
      return col !== EXPAND_COLUMN;
    });
  }, [expandable, baseColumns, getRowKey, expandedKeys, expandIcon, direction]), mergedColumns = React.useMemo(function() {
    var finalColumns = withExpandColumns;
    return transformColumns && (finalColumns = transformColumns(finalColumns)), finalColumns.length || (finalColumns = [{
      render: /* @__PURE__ */ __name(function() {
        return null;
      }, "render")
    }]), finalColumns;
  }, [transformColumns, withExpandColumns, direction]), flattenColumns = React.useMemo(function() {
    return direction === "rtl" ? revertForRtl(flatColumns(mergedColumns)) : flatColumns(mergedColumns);
  }, [mergedColumns, direction, scrollWidth]), hasGapFixed = React.useMemo(function() {
    for (var lastLeftIndex = -1, i = flattenColumns.length - 1; i >= 0; i -= 1) {
      var colFixed = flattenColumns[i].fixed;
      if (colFixed === "left" || colFixed === !0) {
        lastLeftIndex = i;
        break;
      }
    }
    if (lastLeftIndex >= 0)
      for (var _i = 0; _i <= lastLeftIndex; _i += 1) {
        var _colFixed = flattenColumns[_i].fixed;
        if (_colFixed !== "left" && _colFixed !== !0)
          return !0;
      }
    var firstRightIndex = flattenColumns.findIndex(function(_ref3) {
      var colFixed2 = _ref3.fixed;
      return colFixed2 === "right";
    });
    if (firstRightIndex >= 0)
      for (var _i2 = firstRightIndex; _i2 < flattenColumns.length; _i2 += 1) {
        var _colFixed2 = flattenColumns[_i2].fixed;
        if (_colFixed2 !== "right")
          return !0;
      }
    return !1;
  }, [flattenColumns]), _useWidthColumns = useWidthColumns(flattenColumns, scrollWidth, clientWidth), _useWidthColumns2 = _slicedToArray(_useWidthColumns, 2), filledColumns = _useWidthColumns2[0], realScrollWidth = _useWidthColumns2[1];
  return [mergedColumns, filledColumns, realScrollWidth, hasGapFixed];
}
__name(useColumns, "useColumns");
function useExpand(props, mergedData, getRowKey) {
  var expandableConfig = getExpandableProps(props), expandIcon = expandableConfig.expandIcon, expandedRowKeys = expandableConfig.expandedRowKeys, defaultExpandedRowKeys = expandableConfig.defaultExpandedRowKeys, defaultExpandAllRows = expandableConfig.defaultExpandAllRows, expandedRowRender = expandableConfig.expandedRowRender, onExpand = expandableConfig.onExpand, onExpandedRowsChange = expandableConfig.onExpandedRowsChange, childrenColumnName = expandableConfig.childrenColumnName, mergedExpandIcon = expandIcon || renderExpandIcon$1, mergedChildrenColumnName = childrenColumnName || "children", expandableType = React.useMemo(function() {
    return expandedRowRender ? "row" : props.expandable && props.internalHooks === INTERNAL_HOOKS && props.expandable.__PARENT_RENDER_ICON__ || mergedData.some(function(record) {
      return record && _typeof$4(record) === "object" && record[mergedChildrenColumnName];
    }) ? "nest" : !1;
  }, [!!expandedRowRender, mergedData]), _React$useState = React.useState(function() {
    return defaultExpandedRowKeys || (defaultExpandAllRows ? findAllChildrenKeys(mergedData, getRowKey, mergedChildrenColumnName) : []);
  }), _React$useState2 = _slicedToArray(_React$useState, 2), innerExpandedKeys = _React$useState2[0], setInnerExpandedKeys = _React$useState2[1], mergedExpandedKeys = React.useMemo(function() {
    return new Set(expandedRowKeys || innerExpandedKeys || []);
  }, [expandedRowKeys, innerExpandedKeys]), onTriggerExpand = React.useCallback(function(record) {
    var key = getRowKey(record, mergedData.indexOf(record)), newExpandedKeys, hasKey = mergedExpandedKeys.has(key);
    hasKey ? (mergedExpandedKeys.delete(key), newExpandedKeys = _toConsumableArray(mergedExpandedKeys)) : newExpandedKeys = [].concat(_toConsumableArray(mergedExpandedKeys), [key]), setInnerExpandedKeys(newExpandedKeys), onExpand && onExpand(!hasKey, record), onExpandedRowsChange && onExpandedRowsChange(newExpandedKeys);
  }, [getRowKey, mergedExpandedKeys, mergedData, onExpand, onExpandedRowsChange]);
  return process.env.NODE_ENV !== "production" && expandedRowRender && mergedData.some(function(record) {
    return Array.isArray(record == null ? void 0 : record[mergedChildrenColumnName]);
  }) && warningOnce(!1, "`expandedRowRender` should not use with nested Table"), [expandableConfig, expandableType, mergedExpandedKeys, mergedExpandIcon, mergedChildrenColumnName, onTriggerExpand];
}
__name(useExpand, "useExpand");
function useFixedInfo(flattenColumns, stickyOffsets, direction) {
  var fixedInfoList = flattenColumns.map(function(_2, colIndex) {
    return getCellFixedInfo(colIndex, colIndex, flattenColumns, stickyOffsets, direction);
  });
  return useMemo(function() {
    return fixedInfoList;
  }, [fixedInfoList], function(prev2, next2) {
    return !isEqual(prev2, next2);
  });
}
__name(useFixedInfo, "useFixedInfo");
function useLayoutState(defaultState) {
  var stateRef = useRef(defaultState), _useState = useState({}), _useState2 = _slicedToArray(_useState, 2), forceUpdate = _useState2[1], lastPromiseRef = useRef(null), updateBatchRef = useRef([]);
  function setFrameState(updater) {
    updateBatchRef.current.push(updater);
    var promise = Promise.resolve();
    lastPromiseRef.current = promise, promise.then(function() {
      if (lastPromiseRef.current === promise) {
        var prevBatch = updateBatchRef.current, prevState = stateRef.current;
        updateBatchRef.current = [], prevBatch.forEach(function(batchUpdater) {
          stateRef.current = batchUpdater(stateRef.current);
        }), lastPromiseRef.current = null, prevState !== stateRef.current && forceUpdate({});
      }
    });
  }
  return __name(setFrameState, "setFrameState"), useEffect(function() {
    return function() {
      lastPromiseRef.current = null;
    };
  }, []), [stateRef.current, setFrameState];
}
__name(useLayoutState, "useLayoutState");
function useTimeoutLock(defaultState) {
  var frameRef = useRef(null), timeoutRef = useRef();
  function cleanUp() {
    window.clearTimeout(timeoutRef.current);
  }
  __name(cleanUp, "cleanUp");
  function setState(newState) {
    frameRef.current = newState, cleanUp(), timeoutRef.current = window.setTimeout(function() {
      frameRef.current = null, timeoutRef.current = void 0;
    }, 100);
  }
  __name(setState, "setState");
  function getState() {
    return frameRef.current;
  }
  return __name(getState, "getState"), useEffect(function() {
    return cleanUp;
  }, []), [setState, getState];
}
__name(useTimeoutLock, "useTimeoutLock");
function useHover() {
  var _React$useState = React.useState(-1), _React$useState2 = _slicedToArray(_React$useState, 2), startRow = _React$useState2[0], setStartRow = _React$useState2[1], _React$useState3 = React.useState(-1), _React$useState4 = _slicedToArray(_React$useState3, 2), endRow = _React$useState4[0], setEndRow = _React$useState4[1], onHover = React.useCallback(function(start, end) {
    setStartRow(start), setEndRow(end);
  }, []);
  return [startRow, endRow, onHover];
}
__name(useHover, "useHover");
var defaultContainer = canUseDom() ? window : null;
function useSticky(sticky, prefixCls) {
  var _ref = _typeof$4(sticky) === "object" ? sticky : {}, _ref$offsetHeader = _ref.offsetHeader, offsetHeader = _ref$offsetHeader === void 0 ? 0 : _ref$offsetHeader, _ref$offsetSummary = _ref.offsetSummary, offsetSummary = _ref$offsetSummary === void 0 ? 0 : _ref$offsetSummary, _ref$offsetScroll = _ref.offsetScroll, offsetScroll = _ref$offsetScroll === void 0 ? 0 : _ref$offsetScroll, _ref$getContainer = _ref.getContainer, getContainer2 = _ref$getContainer === void 0 ? function() {
    return defaultContainer;
  } : _ref$getContainer, container2 = getContainer2() || defaultContainer, isSticky = !!sticky;
  return React.useMemo(function() {
    return {
      isSticky,
      stickyClassName: isSticky ? "".concat(prefixCls, "-sticky-holder") : "",
      offsetHeader,
      offsetSummary,
      offsetScroll,
      container: container2
    };
  }, [isSticky, offsetScroll, offsetHeader, offsetSummary, prefixCls, container2]);
}
__name(useSticky, "useSticky");
function useStickyOffsets(colWidths, flattenColumns, direction) {
  var stickyOffsets = useMemo$1(function() {
    var columnCount = flattenColumns.length, getOffsets = /* @__PURE__ */ __name(function(startIndex, endIndex, offset2) {
      for (var offsets = [], total = 0, i = startIndex; i !== endIndex; i += offset2)
        offsets.push(total), flattenColumns[i].fixed && (total += colWidths[i] || 0);
      return offsets;
    }, "getOffsets"), startOffsets = getOffsets(0, columnCount, 1), endOffsets = getOffsets(columnCount - 1, -1, -1).reverse();
    return direction === "rtl" ? {
      left: endOffsets,
      right: startOffsets
    } : {
      left: startOffsets,
      right: endOffsets
    };
  }, [colWidths, flattenColumns, direction]);
  return stickyOffsets;
}
__name(useStickyOffsets, "useStickyOffsets");
function Panel(_ref) {
  var className = _ref.className, children = _ref.children;
  return /* @__PURE__ */ React.createElement("div", {
    className
  }, children);
}
__name(Panel, "Panel");
var StickyScrollBar = /* @__PURE__ */ __name(function(_ref, ref) {
  var _scrollBodyRef$curren, _scrollBodyRef$curren2, scrollBodyRef = _ref.scrollBodyRef, onScroll = _ref.onScroll, offsetScroll = _ref.offsetScroll, container2 = _ref.container, prefixCls = useContext(TableContext, "prefixCls"), bodyScrollWidth = ((_scrollBodyRef$curren = scrollBodyRef.current) === null || _scrollBodyRef$curren === void 0 ? void 0 : _scrollBodyRef$curren.scrollWidth) || 0, bodyWidth = ((_scrollBodyRef$curren2 = scrollBodyRef.current) === null || _scrollBodyRef$curren2 === void 0 ? void 0 : _scrollBodyRef$curren2.clientWidth) || 0, scrollBarWidth = bodyScrollWidth && bodyWidth * (bodyWidth / bodyScrollWidth), scrollBarRef = React.useRef(), _useLayoutState = useLayoutState({
    scrollLeft: 0,
    isHiddenScrollBar: !0
  }), _useLayoutState2 = _slicedToArray(_useLayoutState, 2), scrollState = _useLayoutState2[0], setScrollState = _useLayoutState2[1], refState = React.useRef({
    delta: 0,
    x: 0
  }), _React$useState = React.useState(!1), _React$useState2 = _slicedToArray(_React$useState, 2), isActive2 = _React$useState2[0], setActive = _React$useState2[1], rafRef = React.useRef(null);
  React.useEffect(function() {
    return function() {
      wrapperRaf.cancel(rafRef.current);
    };
  }, []);
  var onMouseUp = /* @__PURE__ */ __name(function() {
    setActive(!1);
  }, "onMouseUp"), onMouseDown = /* @__PURE__ */ __name(function(event) {
    event.persist(), refState.current.delta = event.pageX - scrollState.scrollLeft, refState.current.x = 0, setActive(!0), event.preventDefault();
  }, "onMouseDown"), onMouseMove = /* @__PURE__ */ __name(function(event) {
    var _window, _ref2 = event || ((_window = window) === null || _window === void 0 ? void 0 : _window.event), buttons = _ref2.buttons;
    if (!isActive2 || buttons === 0) {
      isActive2 && setActive(!1);
      return;
    }
    var left = refState.current.x + event.pageX - refState.current.x - refState.current.delta;
    left <= 0 && (left = 0), left + scrollBarWidth >= bodyWidth && (left = bodyWidth - scrollBarWidth), onScroll({
      scrollLeft: left / bodyWidth * (bodyScrollWidth + 2)
    }), refState.current.x = event.pageX;
  }, "onMouseMove"), checkScrollBarVisible = /* @__PURE__ */ __name(function() {
    rafRef.current = wrapperRaf(function() {
      if (scrollBodyRef.current) {
        var tableOffsetTop = getOffset(scrollBodyRef.current).top, tableBottomOffset = tableOffsetTop + scrollBodyRef.current.offsetHeight, currentClientOffset = container2 === window ? document.documentElement.scrollTop + window.innerHeight : getOffset(container2).top + container2.clientHeight;
        tableBottomOffset - getScrollBarSize() <= currentClientOffset || tableOffsetTop >= currentClientOffset - offsetScroll ? setScrollState(function(state) {
          return _objectSpread2$1(_objectSpread2$1({}, state), {}, {
            isHiddenScrollBar: !0
          });
        }) : setScrollState(function(state) {
          return _objectSpread2$1(_objectSpread2$1({}, state), {}, {
            isHiddenScrollBar: !1
          });
        });
      }
    });
  }, "checkScrollBarVisible"), setScrollLeft = /* @__PURE__ */ __name(function(left) {
    setScrollState(function(state) {
      return _objectSpread2$1(_objectSpread2$1({}, state), {}, {
        scrollLeft: left / bodyScrollWidth * bodyWidth || 0
      });
    });
  }, "setScrollLeft");
  return React.useImperativeHandle(ref, function() {
    return {
      setScrollLeft,
      checkScrollBarVisible
    };
  }), React.useEffect(function() {
    var onMouseUpListener = addEventListenerWrap(document.body, "mouseup", onMouseUp, !1), onMouseMoveListener = addEventListenerWrap(document.body, "mousemove", onMouseMove, !1);
    return checkScrollBarVisible(), function() {
      onMouseUpListener.remove(), onMouseMoveListener.remove();
    };
  }, [scrollBarWidth, isActive2]), React.useEffect(function() {
    var onScrollListener = addEventListenerWrap(container2, "scroll", checkScrollBarVisible, !1), onResizeListener = addEventListenerWrap(window, "resize", checkScrollBarVisible, !1);
    return function() {
      onScrollListener.remove(), onResizeListener.remove();
    };
  }, [container2]), React.useEffect(function() {
    scrollState.isHiddenScrollBar || setScrollState(function(state) {
      var bodyNode = scrollBodyRef.current;
      return bodyNode ? _objectSpread2$1(_objectSpread2$1({}, state), {}, {
        scrollLeft: bodyNode.scrollLeft / bodyNode.scrollWidth * bodyNode.clientWidth
      }) : state;
    });
  }, [scrollState.isHiddenScrollBar]), bodyScrollWidth <= bodyWidth || !scrollBarWidth || scrollState.isHiddenScrollBar ? null : /* @__PURE__ */ React.createElement("div", {
    style: {
      height: getScrollBarSize(),
      width: bodyWidth,
      bottom: offsetScroll
    },
    className: "".concat(prefixCls, "-sticky-scroll")
  }, /* @__PURE__ */ React.createElement("div", {
    onMouseDown,
    ref: scrollBarRef,
    className: cn("".concat(prefixCls, "-sticky-scroll-bar"), _defineProperty$2({}, "".concat(prefixCls, "-sticky-scroll-bar-active"), isActive2)),
    style: {
      width: "".concat(scrollBarWidth, "px"),
      transform: "translate3d(".concat(scrollState.scrollLeft, "px, 0, 0)")
    }
  }));
}, "StickyScrollBar");
const StickyScrollBar$1 = /* @__PURE__ */ React.forwardRef(StickyScrollBar);
var DEFAULT_PREFIX = "rc-table", EMPTY_DATA = [], EMPTY_SCROLL_TARGET = {};
function defaultEmpty() {
  return "No Data";
}
__name(defaultEmpty, "defaultEmpty");
function Table$2(tableProps, ref) {
  var props = _objectSpread2$1({
    rowKey: "key",
    prefixCls: DEFAULT_PREFIX,
    emptyText: defaultEmpty
  }, tableProps), prefixCls = props.prefixCls, className = props.className, rowClassName = props.rowClassName, style2 = props.style, data = props.data, rowKey = props.rowKey, scroll = props.scroll, tableLayout = props.tableLayout, direction = props.direction, title2 = props.title, footer = props.footer, summary = props.summary, caption = props.caption, id2 = props.id, showHeader = props.showHeader, components2 = props.components, emptyText = props.emptyText, onRow = props.onRow, onHeaderRow = props.onHeaderRow, onScroll = props.onScroll, internalHooks = props.internalHooks, transformColumns = props.transformColumns, internalRefs = props.internalRefs, tailor = props.tailor, getContainerWidth = props.getContainerWidth, sticky = props.sticky, _props$rowHoverable = props.rowHoverable, rowHoverable = _props$rowHoverable === void 0 ? !0 : _props$rowHoverable, mergedData = data || EMPTY_DATA, hasData = !!mergedData.length, useInternalHooks = internalHooks === INTERNAL_HOOKS;
  process.env.NODE_ENV !== "production" && (["onRowClick", "onRowDoubleClick", "onRowContextMenu", "onRowMouseEnter", "onRowMouseLeave"].forEach(function(name) {
    warningOnce(props[name] === void 0, "`".concat(name, "` is removed, please use `onRow` instead."));
  }), warningOnce(!("getBodyWrapper" in props), "`getBodyWrapper` is deprecated, please use custom `components` instead."));
  var getComponent = React.useCallback(function(path2, defaultComponent) {
    return get(components2, path2) || defaultComponent;
  }, [components2]), getRowKey = React.useMemo(function() {
    return typeof rowKey == "function" ? rowKey : function(record) {
      var key = record && record[rowKey];
      return process.env.NODE_ENV !== "production" && warningOnce(key !== void 0, "Each record in table should have a unique `key` prop, or set `rowKey` to an unique primary key."), key;
    };
  }, [rowKey]), customizeScrollBody = getComponent(["body"]), _useHover = useHover(), _useHover2 = _slicedToArray(_useHover, 3), startRow = _useHover2[0], endRow = _useHover2[1], onHover = _useHover2[2], _useExpand = useExpand(props, mergedData, getRowKey), _useExpand2 = _slicedToArray(_useExpand, 6), expandableConfig = _useExpand2[0], expandableType = _useExpand2[1], mergedExpandedKeys = _useExpand2[2], mergedExpandIcon = _useExpand2[3], mergedChildrenColumnName = _useExpand2[4], onTriggerExpand = _useExpand2[5], scrollX = scroll == null ? void 0 : scroll.x, _React$useState = React.useState(0), _React$useState2 = _slicedToArray(_React$useState, 2), componentWidth = _React$useState2[0], setComponentWidth = _React$useState2[1], _useColumns = useColumns(_objectSpread2$1(_objectSpread2$1(_objectSpread2$1({}, props), expandableConfig), {}, {
    expandable: !!expandableConfig.expandedRowRender,
    columnTitle: expandableConfig.columnTitle,
    expandedKeys: mergedExpandedKeys,
    getRowKey,
    // https://github.com/ant-design/ant-design/issues/23894
    onTriggerExpand,
    expandIcon: mergedExpandIcon,
    expandIconColumnIndex: expandableConfig.expandIconColumnIndex,
    direction,
    scrollWidth: useInternalHooks && tailor && typeof scrollX == "number" ? scrollX : null,
    clientWidth: componentWidth
  }), useInternalHooks ? transformColumns : null), _useColumns2 = _slicedToArray(_useColumns, 4), columns = _useColumns2[0], flattenColumns = _useColumns2[1], flattenScrollX = _useColumns2[2], hasGapFixed = _useColumns2[3], mergedScrollX = flattenScrollX ?? scrollX, columnContext = React.useMemo(function() {
    return {
      columns,
      flattenColumns
    };
  }, [columns, flattenColumns]), fullTableRef = React.useRef(), scrollHeaderRef = React.useRef(), scrollBodyRef = React.useRef(), scrollBodyContainerRef = React.useRef();
  React.useImperativeHandle(ref, function() {
    return {
      nativeElement: fullTableRef.current,
      scrollTo: /* @__PURE__ */ __name(function(config) {
        var _scrollBodyRef$curren3;
        if (scrollBodyRef.current instanceof HTMLElement) {
          var index2 = config.index, top = config.top, key = config.key;
          if (validNumberValue(top)) {
            var _scrollBodyRef$curren;
            (_scrollBodyRef$curren = scrollBodyRef.current) === null || _scrollBodyRef$curren === void 0 || _scrollBodyRef$curren.scrollTo({
              top
            });
          } else {
            var _scrollBodyRef$curren2, mergedKey = key ?? getRowKey(mergedData[index2]);
            (_scrollBodyRef$curren2 = scrollBodyRef.current.querySelector('[data-row-key="'.concat(mergedKey, '"]'))) === null || _scrollBodyRef$curren2 === void 0 || _scrollBodyRef$curren2.scrollIntoView();
          }
        } else (_scrollBodyRef$curren3 = scrollBodyRef.current) !== null && _scrollBodyRef$curren3 !== void 0 && _scrollBodyRef$curren3.scrollTo && scrollBodyRef.current.scrollTo(config);
      }, "scrollTo")
    };
  });
  var scrollSummaryRef = React.useRef(), _React$useState3 = React.useState(!1), _React$useState4 = _slicedToArray(_React$useState3, 2), pingedLeft = _React$useState4[0], setPingedLeft = _React$useState4[1], _React$useState5 = React.useState(!1), _React$useState6 = _slicedToArray(_React$useState5, 2), pingedRight = _React$useState6[0], setPingedRight = _React$useState6[1], _useLayoutState = useLayoutState(/* @__PURE__ */ new Map()), _useLayoutState2 = _slicedToArray(_useLayoutState, 2), colsWidths = _useLayoutState2[0], updateColsWidths = _useLayoutState2[1], colsKeys = getColumnsKey(flattenColumns), pureColWidths = colsKeys.map(function(columnKey) {
    return colsWidths.get(columnKey);
  }), colWidths = React.useMemo(function() {
    return pureColWidths;
  }, [pureColWidths.join("_")]), stickyOffsets = useStickyOffsets(colWidths, flattenColumns, direction), fixHeader = scroll && validateValue(scroll.y), horizonScroll = scroll && validateValue(mergedScrollX) || !!expandableConfig.fixed, fixColumn = horizonScroll && flattenColumns.some(function(_ref) {
    var fixed = _ref.fixed;
    return fixed;
  }), stickyRef = React.useRef(), _useSticky = useSticky(sticky, prefixCls), isSticky = _useSticky.isSticky, offsetHeader = _useSticky.offsetHeader, offsetSummary = _useSticky.offsetSummary, offsetScroll = _useSticky.offsetScroll, stickyClassName = _useSticky.stickyClassName, container2 = _useSticky.container, summaryNode = React.useMemo(function() {
    return summary == null ? void 0 : summary(mergedData);
  }, [summary, mergedData]), fixFooter = (fixHeader || isSticky) && /* @__PURE__ */ React.isValidElement(summaryNode) && summaryNode.type === Summary && summaryNode.props.fixed, scrollXStyle, scrollYStyle, scrollTableStyle;
  fixHeader && (scrollYStyle = {
    overflowY: hasData ? "scroll" : "auto",
    maxHeight: scroll.y
  }), horizonScroll && (scrollXStyle = {
    overflowX: "auto"
  }, fixHeader || (scrollYStyle = {
    overflowY: "hidden"
  }), scrollTableStyle = {
    width: mergedScrollX === !0 ? "auto" : mergedScrollX,
    minWidth: "100%"
  });
  var onColumnResize = React.useCallback(function(columnKey, width) {
    isVisible(fullTableRef.current) && updateColsWidths(function(widths) {
      if (widths.get(columnKey) !== width) {
        var newWidths = new Map(widths);
        return newWidths.set(columnKey, width), newWidths;
      }
      return widths;
    });
  }, []), _useTimeoutLock = useTimeoutLock(), _useTimeoutLock2 = _slicedToArray(_useTimeoutLock, 2), setScrollTarget = _useTimeoutLock2[0], getScrollTarget = _useTimeoutLock2[1];
  function forceScroll(scrollLeft, target) {
    target && (typeof target == "function" ? target(scrollLeft) : target.scrollLeft !== scrollLeft && (target.scrollLeft = scrollLeft, target.scrollLeft !== scrollLeft && setTimeout(function() {
      target.scrollLeft = scrollLeft;
    }, 0)));
  }
  __name(forceScroll, "forceScroll");
  var onInternalScroll = useEvent(function(_ref2) {
    var currentTarget = _ref2.currentTarget, scrollLeft = _ref2.scrollLeft, isRTL = direction === "rtl", mergedScrollLeft = typeof scrollLeft == "number" ? scrollLeft : currentTarget.scrollLeft, compareTarget = currentTarget || EMPTY_SCROLL_TARGET;
    if (!getScrollTarget() || getScrollTarget() === compareTarget) {
      var _stickyRef$current;
      setScrollTarget(compareTarget), forceScroll(mergedScrollLeft, scrollHeaderRef.current), forceScroll(mergedScrollLeft, scrollBodyRef.current), forceScroll(mergedScrollLeft, scrollSummaryRef.current), forceScroll(mergedScrollLeft, (_stickyRef$current = stickyRef.current) === null || _stickyRef$current === void 0 ? void 0 : _stickyRef$current.setScrollLeft);
    }
    var measureTarget = currentTarget || scrollHeaderRef.current;
    if (measureTarget) {
      var scrollWidth = (
        // Should use mergedScrollX in virtual table(useInternalHooks && tailor === true)
        useInternalHooks && tailor && typeof mergedScrollX == "number" ? mergedScrollX : measureTarget.scrollWidth
      ), clientWidth = measureTarget.clientWidth;
      if (scrollWidth === clientWidth) {
        setPingedLeft(!1), setPingedRight(!1);
        return;
      }
      isRTL ? (setPingedLeft(-mergedScrollLeft < scrollWidth - clientWidth), setPingedRight(-mergedScrollLeft > 0)) : (setPingedLeft(mergedScrollLeft > 0), setPingedRight(mergedScrollLeft < scrollWidth - clientWidth));
    }
  }), onBodyScroll = useEvent(function(e2) {
    onInternalScroll(e2), onScroll == null || onScroll(e2);
  }), triggerOnScroll = /* @__PURE__ */ __name(function() {
    if (horizonScroll && scrollBodyRef.current) {
      var _scrollBodyRef$curren4;
      onInternalScroll({
        currentTarget: getDOM(scrollBodyRef.current),
        scrollLeft: (_scrollBodyRef$curren4 = scrollBodyRef.current) === null || _scrollBodyRef$curren4 === void 0 ? void 0 : _scrollBodyRef$curren4.scrollLeft
      });
    } else
      setPingedLeft(!1), setPingedRight(!1);
  }, "triggerOnScroll"), onFullTableResize = /* @__PURE__ */ __name(function(_ref3) {
    var _stickyRef$current2, width = _ref3.width;
    (_stickyRef$current2 = stickyRef.current) === null || _stickyRef$current2 === void 0 || _stickyRef$current2.checkScrollBarVisible();
    var mergedWidth = fullTableRef.current ? fullTableRef.current.offsetWidth : width;
    useInternalHooks && getContainerWidth && fullTableRef.current && (mergedWidth = getContainerWidth(fullTableRef.current, mergedWidth) || mergedWidth), mergedWidth !== componentWidth && (triggerOnScroll(), setComponentWidth(mergedWidth));
  }, "onFullTableResize"), mounted = React.useRef(!1);
  React.useEffect(function() {
    mounted.current && triggerOnScroll();
  }, [horizonScroll, data, columns.length]), React.useEffect(function() {
    mounted.current = !0;
  }, []);
  var _React$useState7 = React.useState(0), _React$useState8 = _slicedToArray(_React$useState7, 2), scrollbarSize = _React$useState8[0], setScrollbarSize = _React$useState8[1], _React$useState9 = React.useState(!0), _React$useState10 = _slicedToArray(_React$useState9, 2), supportSticky = _React$useState10[0], setSupportSticky = _React$useState10[1];
  React.useEffect(function() {
    (!tailor || !useInternalHooks) && (scrollBodyRef.current instanceof Element ? setScrollbarSize(getTargetScrollBarSize(scrollBodyRef.current).width) : setScrollbarSize(getTargetScrollBarSize(scrollBodyContainerRef.current).width)), setSupportSticky(isStyleSupport("position", "sticky"));
  }, []), React.useEffect(function() {
    useInternalHooks && internalRefs && (internalRefs.body.current = scrollBodyRef.current);
  });
  var renderFixedHeaderTable = React.useCallback(function(fixedHolderPassProps) {
    return /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement(Header$2, fixedHolderPassProps), fixFooter === "top" && /* @__PURE__ */ React.createElement(Footer$1, fixedHolderPassProps, summaryNode));
  }, [fixFooter, summaryNode]), renderFixedFooterTable = React.useCallback(function(fixedHolderPassProps) {
    return /* @__PURE__ */ React.createElement(Footer$1, fixedHolderPassProps, summaryNode);
  }, [summaryNode]), TableComponent = getComponent(["table"], "table"), mergedTableLayout = React.useMemo(function() {
    return tableLayout || (fixColumn ? mergedScrollX === "max-content" ? "auto" : "fixed" : fixHeader || isSticky || flattenColumns.some(function(_ref4) {
      var ellipsis = _ref4.ellipsis;
      return ellipsis;
    }) ? "fixed" : "auto");
  }, [fixHeader, fixColumn, flattenColumns, tableLayout, isSticky]), groupTableNode, headerProps = {
    colWidths,
    columCount: flattenColumns.length,
    stickyOffsets,
    onHeaderRow,
    fixHeader,
    scroll
  }, emptyNode = React.useMemo(function() {
    return hasData ? null : typeof emptyText == "function" ? emptyText() : emptyText;
  }, [hasData, emptyText]), bodyTable = /* @__PURE__ */ React.createElement(Body$1, {
    data: mergedData,
    measureColumnWidth: fixHeader || horizonScroll || isSticky
  }), bodyColGroup = /* @__PURE__ */ React.createElement(ColGroup, {
    colWidths: flattenColumns.map(function(_ref5) {
      var width = _ref5.width;
      return width;
    }),
    columns: flattenColumns
  }), captionElement = caption != null ? /* @__PURE__ */ React.createElement("caption", {
    className: "".concat(prefixCls, "-caption")
  }, caption) : void 0, dataProps = pickAttrs(props, {
    data: !0
  }), ariaProps = pickAttrs(props, {
    aria: !0
  });
  if (fixHeader || isSticky) {
    var bodyContent;
    typeof customizeScrollBody == "function" ? (bodyContent = customizeScrollBody(mergedData, {
      scrollbarSize,
      ref: scrollBodyRef,
      onScroll: onInternalScroll
    }), headerProps.colWidths = flattenColumns.map(function(_ref6, index2) {
      var width = _ref6.width, colWidth = index2 === flattenColumns.length - 1 ? width - scrollbarSize : width;
      return typeof colWidth == "number" && !Number.isNaN(colWidth) ? colWidth : (process.env.NODE_ENV !== "production" && warningOnce(props.columns.length === 0, "When use `components.body` with render props. Each column should have a fixed `width` value."), 0);
    })) : bodyContent = /* @__PURE__ */ React.createElement("div", {
      style: _objectSpread2$1(_objectSpread2$1({}, scrollXStyle), scrollYStyle),
      onScroll: onBodyScroll,
      ref: scrollBodyRef,
      className: cn("".concat(prefixCls, "-body"))
    }, /* @__PURE__ */ React.createElement(TableComponent, _extends({
      style: _objectSpread2$1(_objectSpread2$1({}, scrollTableStyle), {}, {
        tableLayout: mergedTableLayout
      })
    }, ariaProps), captionElement, bodyColGroup, bodyTable, !fixFooter && summaryNode && /* @__PURE__ */ React.createElement(Footer$1, {
      stickyOffsets,
      flattenColumns
    }, summaryNode)));
    var fixedHolderProps = _objectSpread2$1(_objectSpread2$1(_objectSpread2$1({
      noData: !mergedData.length,
      maxContentScroll: horizonScroll && mergedScrollX === "max-content"
    }, headerProps), columnContext), {}, {
      direction,
      stickyClassName,
      onScroll: onInternalScroll
    });
    groupTableNode = /* @__PURE__ */ React.createElement(React.Fragment, null, showHeader !== !1 && /* @__PURE__ */ React.createElement(FixedHolder$1, _extends({}, fixedHolderProps, {
      stickyTopOffset: offsetHeader,
      className: "".concat(prefixCls, "-header"),
      ref: scrollHeaderRef
    }), renderFixedHeaderTable), bodyContent, fixFooter && fixFooter !== "top" && /* @__PURE__ */ React.createElement(FixedHolder$1, _extends({}, fixedHolderProps, {
      stickyBottomOffset: offsetSummary,
      className: "".concat(prefixCls, "-summary"),
      ref: scrollSummaryRef
    }), renderFixedFooterTable), isSticky && scrollBodyRef.current && scrollBodyRef.current instanceof Element && /* @__PURE__ */ React.createElement(StickyScrollBar$1, {
      ref: stickyRef,
      offsetScroll,
      scrollBodyRef,
      onScroll: onInternalScroll,
      container: container2
    }));
  } else
    groupTableNode = /* @__PURE__ */ React.createElement("div", {
      style: _objectSpread2$1(_objectSpread2$1({}, scrollXStyle), scrollYStyle),
      className: cn("".concat(prefixCls, "-content")),
      onScroll: onInternalScroll,
      ref: scrollBodyRef
    }, /* @__PURE__ */ React.createElement(TableComponent, _extends({
      style: _objectSpread2$1(_objectSpread2$1({}, scrollTableStyle), {}, {
        tableLayout: mergedTableLayout
      })
    }, ariaProps), captionElement, bodyColGroup, showHeader !== !1 && /* @__PURE__ */ React.createElement(Header$2, _extends({}, headerProps, columnContext)), bodyTable, summaryNode && /* @__PURE__ */ React.createElement(Footer$1, {
      stickyOffsets,
      flattenColumns
    }, summaryNode)));
  var fullTable = /* @__PURE__ */ React.createElement("div", _extends({
    className: cn(prefixCls, className, _defineProperty$2(_defineProperty$2(_defineProperty$2(_defineProperty$2(_defineProperty$2(_defineProperty$2(_defineProperty$2(_defineProperty$2(_defineProperty$2(_defineProperty$2({}, "".concat(prefixCls, "-rtl"), direction === "rtl"), "".concat(prefixCls, "-ping-left"), pingedLeft), "".concat(prefixCls, "-ping-right"), pingedRight), "".concat(prefixCls, "-layout-fixed"), tableLayout === "fixed"), "".concat(prefixCls, "-fixed-header"), fixHeader), "".concat(prefixCls, "-fixed-column"), fixColumn), "".concat(prefixCls, "-fixed-column-gapped"), fixColumn && hasGapFixed), "".concat(prefixCls, "-scroll-horizontal"), horizonScroll), "".concat(prefixCls, "-has-fix-left"), flattenColumns[0] && flattenColumns[0].fixed), "".concat(prefixCls, "-has-fix-right"), flattenColumns[flattenColumns.length - 1] && flattenColumns[flattenColumns.length - 1].fixed === "right")),
    style: style2,
    id: id2,
    ref: fullTableRef
  }, dataProps), title2 && /* @__PURE__ */ React.createElement(Panel, {
    className: "".concat(prefixCls, "-title")
  }, title2(mergedData)), /* @__PURE__ */ React.createElement("div", {
    ref: scrollBodyContainerRef,
    className: "".concat(prefixCls, "-container")
  }, groupTableNode), footer && /* @__PURE__ */ React.createElement(Panel, {
    className: "".concat(prefixCls, "-footer")
  }, footer(mergedData)));
  horizonScroll && (fullTable = /* @__PURE__ */ React.createElement(RefResizeObserver, {
    onResize: onFullTableResize
  }, fullTable));
  var fixedInfoList = useFixedInfo(flattenColumns, stickyOffsets, direction), TableContextValue = React.useMemo(function() {
    return {
      // Scroll
      scrollX: mergedScrollX,
      // Table
      prefixCls,
      getComponent,
      scrollbarSize,
      direction,
      fixedInfoList,
      isSticky,
      supportSticky,
      componentWidth,
      fixHeader,
      fixColumn,
      horizonScroll,
      // Body
      tableLayout: mergedTableLayout,
      rowClassName,
      expandedRowClassName: expandableConfig.expandedRowClassName,
      expandIcon: mergedExpandIcon,
      expandableType,
      expandRowByClick: expandableConfig.expandRowByClick,
      expandedRowRender: expandableConfig.expandedRowRender,
      onTriggerExpand,
      expandIconColumnIndex: expandableConfig.expandIconColumnIndex,
      indentSize: expandableConfig.indentSize,
      allColumnsFixedLeft: flattenColumns.every(function(col) {
        return col.fixed === "left";
      }),
      emptyNode,
      // Column
      columns,
      flattenColumns,
      onColumnResize,
      // Row
      hoverStartRow: startRow,
      hoverEndRow: endRow,
      onHover,
      rowExpandable: expandableConfig.rowExpandable,
      onRow,
      getRowKey,
      expandedKeys: mergedExpandedKeys,
      childrenColumnName: mergedChildrenColumnName,
      rowHoverable
    };
  }, [
    // Scroll
    mergedScrollX,
    // Table
    prefixCls,
    getComponent,
    scrollbarSize,
    direction,
    fixedInfoList,
    isSticky,
    supportSticky,
    componentWidth,
    fixHeader,
    fixColumn,
    horizonScroll,
    // Body
    mergedTableLayout,
    rowClassName,
    expandableConfig.expandedRowClassName,
    mergedExpandIcon,
    expandableType,
    expandableConfig.expandRowByClick,
    expandableConfig.expandedRowRender,
    onTriggerExpand,
    expandableConfig.expandIconColumnIndex,
    expandableConfig.indentSize,
    emptyNode,
    // Column
    columns,
    flattenColumns,
    onColumnResize,
    // Row
    startRow,
    endRow,
    onHover,
    expandableConfig.rowExpandable,
    onRow,
    getRowKey,
    mergedExpandedKeys,
    mergedChildrenColumnName,
    rowHoverable
  ]);
  return /* @__PURE__ */ React.createElement(TableContext.Provider, {
    value: TableContextValue
  }, fullTable);
}
__name(Table$2, "Table$2");
var RefTable = /* @__PURE__ */ React.forwardRef(Table$2);
process.env.NODE_ENV !== "production" && (RefTable.displayName = "Table");
function genTable(shouldTriggerRender) {
  return makeImmutable(RefTable, shouldTriggerRender);
}
__name(genTable, "genTable");
var ImmutableTable = genTable();
ImmutableTable.EXPAND_COLUMN = EXPAND_COLUMN;
ImmutableTable.INTERNAL_HOOKS = INTERNAL_HOOKS;
ImmutableTable.Column = Column$1;
ImmutableTable.ColumnGroup = ColumnGroup$1;
ImmutableTable.Summary = FooterComponents;
var StaticContext = createContext(null), GridContext = createContext(null);
function getColumnWidth(colIndex, colSpan, columnsOffset) {
  var mergedColSpan = colSpan || 1;
  return columnsOffset[colIndex + mergedColSpan] - (columnsOffset[colIndex] || 0);
}
__name(getColumnWidth, "getColumnWidth");
function VirtualCell(props) {
  var rowInfo = props.rowInfo, column2 = props.column, colIndex = props.colIndex, indent = props.indent, index2 = props.index, component = props.component, renderIndex = props.renderIndex, record = props.record, style2 = props.style, className = props.className, inverse = props.inverse, getHeight = props.getHeight, render4 = column2.render, dataIndex = column2.dataIndex, columnClassName = column2.className, colWidth = column2.width, _useContext = useContext(GridContext, ["columnsOffset"]), columnsOffset = _useContext.columnsOffset, _getCellProps = getCellProps(rowInfo, column2, colIndex, indent, index2), key = _getCellProps.key, fixedInfo = _getCellProps.fixedInfo, appendCellNode = _getCellProps.appendCellNode, additionalCellProps = _getCellProps.additionalCellProps, cellStyle = additionalCellProps.style, _additionalCellProps$ = additionalCellProps.colSpan, colSpan = _additionalCellProps$ === void 0 ? 1 : _additionalCellProps$, _additionalCellProps$2 = additionalCellProps.rowSpan, rowSpan = _additionalCellProps$2 === void 0 ? 1 : _additionalCellProps$2, startColIndex = colIndex - 1, concatColWidth = getColumnWidth(startColIndex, colSpan, columnsOffset), marginOffset = colSpan > 1 ? colWidth - concatColWidth : 0, mergedStyle = _objectSpread2$1(_objectSpread2$1(_objectSpread2$1({}, cellStyle), style2), {}, {
    flex: "0 0 ".concat(concatColWidth, "px"),
    width: "".concat(concatColWidth, "px"),
    marginRight: marginOffset,
    pointerEvents: "auto"
  }), needHide = React.useMemo(function() {
    return inverse ? rowSpan <= 1 : colSpan === 0 || rowSpan === 0 || rowSpan > 1;
  }, [rowSpan, colSpan, inverse]);
  needHide ? mergedStyle.visibility = "hidden" : inverse && (mergedStyle.height = getHeight == null ? void 0 : getHeight(rowSpan));
  var mergedRender = needHide ? function() {
    return null;
  } : render4, cellSpan = {};
  return (rowSpan === 0 || colSpan === 0) && (cellSpan.rowSpan = 1, cellSpan.colSpan = 1), /* @__PURE__ */ React.createElement(Cell$1, _extends({
    className: cn(columnClassName, className),
    ellipsis: column2.ellipsis,
    align: column2.align,
    scope: column2.rowScope,
    component,
    prefixCls: rowInfo.prefixCls,
    key,
    record,
    index: index2,
    renderIndex,
    dataIndex,
    render: mergedRender,
    shouldCellUpdate: column2.shouldCellUpdate
  }, fixedInfo, {
    appendNode: appendCellNode,
    additionalProps: _objectSpread2$1(_objectSpread2$1({}, additionalCellProps), {}, {
      style: mergedStyle
    }, cellSpan)
  }));
}
__name(VirtualCell, "VirtualCell");
var _excluded$4 = ["data", "index", "className", "rowKey", "style", "extra", "getHeight"], BodyLine = /* @__PURE__ */ React.forwardRef(function(props, ref) {
  var data = props.data, index2 = props.index, className = props.className, rowKey = props.rowKey, style2 = props.style, extra = props.extra, getHeight = props.getHeight, restProps = _objectWithoutProperties(props, _excluded$4), record = data.record, indent = data.indent, renderIndex = data.index, _useContext = useContext(TableContext, ["prefixCls", "flattenColumns", "fixColumn", "componentWidth", "scrollX"]), scrollX = _useContext.scrollX, flattenColumns = _useContext.flattenColumns, prefixCls = _useContext.prefixCls, fixColumn = _useContext.fixColumn, componentWidth = _useContext.componentWidth, _useContext2 = useContext(StaticContext, ["getComponent"]), getComponent = _useContext2.getComponent, rowInfo = useRowInfo(record, rowKey, index2, indent), RowComponent = getComponent(["body", "row"], "div"), cellComponent = getComponent(["body", "cell"], "div"), rowSupportExpand = rowInfo.rowSupportExpand, expanded = rowInfo.expanded, rowProps = rowInfo.rowProps, expandedRowRender = rowInfo.expandedRowRender, expandedRowClassName = rowInfo.expandedRowClassName, expandRowNode;
  if (rowSupportExpand && expanded) {
    var expandContent = expandedRowRender(record, index2, indent + 1, expanded), expandedClsName = computedExpandedClassName(expandedRowClassName, record, index2, indent), additionalProps = {};
    fixColumn && (additionalProps = {
      style: _defineProperty$2({}, "--virtual-width", "".concat(componentWidth, "px"))
    });
    var rowCellCls = "".concat(prefixCls, "-expanded-row-cell");
    expandRowNode = /* @__PURE__ */ React.createElement(RowComponent, {
      className: cn("".concat(prefixCls, "-expanded-row"), "".concat(prefixCls, "-expanded-row-level-").concat(indent + 1), expandedClsName)
    }, /* @__PURE__ */ React.createElement(Cell$1, {
      component: cellComponent,
      prefixCls,
      className: cn(rowCellCls, _defineProperty$2({}, "".concat(rowCellCls, "-fixed"), fixColumn)),
      additionalProps
    }, expandContent));
  }
  var rowStyle = _objectSpread2$1(_objectSpread2$1({}, style2), {}, {
    width: scrollX
  });
  extra && (rowStyle.position = "absolute", rowStyle.pointerEvents = "none");
  var rowNode = /* @__PURE__ */ React.createElement(RowComponent, _extends({}, rowProps, restProps, {
    "data-row-key": rowKey,
    ref: rowSupportExpand ? null : ref,
    className: cn(className, "".concat(prefixCls, "-row"), rowProps == null ? void 0 : rowProps.className, _defineProperty$2({}, "".concat(prefixCls, "-row-extra"), extra)),
    style: _objectSpread2$1(_objectSpread2$1({}, rowStyle), rowProps == null ? void 0 : rowProps.style)
  }), flattenColumns.map(function(column2, colIndex) {
    return /* @__PURE__ */ React.createElement(VirtualCell, {
      key: colIndex,
      component: cellComponent,
      rowInfo,
      column: column2,
      colIndex,
      indent,
      index: index2,
      renderIndex,
      record,
      inverse: extra,
      getHeight
    });
  }));
  return rowSupportExpand ? /* @__PURE__ */ React.createElement("div", {
    ref
  }, rowNode, expandRowNode) : rowNode;
}), ResponseBodyLine = responseImmutable(BodyLine);
process.env.NODE_ENV !== "production" && (ResponseBodyLine.displayName = "BodyLine");
var Grid = /* @__PURE__ */ React.forwardRef(function(props, ref) {
  var data = props.data, onScroll = props.onScroll, _useContext = useContext(TableContext, ["flattenColumns", "onColumnResize", "getRowKey", "prefixCls", "expandedKeys", "childrenColumnName", "scrollX", "direction"]), flattenColumns = _useContext.flattenColumns, onColumnResize = _useContext.onColumnResize, getRowKey = _useContext.getRowKey, expandedKeys = _useContext.expandedKeys, prefixCls = _useContext.prefixCls, childrenColumnName = _useContext.childrenColumnName, scrollX = _useContext.scrollX, direction = _useContext.direction, _useContext2 = useContext(StaticContext), sticky = _useContext2.sticky, scrollY = _useContext2.scrollY, listItemHeight = _useContext2.listItemHeight, getComponent = _useContext2.getComponent, onTablePropScroll = _useContext2.onScroll, listRef = React.useRef(), flattenData2 = useFlattenRecords(data, childrenColumnName, expandedKeys, getRowKey), columnsWidth = React.useMemo(function() {
    var total = 0;
    return flattenColumns.map(function(_ref) {
      var width = _ref.width, key = _ref.key;
      return total += width, [key, width, total];
    });
  }, [flattenColumns]), columnsOffset = React.useMemo(function() {
    return columnsWidth.map(function(colWidth) {
      return colWidth[2];
    });
  }, [columnsWidth]);
  React.useEffect(function() {
    columnsWidth.forEach(function(_ref2) {
      var _ref3 = _slicedToArray(_ref2, 2), key = _ref3[0], width = _ref3[1];
      onColumnResize(key, width);
    });
  }, [columnsWidth]), React.useImperativeHandle(ref, function() {
    var _listRef$current2, obj = {
      scrollTo: /* @__PURE__ */ __name(function(config) {
        var _listRef$current;
        (_listRef$current = listRef.current) === null || _listRef$current === void 0 || _listRef$current.scrollTo(config);
      }, "scrollTo"),
      nativeElement: (_listRef$current2 = listRef.current) === null || _listRef$current2 === void 0 ? void 0 : _listRef$current2.nativeElement
    };
    return Object.defineProperty(obj, "scrollLeft", {
      get: /* @__PURE__ */ __name(function() {
        var _listRef$current3;
        return ((_listRef$current3 = listRef.current) === null || _listRef$current3 === void 0 ? void 0 : _listRef$current3.getScrollInfo().x) || 0;
      }, "get"),
      set: /* @__PURE__ */ __name(function(value) {
        var _listRef$current4;
        (_listRef$current4 = listRef.current) === null || _listRef$current4 === void 0 || _listRef$current4.scrollTo({
          left: value
        });
      }, "set")
    }), obj;
  });
  var getRowSpan = /* @__PURE__ */ __name(function(column2, index2) {
    var _flattenData$index, record = (_flattenData$index = flattenData2[index2]) === null || _flattenData$index === void 0 ? void 0 : _flattenData$index.record, onCell = column2.onCell;
    if (onCell) {
      var _cellProps$rowSpan, cellProps = onCell(record, index2);
      return (_cellProps$rowSpan = cellProps == null ? void 0 : cellProps.rowSpan) !== null && _cellProps$rowSpan !== void 0 ? _cellProps$rowSpan : 1;
    }
    return 1;
  }, "getRowSpan"), extraRender = /* @__PURE__ */ __name(function(info) {
    var start = info.start, end = info.end, getSize3 = info.getSize, offsetY = info.offsetY;
    if (end < 0)
      return null;
    for (var firstRowSpanColumns = flattenColumns.filter(
      // rowSpan is 0
      function(column2) {
        return getRowSpan(column2, start) === 0;
      }
    ), startIndex = start, _loop = /* @__PURE__ */ __name(function(i2) {
      if (firstRowSpanColumns = firstRowSpanColumns.filter(function(column2) {
        return getRowSpan(column2, i2) === 0;
      }), !firstRowSpanColumns.length)
        return startIndex = i2, 1;
    }, "_loop"), i = start; i >= 0 && !_loop(i); i -= 1)
      ;
    for (var lastRowSpanColumns = flattenColumns.filter(
      // rowSpan is not 1
      function(column2) {
        return getRowSpan(column2, end) !== 1;
      }
    ), endIndex = end, _loop2 = /* @__PURE__ */ __name(function(_i3) {
      if (lastRowSpanColumns = lastRowSpanColumns.filter(function(column2) {
        return getRowSpan(column2, _i3) !== 1;
      }), !lastRowSpanColumns.length)
        return endIndex = Math.max(_i3 - 1, end), 1;
    }, "_loop2"), _i = end; _i < flattenData2.length && !_loop2(_i); _i += 1)
      ;
    for (var spanLines = [], _loop3 = /* @__PURE__ */ __name(function(_i22) {
      var item = flattenData2[_i22];
      if (!item)
        return 1;
      flattenColumns.some(function(column2) {
        return getRowSpan(column2, _i22) > 1;
      }) && spanLines.push(_i22);
    }, "_loop3"), _i2 = startIndex; _i2 <= endIndex; _i2 += 1)
      _loop3(_i2);
    var nodes = spanLines.map(function(index2) {
      var item = flattenData2[index2], rowKey = getRowKey(item.record, index2), getHeight = /* @__PURE__ */ __name(function(rowSpan) {
        var endItemIndex = index2 + rowSpan - 1, endItemKey = getRowKey(flattenData2[endItemIndex].record, endItemIndex), sizeInfo2 = getSize3(rowKey, endItemKey);
        return sizeInfo2.bottom - sizeInfo2.top;
      }, "getHeight"), sizeInfo = getSize3(rowKey);
      return /* @__PURE__ */ React.createElement(ResponseBodyLine, {
        key: index2,
        data: item,
        rowKey,
        index: index2,
        style: {
          top: -offsetY + sizeInfo.top
        },
        extra: !0,
        getHeight
      });
    });
    return nodes;
  }, "extraRender"), gridContext = React.useMemo(function() {
    return {
      columnsOffset
    };
  }, [columnsOffset]), tblPrefixCls = "".concat(prefixCls, "-tbody"), wrapperComponent = getComponent(["body", "wrapper"]), horizontalScrollBarStyle = {};
  return sticky && (horizontalScrollBarStyle.position = "sticky", horizontalScrollBarStyle.bottom = 0, _typeof$4(sticky) === "object" && sticky.offsetScroll && (horizontalScrollBarStyle.bottom = sticky.offsetScroll)), /* @__PURE__ */ React.createElement(GridContext.Provider, {
    value: gridContext
  }, /* @__PURE__ */ React.createElement(List, {
    fullHeight: !1,
    ref: listRef,
    prefixCls: "".concat(tblPrefixCls, "-virtual"),
    styles: {
      horizontalScrollBar: horizontalScrollBarStyle
    },
    className: tblPrefixCls,
    height: scrollY,
    itemHeight: listItemHeight || 24,
    data: flattenData2,
    itemKey: /* @__PURE__ */ __name(function(item) {
      return getRowKey(item.record);
    }, "itemKey"),
    component: wrapperComponent,
    scrollWidth: scrollX,
    direction,
    onVirtualScroll: /* @__PURE__ */ __name(function(_ref4) {
      var _listRef$current5, x = _ref4.x;
      onScroll({
        currentTarget: (_listRef$current5 = listRef.current) === null || _listRef$current5 === void 0 ? void 0 : _listRef$current5.nativeElement,
        scrollLeft: x
      });
    }, "onVirtualScroll"),
    onScroll: onTablePropScroll,
    extraRender
  }, function(item, index2, itemProps) {
    var rowKey = getRowKey(item.record, index2);
    return /* @__PURE__ */ React.createElement(ResponseBodyLine, {
      data: item,
      rowKey,
      index: index2,
      style: itemProps.style
    });
  }));
}), ResponseGrid = responseImmutable(Grid);
process.env.NODE_ENV !== "production" && (ResponseGrid.displayName = "ResponseGrid");
var renderBody = /* @__PURE__ */ __name(function(rawData, props) {
  var ref = props.ref, onScroll = props.onScroll;
  return /* @__PURE__ */ React.createElement(ResponseGrid, {
    ref,
    data: rawData,
    onScroll
  });
}, "renderBody");
function VirtualTable(props, ref) {
  var data = props.data, columns = props.columns, scroll = props.scroll, sticky = props.sticky, _props$prefixCls = props.prefixCls, prefixCls = _props$prefixCls === void 0 ? DEFAULT_PREFIX : _props$prefixCls, className = props.className, listItemHeight = props.listItemHeight, components2 = props.components, onScroll = props.onScroll, _ref = scroll || {}, scrollX = _ref.x, scrollY = _ref.y;
  typeof scrollX != "number" && (process.env.NODE_ENV !== "production" && warningOnce(!scrollX, "`scroll.x` in virtual table must be number."), scrollX = 1), typeof scrollY != "number" && (scrollY = 500, process.env.NODE_ENV !== "production" && warningOnce(!1, "`scroll.y` in virtual table must be number."));
  var getComponent = useEvent(function(path2, defaultComponent) {
    return get(components2, path2) || defaultComponent;
  }), onInternalScroll = useEvent(onScroll), context = React.useMemo(function() {
    return {
      sticky,
      scrollY,
      listItemHeight,
      getComponent,
      onScroll: onInternalScroll
    };
  }, [sticky, scrollY, listItemHeight, getComponent, onInternalScroll]);
  return /* @__PURE__ */ React.createElement(StaticContext.Provider, {
    value: context
  }, /* @__PURE__ */ React.createElement(ImmutableTable, _extends({}, props, {
    className: cn(className, "".concat(prefixCls, "-virtual")),
    scroll: _objectSpread2$1(_objectSpread2$1({}, scroll), {}, {
      x: scrollX
    }),
    components: _objectSpread2$1(_objectSpread2$1({}, components2), {}, {
      // fix https://github.com/ant-design/ant-design/issues/48991
      body: data != null && data.length ? renderBody : void 0
    }),
    columns,
    internalHooks: INTERNAL_HOOKS,
    tailor: !0,
    ref
  })));
}
__name(VirtualTable, "VirtualTable");
var RefVirtualTable = /* @__PURE__ */ React.forwardRef(VirtualTable);
process.env.NODE_ENV !== "production" && (RefVirtualTable.displayName = "VirtualTable");
function genVirtualTable(shouldTriggerRender) {
  return makeImmutable(RefVirtualTable, shouldTriggerRender);
}
__name(genVirtualTable, "genVirtualTable");
genVirtualTable();
const Column = /* @__PURE__ */ __name((_2) => null, "Column"), ColumnGroup = /* @__PURE__ */ __name((_2) => null, "ColumnGroup");
var TreeContext = /* @__PURE__ */ React.createContext(null), Indent = /* @__PURE__ */ __name(function(_ref) {
  for (var prefixCls = _ref.prefixCls, level = _ref.level, isStart = _ref.isStart, isEnd = _ref.isEnd, baseClassName = "".concat(prefixCls, "-indent-unit"), list = [], i = 0; i < level; i += 1)
    list.push(/* @__PURE__ */ React.createElement("span", {
      key: i,
      className: cn(baseClassName, _defineProperty$2(_defineProperty$2({}, "".concat(baseClassName, "-start"), isStart[i]), "".concat(baseClassName, "-end"), isEnd[i]))
    }));
  return /* @__PURE__ */ React.createElement("span", {
    "aria-hidden": "true",
    className: "".concat(prefixCls, "-indent")
  }, list);
}, "Indent");
const Indent$1 = /* @__PURE__ */ React.memo(Indent);
var _excluded$3 = ["eventKey", "className", "style", "dragOver", "dragOverGapTop", "dragOverGapBottom", "isLeaf", "isStart", "isEnd", "expanded", "selected", "checked", "halfChecked", "loading", "domRef", "active", "data", "onMouseMove", "selectable"], ICON_OPEN = "open", ICON_CLOSE = "close", defaultTitle = "---", InternalTreeNode = /* @__PURE__ */ function(_React$Component) {
  _inherits(InternalTreeNode2, _React$Component);
  var _super = _createSuper(InternalTreeNode2);
  function InternalTreeNode2() {
    var _this;
    _classCallCheck$1(this, InternalTreeNode2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++)
      args[_key] = arguments[_key];
    return _this = _super.call.apply(_super, [this].concat(args)), _defineProperty$2(_assertThisInitialized(_this), "state", {
      dragNodeHighlight: !1
    }), _defineProperty$2(_assertThisInitialized(_this), "selectHandle", void 0), _defineProperty$2(_assertThisInitialized(_this), "cacheIndent", void 0), _defineProperty$2(_assertThisInitialized(_this), "onSelectorClick", function(e2) {
      var onNodeClick = _this.props.context.onNodeClick;
      onNodeClick(e2, convertNodePropsToEventData(_this.props)), _this.isSelectable() ? _this.onSelect(e2) : _this.onCheck(e2);
    }), _defineProperty$2(_assertThisInitialized(_this), "onSelectorDoubleClick", function(e2) {
      var onNodeDoubleClick = _this.props.context.onNodeDoubleClick;
      onNodeDoubleClick(e2, convertNodePropsToEventData(_this.props));
    }), _defineProperty$2(_assertThisInitialized(_this), "onSelect", function(e2) {
      if (!_this.isDisabled()) {
        var onNodeSelect = _this.props.context.onNodeSelect;
        onNodeSelect(e2, convertNodePropsToEventData(_this.props));
      }
    }), _defineProperty$2(_assertThisInitialized(_this), "onCheck", function(e2) {
      if (!_this.isDisabled()) {
        var _this$props = _this.props, disableCheckbox = _this$props.disableCheckbox, checked = _this$props.checked, onNodeCheck = _this.props.context.onNodeCheck;
        if (!(!_this.isCheckable() || disableCheckbox)) {
          var targetChecked = !checked;
          onNodeCheck(e2, convertNodePropsToEventData(_this.props), targetChecked);
        }
      }
    }), _defineProperty$2(_assertThisInitialized(_this), "onMouseEnter", function(e2) {
      var onNodeMouseEnter = _this.props.context.onNodeMouseEnter;
      onNodeMouseEnter(e2, convertNodePropsToEventData(_this.props));
    }), _defineProperty$2(_assertThisInitialized(_this), "onMouseLeave", function(e2) {
      var onNodeMouseLeave = _this.props.context.onNodeMouseLeave;
      onNodeMouseLeave(e2, convertNodePropsToEventData(_this.props));
    }), _defineProperty$2(_assertThisInitialized(_this), "onContextMenu", function(e2) {
      var onNodeContextMenu = _this.props.context.onNodeContextMenu;
      onNodeContextMenu(e2, convertNodePropsToEventData(_this.props));
    }), _defineProperty$2(_assertThisInitialized(_this), "onDragStart", function(e2) {
      var onNodeDragStart = _this.props.context.onNodeDragStart;
      e2.stopPropagation(), _this.setState({
        dragNodeHighlight: !0
      }), onNodeDragStart(e2, _assertThisInitialized(_this));
      try {
        e2.dataTransfer.setData("text/plain", "");
      } catch {
      }
    }), _defineProperty$2(_assertThisInitialized(_this), "onDragEnter", function(e2) {
      var onNodeDragEnter = _this.props.context.onNodeDragEnter;
      e2.preventDefault(), e2.stopPropagation(), onNodeDragEnter(e2, _assertThisInitialized(_this));
    }), _defineProperty$2(_assertThisInitialized(_this), "onDragOver", function(e2) {
      var onNodeDragOver = _this.props.context.onNodeDragOver;
      e2.preventDefault(), e2.stopPropagation(), onNodeDragOver(e2, _assertThisInitialized(_this));
    }), _defineProperty$2(_assertThisInitialized(_this), "onDragLeave", function(e2) {
      var onNodeDragLeave = _this.props.context.onNodeDragLeave;
      e2.stopPropagation(), onNodeDragLeave(e2, _assertThisInitialized(_this));
    }), _defineProperty$2(_assertThisInitialized(_this), "onDragEnd", function(e2) {
      var onNodeDragEnd = _this.props.context.onNodeDragEnd;
      e2.stopPropagation(), _this.setState({
        dragNodeHighlight: !1
      }), onNodeDragEnd(e2, _assertThisInitialized(_this));
    }), _defineProperty$2(_assertThisInitialized(_this), "onDrop", function(e2) {
      var onNodeDrop = _this.props.context.onNodeDrop;
      e2.preventDefault(), e2.stopPropagation(), _this.setState({
        dragNodeHighlight: !1
      }), onNodeDrop(e2, _assertThisInitialized(_this));
    }), _defineProperty$2(_assertThisInitialized(_this), "onExpand", function(e2) {
      var _this$props2 = _this.props, loading = _this$props2.loading, onNodeExpand = _this$props2.context.onNodeExpand;
      loading || onNodeExpand(e2, convertNodePropsToEventData(_this.props));
    }), _defineProperty$2(_assertThisInitialized(_this), "setSelectHandle", function(node2) {
      _this.selectHandle = node2;
    }), _defineProperty$2(_assertThisInitialized(_this), "getNodeState", function() {
      var expanded = _this.props.expanded;
      return _this.isLeaf() ? null : expanded ? ICON_OPEN : ICON_CLOSE;
    }), _defineProperty$2(_assertThisInitialized(_this), "hasChildren", function() {
      var eventKey = _this.props.eventKey, keyEntities = _this.props.context.keyEntities, _ref = getEntity(keyEntities, eventKey) || {}, children = _ref.children;
      return !!(children || []).length;
    }), _defineProperty$2(_assertThisInitialized(_this), "isLeaf", function() {
      var _this$props3 = _this.props, isLeaf = _this$props3.isLeaf, loaded = _this$props3.loaded, loadData = _this.props.context.loadData, hasChildren = _this.hasChildren();
      return isLeaf === !1 ? !1 : isLeaf || !loadData && !hasChildren || loadData && loaded && !hasChildren;
    }), _defineProperty$2(_assertThisInitialized(_this), "isDisabled", function() {
      var disabled = _this.props.disabled, treeDisabled = _this.props.context.disabled;
      return !!(treeDisabled || disabled);
    }), _defineProperty$2(_assertThisInitialized(_this), "isCheckable", function() {
      var checkable = _this.props.checkable, treeCheckable = _this.props.context.checkable;
      return !treeCheckable || checkable === !1 ? !1 : treeCheckable;
    }), _defineProperty$2(_assertThisInitialized(_this), "syncLoadData", function(props) {
      var expanded = props.expanded, loading = props.loading, loaded = props.loaded, _this$props$context = _this.props.context, loadData = _this$props$context.loadData, onNodeLoad = _this$props$context.onNodeLoad;
      loading || loadData && expanded && !_this.isLeaf() && !loaded && onNodeLoad(convertNodePropsToEventData(_this.props));
    }), _defineProperty$2(_assertThisInitialized(_this), "isDraggable", function() {
      var _this$props4 = _this.props, data = _this$props4.data, draggable = _this$props4.context.draggable;
      return !!(draggable && (!draggable.nodeDraggable || draggable.nodeDraggable(data)));
    }), _defineProperty$2(_assertThisInitialized(_this), "renderDragHandler", function() {
      var _this$props$context2 = _this.props.context, draggable = _this$props$context2.draggable, prefixCls = _this$props$context2.prefixCls;
      return draggable != null && draggable.icon ? /* @__PURE__ */ React.createElement("span", {
        className: "".concat(prefixCls, "-draggable-icon")
      }, draggable.icon) : null;
    }), _defineProperty$2(_assertThisInitialized(_this), "renderSwitcherIconDom", function(isLeaf) {
      var switcherIconFromProps = _this.props.switcherIcon, switcherIconFromCtx = _this.props.context.switcherIcon, switcherIcon = switcherIconFromProps || switcherIconFromCtx;
      return typeof switcherIcon == "function" ? switcherIcon(_objectSpread2$1(_objectSpread2$1({}, _this.props), {}, {
        isLeaf
      })) : switcherIcon;
    }), _defineProperty$2(_assertThisInitialized(_this), "renderSwitcher", function() {
      var expanded = _this.props.expanded, prefixCls = _this.props.context.prefixCls;
      if (_this.isLeaf()) {
        var _switcherIconDom = _this.renderSwitcherIconDom(!0);
        return _switcherIconDom !== !1 ? /* @__PURE__ */ React.createElement("span", {
          className: cn("".concat(prefixCls, "-switcher"), "".concat(prefixCls, "-switcher-noop"))
        }, _switcherIconDom) : null;
      }
      var switcherCls = cn("".concat(prefixCls, "-switcher"), "".concat(prefixCls, "-switcher_").concat(expanded ? ICON_OPEN : ICON_CLOSE)), switcherIconDom = _this.renderSwitcherIconDom(!1);
      return switcherIconDom !== !1 ? /* @__PURE__ */ React.createElement("span", {
        onClick: _this.onExpand,
        className: switcherCls
      }, switcherIconDom) : null;
    }), _defineProperty$2(_assertThisInitialized(_this), "renderCheckbox", function() {
      var _this$props5 = _this.props, checked = _this$props5.checked, halfChecked = _this$props5.halfChecked, disableCheckbox = _this$props5.disableCheckbox, prefixCls = _this.props.context.prefixCls, disabled = _this.isDisabled(), checkable = _this.isCheckable();
      if (!checkable) return null;
      var $custom = typeof checkable != "boolean" ? checkable : null;
      return /* @__PURE__ */ React.createElement("span", {
        className: cn("".concat(prefixCls, "-checkbox"), checked && "".concat(prefixCls, "-checkbox-checked"), !checked && halfChecked && "".concat(prefixCls, "-checkbox-indeterminate"), (disabled || disableCheckbox) && "".concat(prefixCls, "-checkbox-disabled")),
        onClick: _this.onCheck
      }, $custom);
    }), _defineProperty$2(_assertThisInitialized(_this), "renderIcon", function() {
      var loading = _this.props.loading, prefixCls = _this.props.context.prefixCls;
      return /* @__PURE__ */ React.createElement("span", {
        className: cn("".concat(prefixCls, "-iconEle"), "".concat(prefixCls, "-icon__").concat(_this.getNodeState() || "docu"), loading && "".concat(prefixCls, "-icon_loading"))
      });
    }), _defineProperty$2(_assertThisInitialized(_this), "renderSelector", function() {
      var dragNodeHighlight = _this.state.dragNodeHighlight, _this$props6 = _this.props, _this$props6$title = _this$props6.title, title2 = _this$props6$title === void 0 ? defaultTitle : _this$props6$title, selected = _this$props6.selected, icon = _this$props6.icon, loading = _this$props6.loading, data = _this$props6.data, _this$props$context3 = _this.props.context, prefixCls = _this$props$context3.prefixCls, showIcon = _this$props$context3.showIcon, treeIcon = _this$props$context3.icon, loadData = _this$props$context3.loadData, titleRender = _this$props$context3.titleRender, disabled = _this.isDisabled(), wrapClass = "".concat(prefixCls, "-node-content-wrapper"), $icon;
      if (showIcon) {
        var currentIcon = icon || treeIcon;
        $icon = currentIcon ? /* @__PURE__ */ React.createElement("span", {
          className: cn("".concat(prefixCls, "-iconEle"), "".concat(prefixCls, "-icon__customize"))
        }, typeof currentIcon == "function" ? currentIcon(_this.props) : currentIcon) : _this.renderIcon();
      } else loadData && loading && ($icon = _this.renderIcon());
      var titleNode;
      typeof title2 == "function" ? titleNode = title2(data) : titleRender ? titleNode = titleRender(data) : titleNode = title2;
      var $title = /* @__PURE__ */ React.createElement("span", {
        className: "".concat(prefixCls, "-title")
      }, titleNode);
      return /* @__PURE__ */ React.createElement("span", {
        ref: _this.setSelectHandle,
        title: typeof title2 == "string" ? title2 : "",
        className: cn("".concat(wrapClass), "".concat(wrapClass, "-").concat(_this.getNodeState() || "normal"), !disabled && (selected || dragNodeHighlight) && "".concat(prefixCls, "-node-selected")),
        onMouseEnter: _this.onMouseEnter,
        onMouseLeave: _this.onMouseLeave,
        onContextMenu: _this.onContextMenu,
        onClick: _this.onSelectorClick,
        onDoubleClick: _this.onSelectorDoubleClick
      }, $icon, $title, _this.renderDropIndicator());
    }), _defineProperty$2(_assertThisInitialized(_this), "renderDropIndicator", function() {
      var _this$props7 = _this.props, disabled = _this$props7.disabled, eventKey = _this$props7.eventKey, _this$props$context4 = _this.props.context, draggable = _this$props$context4.draggable, dropLevelOffset = _this$props$context4.dropLevelOffset, dropPosition = _this$props$context4.dropPosition, prefixCls = _this$props$context4.prefixCls, indent = _this$props$context4.indent, dropIndicatorRender2 = _this$props$context4.dropIndicatorRender, dragOverNodeKey = _this$props$context4.dragOverNodeKey, direction = _this$props$context4.direction, rootDraggable = !!draggable, showIndicator = !disabled && rootDraggable && dragOverNodeKey === eventKey, mergedIndent = indent ?? _this.cacheIndent;
      return _this.cacheIndent = indent, showIndicator ? dropIndicatorRender2({
        dropPosition,
        dropLevelOffset,
        indent: mergedIndent,
        prefixCls,
        direction
      }) : null;
    }), _this;
  }
  return __name(InternalTreeNode2, "InternalTreeNode"), _createClass$1(InternalTreeNode2, [{
    key: "componentDidMount",
    value: (
      // Isomorphic needn't load data in server side
      /* @__PURE__ */ __name(function() {
        this.syncLoadData(this.props);
      }, "componentDidMount")
    )
  }, {
    key: "componentDidUpdate",
    value: /* @__PURE__ */ __name(function() {
      this.syncLoadData(this.props);
    }, "componentDidUpdate")
  }, {
    key: "isSelectable",
    value: /* @__PURE__ */ __name(function() {
      var selectable = this.props.selectable, treeSelectable = this.props.context.selectable;
      return typeof selectable == "boolean" ? selectable : treeSelectable;
    }, "isSelectable")
  }, {
    key: "render",
    value: (
      // =========================== Render ===========================
      /* @__PURE__ */ __name(function() {
        var _classNames, _this$props8 = this.props, eventKey = _this$props8.eventKey, className = _this$props8.className, style2 = _this$props8.style, dragOver = _this$props8.dragOver, dragOverGapTop = _this$props8.dragOverGapTop, dragOverGapBottom = _this$props8.dragOverGapBottom, isLeaf = _this$props8.isLeaf, isStart = _this$props8.isStart, isEnd = _this$props8.isEnd, expanded = _this$props8.expanded, selected = _this$props8.selected, checked = _this$props8.checked, halfChecked = _this$props8.halfChecked, loading = _this$props8.loading, domRef = _this$props8.domRef, active = _this$props8.active;
        _this$props8.data;
        var onMouseMove = _this$props8.onMouseMove, selectable = _this$props8.selectable, otherProps = _objectWithoutProperties(_this$props8, _excluded$3), _this$props$context5 = this.props.context, prefixCls = _this$props$context5.prefixCls, filterTreeNode = _this$props$context5.filterTreeNode, keyEntities = _this$props$context5.keyEntities, dropContainerKey = _this$props$context5.dropContainerKey, dropTargetKey = _this$props$context5.dropTargetKey, draggingNodeKey = _this$props$context5.draggingNodeKey, disabled = this.isDisabled(), dataOrAriaAttributeProps = pickAttrs(otherProps, {
          aria: !0,
          data: !0
        }), _ref2 = getEntity(keyEntities, eventKey) || {}, level = _ref2.level, isEndNode = isEnd[isEnd.length - 1], mergedDraggable = this.isDraggable(), draggableWithoutDisabled = !disabled && mergedDraggable, dragging = draggingNodeKey === eventKey, ariaSelected = selectable !== void 0 ? {
          "aria-selected": !!selectable
        } : void 0;
        return /* @__PURE__ */ React.createElement("div", _extends({
          ref: domRef,
          className: cn(className, "".concat(prefixCls, "-treenode"), (_classNames = {}, _defineProperty$2(_defineProperty$2(_defineProperty$2(_defineProperty$2(_defineProperty$2(_defineProperty$2(_defineProperty$2(_defineProperty$2(_defineProperty$2(_defineProperty$2(_classNames, "".concat(prefixCls, "-treenode-disabled"), disabled), "".concat(prefixCls, "-treenode-switcher-").concat(expanded ? "open" : "close"), !isLeaf), "".concat(prefixCls, "-treenode-checkbox-checked"), checked), "".concat(prefixCls, "-treenode-checkbox-indeterminate"), halfChecked), "".concat(prefixCls, "-treenode-selected"), selected), "".concat(prefixCls, "-treenode-loading"), loading), "".concat(prefixCls, "-treenode-active"), active), "".concat(prefixCls, "-treenode-leaf-last"), isEndNode), "".concat(prefixCls, "-treenode-draggable"), mergedDraggable), "dragging", dragging), _defineProperty$2(_defineProperty$2(_defineProperty$2(_defineProperty$2(_defineProperty$2(_defineProperty$2(_classNames, "drop-target", dropTargetKey === eventKey), "drop-container", dropContainerKey === eventKey), "drag-over", !disabled && dragOver), "drag-over-gap-top", !disabled && dragOverGapTop), "drag-over-gap-bottom", !disabled && dragOverGapBottom), "filter-node", filterTreeNode && filterTreeNode(convertNodePropsToEventData(this.props))))),
          style: style2,
          draggable: draggableWithoutDisabled,
          "aria-grabbed": dragging,
          onDragStart: draggableWithoutDisabled ? this.onDragStart : void 0,
          onDragEnter: mergedDraggable ? this.onDragEnter : void 0,
          onDragOver: mergedDraggable ? this.onDragOver : void 0,
          onDragLeave: mergedDraggable ? this.onDragLeave : void 0,
          onDrop: mergedDraggable ? this.onDrop : void 0,
          onDragEnd: mergedDraggable ? this.onDragEnd : void 0,
          onMouseMove
        }, ariaSelected, dataOrAriaAttributeProps), /* @__PURE__ */ React.createElement(Indent$1, {
          prefixCls,
          level,
          isStart,
          isEnd
        }), this.renderDragHandler(), this.renderSwitcher(), this.renderCheckbox(), this.renderSelector());
      }, "render")
    )
  }]), InternalTreeNode2;
}(React.Component), ContextTreeNode = /* @__PURE__ */ __name(function(props) {
  return /* @__PURE__ */ React.createElement(TreeContext.Consumer, null, function(context) {
    return /* @__PURE__ */ React.createElement(InternalTreeNode, _extends({}, props, {
      context
    }));
  });
}, "ContextTreeNode");
ContextTreeNode.displayName = "TreeNode";
ContextTreeNode.isTreeNode = 1;
function arrDel(list, value) {
  if (!list) return [];
  var clone = list.slice(), index2 = clone.indexOf(value);
  return index2 >= 0 && clone.splice(index2, 1), clone;
}
__name(arrDel, "arrDel");
function arrAdd(list, value) {
  var clone = (list || []).slice();
  return clone.indexOf(value) === -1 && clone.push(value), clone;
}
__name(arrAdd, "arrAdd");
function posToArr(pos) {
  return pos.split("-");
}
__name(posToArr, "posToArr");
function getDragChildrenKeys(dragNodeKey, keyEntities) {
  var dragChildrenKeys = [], entity = getEntity(keyEntities, dragNodeKey);
  function dig() {
    var list = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
    list.forEach(function(_ref) {
      var key = _ref.key, children = _ref.children;
      dragChildrenKeys.push(key), dig(children);
    });
  }
  return __name(dig, "dig"), dig(entity.children), dragChildrenKeys;
}
__name(getDragChildrenKeys, "getDragChildrenKeys");
function isLastChild(treeNodeEntity) {
  if (treeNodeEntity.parent) {
    var posArr = posToArr(treeNodeEntity.pos);
    return Number(posArr[posArr.length - 1]) === treeNodeEntity.parent.children.length - 1;
  }
  return !1;
}
__name(isLastChild, "isLastChild");
function isFirstChild(treeNodeEntity) {
  var posArr = posToArr(treeNodeEntity.pos);
  return Number(posArr[posArr.length - 1]) === 0;
}
__name(isFirstChild, "isFirstChild");
function calcDropPosition(event, dragNode, targetNode, indent, startMousePosition, allowDrop2, flattenedNodes, keyEntities, expandKeys, direction) {
  var _abstractDropNodeEnti, clientX = event.clientX, clientY = event.clientY, _getBoundingClientRec = event.target.getBoundingClientRect(), top = _getBoundingClientRec.top, height = _getBoundingClientRec.height, horizontalMouseOffset = (direction === "rtl" ? -1 : 1) * (((startMousePosition == null ? void 0 : startMousePosition.x) || 0) - clientX), rawDropLevelOffset = (horizontalMouseOffset - 12) / indent, filteredExpandKeys = expandKeys.filter(function(key) {
    var _keyEntities$key;
    return (_keyEntities$key = keyEntities[key]) === null || _keyEntities$key === void 0 || (_keyEntities$key = _keyEntities$key.children) === null || _keyEntities$key === void 0 ? void 0 : _keyEntities$key.length;
  }), abstractDropNodeEntity = getEntity(keyEntities, targetNode.props.eventKey);
  if (clientY < top + height / 2) {
    var nodeIndex = flattenedNodes.findIndex(function(flattenedNode) {
      return flattenedNode.key === abstractDropNodeEntity.key;
    }), prevNodeIndex = nodeIndex <= 0 ? 0 : nodeIndex - 1, prevNodeKey = flattenedNodes[prevNodeIndex].key;
    abstractDropNodeEntity = getEntity(keyEntities, prevNodeKey);
  }
  var initialAbstractDropNodeKey = abstractDropNodeEntity.key, abstractDragOverEntity = abstractDropNodeEntity, dragOverNodeKey = abstractDropNodeEntity.key, dropPosition = 0, dropLevelOffset = 0;
  if (!filteredExpandKeys.includes(initialAbstractDropNodeKey))
    for (var i = 0; i < rawDropLevelOffset && isLastChild(abstractDropNodeEntity); i += 1)
      abstractDropNodeEntity = abstractDropNodeEntity.parent, dropLevelOffset += 1;
  var abstractDragDataNode = dragNode.props.data, abstractDropDataNode = abstractDropNodeEntity.node, dropAllowed = !0;
  return isFirstChild(abstractDropNodeEntity) && abstractDropNodeEntity.level === 0 && clientY < top + height / 2 && allowDrop2({
    dragNode: abstractDragDataNode,
    dropNode: abstractDropDataNode,
    dropPosition: -1
  }) && abstractDropNodeEntity.key === targetNode.props.eventKey ? dropPosition = -1 : (abstractDragOverEntity.children || []).length && filteredExpandKeys.includes(dragOverNodeKey) ? allowDrop2({
    dragNode: abstractDragDataNode,
    dropNode: abstractDropDataNode,
    dropPosition: 0
  }) ? dropPosition = 0 : dropAllowed = !1 : dropLevelOffset === 0 ? rawDropLevelOffset > -1.5 ? allowDrop2({
    dragNode: abstractDragDataNode,
    dropNode: abstractDropDataNode,
    dropPosition: 1
  }) ? dropPosition = 1 : dropAllowed = !1 : allowDrop2({
    dragNode: abstractDragDataNode,
    dropNode: abstractDropDataNode,
    dropPosition: 0
  }) ? dropPosition = 0 : allowDrop2({
    dragNode: abstractDragDataNode,
    dropNode: abstractDropDataNode,
    dropPosition: 1
  }) ? dropPosition = 1 : dropAllowed = !1 : allowDrop2({
    dragNode: abstractDragDataNode,
    dropNode: abstractDropDataNode,
    dropPosition: 1
  }) ? dropPosition = 1 : dropAllowed = !1, {
    dropPosition,
    dropLevelOffset,
    dropTargetKey: abstractDropNodeEntity.key,
    dropTargetPos: abstractDropNodeEntity.pos,
    dragOverNodeKey,
    dropContainerKey: dropPosition === 0 ? null : ((_abstractDropNodeEnti = abstractDropNodeEntity.parent) === null || _abstractDropNodeEnti === void 0 ? void 0 : _abstractDropNodeEnti.key) || null,
    dropAllowed
  };
}
__name(calcDropPosition, "calcDropPosition");
function calcSelectedKeys(selectedKeys, props) {
  if (selectedKeys) {
    var multiple = props.multiple;
    return multiple ? selectedKeys.slice() : selectedKeys.length ? [selectedKeys[0]] : selectedKeys;
  }
}
__name(calcSelectedKeys, "calcSelectedKeys");
function parseCheckedKeys(keys2) {
  if (!keys2)
    return null;
  var keyProps;
  if (Array.isArray(keys2))
    keyProps = {
      checkedKeys: keys2,
      halfCheckedKeys: void 0
    };
  else if (_typeof$4(keys2) === "object")
    keyProps = {
      checkedKeys: keys2.checked || void 0,
      halfCheckedKeys: keys2.halfChecked || void 0
    };
  else
    return warningOnce(!1, "`checkedKeys` is not an array or an object"), null;
  return keyProps;
}
__name(parseCheckedKeys, "parseCheckedKeys");
function conductExpandParent(keyList, keyEntities) {
  var expandedKeys = /* @__PURE__ */ new Set();
  function conductUp(key) {
    if (!expandedKeys.has(key)) {
      var entity = getEntity(keyEntities, key);
      if (entity) {
        expandedKeys.add(key);
        var parent = entity.parent, node2 = entity.node;
        node2.disabled || parent && conductUp(parent.key);
      }
    }
  }
  return __name(conductUp, "conductUp"), (keyList || []).forEach(function(key) {
    conductUp(key);
  }), _toConsumableArray(expandedKeys);
}
__name(conductExpandParent, "conductExpandParent");
function useMultipleSelect(getKey2) {
  const [prevSelectedIndex, setPrevSelectedIndex] = useState(null);
  return [useCallback((currentSelectedIndex, data, selectedKeys) => {
    const configPrevSelectedIndex = prevSelectedIndex ?? currentSelectedIndex, startIndex = Math.min(configPrevSelectedIndex || 0, currentSelectedIndex), endIndex = Math.max(configPrevSelectedIndex || 0, currentSelectedIndex), rangeKeys = data.slice(startIndex, endIndex + 1).map((item) => getKey2(item)), shouldSelected = rangeKeys.some((rangeKey) => !selectedKeys.has(rangeKey)), changedKeys = [];
    return rangeKeys.forEach((item) => {
      shouldSelected ? (selectedKeys.has(item) || changedKeys.push(item), selectedKeys.add(item)) : (selectedKeys.delete(item), changedKeys.push(item));
    }), setPrevSelectedIndex(shouldSelected ? endIndex : null), changedKeys;
  }, [prevSelectedIndex]), /* @__PURE__ */ __name((val) => {
    setPrevSelectedIndex(val);
  }, "updatePrevSelectedIndex")];
}
__name(useMultipleSelect, "useMultipleSelect");
const SELECTION_COLUMN = {}, SELECTION_ALL = "SELECT_ALL", SELECTION_INVERT = "SELECT_INVERT", SELECTION_NONE = "SELECT_NONE", EMPTY_LIST$1 = [], flattenData = /* @__PURE__ */ __name((childrenColumnName, data) => {
  let list = [];
  return (data || []).forEach((record) => {
    list.push(record), record && typeof record == "object" && childrenColumnName in record && (list = [].concat(_toConsumableArray(list), _toConsumableArray(flattenData(childrenColumnName, record[childrenColumnName]))));
  }), list;
}, "flattenData"), useSelection$1 = /* @__PURE__ */ __name((config, rowSelection) => {
  const {
    preserveSelectedRowKeys,
    selectedRowKeys,
    defaultSelectedRowKeys,
    getCheckboxProps,
    onChange: onSelectionChange,
    onSelect,
    onSelectAll,
    onSelectInvert,
    onSelectNone,
    onSelectMultiple,
    columnWidth: selectionColWidth,
    type: selectionType,
    selections,
    fixed,
    renderCell: customizeRenderCell,
    hideSelectAll,
    checkStrictly = !0
  } = rowSelection || {}, {
    prefixCls,
    data,
    pageData,
    getRecordByKey,
    getRowKey,
    expandType,
    childrenColumnName,
    locale: tableLocale,
    getPopupContainer
  } = config, warning3 = devUseWarning("Table"), [multipleSelect, updatePrevSelectedIndex] = useMultipleSelect((item) => item), [mergedSelectedKeys, setMergedSelectedKeys] = useMergedState(selectedRowKeys || defaultSelectedRowKeys || EMPTY_LIST$1, {
    value: selectedRowKeys
  }), preserveRecordsRef = React.useRef(/* @__PURE__ */ new Map()), updatePreserveRecordsCache = useCallback((keys2) => {
    if (preserveSelectedRowKeys) {
      const newCache = /* @__PURE__ */ new Map();
      keys2.forEach((key) => {
        let record = getRecordByKey(key);
        !record && preserveRecordsRef.current.has(key) && (record = preserveRecordsRef.current.get(key)), newCache.set(key, record);
      }), preserveRecordsRef.current = newCache;
    }
  }, [getRecordByKey, preserveSelectedRowKeys]);
  React.useEffect(() => {
    updatePreserveRecordsCache(mergedSelectedKeys);
  }, [mergedSelectedKeys]);
  const flattedData = useMemo$1(() => flattenData(childrenColumnName, pageData), [childrenColumnName, pageData]), {
    keyEntities
  } = useMemo$1(() => {
    if (checkStrictly)
      return {
        keyEntities: null
      };
    let convertData = data;
    if (preserveSelectedRowKeys) {
      const keysSet = new Set(flattedData.map((record, index2) => getRowKey(record, index2))), preserveRecords = Array.from(preserveRecordsRef.current).reduce((total, _ref) => {
        let [key, value] = _ref;
        return keysSet.has(key) ? total : total.concat(value);
      }, []);
      convertData = [].concat(_toConsumableArray(convertData), _toConsumableArray(preserveRecords));
    }
    return convertDataToEntities(convertData, {
      externalGetKey: getRowKey,
      childrenPropName: childrenColumnName
    });
  }, [data, getRowKey, checkStrictly, childrenColumnName, preserveSelectedRowKeys, flattedData]), checkboxPropsMap = useMemo$1(() => {
    const map = /* @__PURE__ */ new Map();
    return flattedData.forEach((record, index2) => {
      const key = getRowKey(record, index2), checkboxProps = (getCheckboxProps ? getCheckboxProps(record) : null) || {};
      map.set(key, checkboxProps), process.env.NODE_ENV !== "production" && warning3(!("checked" in checkboxProps || "defaultChecked" in checkboxProps), "usage", "Do not set `checked` or `defaultChecked` in `getCheckboxProps`. Please use `selectedRowKeys` instead.");
    }), map;
  }, [flattedData, getRowKey, getCheckboxProps]), isCheckboxDisabled = useCallback((r2) => {
    var _a;
    return !!(!((_a = checkboxPropsMap.get(getRowKey(r2))) === null || _a === void 0) && _a.disabled);
  }, [checkboxPropsMap, getRowKey]), [derivedSelectedKeys, derivedHalfSelectedKeys] = useMemo$1(() => {
    if (checkStrictly)
      return [mergedSelectedKeys || [], []];
    const {
      checkedKeys,
      halfCheckedKeys
    } = conductCheck(mergedSelectedKeys, !0, keyEntities, isCheckboxDisabled);
    return [checkedKeys || [], halfCheckedKeys];
  }, [mergedSelectedKeys, checkStrictly, keyEntities, isCheckboxDisabled]), derivedSelectedKeySet = useMemo$1(() => {
    const keys2 = selectionType === "radio" ? derivedSelectedKeys.slice(0, 1) : derivedSelectedKeys;
    return new Set(keys2);
  }, [derivedSelectedKeys, selectionType]), derivedHalfSelectedKeySet = useMemo$1(() => selectionType === "radio" ? /* @__PURE__ */ new Set() : new Set(derivedHalfSelectedKeys), [derivedHalfSelectedKeys, selectionType]);
  React.useEffect(() => {
    rowSelection || setMergedSelectedKeys(EMPTY_LIST$1);
  }, [!!rowSelection]);
  const setSelectedKeys = useCallback((keys2, method4) => {
    let availableKeys, records;
    updatePreserveRecordsCache(keys2), preserveSelectedRowKeys ? (availableKeys = keys2, records = keys2.map((key) => preserveRecordsRef.current.get(key))) : (availableKeys = [], records = [], keys2.forEach((key) => {
      const record = getRecordByKey(key);
      record !== void 0 && (availableKeys.push(key), records.push(record));
    })), setMergedSelectedKeys(availableKeys), onSelectionChange == null || onSelectionChange(availableKeys, records, {
      type: method4
    });
  }, [setMergedSelectedKeys, getRecordByKey, onSelectionChange, preserveSelectedRowKeys]), triggerSingleSelection = useCallback((key, selected, keys2, event) => {
    if (onSelect) {
      const rows = keys2.map((k) => getRecordByKey(k));
      onSelect(getRecordByKey(key), selected, rows, event);
    }
    setSelectedKeys(keys2, "single");
  }, [onSelect, getRecordByKey, setSelectedKeys]), mergedSelections = useMemo$1(() => !selections || hideSelectAll ? null : (selections === !0 ? [SELECTION_ALL, SELECTION_INVERT, SELECTION_NONE] : selections).map((selection) => selection === SELECTION_ALL ? {
    key: "all",
    text: tableLocale.selectionAll,
    onSelect() {
      setSelectedKeys(data.map((record, index2) => getRowKey(record, index2)).filter((key) => {
        const checkProps = checkboxPropsMap.get(key);
        return !(checkProps != null && checkProps.disabled) || derivedSelectedKeySet.has(key);
      }), "all");
    }
  } : selection === SELECTION_INVERT ? {
    key: "invert",
    text: tableLocale.selectInvert,
    onSelect() {
      const keySet = new Set(derivedSelectedKeySet);
      pageData.forEach((record, index2) => {
        const key = getRowKey(record, index2), checkProps = checkboxPropsMap.get(key);
        checkProps != null && checkProps.disabled || (keySet.has(key) ? keySet.delete(key) : keySet.add(key));
      });
      const keys2 = Array.from(keySet);
      onSelectInvert && (warning3.deprecated(!1, "onSelectInvert", "onChange"), onSelectInvert(keys2)), setSelectedKeys(keys2, "invert");
    }
  } : selection === SELECTION_NONE ? {
    key: "none",
    text: tableLocale.selectNone,
    onSelect() {
      onSelectNone == null || onSelectNone(), setSelectedKeys(Array.from(derivedSelectedKeySet).filter((key) => {
        const checkProps = checkboxPropsMap.get(key);
        return checkProps == null ? void 0 : checkProps.disabled;
      }), "none");
    }
  } : selection).map((selection) => Object.assign(Object.assign({}, selection), {
    onSelect: /* @__PURE__ */ __name(function() {
      for (var _a2, _a, _len = arguments.length, rest = new Array(_len), _key = 0; _key < _len; _key++)
        rest[_key] = arguments[_key];
      (_a = selection.onSelect) === null || _a === void 0 || (_a2 = _a).call.apply(_a2, [selection].concat(rest)), updatePrevSelectedIndex(null);
    }, "onSelect")
  })), [selections, derivedSelectedKeySet, pageData, getRowKey, onSelectInvert, setSelectedKeys]);
  return [useCallback((columns) => {
    var _a;
    if (!rowSelection)
      return process.env.NODE_ENV !== "production" && warning3(!columns.includes(SELECTION_COLUMN), "usage", "`rowSelection` is not config but `SELECTION_COLUMN` exists in the `columns`."), columns.filter((col) => col !== SELECTION_COLUMN);
    let cloneColumns = _toConsumableArray(columns);
    const keySet = new Set(derivedSelectedKeySet), recordKeys = flattedData.map(getRowKey).filter((key) => !checkboxPropsMap.get(key).disabled), checkedCurrentAll = recordKeys.every((key) => keySet.has(key)), checkedCurrentSome = recordKeys.some((key) => keySet.has(key)), onSelectAllChange = /* @__PURE__ */ __name(() => {
      const changeKeys = [];
      checkedCurrentAll ? recordKeys.forEach((key) => {
        keySet.delete(key), changeKeys.push(key);
      }) : recordKeys.forEach((key) => {
        keySet.has(key) || (keySet.add(key), changeKeys.push(key));
      });
      const keys2 = Array.from(keySet);
      onSelectAll == null || onSelectAll(!checkedCurrentAll, keys2.map((k) => getRecordByKey(k)), changeKeys.map((k) => getRecordByKey(k))), setSelectedKeys(keys2, "all"), updatePrevSelectedIndex(null);
    }, "onSelectAllChange");
    let title2, columnTitleCheckbox;
    if (selectionType !== "radio") {
      let customizeSelections;
      if (mergedSelections) {
        const menu = {
          getPopupContainer,
          items: mergedSelections.map((selection, index2) => {
            const {
              key,
              text,
              onSelect: onSelectionClick
            } = selection;
            return {
              key: key ?? index2,
              onClick: /* @__PURE__ */ __name(() => {
                onSelectionClick == null || onSelectionClick(recordKeys);
              }, "onClick"),
              label: text
            };
          })
        };
        customizeSelections = /* @__PURE__ */ React.createElement("div", {
          className: `${prefixCls}-selection-extra`
        }, /* @__PURE__ */ React.createElement(Dropdown, {
          menu,
          getPopupContainer
        }, /* @__PURE__ */ React.createElement("span", null, /* @__PURE__ */ React.createElement(RefIcon$w, null))));
      }
      const allDisabledData = flattedData.map((record, index2) => {
        const key = getRowKey(record, index2), checkboxProps = checkboxPropsMap.get(key) || {};
        return Object.assign({
          checked: keySet.has(key)
        }, checkboxProps);
      }).filter((_ref2) => {
        let {
          disabled
        } = _ref2;
        return disabled;
      }), allDisabled = !!allDisabledData.length && allDisabledData.length === flattedData.length, allDisabledAndChecked = allDisabled && allDisabledData.every((_ref3) => {
        let {
          checked
        } = _ref3;
        return checked;
      }), allDisabledSomeChecked = allDisabled && allDisabledData.some((_ref4) => {
        let {
          checked
        } = _ref4;
        return checked;
      });
      columnTitleCheckbox = /* @__PURE__ */ React.createElement(Checkbox$1, {
        checked: allDisabled ? allDisabledAndChecked : !!flattedData.length && checkedCurrentAll,
        indeterminate: allDisabled ? !allDisabledAndChecked && allDisabledSomeChecked : !checkedCurrentAll && checkedCurrentSome,
        onChange: onSelectAllChange,
        disabled: flattedData.length === 0 || allDisabled,
        "aria-label": customizeSelections ? "Custom selection" : "Select all",
        skipGroup: !0
      }), title2 = !hideSelectAll && /* @__PURE__ */ React.createElement("div", {
        className: `${prefixCls}-selection`
      }, columnTitleCheckbox, customizeSelections);
    }
    let renderCell;
    selectionType === "radio" ? renderCell = /* @__PURE__ */ __name((_2, record, index2) => {
      const key = getRowKey(record, index2), checked = keySet.has(key), checkboxProps = checkboxPropsMap.get(key);
      return {
        node: /* @__PURE__ */ React.createElement(Radio, Object.assign({}, checkboxProps, {
          checked,
          onClick: /* @__PURE__ */ __name((e2) => {
            var _a2;
            e2.stopPropagation(), (_a2 = checkboxProps == null ? void 0 : checkboxProps.onClick) === null || _a2 === void 0 || _a2.call(checkboxProps, e2);
          }, "onClick"),
          onChange: /* @__PURE__ */ __name((event) => {
            var _a2;
            keySet.has(key) || triggerSingleSelection(key, !0, [key], event.nativeEvent), (_a2 = checkboxProps == null ? void 0 : checkboxProps.onChange) === null || _a2 === void 0 || _a2.call(checkboxProps, event);
          }, "onChange")
        })),
        checked
      };
    }, "renderCell") : renderCell = /* @__PURE__ */ __name((_2, record, index2) => {
      var _a2;
      const key = getRowKey(record, index2), checked = keySet.has(key), indeterminate = derivedHalfSelectedKeySet.has(key), checkboxProps = checkboxPropsMap.get(key);
      let mergedIndeterminate;
      return expandType === "nest" ? (mergedIndeterminate = indeterminate, process.env.NODE_ENV !== "production" && warning3(typeof (checkboxProps == null ? void 0 : checkboxProps.indeterminate) != "boolean", "usage", "set `indeterminate` using `rowSelection.getCheckboxProps` is not allowed with tree structured dataSource.")) : mergedIndeterminate = (_a2 = checkboxProps == null ? void 0 : checkboxProps.indeterminate) !== null && _a2 !== void 0 ? _a2 : indeterminate, {
        node: /* @__PURE__ */ React.createElement(Checkbox$1, Object.assign({}, checkboxProps, {
          indeterminate: mergedIndeterminate,
          checked,
          skipGroup: !0,
          onClick: /* @__PURE__ */ __name((e2) => {
            var _a3;
            e2.stopPropagation(), (_a3 = checkboxProps == null ? void 0 : checkboxProps.onClick) === null || _a3 === void 0 || _a3.call(checkboxProps, e2);
          }, "onClick"),
          onChange: /* @__PURE__ */ __name((event) => {
            var _a3;
            const {
              nativeEvent
            } = event, {
              shiftKey
            } = nativeEvent, currentSelectedIndex = recordKeys.findIndex((item) => item === key), isMultiple3 = derivedSelectedKeys.some((item) => recordKeys.includes(item));
            if (shiftKey && checkStrictly && isMultiple3) {
              const changedKeys = multipleSelect(currentSelectedIndex, recordKeys, keySet), keys2 = Array.from(keySet);
              onSelectMultiple == null || onSelectMultiple(!checked, keys2.map((recordKey) => getRecordByKey(recordKey)), changedKeys.map((recordKey) => getRecordByKey(recordKey))), setSelectedKeys(keys2, "multiple");
            } else {
              const originCheckedKeys = derivedSelectedKeys;
              if (checkStrictly) {
                const checkedKeys = checked ? arrDel(originCheckedKeys, key) : arrAdd(originCheckedKeys, key);
                triggerSingleSelection(key, !checked, checkedKeys, nativeEvent);
              } else {
                const result = conductCheck([].concat(_toConsumableArray(originCheckedKeys), [key]), !0, keyEntities, isCheckboxDisabled), {
                  checkedKeys,
                  halfCheckedKeys
                } = result;
                let nextCheckedKeys = checkedKeys;
                if (checked) {
                  const tempKeySet = new Set(checkedKeys);
                  tempKeySet.delete(key), nextCheckedKeys = conductCheck(Array.from(tempKeySet), {
                    halfCheckedKeys
                  }, keyEntities, isCheckboxDisabled).checkedKeys;
                }
                triggerSingleSelection(key, !checked, nextCheckedKeys, nativeEvent);
              }
            }
            updatePrevSelectedIndex(checked ? null : currentSelectedIndex), (_a3 = checkboxProps == null ? void 0 : checkboxProps.onChange) === null || _a3 === void 0 || _a3.call(checkboxProps, event);
          }, "onChange")
        })),
        checked
      };
    }, "renderCell");
    const renderSelectionCell = /* @__PURE__ */ __name((_2, record, index2) => {
      const {
        node: node2,
        checked
      } = renderCell(_2, record, index2);
      return customizeRenderCell ? customizeRenderCell(checked, record, index2, node2) : node2;
    }, "renderSelectionCell");
    if (!cloneColumns.includes(SELECTION_COLUMN))
      if (cloneColumns.findIndex((col) => {
        var _a2;
        return ((_a2 = col[INTERNAL_COL_DEFINE]) === null || _a2 === void 0 ? void 0 : _a2.columnType) === "EXPAND_COLUMN";
      }) === 0) {
        const [expandColumn, ...restColumns] = cloneColumns;
        cloneColumns = [expandColumn, SELECTION_COLUMN].concat(_toConsumableArray(restColumns));
      } else
        cloneColumns = [SELECTION_COLUMN].concat(_toConsumableArray(cloneColumns));
    const selectionColumnIndex = cloneColumns.indexOf(SELECTION_COLUMN);
    process.env.NODE_ENV !== "production" && warning3(cloneColumns.filter((col) => col === SELECTION_COLUMN).length <= 1, "usage", "Multiple `SELECTION_COLUMN` exist in `columns`."), cloneColumns = cloneColumns.filter((column2, index2) => column2 !== SELECTION_COLUMN || index2 === selectionColumnIndex);
    const prevCol = cloneColumns[selectionColumnIndex - 1], nextCol = cloneColumns[selectionColumnIndex + 1];
    let mergedFixed = fixed;
    mergedFixed === void 0 && ((nextCol == null ? void 0 : nextCol.fixed) !== void 0 ? mergedFixed = nextCol.fixed : (prevCol == null ? void 0 : prevCol.fixed) !== void 0 && (mergedFixed = prevCol.fixed)), mergedFixed && prevCol && ((_a = prevCol[INTERNAL_COL_DEFINE]) === null || _a === void 0 ? void 0 : _a.columnType) === "EXPAND_COLUMN" && prevCol.fixed === void 0 && (prevCol.fixed = mergedFixed);
    const columnCls = cn(`${prefixCls}-selection-col`, {
      [`${prefixCls}-selection-col-with-dropdown`]: selections && selectionType === "checkbox"
    }), renderColumnTitle2 = /* @__PURE__ */ __name(() => rowSelection != null && rowSelection.columnTitle ? typeof rowSelection.columnTitle == "function" ? rowSelection.columnTitle(columnTitleCheckbox) : rowSelection.columnTitle : title2, "renderColumnTitle"), selectionColumn = {
      fixed: mergedFixed,
      width: selectionColWidth,
      className: `${prefixCls}-selection-column`,
      title: renderColumnTitle2(),
      render: renderSelectionCell,
      onCell: rowSelection.onCell,
      [INTERNAL_COL_DEFINE]: {
        className: columnCls
      }
    };
    return cloneColumns.map((col) => col === SELECTION_COLUMN ? selectionColumn : col);
  }, [getRowKey, flattedData, rowSelection, derivedSelectedKeys, derivedSelectedKeySet, derivedHalfSelectedKeySet, selectionColWidth, mergedSelections, expandType, checkboxPropsMap, onSelectMultiple, triggerSingleSelection, isCheckboxDisabled]), derivedSelectedKeySet];
}, "useSelection$1");
function fillProxy(element, handler) {
  return element._antProxy = element._antProxy || {}, Object.keys(handler).forEach((key) => {
    if (!(key in element._antProxy)) {
      const ori = element[key];
      element._antProxy[key] = ori, element[key] = handler[key];
    }
  }), element;
}
__name(fillProxy, "fillProxy");
function useProxyImperativeHandle(ref, init) {
  return useImperativeHandle(ref, () => {
    const refObj = init(), {
      nativeElement
    } = refObj;
    return typeof Proxy < "u" ? new Proxy(nativeElement, {
      get(obj, prop) {
        return refObj[prop] ? refObj[prop] : Reflect.get(obj, prop);
      }
    }) : fillProxy(nativeElement, refObj);
  });
}
__name(useProxyImperativeHandle, "useProxyImperativeHandle");
function renderExpandIcon(locale2) {
  return (props) => {
    const {
      prefixCls,
      onExpand,
      record,
      expanded,
      expandable
    } = props, iconPrefix = `${prefixCls}-row-expand-icon`;
    return /* @__PURE__ */ React.createElement("button", {
      type: "button",
      onClick: /* @__PURE__ */ __name((e2) => {
        onExpand(record, e2), e2.stopPropagation();
      }, "onClick"),
      className: cn(iconPrefix, {
        [`${iconPrefix}-spaced`]: !expandable,
        [`${iconPrefix}-expanded`]: expandable && expanded,
        [`${iconPrefix}-collapsed`]: expandable && !expanded
      }),
      "aria-label": expanded ? locale2.collapse : locale2.expand,
      "aria-expanded": expanded
    });
  };
}
__name(renderExpandIcon, "renderExpandIcon");
function useContainerWidth(prefixCls) {
  return /* @__PURE__ */ __name((ele, width) => {
    const container2 = ele.querySelector(`.${prefixCls}-container`);
    let returnWidth = width;
    if (container2) {
      const style2 = getComputedStyle(container2), borderLeft = parseInt(style2.borderLeftWidth, 10), borderRight = parseInt(style2.borderRightWidth, 10);
      returnWidth = width - borderLeft - borderRight;
    }
    return returnWidth;
  }, "getContainerWidth");
}
__name(useContainerWidth, "useContainerWidth");
const getColumnKey = /* @__PURE__ */ __name((column2, defaultKey) => "key" in column2 && column2.key !== void 0 && column2.key !== null ? column2.key : column2.dataIndex ? Array.isArray(column2.dataIndex) ? column2.dataIndex.join(".") : column2.dataIndex : defaultKey, "getColumnKey");
function getColumnPos(index2, pos) {
  return pos ? `${pos}-${index2}` : `${index2}`;
}
__name(getColumnPos, "getColumnPos");
const renderColumnTitle = /* @__PURE__ */ __name((title2, props) => typeof title2 == "function" ? title2(props) : title2, "renderColumnTitle"), safeColumnTitle = /* @__PURE__ */ __name((title2, props) => {
  const res = renderColumnTitle(title2, props);
  return Object.prototype.toString.call(res) === "[object Object]" ? "" : res;
}, "safeColumnTitle");
function useSyncState(initialValue) {
  const ref = React.useRef(initialValue), forceUpdate = useForceUpdate();
  return [() => ref.current, (newValue) => {
    ref.current = newValue, forceUpdate();
  }];
}
__name(useSyncState, "useSyncState");
function DropIndicator(_ref) {
  var dropPosition = _ref.dropPosition, dropLevelOffset = _ref.dropLevelOffset, indent = _ref.indent, style2 = {
    pointerEvents: "none",
    position: "absolute",
    right: 0,
    backgroundColor: "red",
    height: 2
  };
  switch (dropPosition) {
    case -1:
      style2.top = 0, style2.left = -dropLevelOffset * indent;
      break;
    case 1:
      style2.bottom = 0, style2.left = -dropLevelOffset * indent;
      break;
    case 0:
      style2.bottom = 0, style2.left = indent;
      break;
  }
  return /* @__PURE__ */ React.createElement("div", {
    style: style2
  });
}
__name(DropIndicator, "DropIndicator");
function _objectDestructuringEmpty(t2) {
  if (t2 == null) throw new TypeError("Cannot destructure " + t2);
}
__name(_objectDestructuringEmpty, "_objectDestructuringEmpty");
function useUnmount(triggerStart, triggerEnd) {
  var _React$useState = React.useState(!1), _React$useState2 = _slicedToArray(_React$useState, 2), firstMount = _React$useState2[0], setFirstMount = _React$useState2[1];
  useLayoutEffect$1(function() {
    if (firstMount)
      return triggerStart(), function() {
        triggerEnd();
      };
  }, [firstMount]), useLayoutEffect$1(function() {
    return setFirstMount(!0), function() {
      setFirstMount(!1);
    };
  }, []);
}
__name(useUnmount, "useUnmount");
var _excluded$2 = ["className", "style", "motion", "motionNodes", "motionType", "onMotionStart", "onMotionEnd", "active", "treeNodeRequiredProps"], MotionTreeNode = /* @__PURE__ */ __name(function(_ref, ref) {
  var className = _ref.className, style2 = _ref.style, motion2 = _ref.motion, motionNodes = _ref.motionNodes, motionType = _ref.motionType, onOriginMotionStart = _ref.onMotionStart, onOriginMotionEnd = _ref.onMotionEnd, active = _ref.active, treeNodeRequiredProps = _ref.treeNodeRequiredProps, props = _objectWithoutProperties(_ref, _excluded$2), _React$useState = React.useState(!0), _React$useState2 = _slicedToArray(_React$useState, 2), visible = _React$useState2[0], setVisible = _React$useState2[1], _React$useContext = React.useContext(TreeContext), prefixCls = _React$useContext.prefixCls, targetVisible = motionNodes && motionType !== "hide";
  useLayoutEffect$1(function() {
    motionNodes && targetVisible !== visible && setVisible(targetVisible);
  }, [motionNodes]);
  var triggerMotionStart = /* @__PURE__ */ __name(function() {
    motionNodes && onOriginMotionStart();
  }, "triggerMotionStart"), triggerMotionEndRef = React.useRef(!1), triggerMotionEnd = /* @__PURE__ */ __name(function() {
    motionNodes && !triggerMotionEndRef.current && (triggerMotionEndRef.current = !0, onOriginMotionEnd());
  }, "triggerMotionEnd");
  useUnmount(triggerMotionStart, triggerMotionEnd);
  var onVisibleChanged = /* @__PURE__ */ __name(function(nextVisible) {
    targetVisible === nextVisible && triggerMotionEnd();
  }, "onVisibleChanged");
  return motionNodes ? /* @__PURE__ */ React.createElement(CSSMotion, _extends({
    ref,
    visible
  }, motion2, {
    motionAppear: motionType === "show",
    onVisibleChanged
  }), function(_ref2, motionRef) {
    var motionClassName = _ref2.className, motionStyle = _ref2.style;
    return /* @__PURE__ */ React.createElement("div", {
      ref: motionRef,
      className: cn("".concat(prefixCls, "-treenode-motion"), motionClassName),
      style: motionStyle
    }, motionNodes.map(function(treeNode) {
      var restProps = Object.assign({}, (_objectDestructuringEmpty(treeNode.data), treeNode.data)), title2 = treeNode.title, key = treeNode.key, isStart = treeNode.isStart, isEnd = treeNode.isEnd;
      delete restProps.children;
      var treeNodeProps = getTreeNodeProps(key, treeNodeRequiredProps);
      return /* @__PURE__ */ React.createElement(ContextTreeNode, _extends({}, restProps, treeNodeProps, {
        title: title2,
        active,
        data: treeNode.data,
        key,
        isStart,
        isEnd
      }));
    }));
  }) : /* @__PURE__ */ React.createElement(ContextTreeNode, _extends({
    domRef: ref,
    className,
    style: style2
  }, props, {
    active
  }));
}, "MotionTreeNode");
MotionTreeNode.displayName = "MotionTreeNode";
var RefMotionTreeNode = /* @__PURE__ */ React.forwardRef(MotionTreeNode);
function findExpandedKeys() {
  var prev2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [], next2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [], prevLen = prev2.length, nextLen = next2.length;
  if (Math.abs(prevLen - nextLen) !== 1)
    return {
      add: !1,
      key: null
    };
  function find(shorter, longer) {
    var cache = /* @__PURE__ */ new Map();
    shorter.forEach(function(key) {
      cache.set(key, !0);
    });
    var keys2 = longer.filter(function(key) {
      return !cache.has(key);
    });
    return keys2.length === 1 ? keys2[0] : null;
  }
  return __name(find, "find"), prevLen < nextLen ? {
    add: !0,
    key: find(prev2, next2)
  } : {
    add: !1,
    key: find(next2, prev2)
  };
}
__name(findExpandedKeys, "findExpandedKeys");
function getExpandRange(shorter, longer, key) {
  var shorterStartIndex = shorter.findIndex(function(data) {
    return data.key === key;
  }), shorterEndNode = shorter[shorterStartIndex + 1], longerStartIndex = longer.findIndex(function(data) {
    return data.key === key;
  });
  if (shorterEndNode) {
    var longerEndIndex = longer.findIndex(function(data) {
      return data.key === shorterEndNode.key;
    });
    return longer.slice(longerStartIndex + 1, longerEndIndex);
  }
  return longer.slice(longerStartIndex + 1);
}
__name(getExpandRange, "getExpandRange");
var _excluded$1 = ["prefixCls", "data", "selectable", "checkable", "expandedKeys", "selectedKeys", "checkedKeys", "loadedKeys", "loadingKeys", "halfCheckedKeys", "keyEntities", "disabled", "dragging", "dragOverNodeKey", "dropPosition", "motion", "height", "itemHeight", "virtual", "focusable", "activeItem", "focused", "tabIndex", "onKeyDown", "onFocus", "onBlur", "onActiveChange", "onListChangeStart", "onListChangeEnd"], HIDDEN_STYLE = {
  width: 0,
  height: 0,
  display: "flex",
  overflow: "hidden",
  opacity: 0,
  border: 0,
  padding: 0,
  margin: 0
}, noop = /* @__PURE__ */ __name(function() {
}, "noop"), MOTION_KEY = "RC_TREE_MOTION_".concat(Math.random()), MotionNode = {
  key: MOTION_KEY
}, MotionEntity = {
  key: MOTION_KEY,
  level: 0,
  index: 0,
  pos: "0",
  node: MotionNode,
  nodes: [MotionNode]
}, MotionFlattenData = {
  parent: null,
  children: [],
  pos: MotionEntity.pos,
  data: MotionNode,
  title: null,
  key: MOTION_KEY,
  /** Hold empty list here since we do not use it */
  isStart: [],
  isEnd: []
};
function getMinimumRangeTransitionRange(list, virtual, height, itemHeight) {
  return virtual === !1 || !height ? list : list.slice(0, Math.ceil(height / itemHeight) + 1);
}
__name(getMinimumRangeTransitionRange, "getMinimumRangeTransitionRange");
function itemKey(item) {
  var key = item.key, pos = item.pos;
  return getKey(key, pos);
}
__name(itemKey, "itemKey");
function getAccessibilityPath(item) {
  for (var path2 = String(item.data.key), current = item; current.parent; )
    current = current.parent, path2 = "".concat(current.data.key, " > ").concat(path2);
  return path2;
}
__name(getAccessibilityPath, "getAccessibilityPath");
var NodeList = /* @__PURE__ */ React.forwardRef(function(props, ref) {
  var prefixCls = props.prefixCls, data = props.data;
  props.selectable, props.checkable;
  var expandedKeys = props.expandedKeys, selectedKeys = props.selectedKeys, checkedKeys = props.checkedKeys, loadedKeys = props.loadedKeys, loadingKeys = props.loadingKeys, halfCheckedKeys = props.halfCheckedKeys, keyEntities = props.keyEntities, disabled = props.disabled, dragging = props.dragging, dragOverNodeKey = props.dragOverNodeKey, dropPosition = props.dropPosition, motion2 = props.motion, height = props.height, itemHeight = props.itemHeight, virtual = props.virtual, focusable2 = props.focusable, activeItem = props.activeItem, focused = props.focused, tabIndex = props.tabIndex, onKeyDown2 = props.onKeyDown, onFocus = props.onFocus, onBlur = props.onBlur, onActiveChange = props.onActiveChange, onListChangeStart = props.onListChangeStart, onListChangeEnd = props.onListChangeEnd, domProps = _objectWithoutProperties(props, _excluded$1), listRef = React.useRef(null), indentMeasurerRef = React.useRef(null);
  React.useImperativeHandle(ref, function() {
    return {
      scrollTo: /* @__PURE__ */ __name(function(scroll) {
        listRef.current.scrollTo(scroll);
      }, "scrollTo"),
      getIndentWidth: /* @__PURE__ */ __name(function() {
        return indentMeasurerRef.current.offsetWidth;
      }, "getIndentWidth")
    };
  });
  var _React$useState = React.useState(expandedKeys), _React$useState2 = _slicedToArray(_React$useState, 2), prevExpandedKeys = _React$useState2[0], setPrevExpandedKeys = _React$useState2[1], _React$useState3 = React.useState(data), _React$useState4 = _slicedToArray(_React$useState3, 2), prevData = _React$useState4[0], setPrevData = _React$useState4[1], _React$useState5 = React.useState(data), _React$useState6 = _slicedToArray(_React$useState5, 2), transitionData = _React$useState6[0], setTransitionData = _React$useState6[1], _React$useState7 = React.useState([]), _React$useState8 = _slicedToArray(_React$useState7, 2), transitionRange = _React$useState8[0], setTransitionRange = _React$useState8[1], _React$useState9 = React.useState(null), _React$useState10 = _slicedToArray(_React$useState9, 2), motionType = _React$useState10[0], setMotionType = _React$useState10[1], dataRef = React.useRef(data);
  dataRef.current = data;
  function onMotionEnd() {
    var latestData = dataRef.current;
    setPrevData(latestData), setTransitionData(latestData), setTransitionRange([]), setMotionType(null), onListChangeEnd();
  }
  __name(onMotionEnd, "onMotionEnd"), useLayoutEffect$1(function() {
    setPrevExpandedKeys(expandedKeys);
    var diffExpanded = findExpandedKeys(prevExpandedKeys, expandedKeys);
    if (diffExpanded.key !== null)
      if (diffExpanded.add) {
        var keyIndex = prevData.findIndex(function(_ref) {
          var key = _ref.key;
          return key === diffExpanded.key;
        }), rangeNodes = getMinimumRangeTransitionRange(getExpandRange(prevData, data, diffExpanded.key), virtual, height, itemHeight), newTransitionData = prevData.slice();
        newTransitionData.splice(keyIndex + 1, 0, MotionFlattenData), setTransitionData(newTransitionData), setTransitionRange(rangeNodes), setMotionType("show");
      } else {
        var _keyIndex = data.findIndex(function(_ref2) {
          var key = _ref2.key;
          return key === diffExpanded.key;
        }), _rangeNodes = getMinimumRangeTransitionRange(getExpandRange(data, prevData, diffExpanded.key), virtual, height, itemHeight), _newTransitionData = data.slice();
        _newTransitionData.splice(_keyIndex + 1, 0, MotionFlattenData), setTransitionData(_newTransitionData), setTransitionRange(_rangeNodes), setMotionType("hide");
      }
    else prevData !== data && (setPrevData(data), setTransitionData(data));
  }, [expandedKeys, data]), React.useEffect(function() {
    dragging || onMotionEnd();
  }, [dragging]);
  var mergedData = motion2 ? transitionData : data, treeNodeRequiredProps = {
    expandedKeys,
    selectedKeys,
    loadedKeys,
    loadingKeys,
    checkedKeys,
    halfCheckedKeys,
    dragOverNodeKey,
    dropPosition,
    keyEntities
  };
  return /* @__PURE__ */ React.createElement(React.Fragment, null, focused && activeItem && /* @__PURE__ */ React.createElement("span", {
    style: HIDDEN_STYLE,
    "aria-live": "assertive"
  }, getAccessibilityPath(activeItem)), /* @__PURE__ */ React.createElement("div", null, /* @__PURE__ */ React.createElement("input", {
    style: HIDDEN_STYLE,
    disabled: focusable2 === !1 || disabled,
    tabIndex: focusable2 !== !1 ? tabIndex : null,
    onKeyDown: onKeyDown2,
    onFocus,
    onBlur,
    value: "",
    onChange: noop,
    "aria-label": "for screen reader"
  })), /* @__PURE__ */ React.createElement("div", {
    className: "".concat(prefixCls, "-treenode"),
    "aria-hidden": !0,
    style: {
      position: "absolute",
      pointerEvents: "none",
      visibility: "hidden",
      height: 0,
      overflow: "hidden",
      border: 0,
      padding: 0
    }
  }, /* @__PURE__ */ React.createElement("div", {
    className: "".concat(prefixCls, "-indent")
  }, /* @__PURE__ */ React.createElement("div", {
    ref: indentMeasurerRef,
    className: "".concat(prefixCls, "-indent-unit")
  }))), /* @__PURE__ */ React.createElement(List, _extends({}, domProps, {
    data: mergedData,
    itemKey,
    height,
    fullHeight: !1,
    virtual,
    itemHeight,
    prefixCls: "".concat(prefixCls, "-list"),
    ref: listRef,
    onVisibleChange: /* @__PURE__ */ __name(function(originList) {
      originList.every(function(item) {
        return itemKey(item) !== MOTION_KEY;
      }) && onMotionEnd();
    }, "onVisibleChange")
  }), function(treeNode) {
    var pos = treeNode.pos, restProps = Object.assign({}, (_objectDestructuringEmpty(treeNode.data), treeNode.data)), title2 = treeNode.title, key = treeNode.key, isStart = treeNode.isStart, isEnd = treeNode.isEnd, mergedKey = getKey(key, pos);
    delete restProps.key, delete restProps.children;
    var treeNodeProps = getTreeNodeProps(mergedKey, treeNodeRequiredProps);
    return /* @__PURE__ */ React.createElement(RefMotionTreeNode, _extends({}, restProps, treeNodeProps, {
      title: title2,
      active: !!activeItem && key === activeItem.key,
      pos,
      data: treeNode.data,
      isStart,
      isEnd,
      motion: motion2,
      motionNodes: key === MOTION_KEY ? transitionRange : null,
      motionType,
      onMotionStart: onListChangeStart,
      onMotionEnd,
      treeNodeRequiredProps,
      onMouseMove: /* @__PURE__ */ __name(function() {
        onActiveChange(null);
      }, "onMouseMove")
    }));
  }));
});
NodeList.displayName = "NodeList";
var MAX_RETRY_TIMES = 10, Tree$2 = /* @__PURE__ */ function(_React$Component) {
  _inherits(Tree2, _React$Component);
  var _super = _createSuper(Tree2);
  function Tree2() {
    var _this;
    _classCallCheck$1(this, Tree2);
    for (var _len = arguments.length, _args = new Array(_len), _key = 0; _key < _len; _key++)
      _args[_key] = arguments[_key];
    return _this = _super.call.apply(_super, [this].concat(_args)), _defineProperty$2(_assertThisInitialized(_this), "destroyed", !1), _defineProperty$2(_assertThisInitialized(_this), "delayedDragEnterLogic", void 0), _defineProperty$2(_assertThisInitialized(_this), "loadingRetryTimes", {}), _defineProperty$2(_assertThisInitialized(_this), "state", {
      keyEntities: {},
      indent: null,
      selectedKeys: [],
      checkedKeys: [],
      halfCheckedKeys: [],
      loadedKeys: [],
      loadingKeys: [],
      expandedKeys: [],
      draggingNodeKey: null,
      dragChildrenKeys: [],
      // dropTargetKey is the key of abstract-drop-node
      // the abstract-drop-node is the real drop node when drag and drop
      // not the DOM drag over node
      dropTargetKey: null,
      dropPosition: null,
      // the drop position of abstract-drop-node, inside 0, top -1, bottom 1
      dropContainerKey: null,
      // the container key of abstract-drop-node if dropPosition is -1 or 1
      dropLevelOffset: null,
      // the drop level offset of abstract-drag-over-node
      dropTargetPos: null,
      // the pos of abstract-drop-node
      dropAllowed: !0,
      // if drop to abstract-drop-node is allowed
      // the abstract-drag-over-node
      // if mouse is on the bottom of top dom node or no the top of the bottom dom node
      // abstract-drag-over-node is the top node
      dragOverNodeKey: null,
      treeData: [],
      flattenNodes: [],
      focused: !1,
      activeKey: null,
      listChanging: !1,
      prevProps: null,
      fieldNames: fillFieldNames()
    }), _defineProperty$2(_assertThisInitialized(_this), "dragStartMousePosition", null), _defineProperty$2(_assertThisInitialized(_this), "dragNode", void 0), _defineProperty$2(_assertThisInitialized(_this), "currentMouseOverDroppableNodeKey", null), _defineProperty$2(_assertThisInitialized(_this), "listRef", /* @__PURE__ */ React.createRef()), _defineProperty$2(_assertThisInitialized(_this), "onNodeDragStart", function(event, node2) {
      var _this$state = _this.state, expandedKeys = _this$state.expandedKeys, keyEntities = _this$state.keyEntities, onDragStart = _this.props.onDragStart, eventKey = node2.props.eventKey;
      _this.dragNode = node2, _this.dragStartMousePosition = {
        x: event.clientX,
        y: event.clientY
      };
      var newExpandedKeys = arrDel(expandedKeys, eventKey);
      _this.setState({
        draggingNodeKey: eventKey,
        dragChildrenKeys: getDragChildrenKeys(eventKey, keyEntities),
        indent: _this.listRef.current.getIndentWidth()
      }), _this.setExpandedKeys(newExpandedKeys), window.addEventListener("dragend", _this.onWindowDragEnd), onDragStart == null || onDragStart({
        event,
        node: convertNodePropsToEventData(node2.props)
      });
    }), _defineProperty$2(_assertThisInitialized(_this), "onNodeDragEnter", function(event, node2) {
      var _this$state2 = _this.state, expandedKeys = _this$state2.expandedKeys, keyEntities = _this$state2.keyEntities, dragChildrenKeys = _this$state2.dragChildrenKeys, flattenNodes = _this$state2.flattenNodes, indent = _this$state2.indent, _this$props = _this.props, onDragEnter = _this$props.onDragEnter, onExpand = _this$props.onExpand, allowDrop2 = _this$props.allowDrop, direction = _this$props.direction, _node$props = node2.props, pos = _node$props.pos, eventKey = _node$props.eventKey, _assertThisInitialize = _assertThisInitialized(_this), dragNode = _assertThisInitialize.dragNode;
      if (_this.currentMouseOverDroppableNodeKey !== eventKey && (_this.currentMouseOverDroppableNodeKey = eventKey), !dragNode) {
        _this.resetDragState();
        return;
      }
      var _calcDropPosition = calcDropPosition(event, dragNode, node2, indent, _this.dragStartMousePosition, allowDrop2, flattenNodes, keyEntities, expandedKeys, direction), dropPosition = _calcDropPosition.dropPosition, dropLevelOffset = _calcDropPosition.dropLevelOffset, dropTargetKey = _calcDropPosition.dropTargetKey, dropContainerKey = _calcDropPosition.dropContainerKey, dropTargetPos = _calcDropPosition.dropTargetPos, dropAllowed = _calcDropPosition.dropAllowed, dragOverNodeKey = _calcDropPosition.dragOverNodeKey;
      if (
        // don't allow drop inside its children
        dragChildrenKeys.indexOf(dropTargetKey) !== -1 || // don't allow drop when drop is not allowed caculated by calcDropPosition
        !dropAllowed
      ) {
        _this.resetDragState();
        return;
      }
      if (_this.delayedDragEnterLogic || (_this.delayedDragEnterLogic = {}), Object.keys(_this.delayedDragEnterLogic).forEach(function(key) {
        clearTimeout(_this.delayedDragEnterLogic[key]);
      }), dragNode.props.eventKey !== node2.props.eventKey && (event.persist(), _this.delayedDragEnterLogic[pos] = window.setTimeout(function() {
        if (_this.state.draggingNodeKey !== null) {
          var newExpandedKeys = _toConsumableArray(expandedKeys), entity = getEntity(keyEntities, node2.props.eventKey);
          entity && (entity.children || []).length && (newExpandedKeys = arrAdd(expandedKeys, node2.props.eventKey)), _this.props.hasOwnProperty("expandedKeys") || _this.setExpandedKeys(newExpandedKeys), onExpand == null || onExpand(newExpandedKeys, {
            node: convertNodePropsToEventData(node2.props),
            expanded: !0,
            nativeEvent: event.nativeEvent
          });
        }
      }, 800)), dragNode.props.eventKey === dropTargetKey && dropLevelOffset === 0) {
        _this.resetDragState();
        return;
      }
      _this.setState({
        dragOverNodeKey,
        dropPosition,
        dropLevelOffset,
        dropTargetKey,
        dropContainerKey,
        dropTargetPos,
        dropAllowed
      }), onDragEnter == null || onDragEnter({
        event,
        node: convertNodePropsToEventData(node2.props),
        expandedKeys
      });
    }), _defineProperty$2(_assertThisInitialized(_this), "onNodeDragOver", function(event, node2) {
      var _this$state3 = _this.state, dragChildrenKeys = _this$state3.dragChildrenKeys, flattenNodes = _this$state3.flattenNodes, keyEntities = _this$state3.keyEntities, expandedKeys = _this$state3.expandedKeys, indent = _this$state3.indent, _this$props2 = _this.props, onDragOver = _this$props2.onDragOver, allowDrop2 = _this$props2.allowDrop, direction = _this$props2.direction, _assertThisInitialize2 = _assertThisInitialized(_this), dragNode = _assertThisInitialize2.dragNode;
      if (dragNode) {
        var _calcDropPosition2 = calcDropPosition(event, dragNode, node2, indent, _this.dragStartMousePosition, allowDrop2, flattenNodes, keyEntities, expandedKeys, direction), dropPosition = _calcDropPosition2.dropPosition, dropLevelOffset = _calcDropPosition2.dropLevelOffset, dropTargetKey = _calcDropPosition2.dropTargetKey, dropContainerKey = _calcDropPosition2.dropContainerKey, dropAllowed = _calcDropPosition2.dropAllowed, dropTargetPos = _calcDropPosition2.dropTargetPos, dragOverNodeKey = _calcDropPosition2.dragOverNodeKey;
        dragChildrenKeys.indexOf(dropTargetKey) !== -1 || !dropAllowed || (dragNode.props.eventKey === dropTargetKey && dropLevelOffset === 0 ? _this.state.dropPosition === null && _this.state.dropLevelOffset === null && _this.state.dropTargetKey === null && _this.state.dropContainerKey === null && _this.state.dropTargetPos === null && _this.state.dropAllowed === !1 && _this.state.dragOverNodeKey === null || _this.resetDragState() : dropPosition === _this.state.dropPosition && dropLevelOffset === _this.state.dropLevelOffset && dropTargetKey === _this.state.dropTargetKey && dropContainerKey === _this.state.dropContainerKey && dropTargetPos === _this.state.dropTargetPos && dropAllowed === _this.state.dropAllowed && dragOverNodeKey === _this.state.dragOverNodeKey || _this.setState({
          dropPosition,
          dropLevelOffset,
          dropTargetKey,
          dropContainerKey,
          dropTargetPos,
          dropAllowed,
          dragOverNodeKey
        }), onDragOver == null || onDragOver({
          event,
          node: convertNodePropsToEventData(node2.props)
        }));
      }
    }), _defineProperty$2(_assertThisInitialized(_this), "onNodeDragLeave", function(event, node2) {
      _this.currentMouseOverDroppableNodeKey === node2.props.eventKey && !event.currentTarget.contains(event.relatedTarget) && (_this.resetDragState(), _this.currentMouseOverDroppableNodeKey = null);
      var onDragLeave = _this.props.onDragLeave;
      onDragLeave == null || onDragLeave({
        event,
        node: convertNodePropsToEventData(node2.props)
      });
    }), _defineProperty$2(_assertThisInitialized(_this), "onWindowDragEnd", function(event) {
      _this.onNodeDragEnd(event, null, !0), window.removeEventListener("dragend", _this.onWindowDragEnd);
    }), _defineProperty$2(_assertThisInitialized(_this), "onNodeDragEnd", function(event, node2) {
      var onDragEnd = _this.props.onDragEnd;
      _this.setState({
        dragOverNodeKey: null
      }), _this.cleanDragState(), onDragEnd == null || onDragEnd({
        event,
        node: convertNodePropsToEventData(node2.props)
      }), _this.dragNode = null, window.removeEventListener("dragend", _this.onWindowDragEnd);
    }), _defineProperty$2(_assertThisInitialized(_this), "onNodeDrop", function(event, node2) {
      var _this$getActiveItem, outsideTree = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !1, _this$state4 = _this.state, dragChildrenKeys = _this$state4.dragChildrenKeys, dropPosition = _this$state4.dropPosition, dropTargetKey = _this$state4.dropTargetKey, dropTargetPos = _this$state4.dropTargetPos, dropAllowed = _this$state4.dropAllowed;
      if (dropAllowed) {
        var onDrop = _this.props.onDrop;
        if (_this.setState({
          dragOverNodeKey: null
        }), _this.cleanDragState(), dropTargetKey !== null) {
          var abstractDropNodeProps = _objectSpread2$1(_objectSpread2$1({}, getTreeNodeProps(dropTargetKey, _this.getTreeNodeRequiredProps())), {}, {
            active: ((_this$getActiveItem = _this.getActiveItem()) === null || _this$getActiveItem === void 0 ? void 0 : _this$getActiveItem.key) === dropTargetKey,
            data: getEntity(_this.state.keyEntities, dropTargetKey).node
          }), dropToChild = dragChildrenKeys.indexOf(dropTargetKey) !== -1;
          warningOnce(!dropToChild, "Can not drop to dragNode's children node. This is a bug of rc-tree. Please report an issue.");
          var posArr = posToArr(dropTargetPos), dropResult = {
            event,
            node: convertNodePropsToEventData(abstractDropNodeProps),
            dragNode: _this.dragNode ? convertNodePropsToEventData(_this.dragNode.props) : null,
            dragNodesKeys: [_this.dragNode.props.eventKey].concat(dragChildrenKeys),
            dropToGap: dropPosition !== 0,
            dropPosition: dropPosition + Number(posArr[posArr.length - 1])
          };
          outsideTree || onDrop == null || onDrop(dropResult), _this.dragNode = null;
        }
      }
    }), _defineProperty$2(_assertThisInitialized(_this), "cleanDragState", function() {
      var draggingNodeKey = _this.state.draggingNodeKey;
      draggingNodeKey !== null && _this.setState({
        draggingNodeKey: null,
        dropPosition: null,
        dropContainerKey: null,
        dropTargetKey: null,
        dropLevelOffset: null,
        dropAllowed: !0,
        dragOverNodeKey: null
      }), _this.dragStartMousePosition = null, _this.currentMouseOverDroppableNodeKey = null;
    }), _defineProperty$2(_assertThisInitialized(_this), "triggerExpandActionExpand", function(e2, treeNode) {
      var _this$state5 = _this.state, expandedKeys = _this$state5.expandedKeys, flattenNodes = _this$state5.flattenNodes, expanded = treeNode.expanded, key = treeNode.key, isLeaf = treeNode.isLeaf;
      if (!(isLeaf || e2.shiftKey || e2.metaKey || e2.ctrlKey)) {
        var node2 = flattenNodes.filter(function(nodeItem) {
          return nodeItem.key === key;
        })[0], eventNode = convertNodePropsToEventData(_objectSpread2$1(_objectSpread2$1({}, getTreeNodeProps(key, _this.getTreeNodeRequiredProps())), {}, {
          data: node2.data
        }));
        _this.setExpandedKeys(expanded ? arrDel(expandedKeys, key) : arrAdd(expandedKeys, key)), _this.onNodeExpand(e2, eventNode);
      }
    }), _defineProperty$2(_assertThisInitialized(_this), "onNodeClick", function(e2, treeNode) {
      var _this$props3 = _this.props, onClick = _this$props3.onClick, expandAction = _this$props3.expandAction;
      expandAction === "click" && _this.triggerExpandActionExpand(e2, treeNode), onClick == null || onClick(e2, treeNode);
    }), _defineProperty$2(_assertThisInitialized(_this), "onNodeDoubleClick", function(e2, treeNode) {
      var _this$props4 = _this.props, onDoubleClick = _this$props4.onDoubleClick, expandAction = _this$props4.expandAction;
      expandAction === "doubleClick" && _this.triggerExpandActionExpand(e2, treeNode), onDoubleClick == null || onDoubleClick(e2, treeNode);
    }), _defineProperty$2(_assertThisInitialized(_this), "onNodeSelect", function(e2, treeNode) {
      var selectedKeys = _this.state.selectedKeys, _this$state6 = _this.state, keyEntities = _this$state6.keyEntities, fieldNames = _this$state6.fieldNames, _this$props5 = _this.props, onSelect = _this$props5.onSelect, multiple = _this$props5.multiple, selected = treeNode.selected, key = treeNode[fieldNames.key], targetSelected = !selected;
      targetSelected ? multiple ? selectedKeys = arrAdd(selectedKeys, key) : selectedKeys = [key] : selectedKeys = arrDel(selectedKeys, key);
      var selectedNodes = selectedKeys.map(function(selectedKey) {
        var entity = getEntity(keyEntities, selectedKey);
        return entity ? entity.node : null;
      }).filter(function(node2) {
        return node2;
      });
      _this.setUncontrolledState({
        selectedKeys
      }), onSelect == null || onSelect(selectedKeys, {
        event: "select",
        selected: targetSelected,
        node: treeNode,
        selectedNodes,
        nativeEvent: e2.nativeEvent
      });
    }), _defineProperty$2(_assertThisInitialized(_this), "onNodeCheck", function(e2, treeNode, checked) {
      var _this$state7 = _this.state, keyEntities = _this$state7.keyEntities, oriCheckedKeys = _this$state7.checkedKeys, oriHalfCheckedKeys = _this$state7.halfCheckedKeys, _this$props6 = _this.props, checkStrictly = _this$props6.checkStrictly, onCheck = _this$props6.onCheck, key = treeNode.key, checkedObj, eventObj = {
        event: "check",
        node: treeNode,
        checked,
        nativeEvent: e2.nativeEvent
      };
      if (checkStrictly) {
        var checkedKeys = checked ? arrAdd(oriCheckedKeys, key) : arrDel(oriCheckedKeys, key), halfCheckedKeys = arrDel(oriHalfCheckedKeys, key);
        checkedObj = {
          checked: checkedKeys,
          halfChecked: halfCheckedKeys
        }, eventObj.checkedNodes = checkedKeys.map(function(checkedKey) {
          return getEntity(keyEntities, checkedKey);
        }).filter(function(entity) {
          return entity;
        }).map(function(entity) {
          return entity.node;
        }), _this.setUncontrolledState({
          checkedKeys
        });
      } else {
        var _conductCheck = conductCheck([].concat(_toConsumableArray(oriCheckedKeys), [key]), !0, keyEntities), _checkedKeys = _conductCheck.checkedKeys, _halfCheckedKeys = _conductCheck.halfCheckedKeys;
        if (!checked) {
          var keySet = new Set(_checkedKeys);
          keySet.delete(key);
          var _conductCheck2 = conductCheck(Array.from(keySet), {
            halfCheckedKeys: _halfCheckedKeys
          }, keyEntities);
          _checkedKeys = _conductCheck2.checkedKeys, _halfCheckedKeys = _conductCheck2.halfCheckedKeys;
        }
        checkedObj = _checkedKeys, eventObj.checkedNodes = [], eventObj.checkedNodesPositions = [], eventObj.halfCheckedKeys = _halfCheckedKeys, _checkedKeys.forEach(function(checkedKey) {
          var entity = getEntity(keyEntities, checkedKey);
          if (entity) {
            var node2 = entity.node, pos = entity.pos;
            eventObj.checkedNodes.push(node2), eventObj.checkedNodesPositions.push({
              node: node2,
              pos
            });
          }
        }), _this.setUncontrolledState({
          checkedKeys: _checkedKeys
        }, !1, {
          halfCheckedKeys: _halfCheckedKeys
        });
      }
      onCheck == null || onCheck(checkedObj, eventObj);
    }), _defineProperty$2(_assertThisInitialized(_this), "onNodeLoad", function(treeNode) {
      var _entity$children, key = treeNode.key, keyEntities = _this.state.keyEntities, entity = getEntity(keyEntities, key);
      if (!(entity != null && (_entity$children = entity.children) !== null && _entity$children !== void 0 && _entity$children.length)) {
        var loadPromise = new Promise(function(resolve, reject) {
          _this.setState(function(_ref) {
            var _ref$loadedKeys = _ref.loadedKeys, loadedKeys = _ref$loadedKeys === void 0 ? [] : _ref$loadedKeys, _ref$loadingKeys = _ref.loadingKeys, loadingKeys = _ref$loadingKeys === void 0 ? [] : _ref$loadingKeys, _this$props7 = _this.props, loadData = _this$props7.loadData, onLoad = _this$props7.onLoad;
            if (!loadData || loadedKeys.indexOf(key) !== -1 || loadingKeys.indexOf(key) !== -1)
              return null;
            var promise = loadData(treeNode);
            return promise.then(function() {
              var currentLoadedKeys = _this.state.loadedKeys, newLoadedKeys = arrAdd(currentLoadedKeys, key);
              onLoad == null || onLoad(newLoadedKeys, {
                event: "load",
                node: treeNode
              }), _this.setUncontrolledState({
                loadedKeys: newLoadedKeys
              }), _this.setState(function(prevState) {
                return {
                  loadingKeys: arrDel(prevState.loadingKeys, key)
                };
              }), resolve();
            }).catch(function(e2) {
              if (_this.setState(function(prevState) {
                return {
                  loadingKeys: arrDel(prevState.loadingKeys, key)
                };
              }), _this.loadingRetryTimes[key] = (_this.loadingRetryTimes[key] || 0) + 1, _this.loadingRetryTimes[key] >= MAX_RETRY_TIMES) {
                var currentLoadedKeys = _this.state.loadedKeys;
                warningOnce(!1, "Retry for `loadData` many times but still failed. No more retry."), _this.setUncontrolledState({
                  loadedKeys: arrAdd(currentLoadedKeys, key)
                }), resolve();
              }
              reject(e2);
            }), {
              loadingKeys: arrAdd(loadingKeys, key)
            };
          });
        });
        return loadPromise.catch(function() {
        }), loadPromise;
      }
    }), _defineProperty$2(_assertThisInitialized(_this), "onNodeMouseEnter", function(event, node2) {
      var onMouseEnter = _this.props.onMouseEnter;
      onMouseEnter == null || onMouseEnter({
        event,
        node: node2
      });
    }), _defineProperty$2(_assertThisInitialized(_this), "onNodeMouseLeave", function(event, node2) {
      var onMouseLeave = _this.props.onMouseLeave;
      onMouseLeave == null || onMouseLeave({
        event,
        node: node2
      });
    }), _defineProperty$2(_assertThisInitialized(_this), "onNodeContextMenu", function(event, node2) {
      var onRightClick = _this.props.onRightClick;
      onRightClick && (event.preventDefault(), onRightClick({
        event,
        node: node2
      }));
    }), _defineProperty$2(_assertThisInitialized(_this), "onFocus", function() {
      var onFocus = _this.props.onFocus;
      _this.setState({
        focused: !0
      });
      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++)
        args[_key2] = arguments[_key2];
      onFocus == null || onFocus.apply(void 0, args);
    }), _defineProperty$2(_assertThisInitialized(_this), "onBlur", function() {
      var onBlur = _this.props.onBlur;
      _this.setState({
        focused: !1
      }), _this.onActiveChange(null);
      for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++)
        args[_key3] = arguments[_key3];
      onBlur == null || onBlur.apply(void 0, args);
    }), _defineProperty$2(_assertThisInitialized(_this), "getTreeNodeRequiredProps", function() {
      var _this$state8 = _this.state, expandedKeys = _this$state8.expandedKeys, selectedKeys = _this$state8.selectedKeys, loadedKeys = _this$state8.loadedKeys, loadingKeys = _this$state8.loadingKeys, checkedKeys = _this$state8.checkedKeys, halfCheckedKeys = _this$state8.halfCheckedKeys, dragOverNodeKey = _this$state8.dragOverNodeKey, dropPosition = _this$state8.dropPosition, keyEntities = _this$state8.keyEntities;
      return {
        expandedKeys: expandedKeys || [],
        selectedKeys: selectedKeys || [],
        loadedKeys: loadedKeys || [],
        loadingKeys: loadingKeys || [],
        checkedKeys: checkedKeys || [],
        halfCheckedKeys: halfCheckedKeys || [],
        dragOverNodeKey,
        dropPosition,
        keyEntities
      };
    }), _defineProperty$2(_assertThisInitialized(_this), "setExpandedKeys", function(expandedKeys) {
      var _this$state9 = _this.state, treeData = _this$state9.treeData, fieldNames = _this$state9.fieldNames, flattenNodes = flattenTreeData(treeData, expandedKeys, fieldNames);
      _this.setUncontrolledState({
        expandedKeys,
        flattenNodes
      }, !0);
    }), _defineProperty$2(_assertThisInitialized(_this), "onNodeExpand", function(e2, treeNode) {
      var expandedKeys = _this.state.expandedKeys, _this$state10 = _this.state, listChanging = _this$state10.listChanging, fieldNames = _this$state10.fieldNames, _this$props8 = _this.props, onExpand = _this$props8.onExpand, loadData = _this$props8.loadData, expanded = treeNode.expanded, key = treeNode[fieldNames.key];
      if (!listChanging) {
        var index2 = expandedKeys.indexOf(key), targetExpanded = !expanded;
        if (warningOnce(expanded && index2 !== -1 || !expanded && index2 === -1, "Expand state not sync with index check"), targetExpanded ? expandedKeys = arrAdd(expandedKeys, key) : expandedKeys = arrDel(expandedKeys, key), _this.setExpandedKeys(expandedKeys), onExpand == null || onExpand(expandedKeys, {
          node: treeNode,
          expanded: targetExpanded,
          nativeEvent: e2.nativeEvent
        }), targetExpanded && loadData) {
          var loadPromise = _this.onNodeLoad(treeNode);
          loadPromise && loadPromise.then(function() {
            var newFlattenTreeData = flattenTreeData(_this.state.treeData, expandedKeys, fieldNames);
            _this.setUncontrolledState({
              flattenNodes: newFlattenTreeData
            });
          }).catch(function() {
            var currentExpandedKeys = _this.state.expandedKeys, expandedKeysToRestore = arrDel(currentExpandedKeys, key);
            _this.setExpandedKeys(expandedKeysToRestore);
          });
        }
      }
    }), _defineProperty$2(_assertThisInitialized(_this), "onListChangeStart", function() {
      _this.setUncontrolledState({
        listChanging: !0
      });
    }), _defineProperty$2(_assertThisInitialized(_this), "onListChangeEnd", function() {
      setTimeout(function() {
        _this.setUncontrolledState({
          listChanging: !1
        });
      });
    }), _defineProperty$2(_assertThisInitialized(_this), "onActiveChange", function(newActiveKey) {
      var activeKey = _this.state.activeKey, _this$props9 = _this.props, onActiveChange = _this$props9.onActiveChange, _this$props9$itemScro = _this$props9.itemScrollOffset, itemScrollOffset = _this$props9$itemScro === void 0 ? 0 : _this$props9$itemScro;
      activeKey !== newActiveKey && (_this.setState({
        activeKey: newActiveKey
      }), newActiveKey !== null && _this.scrollTo({
        key: newActiveKey,
        offset: itemScrollOffset
      }), onActiveChange == null || onActiveChange(newActiveKey));
    }), _defineProperty$2(_assertThisInitialized(_this), "getActiveItem", function() {
      var _this$state11 = _this.state, activeKey = _this$state11.activeKey, flattenNodes = _this$state11.flattenNodes;
      return activeKey === null ? null : flattenNodes.find(function(_ref2) {
        var key = _ref2.key;
        return key === activeKey;
      }) || null;
    }), _defineProperty$2(_assertThisInitialized(_this), "offsetActiveKey", function(offset2) {
      var _this$state12 = _this.state, flattenNodes = _this$state12.flattenNodes, activeKey = _this$state12.activeKey, index2 = flattenNodes.findIndex(function(_ref3) {
        var key = _ref3.key;
        return key === activeKey;
      });
      index2 === -1 && offset2 < 0 && (index2 = flattenNodes.length), index2 = (index2 + offset2 + flattenNodes.length) % flattenNodes.length;
      var item = flattenNodes[index2];
      if (item) {
        var _key4 = item.key;
        _this.onActiveChange(_key4);
      } else
        _this.onActiveChange(null);
    }), _defineProperty$2(_assertThisInitialized(_this), "onKeyDown", function(event) {
      var _this$state13 = _this.state, activeKey = _this$state13.activeKey, expandedKeys = _this$state13.expandedKeys, checkedKeys = _this$state13.checkedKeys, fieldNames = _this$state13.fieldNames, _this$props10 = _this.props, onKeyDown2 = _this$props10.onKeyDown, checkable = _this$props10.checkable, selectable = _this$props10.selectable;
      switch (event.which) {
        case KeyCode.UP: {
          _this.offsetActiveKey(-1), event.preventDefault();
          break;
        }
        case KeyCode.DOWN: {
          _this.offsetActiveKey(1), event.preventDefault();
          break;
        }
      }
      var activeItem = _this.getActiveItem();
      if (activeItem && activeItem.data) {
        var treeNodeRequiredProps = _this.getTreeNodeRequiredProps(), expandable = activeItem.data.isLeaf === !1 || !!(activeItem.data[fieldNames.children] || []).length, eventNode = convertNodePropsToEventData(_objectSpread2$1(_objectSpread2$1({}, getTreeNodeProps(activeKey, treeNodeRequiredProps)), {}, {
          data: activeItem.data,
          active: !0
        }));
        switch (event.which) {
          case KeyCode.LEFT: {
            expandable && expandedKeys.includes(activeKey) ? _this.onNodeExpand({}, eventNode) : activeItem.parent && _this.onActiveChange(activeItem.parent.key), event.preventDefault();
            break;
          }
          case KeyCode.RIGHT: {
            expandable && !expandedKeys.includes(activeKey) ? _this.onNodeExpand({}, eventNode) : activeItem.children && activeItem.children.length && _this.onActiveChange(activeItem.children[0].key), event.preventDefault();
            break;
          }
          case KeyCode.ENTER:
          case KeyCode.SPACE: {
            checkable && !eventNode.disabled && eventNode.checkable !== !1 && !eventNode.disableCheckbox ? _this.onNodeCheck({}, eventNode, !checkedKeys.includes(activeKey)) : !checkable && selectable && !eventNode.disabled && eventNode.selectable !== !1 && _this.onNodeSelect({}, eventNode);
            break;
          }
        }
      }
      onKeyDown2 == null || onKeyDown2(event);
    }), _defineProperty$2(_assertThisInitialized(_this), "setUncontrolledState", function(state) {
      var atomic = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1, forceState = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null;
      if (!_this.destroyed) {
        var needSync = !1, allPassed = !0, newState = {};
        Object.keys(state).forEach(function(name) {
          if (_this.props.hasOwnProperty(name)) {
            allPassed = !1;
            return;
          }
          needSync = !0, newState[name] = state[name];
        }), needSync && (!atomic || allPassed) && _this.setState(_objectSpread2$1(_objectSpread2$1({}, newState), forceState));
      }
    }), _defineProperty$2(_assertThisInitialized(_this), "scrollTo", function(scroll) {
      _this.listRef.current.scrollTo(scroll);
    }), _this;
  }
  return __name(Tree2, "Tree"), _createClass$1(Tree2, [{
    key: "componentDidMount",
    value: /* @__PURE__ */ __name(function() {
      this.destroyed = !1, this.onUpdated();
    }, "componentDidMount")
  }, {
    key: "componentDidUpdate",
    value: /* @__PURE__ */ __name(function() {
      this.onUpdated();
    }, "componentDidUpdate")
  }, {
    key: "onUpdated",
    value: /* @__PURE__ */ __name(function() {
      var _this$props11 = this.props, activeKey = _this$props11.activeKey, _this$props11$itemScr = _this$props11.itemScrollOffset, itemScrollOffset = _this$props11$itemScr === void 0 ? 0 : _this$props11$itemScr;
      activeKey !== void 0 && activeKey !== this.state.activeKey && (this.setState({
        activeKey
      }), activeKey !== null && this.scrollTo({
        key: activeKey,
        offset: itemScrollOffset
      }));
    }, "onUpdated")
  }, {
    key: "componentWillUnmount",
    value: /* @__PURE__ */ __name(function() {
      window.removeEventListener("dragend", this.onWindowDragEnd), this.destroyed = !0;
    }, "componentWillUnmount")
  }, {
    key: "resetDragState",
    value: /* @__PURE__ */ __name(function() {
      this.setState({
        dragOverNodeKey: null,
        dropPosition: null,
        dropLevelOffset: null,
        dropTargetKey: null,
        dropContainerKey: null,
        dropTargetPos: null,
        dropAllowed: !1
      });
    }, "resetDragState")
  }, {
    key: "render",
    value: /* @__PURE__ */ __name(function() {
      var _this$state14 = this.state, focused = _this$state14.focused, flattenNodes = _this$state14.flattenNodes, keyEntities = _this$state14.keyEntities, draggingNodeKey = _this$state14.draggingNodeKey, activeKey = _this$state14.activeKey, dropLevelOffset = _this$state14.dropLevelOffset, dropContainerKey = _this$state14.dropContainerKey, dropTargetKey = _this$state14.dropTargetKey, dropPosition = _this$state14.dropPosition, dragOverNodeKey = _this$state14.dragOverNodeKey, indent = _this$state14.indent, _this$props12 = this.props, prefixCls = _this$props12.prefixCls, className = _this$props12.className, style2 = _this$props12.style, showLine = _this$props12.showLine, focusable2 = _this$props12.focusable, _this$props12$tabInde = _this$props12.tabIndex, tabIndex = _this$props12$tabInde === void 0 ? 0 : _this$props12$tabInde, selectable = _this$props12.selectable, showIcon = _this$props12.showIcon, icon = _this$props12.icon, switcherIcon = _this$props12.switcherIcon, draggable = _this$props12.draggable, checkable = _this$props12.checkable, checkStrictly = _this$props12.checkStrictly, disabled = _this$props12.disabled, motion2 = _this$props12.motion, loadData = _this$props12.loadData, filterTreeNode = _this$props12.filterTreeNode, height = _this$props12.height, itemHeight = _this$props12.itemHeight, virtual = _this$props12.virtual, titleRender = _this$props12.titleRender, dropIndicatorRender2 = _this$props12.dropIndicatorRender, onContextMenu = _this$props12.onContextMenu, onScroll = _this$props12.onScroll, direction = _this$props12.direction, rootClassName = _this$props12.rootClassName, rootStyle = _this$props12.rootStyle, domProps = pickAttrs(this.props, {
        aria: !0,
        data: !0
      }), draggableConfig;
      return draggable && (_typeof$4(draggable) === "object" ? draggableConfig = draggable : typeof draggable == "function" ? draggableConfig = {
        nodeDraggable: draggable
      } : draggableConfig = {}), /* @__PURE__ */ React.createElement(TreeContext.Provider, {
        value: {
          prefixCls,
          selectable,
          showIcon,
          icon,
          switcherIcon,
          draggable: draggableConfig,
          draggingNodeKey,
          checkable,
          checkStrictly,
          disabled,
          keyEntities,
          dropLevelOffset,
          dropContainerKey,
          dropTargetKey,
          dropPosition,
          dragOverNodeKey,
          indent,
          direction,
          dropIndicatorRender: dropIndicatorRender2,
          loadData,
          filterTreeNode,
          titleRender,
          onNodeClick: this.onNodeClick,
          onNodeDoubleClick: this.onNodeDoubleClick,
          onNodeExpand: this.onNodeExpand,
          onNodeSelect: this.onNodeSelect,
          onNodeCheck: this.onNodeCheck,
          onNodeLoad: this.onNodeLoad,
          onNodeMouseEnter: this.onNodeMouseEnter,
          onNodeMouseLeave: this.onNodeMouseLeave,
          onNodeContextMenu: this.onNodeContextMenu,
          onNodeDragStart: this.onNodeDragStart,
          onNodeDragEnter: this.onNodeDragEnter,
          onNodeDragOver: this.onNodeDragOver,
          onNodeDragLeave: this.onNodeDragLeave,
          onNodeDragEnd: this.onNodeDragEnd,
          onNodeDrop: this.onNodeDrop
        }
      }, /* @__PURE__ */ React.createElement("div", {
        role: "tree",
        className: cn(prefixCls, className, rootClassName, _defineProperty$2(_defineProperty$2(_defineProperty$2({}, "".concat(prefixCls, "-show-line"), showLine), "".concat(prefixCls, "-focused"), focused), "".concat(prefixCls, "-active-focused"), activeKey !== null)),
        style: rootStyle
      }, /* @__PURE__ */ React.createElement(NodeList, _extends({
        ref: this.listRef,
        prefixCls,
        style: style2,
        data: flattenNodes,
        disabled,
        selectable,
        checkable: !!checkable,
        motion: motion2,
        dragging: draggingNodeKey !== null,
        height,
        itemHeight,
        virtual,
        focusable: focusable2,
        focused,
        tabIndex,
        activeItem: this.getActiveItem(),
        onFocus: this.onFocus,
        onBlur: this.onBlur,
        onKeyDown: this.onKeyDown,
        onActiveChange: this.onActiveChange,
        onListChangeStart: this.onListChangeStart,
        onListChangeEnd: this.onListChangeEnd,
        onContextMenu,
        onScroll
      }, this.getTreeNodeRequiredProps(), domProps))));
    }, "render")
  }], [{
    key: "getDerivedStateFromProps",
    value: /* @__PURE__ */ __name(function(props, prevState) {
      var prevProps = prevState.prevProps, newState = {
        prevProps: props
      };
      function needSync(name) {
        return !prevProps && props.hasOwnProperty(name) || prevProps && prevProps[name] !== props[name];
      }
      __name(needSync, "needSync");
      var treeData, fieldNames = prevState.fieldNames;
      if (needSync("fieldNames") && (fieldNames = fillFieldNames(props.fieldNames), newState.fieldNames = fieldNames), needSync("treeData") ? treeData = props.treeData : needSync("children") && (warningOnce(!1, "`children` of Tree is deprecated. Please use `treeData` instead."), treeData = convertTreeToData(props.children)), treeData) {
        newState.treeData = treeData;
        var entitiesMap = convertDataToEntities(treeData, {
          fieldNames
        });
        newState.keyEntities = _objectSpread2$1(_defineProperty$2({}, MOTION_KEY, MotionEntity), entitiesMap.keyEntities), process.env.NODE_ENV !== "production" && warningWithoutKey(treeData, fieldNames);
      }
      var keyEntities = newState.keyEntities || prevState.keyEntities;
      if (needSync("expandedKeys") || prevProps && needSync("autoExpandParent"))
        newState.expandedKeys = props.autoExpandParent || !prevProps && props.defaultExpandParent ? conductExpandParent(props.expandedKeys, keyEntities) : props.expandedKeys;
      else if (!prevProps && props.defaultExpandAll) {
        var cloneKeyEntities = _objectSpread2$1({}, keyEntities);
        delete cloneKeyEntities[MOTION_KEY];
        var nextExpandedKeys = [];
        Object.keys(cloneKeyEntities).forEach(function(key) {
          var entity = cloneKeyEntities[key];
          entity.children && entity.children.length && nextExpandedKeys.push(entity.key);
        }), newState.expandedKeys = nextExpandedKeys;
      } else !prevProps && props.defaultExpandedKeys && (newState.expandedKeys = props.autoExpandParent || props.defaultExpandParent ? conductExpandParent(props.defaultExpandedKeys, keyEntities) : props.defaultExpandedKeys);
      if (newState.expandedKeys || delete newState.expandedKeys, treeData || newState.expandedKeys) {
        var flattenNodes = flattenTreeData(treeData || prevState.treeData, newState.expandedKeys || prevState.expandedKeys, fieldNames);
        newState.flattenNodes = flattenNodes;
      }
      if (props.selectable && (needSync("selectedKeys") ? newState.selectedKeys = calcSelectedKeys(props.selectedKeys, props) : !prevProps && props.defaultSelectedKeys && (newState.selectedKeys = calcSelectedKeys(props.defaultSelectedKeys, props))), props.checkable) {
        var checkedKeyEntity;
        if (needSync("checkedKeys") ? checkedKeyEntity = parseCheckedKeys(props.checkedKeys) || {} : !prevProps && props.defaultCheckedKeys ? checkedKeyEntity = parseCheckedKeys(props.defaultCheckedKeys) || {} : treeData && (checkedKeyEntity = parseCheckedKeys(props.checkedKeys) || {
          checkedKeys: prevState.checkedKeys,
          halfCheckedKeys: prevState.halfCheckedKeys
        }), checkedKeyEntity) {
          var _checkedKeyEntity = checkedKeyEntity, _checkedKeyEntity$che = _checkedKeyEntity.checkedKeys, checkedKeys = _checkedKeyEntity$che === void 0 ? [] : _checkedKeyEntity$che, _checkedKeyEntity$hal = _checkedKeyEntity.halfCheckedKeys, halfCheckedKeys = _checkedKeyEntity$hal === void 0 ? [] : _checkedKeyEntity$hal;
          if (!props.checkStrictly) {
            var conductKeys = conductCheck(checkedKeys, !0, keyEntities);
            checkedKeys = conductKeys.checkedKeys, halfCheckedKeys = conductKeys.halfCheckedKeys;
          }
          newState.checkedKeys = checkedKeys, newState.halfCheckedKeys = halfCheckedKeys;
        }
      }
      return needSync("loadedKeys") && (newState.loadedKeys = props.loadedKeys), newState;
    }, "getDerivedStateFromProps")
  }]), Tree2;
}(React.Component);
_defineProperty$2(Tree$2, "defaultProps", {
  prefixCls: "rc-tree",
  showLine: !1,
  showIcon: !0,
  selectable: !0,
  multiple: !1,
  checkable: !1,
  disabled: !1,
  checkStrictly: !1,
  draggable: !1,
  defaultExpandParent: !0,
  autoExpandParent: !1,
  defaultExpandAll: !1,
  defaultExpandedKeys: [],
  defaultCheckedKeys: [],
  defaultSelectedKeys: [],
  dropIndicatorRender: DropIndicator,
  allowDrop: /* @__PURE__ */ __name(function() {
    return !0;
  }, "allowDrop"),
  expandAction: !1
});
_defineProperty$2(Tree$2, "TreeNode", ContextTreeNode);
const genDirectoryStyle = /* @__PURE__ */ __name((_ref) => {
  let {
    treeCls,
    treeNodeCls,
    directoryNodeSelectedBg,
    directoryNodeSelectedColor,
    motionDurationMid,
    borderRadius,
    controlItemBgHover
  } = _ref;
  return {
    [`${treeCls}${treeCls}-directory ${treeNodeCls}`]: {
      // >>> Title
      [`${treeCls}-node-content-wrapper`]: {
        position: "static",
        [`> *:not(${treeCls}-drop-indicator)`]: {
          position: "relative"
        },
        "&:hover": {
          background: "transparent"
        },
        // Expand interactive area to whole line
        "&:before": {
          position: "absolute",
          inset: 0,
          transition: `background-color ${motionDurationMid}`,
          content: '""',
          borderRadius
        },
        "&:hover:before": {
          background: controlItemBgHover
        }
      },
      [`${treeCls}-switcher, ${treeCls}-checkbox, ${treeCls}-draggable-icon`]: {
        zIndex: 1
      },
      // ============= Selected =============
      "&-selected": {
        [`${treeCls}-switcher, ${treeCls}-draggable-icon`]: {
          color: directoryNodeSelectedColor
        },
        // >>> Title
        [`${treeCls}-node-content-wrapper`]: {
          color: directoryNodeSelectedColor,
          background: "transparent",
          "&:before, &:hover:before": {
            background: directoryNodeSelectedBg
          }
        }
      }
    }
  };
}, "genDirectoryStyle"), treeNodeFX = new Keyframe("ant-tree-node-fx-do-not-use", {
  "0%": {
    opacity: 0
  },
  "100%": {
    opacity: 1
  }
}), getSwitchStyle = /* @__PURE__ */ __name((prefixCls, token2) => ({
  [`.${prefixCls}-switcher-icon`]: {
    display: "inline-block",
    fontSize: 10,
    verticalAlign: "baseline",
    svg: {
      transition: `transform ${token2.motionDurationSlow}`
    }
  }
}), "getSwitchStyle"), getDropIndicatorStyle = /* @__PURE__ */ __name((prefixCls, token2) => ({
  [`.${prefixCls}-drop-indicator`]: {
    position: "absolute",
    // it should displayed over the following node
    zIndex: 1,
    height: 2,
    backgroundColor: token2.colorPrimary,
    borderRadius: 1,
    pointerEvents: "none",
    "&:after": {
      position: "absolute",
      top: -3,
      insetInlineStart: -6,
      width: 8,
      height: 8,
      backgroundColor: "transparent",
      border: `${unit$1(token2.lineWidthBold)} solid ${token2.colorPrimary}`,
      borderRadius: "50%",
      content: '""'
    }
  }
}), "getDropIndicatorStyle"), genBaseStyle$1 = /* @__PURE__ */ __name((prefixCls, token2) => {
  const {
    treeCls,
    treeNodeCls,
    treeNodePadding,
    titleHeight,
    indentSize,
    nodeSelectedBg,
    nodeHoverBg,
    colorTextQuaternary
  } = token2;
  return {
    [treeCls]: Object.assign(Object.assign({}, resetComponent(token2)), {
      background: token2.colorBgContainer,
      borderRadius: token2.borderRadius,
      transition: `background-color ${token2.motionDurationSlow}`,
      "&-rtl": {
        direction: "rtl"
      },
      [`&${treeCls}-rtl ${treeCls}-switcher_close ${treeCls}-switcher-icon svg`]: {
        transform: "rotate(90deg)"
      },
      [`&-focused:not(:hover):not(${treeCls}-active-focused)`]: Object.assign({}, genFocusOutline(token2)),
      // =================== Virtual List ===================
      [`${treeCls}-list-holder-inner`]: {
        alignItems: "flex-start"
      },
      [`&${treeCls}-block-node`]: {
        [`${treeCls}-list-holder-inner`]: {
          alignItems: "stretch",
          // >>> Title
          [`${treeCls}-node-content-wrapper`]: {
            flex: "auto"
          },
          // >>> Drag
          [`${treeNodeCls}.dragging:after`]: {
            position: "absolute",
            inset: 0,
            border: `1px solid ${token2.colorPrimary}`,
            opacity: 0,
            animationName: treeNodeFX,
            animationDuration: token2.motionDurationSlow,
            animationPlayState: "running",
            animationFillMode: "forwards",
            content: '""',
            pointerEvents: "none",
            borderRadius: token2.borderRadius
          }
        }
      },
      // ===================== TreeNode =====================
      [treeNodeCls]: {
        display: "flex",
        alignItems: "flex-start",
        marginBottom: treeNodePadding,
        lineHeight: unit$1(titleHeight),
        position: "relative",
        // 非常重要，避免 drop-indicator 在拖拽过程中闪烁
        "&:before": {
          content: '""',
          position: "absolute",
          zIndex: 1,
          insetInlineStart: 0,
          width: "100%",
          top: "100%",
          height: treeNodePadding
        },
        // Disabled
        [`&-disabled ${treeCls}-node-content-wrapper`]: {
          color: token2.colorTextDisabled,
          cursor: "not-allowed",
          "&:hover": {
            background: "transparent"
          }
        },
        // not disable
        [`&:not(${treeNodeCls}-disabled)`]: {
          // >>> Title
          [`${treeCls}-node-content-wrapper`]: {
            "&:hover": {
              color: token2.nodeHoverColor
            }
          }
        },
        [`&-active ${treeCls}-node-content-wrapper`]: {
          background: token2.controlItemBgHover
        },
        [`&:not(${treeNodeCls}-disabled).filter-node ${treeCls}-title`]: {
          color: token2.colorPrimary,
          fontWeight: 500
        },
        "&-draggable": {
          cursor: "grab",
          [`${treeCls}-draggable-icon`]: {
            // https://github.com/ant-design/ant-design/issues/41915
            flexShrink: 0,
            width: titleHeight,
            textAlign: "center",
            visibility: "visible",
            color: colorTextQuaternary
          },
          [`&${treeNodeCls}-disabled ${treeCls}-draggable-icon`]: {
            visibility: "hidden"
          }
        }
      },
      // >>> Indent
      [`${treeCls}-indent`]: {
        alignSelf: "stretch",
        whiteSpace: "nowrap",
        userSelect: "none",
        "&-unit": {
          display: "inline-block",
          width: indentSize
        }
      },
      // >>> Drag Handler
      [`${treeCls}-draggable-icon`]: {
        visibility: "hidden"
      },
      // Switcher / Checkbox
      [`${treeCls}-switcher, ${treeCls}-checkbox`]: {
        marginInlineEnd: token2.calc(token2.calc(titleHeight).sub(token2.controlInteractiveSize)).div(2).equal()
      },
      // >>> Switcher
      [`${treeCls}-switcher`]: Object.assign(Object.assign({}, getSwitchStyle(prefixCls, token2)), {
        position: "relative",
        flex: "none",
        alignSelf: "stretch",
        width: titleHeight,
        textAlign: "center",
        cursor: "pointer",
        userSelect: "none",
        transition: `all ${token2.motionDurationSlow}`,
        "&-noop": {
          cursor: "unset"
        },
        "&:before": {
          pointerEvents: "none",
          content: '""',
          width: titleHeight,
          height: titleHeight,
          position: "absolute",
          left: {
            _skip_check_: !0,
            value: 0
          },
          top: 0,
          borderRadius: token2.borderRadius,
          transition: `all ${token2.motionDurationSlow}`
        },
        [`&:not(${treeCls}-switcher-noop):hover:before`]: {
          backgroundColor: token2.colorBgTextHover
        },
        [`&_close ${treeCls}-switcher-icon svg`]: {
          transform: "rotate(-90deg)"
        },
        "&-loading-icon": {
          color: token2.colorPrimary
        },
        "&-leaf-line": {
          position: "relative",
          zIndex: 1,
          display: "inline-block",
          width: "100%",
          height: "100%",
          // https://github.com/ant-design/ant-design/issues/31884
          "&:before": {
            position: "absolute",
            top: 0,
            insetInlineEnd: token2.calc(titleHeight).div(2).equal(),
            bottom: token2.calc(treeNodePadding).mul(-1).equal(),
            marginInlineStart: -1,
            borderInlineEnd: `1px solid ${token2.colorBorder}`,
            content: '""'
          },
          "&:after": {
            position: "absolute",
            width: token2.calc(token2.calc(titleHeight).div(2).equal()).mul(0.8).equal(),
            height: token2.calc(titleHeight).div(2).equal(),
            borderBottom: `1px solid ${token2.colorBorder}`,
            content: '""'
          }
        }
      }),
      // >>> Title
      // add `${treeCls}-checkbox + span` to cover checkbox `${checkboxCls} + span`
      [`${treeCls}-node-content-wrapper`]: Object.assign(Object.assign({
        position: "relative",
        minHeight: titleHeight,
        paddingBlock: 0,
        paddingInline: token2.paddingXS,
        background: "transparent",
        borderRadius: token2.borderRadius,
        cursor: "pointer",
        transition: `all ${token2.motionDurationMid}, border 0s, line-height 0s, box-shadow 0s`
      }, getDropIndicatorStyle(prefixCls, token2)), {
        "&:hover": {
          backgroundColor: nodeHoverBg
        },
        [`&${treeCls}-node-selected`]: {
          color: token2.nodeSelectedColor,
          backgroundColor: nodeSelectedBg
        },
        // Icon
        [`${treeCls}-iconEle`]: {
          display: "inline-block",
          width: titleHeight,
          height: titleHeight,
          textAlign: "center",
          verticalAlign: "top",
          "&:empty": {
            display: "none"
          }
        }
      }),
      // https://github.com/ant-design/ant-design/issues/28217
      [`${treeCls}-unselectable ${treeCls}-node-content-wrapper:hover`]: {
        backgroundColor: "transparent"
      },
      [`${treeNodeCls}.drop-container > [draggable]`]: {
        boxShadow: `0 0 0 2px ${token2.colorPrimary}`
      },
      // ==================== Show Line =====================
      "&-show-line": {
        // ================ Indent lines ================
        [`${treeCls}-indent-unit`]: {
          position: "relative",
          height: "100%",
          "&:before": {
            position: "absolute",
            top: 0,
            insetInlineEnd: token2.calc(titleHeight).div(2).equal(),
            bottom: token2.calc(treeNodePadding).mul(-1).equal(),
            borderInlineEnd: `1px solid ${token2.colorBorder}`,
            content: '""'
          },
          "&-end:before": {
            display: "none"
          }
        },
        // ============== Cover Background ==============
        [`${treeCls}-switcher`]: {
          background: "transparent",
          "&-line-icon": {
            // https://github.com/ant-design/ant-design/issues/32813
            verticalAlign: "-0.15em"
          }
        }
      },
      [`${treeNodeCls}-leaf-last ${treeCls}-switcher-leaf-line:before`]: {
        top: "auto !important",
        bottom: "auto !important",
        height: `${unit$1(token2.calc(titleHeight).div(2).equal())} !important`
      }
    })
  };
}, "genBaseStyle$1"), genTreeStyle = /* @__PURE__ */ __name((prefixCls, token2) => {
  const treeCls = `.${prefixCls}`, treeNodeCls = `${treeCls}-treenode`, treeNodePadding = token2.calc(token2.paddingXS).div(2).equal(), treeToken = merge(token2, {
    treeCls,
    treeNodeCls,
    treeNodePadding
  });
  return [
    // Basic
    genBaseStyle$1(prefixCls, treeToken),
    // Directory
    genDirectoryStyle(treeToken)
  ];
}, "genTreeStyle"), initComponentToken = /* @__PURE__ */ __name((token2) => {
  const {
    controlHeightSM,
    controlItemBgHover,
    controlItemBgActive
  } = token2, titleHeight = controlHeightSM;
  return {
    titleHeight,
    indentSize: titleHeight,
    nodeHoverBg: controlItemBgHover,
    nodeHoverColor: token2.colorText,
    nodeSelectedBg: controlItemBgActive,
    nodeSelectedColor: token2.colorText
  };
}, "initComponentToken"), prepareComponentToken$4 = /* @__PURE__ */ __name((token2) => {
  const {
    colorTextLightSolid,
    colorPrimary
  } = token2;
  return Object.assign(Object.assign({}, initComponentToken(token2)), {
    directoryNodeSelectedColor: colorTextLightSolid,
    directoryNodeSelectedBg: colorPrimary
  });
}, "prepareComponentToken$4"), useStyle$4 = genStyleHooks("Tree", (token2, _ref) => {
  let {
    prefixCls
  } = _ref;
  return [{
    [token2.componentCls]: getStyle(`${prefixCls}-checkbox`, token2)
  }, genTreeStyle(prefixCls, token2), genCollapseMotion(token2)];
}, prepareComponentToken$4), offset = 4;
function dropIndicatorRender(props) {
  const {
    dropPosition,
    dropLevelOffset,
    prefixCls,
    indent,
    direction = "ltr"
  } = props, startPosition = direction === "ltr" ? "left" : "right", endPosition = direction === "ltr" ? "right" : "left", style2 = {
    [startPosition]: -dropLevelOffset * indent + offset,
    [endPosition]: 0
  };
  switch (dropPosition) {
    case -1:
      style2.top = -3;
      break;
    case 1:
      style2.bottom = -3;
      break;
    default:
      style2.bottom = -3, style2[startPosition] = indent + offset;
      break;
  }
  return /* @__PURE__ */ React__default.createElement("div", {
    style: style2,
    className: `${prefixCls}-drop-indicator`
  });
}
__name(dropIndicatorRender, "dropIndicatorRender");
const SwitcherIconCom = /* @__PURE__ */ __name((props) => {
  const {
    prefixCls,
    switcherIcon,
    treeNodeProps,
    showLine,
    switcherLoadingIcon
  } = props, {
    isLeaf,
    expanded,
    loading
  } = treeNodeProps;
  if (loading)
    return /* @__PURE__ */ React.isValidElement(switcherLoadingIcon) ? switcherLoadingIcon : /* @__PURE__ */ React.createElement(RefIcon$z, {
      className: `${prefixCls}-switcher-loading-icon`
    });
  let showLeafIcon;
  if (showLine && typeof showLine == "object" && (showLeafIcon = showLine.showLeafIcon), isLeaf) {
    if (!showLine)
      return null;
    if (typeof showLeafIcon != "boolean" && showLeafIcon) {
      const leafIcon = typeof showLeafIcon == "function" ? showLeafIcon(treeNodeProps) : showLeafIcon, leafCls = `${prefixCls}-switcher-line-custom-icon`;
      return /* @__PURE__ */ React.isValidElement(leafIcon) ? cloneElement(leafIcon, {
        className: cn(leafIcon.props.className || "", leafCls)
      }) : leafIcon;
    }
    return showLeafIcon ? /* @__PURE__ */ React.createElement(RefIcon$9, {
      className: `${prefixCls}-switcher-line-icon`
    }) : /* @__PURE__ */ React.createElement("span", {
      className: `${prefixCls}-switcher-leaf-line`
    });
  }
  const switcherCls = `${prefixCls}-switcher-icon`, switcher = typeof switcherIcon == "function" ? switcherIcon(treeNodeProps) : switcherIcon;
  return /* @__PURE__ */ React.isValidElement(switcher) ? cloneElement(switcher, {
    className: cn(switcher.props.className || "", switcherCls)
  }) : switcher !== void 0 ? switcher : showLine ? expanded ? /* @__PURE__ */ React.createElement(RefIcon$3, {
    className: `${prefixCls}-switcher-line-icon`
  }) : /* @__PURE__ */ React.createElement(RefIcon, {
    className: `${prefixCls}-switcher-line-icon`
  }) : /* @__PURE__ */ React.createElement(RefIcon$h, {
    className: switcherCls
  });
}, "SwitcherIconCom"), Tree$1 = /* @__PURE__ */ React__default.forwardRef((props, ref) => {
  var _a;
  const {
    getPrefixCls,
    direction,
    virtual,
    tree
  } = React__default.useContext(ConfigContext), {
    prefixCls: customizePrefixCls,
    className,
    showIcon = !1,
    showLine,
    switcherIcon,
    switcherLoadingIcon,
    blockNode = !1,
    children,
    checkable = !1,
    selectable = !0,
    draggable,
    motion: customMotion,
    style: style2
  } = props, prefixCls = getPrefixCls("tree", customizePrefixCls), rootPrefixCls = getPrefixCls(), motion2 = customMotion ?? Object.assign(Object.assign({}, initCollapseMotion(rootPrefixCls)), {
    motionAppear: !1
  }), newProps = Object.assign(Object.assign({}, props), {
    checkable,
    selectable,
    showIcon,
    motion: motion2,
    blockNode,
    showLine: !!showLine,
    dropIndicatorRender
  }), [wrapCSSVar, hashId, cssVarCls] = useStyle$4(prefixCls), [, token2] = useToken(), itemHeight = token2.paddingXS / 2 + (((_a = token2.Tree) === null || _a === void 0 ? void 0 : _a.titleHeight) || token2.controlHeightSM), draggableConfig = React__default.useMemo(() => {
    if (!draggable)
      return !1;
    let mergedDraggable = {};
    switch (typeof draggable) {
      case "function":
        mergedDraggable.nodeDraggable = draggable;
        break;
      case "object":
        mergedDraggable = Object.assign({}, draggable);
        break;
    }
    return mergedDraggable.icon !== !1 && (mergedDraggable.icon = mergedDraggable.icon || /* @__PURE__ */ React__default.createElement(RefIcon$4, null)), mergedDraggable;
  }, [draggable]), renderSwitcherIcon = /* @__PURE__ */ __name((nodeProps) => /* @__PURE__ */ React__default.createElement(SwitcherIconCom, {
    prefixCls,
    switcherIcon,
    switcherLoadingIcon,
    treeNodeProps: nodeProps,
    showLine
  }), "renderSwitcherIcon");
  return wrapCSSVar(
    // @ts-ignore
    /* @__PURE__ */ React__default.createElement(Tree$2, Object.assign({
      itemHeight,
      ref,
      virtual
    }, newProps, {
      // newProps may contain style so declare style below it
      style: Object.assign(Object.assign({}, tree == null ? void 0 : tree.style), style2),
      prefixCls,
      className: cn({
        [`${prefixCls}-icon-hide`]: !showIcon,
        [`${prefixCls}-block-node`]: blockNode,
        [`${prefixCls}-unselectable`]: !selectable,
        [`${prefixCls}-rtl`]: direction === "rtl"
      }, tree == null ? void 0 : tree.className, className, hashId, cssVarCls),
      direction,
      checkable: checkable && /* @__PURE__ */ React__default.createElement("span", {
        className: `${prefixCls}-checkbox-inner`
      }),
      selectable,
      switcherIcon: renderSwitcherIcon,
      draggable: draggableConfig
    }), children)
  );
});
process.env.NODE_ENV !== "production" && (Tree$1.displayName = "Tree");
const RECORD_NONE = 0, RECORD_START = 1, RECORD_END = 2;
function traverseNodesKey(treeData, callback, fieldNames) {
  const {
    key: fieldKey,
    children: fieldChildren
  } = fieldNames;
  function processNode(dataNode) {
    const key = dataNode[fieldKey], children = dataNode[fieldChildren];
    callback(key, dataNode) !== !1 && traverseNodesKey(children || [], callback, fieldNames);
  }
  __name(processNode, "processNode"), treeData.forEach(processNode);
}
__name(traverseNodesKey, "traverseNodesKey");
function calcRangeKeys(_ref) {
  let {
    treeData,
    expandedKeys,
    startKey,
    endKey,
    fieldNames
  } = _ref;
  const keys2 = [];
  let record = RECORD_NONE;
  if (startKey && startKey === endKey)
    return [startKey];
  if (!startKey || !endKey)
    return [];
  function matchKey(key) {
    return key === startKey || key === endKey;
  }
  return __name(matchKey, "matchKey"), traverseNodesKey(treeData, (key) => {
    if (record === RECORD_END)
      return !1;
    if (matchKey(key)) {
      if (keys2.push(key), record === RECORD_NONE)
        record = RECORD_START;
      else if (record === RECORD_START)
        return record = RECORD_END, !1;
    } else record === RECORD_START && keys2.push(key);
    return expandedKeys.includes(key);
  }, fillFieldNames(fieldNames)), keys2;
}
__name(calcRangeKeys, "calcRangeKeys");
function convertDirectoryKeysToNodes(treeData, keys2, fieldNames) {
  const restKeys = _toConsumableArray(keys2), nodes = [];
  return traverseNodesKey(treeData, (key, node2) => {
    const index2 = restKeys.indexOf(key);
    return index2 !== -1 && (nodes.push(node2), restKeys.splice(index2, 1)), !!restKeys.length;
  }, fillFieldNames(fieldNames)), nodes;
}
__name(convertDirectoryKeysToNodes, "convertDirectoryKeysToNodes");
var __rest$8 = function(s, e2) {
  var t2 = {};
  for (var p in s) Object.prototype.hasOwnProperty.call(s, p) && e2.indexOf(p) < 0 && (t2[p] = s[p]);
  if (s != null && typeof Object.getOwnPropertySymbols == "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++)
    e2.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]) && (t2[p[i]] = s[p[i]]);
  return t2;
};
function getIcon(props) {
  const {
    isLeaf,
    expanded
  } = props;
  return isLeaf ? /* @__PURE__ */ React.createElement(RefIcon$9, null) : expanded ? /* @__PURE__ */ React.createElement(RefIcon$6, null) : /* @__PURE__ */ React.createElement(RefIcon$5, null);
}
__name(getIcon, "getIcon");
function getTreeData(_ref) {
  let {
    treeData,
    children
  } = _ref;
  return treeData || convertTreeToData(children);
}
__name(getTreeData, "getTreeData");
const DirectoryTree = /* @__PURE__ */ __name((_a, ref) => {
  var {
    defaultExpandAll,
    defaultExpandParent,
    defaultExpandedKeys
  } = _a, props = __rest$8(_a, ["defaultExpandAll", "defaultExpandParent", "defaultExpandedKeys"]);
  const lastSelectedKey = React.useRef(null), cachedSelectedKeys = React.useRef(null), getInitExpandedKeys = /* @__PURE__ */ __name(() => {
    const {
      keyEntities
    } = convertDataToEntities(getTreeData(props));
    let initExpandedKeys;
    return defaultExpandAll ? initExpandedKeys = Object.keys(keyEntities) : defaultExpandParent ? initExpandedKeys = conductExpandParent(props.expandedKeys || defaultExpandedKeys || [], keyEntities) : initExpandedKeys = props.expandedKeys || defaultExpandedKeys || [], initExpandedKeys;
  }, "getInitExpandedKeys"), [selectedKeys, setSelectedKeys] = React.useState(props.selectedKeys || props.defaultSelectedKeys || []), [expandedKeys, setExpandedKeys] = React.useState(() => getInitExpandedKeys());
  React.useEffect(() => {
    "selectedKeys" in props && setSelectedKeys(props.selectedKeys);
  }, [props.selectedKeys]), React.useEffect(() => {
    "expandedKeys" in props && setExpandedKeys(props.expandedKeys);
  }, [props.expandedKeys]);
  const onExpand = /* @__PURE__ */ __name((keys2, info) => {
    var _a2;
    return "expandedKeys" in props || setExpandedKeys(keys2), (_a2 = props.onExpand) === null || _a2 === void 0 ? void 0 : _a2.call(props, keys2, info);
  }, "onExpand"), onSelect = /* @__PURE__ */ __name((keys2, event) => {
    var _a2;
    const {
      multiple,
      fieldNames
    } = props, {
      node: node2,
      nativeEvent
    } = event, {
      key = ""
    } = node2, treeData = getTreeData(props), newEvent = Object.assign(Object.assign({}, event), {
      selected: !0
    }), ctrlPick = (nativeEvent == null ? void 0 : nativeEvent.ctrlKey) || (nativeEvent == null ? void 0 : nativeEvent.metaKey), shiftPick = nativeEvent == null ? void 0 : nativeEvent.shiftKey;
    let newSelectedKeys;
    multiple && ctrlPick ? (newSelectedKeys = keys2, lastSelectedKey.current = key, cachedSelectedKeys.current = newSelectedKeys, newEvent.selectedNodes = convertDirectoryKeysToNodes(treeData, newSelectedKeys, fieldNames)) : multiple && shiftPick ? (newSelectedKeys = Array.from(new Set([].concat(_toConsumableArray(cachedSelectedKeys.current || []), _toConsumableArray(calcRangeKeys({
      treeData,
      expandedKeys,
      startKey: key,
      endKey: lastSelectedKey.current,
      fieldNames
    }))))), newEvent.selectedNodes = convertDirectoryKeysToNodes(treeData, newSelectedKeys, fieldNames)) : (newSelectedKeys = [key], lastSelectedKey.current = key, cachedSelectedKeys.current = newSelectedKeys, newEvent.selectedNodes = convertDirectoryKeysToNodes(treeData, newSelectedKeys, fieldNames)), (_a2 = props.onSelect) === null || _a2 === void 0 || _a2.call(props, newSelectedKeys, newEvent), "selectedKeys" in props || setSelectedKeys(newSelectedKeys);
  }, "onSelect"), {
    getPrefixCls,
    direction
  } = React.useContext(ConfigContext), {
    prefixCls: customizePrefixCls,
    className,
    showIcon = !0,
    expandAction = "click"
  } = props, otherProps = __rest$8(props, ["prefixCls", "className", "showIcon", "expandAction"]), prefixCls = getPrefixCls("tree", customizePrefixCls), connectClassName = cn(`${prefixCls}-directory`, {
    [`${prefixCls}-directory-rtl`]: direction === "rtl"
  }, className);
  return /* @__PURE__ */ React.createElement(Tree$1, Object.assign({
    icon: getIcon,
    ref,
    blockNode: !0
  }, otherProps, {
    showIcon,
    expandAction,
    prefixCls,
    className: connectClassName,
    expandedKeys,
    selectedKeys,
    onSelect,
    onExpand
  }));
}, "DirectoryTree"), ForwardDirectoryTree = /* @__PURE__ */ React.forwardRef(DirectoryTree);
process.env.NODE_ENV !== "production" && (ForwardDirectoryTree.displayName = "DirectoryTree");
const Tree = Tree$1;
Tree.DirectoryTree = ForwardDirectoryTree;
Tree.TreeNode = ContextTreeNode;
const FilterSearch = /* @__PURE__ */ __name((props) => {
  const {
    value,
    filterSearch,
    tablePrefixCls,
    locale: locale2,
    onChange
  } = props;
  return filterSearch ? /* @__PURE__ */ React.createElement("div", {
    className: `${tablePrefixCls}-filter-dropdown-search`
  }, /* @__PURE__ */ React.createElement(Input$1, {
    prefix: /* @__PURE__ */ React.createElement(RefIcon$v, null),
    placeholder: locale2.filterSearchPlaceholder,
    onChange,
    value,
    // for skip min-width of input
    htmlSize: 1,
    className: `${tablePrefixCls}-filter-dropdown-search-input`
  })) : null;
}, "FilterSearch"), onKeyDown = /* @__PURE__ */ __name((event) => {
  const {
    keyCode
  } = event;
  keyCode === KeyCode.ENTER && event.stopPropagation();
}, "onKeyDown"), FilterDropdownMenuWrapper = /* @__PURE__ */ React.forwardRef((props, ref) => /* @__PURE__ */ React.createElement("div", {
  className: props.className,
  onClick: /* @__PURE__ */ __name((e2) => e2.stopPropagation(), "onClick"),
  onKeyDown,
  ref
}, props.children));
process.env.NODE_ENV !== "production" && (FilterDropdownMenuWrapper.displayName = "FilterDropdownMenuWrapper");
function flattenKeys$1(filters) {
  let keys2 = [];
  return (filters || []).forEach((_ref) => {
    let {
      value,
      children
    } = _ref;
    keys2.push(value), children && (keys2 = [].concat(_toConsumableArray(keys2), _toConsumableArray(flattenKeys$1(children))));
  }), keys2;
}
__name(flattenKeys$1, "flattenKeys$1");
function hasSubMenu(filters) {
  return filters.some((_ref2) => {
    let {
      children
    } = _ref2;
    return children;
  });
}
__name(hasSubMenu, "hasSubMenu");
function searchValueMatched(searchValue, text) {
  return typeof text == "string" || typeof text == "number" ? text == null ? void 0 : text.toString().toLowerCase().includes(searchValue.trim().toLowerCase()) : !1;
}
__name(searchValueMatched, "searchValueMatched");
function renderFilterItems(_ref3) {
  let {
    filters,
    prefixCls,
    filteredKeys,
    filterMultiple,
    searchValue,
    filterSearch
  } = _ref3;
  return filters.map((filter2, index2) => {
    const key = String(filter2.value);
    if (filter2.children)
      return {
        key: key || index2,
        label: filter2.text,
        popupClassName: `${prefixCls}-dropdown-submenu`,
        children: renderFilterItems({
          filters: filter2.children,
          prefixCls,
          filteredKeys,
          filterMultiple,
          searchValue,
          filterSearch
        })
      };
    const Component2 = filterMultiple ? Checkbox$1 : Radio, item = {
      key: filter2.value !== void 0 ? key : index2,
      label: /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement(Component2, {
        checked: filteredKeys.includes(key)
      }), /* @__PURE__ */ React.createElement("span", null, filter2.text))
    };
    return searchValue.trim() ? typeof filterSearch == "function" ? filterSearch(searchValue, filter2) ? item : null : searchValueMatched(searchValue, filter2.text) ? item : null : item;
  });
}
__name(renderFilterItems, "renderFilterItems");
function wrapStringListType(keys2) {
  return keys2 || [];
}
__name(wrapStringListType, "wrapStringListType");
const FilterDropdown = /* @__PURE__ */ __name((props) => {
  var _a, _b, _c, _d;
  const {
    tablePrefixCls,
    prefixCls,
    column: column2,
    dropdownPrefixCls,
    columnKey,
    filterOnClose,
    filterMultiple,
    filterMode = "menu",
    filterSearch = !1,
    filterState,
    triggerFilter,
    locale: locale2,
    children,
    getPopupContainer,
    rootClassName
  } = props, {
    filterResetToDefaultFilteredValue,
    defaultFilteredValue,
    filterDropdownProps = {},
    // Deprecated
    filterDropdownOpen,
    filterDropdownVisible,
    onFilterDropdownVisibleChange,
    onFilterDropdownOpenChange
  } = column2, [visible, setVisible] = React.useState(!1), filtered = !!(filterState && (!((_a = filterState.filteredKeys) === null || _a === void 0) && _a.length || filterState.forceFiltered)), triggerVisible = /* @__PURE__ */ __name((newVisible) => {
    var _a2;
    setVisible(newVisible), (_a2 = filterDropdownProps.onOpenChange) === null || _a2 === void 0 || _a2.call(filterDropdownProps, newVisible), onFilterDropdownOpenChange == null || onFilterDropdownOpenChange(newVisible), onFilterDropdownVisibleChange == null || onFilterDropdownVisibleChange(newVisible);
  }, "triggerVisible");
  if (process.env.NODE_ENV !== "production") {
    const warning3 = devUseWarning("Table");
    [["filterDropdownOpen", "filterDropdownProps.open"], ["filterDropdownVisible", "filterDropdownProps.open"], ["onFilterDropdownOpenChange", "filterDropdownProps.onOpenChange"], ["onFilterDropdownVisibleChange", "filterDropdownProps.onOpenChange"]].forEach((_ref4) => {
      let [deprecatedName, newName] = _ref4;
      warning3.deprecated(!(deprecatedName in column2), deprecatedName, newName);
    });
  }
  const mergedVisible = (_d = (_c = (_b = filterDropdownProps.open) !== null && _b !== void 0 ? _b : filterDropdownOpen) !== null && _c !== void 0 ? _c : filterDropdownVisible) !== null && _d !== void 0 ? _d : visible, propFilteredKeys = filterState == null ? void 0 : filterState.filteredKeys, [getFilteredKeysSync, setFilteredKeysSync] = useSyncState(wrapStringListType(propFilteredKeys)), onSelectKeys = /* @__PURE__ */ __name((_ref5) => {
    let {
      selectedKeys
    } = _ref5;
    setFilteredKeysSync(selectedKeys);
  }, "onSelectKeys"), onCheck = /* @__PURE__ */ __name((keys2, _ref6) => {
    let {
      node: node2,
      checked
    } = _ref6;
    onSelectKeys(filterMultiple ? {
      selectedKeys: keys2
    } : {
      selectedKeys: checked && node2.key ? [node2.key] : []
    });
  }, "onCheck");
  React.useEffect(() => {
    visible && onSelectKeys({
      selectedKeys: wrapStringListType(propFilteredKeys)
    });
  }, [propFilteredKeys]);
  const [openKeys, setOpenKeys] = React.useState([]), onOpenChange = /* @__PURE__ */ __name((keys2) => {
    setOpenKeys(keys2);
  }, "onOpenChange"), [searchValue, setSearchValue] = React.useState(""), onSearch = /* @__PURE__ */ __name((e2) => {
    const {
      value
    } = e2.target;
    setSearchValue(value);
  }, "onSearch");
  React.useEffect(() => {
    visible || setSearchValue("");
  }, [visible]);
  const internalTriggerFilter = /* @__PURE__ */ __name((keys2) => {
    const mergedKeys = keys2 != null && keys2.length ? keys2 : null;
    if (mergedKeys === null && (!filterState || !filterState.filteredKeys) || isEqual(mergedKeys, filterState == null ? void 0 : filterState.filteredKeys, !0))
      return null;
    triggerFilter({
      column: column2,
      key: columnKey,
      filteredKeys: mergedKeys
    });
  }, "internalTriggerFilter"), onConfirm = /* @__PURE__ */ __name(() => {
    triggerVisible(!1), internalTriggerFilter(getFilteredKeysSync());
  }, "onConfirm"), onReset = /* @__PURE__ */ __name(function() {
    let {
      confirm,
      closeDropdown
    } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {
      confirm: !1,
      closeDropdown: !1
    };
    confirm && internalTriggerFilter([]), closeDropdown && triggerVisible(!1), setSearchValue(""), setFilteredKeysSync(filterResetToDefaultFilteredValue ? (defaultFilteredValue || []).map((key) => String(key)) : []);
  }, "onReset"), doFilter = /* @__PURE__ */ __name(function() {
    let {
      closeDropdown
    } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {
      closeDropdown: !0
    };
    closeDropdown && triggerVisible(!1), internalTriggerFilter(getFilteredKeysSync());
  }, "doFilter"), onVisibleChange = /* @__PURE__ */ __name((newVisible, info) => {
    info.source === "trigger" && (newVisible && propFilteredKeys !== void 0 && setFilteredKeysSync(wrapStringListType(propFilteredKeys)), triggerVisible(newVisible), !newVisible && !column2.filterDropdown && filterOnClose && onConfirm());
  }, "onVisibleChange"), dropdownMenuClass = cn({
    [`${dropdownPrefixCls}-menu-without-submenu`]: !hasSubMenu(column2.filters || [])
  }), onCheckAll = /* @__PURE__ */ __name((e2) => {
    if (e2.target.checked) {
      const allFilterKeys = flattenKeys$1(column2 == null ? void 0 : column2.filters).map((key) => String(key));
      setFilteredKeysSync(allFilterKeys);
    } else
      setFilteredKeysSync([]);
  }, "onCheckAll"), getTreeData2 = /* @__PURE__ */ __name((_ref7) => {
    let {
      filters
    } = _ref7;
    return (filters || []).map((filter2, index2) => {
      const key = String(filter2.value), item = {
        title: filter2.text,
        key: filter2.value !== void 0 ? key : String(index2)
      };
      return filter2.children && (item.children = getTreeData2({
        filters: filter2.children
      })), item;
    });
  }, "getTreeData"), getFilterData2 = /* @__PURE__ */ __name((node2) => {
    var _a2;
    return Object.assign(Object.assign({}, node2), {
      text: node2.title,
      value: node2.key,
      children: ((_a2 = node2.children) === null || _a2 === void 0 ? void 0 : _a2.map((item) => getFilterData2(item))) || []
    });
  }, "getFilterData");
  let dropdownContent;
  const {
    direction,
    renderEmpty
  } = React.useContext(ConfigContext);
  if (typeof column2.filterDropdown == "function")
    dropdownContent = column2.filterDropdown({
      prefixCls: `${dropdownPrefixCls}-custom`,
      setSelectedKeys: /* @__PURE__ */ __name((selectedKeys) => onSelectKeys({
        selectedKeys
      }), "setSelectedKeys"),
      selectedKeys: getFilteredKeysSync(),
      confirm: doFilter,
      clearFilters: onReset,
      filters: column2.filters,
      visible: mergedVisible,
      close: /* @__PURE__ */ __name(() => {
        triggerVisible(!1);
      }, "close")
    });
  else if (column2.filterDropdown)
    dropdownContent = column2.filterDropdown;
  else {
    const selectedKeys = getFilteredKeysSync() || [], getFilterComponent = /* @__PURE__ */ __name(() => {
      var _a2;
      const empty2 = (_a2 = renderEmpty == null ? void 0 : renderEmpty("Table.filter")) !== null && _a2 !== void 0 ? _a2 : /* @__PURE__ */ React.createElement(Empty$1, {
        image: Empty$1.PRESENTED_IMAGE_SIMPLE,
        description: locale2.filterEmptyText,
        imageStyle: {
          height: 24
        },
        style: {
          margin: 0,
          padding: "16px 0"
        }
      });
      if ((column2.filters || []).length === 0)
        return empty2;
      if (filterMode === "tree")
        return /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement(FilterSearch, {
          filterSearch,
          value: searchValue,
          onChange: onSearch,
          tablePrefixCls,
          locale: locale2
        }), /* @__PURE__ */ React.createElement("div", {
          className: `${tablePrefixCls}-filter-dropdown-tree`
        }, filterMultiple ? /* @__PURE__ */ React.createElement(Checkbox$1, {
          checked: selectedKeys.length === flattenKeys$1(column2.filters).length,
          indeterminate: selectedKeys.length > 0 && selectedKeys.length < flattenKeys$1(column2.filters).length,
          className: `${tablePrefixCls}-filter-dropdown-checkall`,
          onChange: onCheckAll
        }, locale2.filterCheckall) : null, /* @__PURE__ */ React.createElement(Tree, {
          checkable: !0,
          selectable: !1,
          blockNode: !0,
          multiple: filterMultiple,
          checkStrictly: !filterMultiple,
          className: `${dropdownPrefixCls}-menu`,
          onCheck,
          checkedKeys: selectedKeys,
          selectedKeys,
          showIcon: !1,
          treeData: getTreeData2({
            filters: column2.filters
          }),
          autoExpandParent: !0,
          defaultExpandAll: !0,
          filterTreeNode: searchValue.trim() ? (node2) => typeof filterSearch == "function" ? filterSearch(searchValue, getFilterData2(node2)) : searchValueMatched(searchValue, node2.title) : void 0
        })));
      const items = renderFilterItems({
        filters: column2.filters || [],
        filterSearch,
        prefixCls,
        filteredKeys: getFilteredKeysSync(),
        filterMultiple,
        searchValue
      }), isEmpty2 = items.every((item) => item === null);
      return /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement(FilterSearch, {
        filterSearch,
        value: searchValue,
        onChange: onSearch,
        tablePrefixCls,
        locale: locale2
      }), isEmpty2 ? empty2 : /* @__PURE__ */ React.createElement(Menu, {
        selectable: !0,
        multiple: filterMultiple,
        prefixCls: `${dropdownPrefixCls}-menu`,
        className: dropdownMenuClass,
        onSelect: onSelectKeys,
        onDeselect: onSelectKeys,
        selectedKeys,
        getPopupContainer,
        openKeys,
        onOpenChange,
        items
      }));
    }, "getFilterComponent"), getResetDisabled = /* @__PURE__ */ __name(() => filterResetToDefaultFilteredValue ? isEqual((defaultFilteredValue || []).map((key) => String(key)), selectedKeys, !0) : selectedKeys.length === 0, "getResetDisabled");
    dropdownContent = /* @__PURE__ */ React.createElement(React.Fragment, null, getFilterComponent(), /* @__PURE__ */ React.createElement("div", {
      className: `${prefixCls}-dropdown-btns`
    }, /* @__PURE__ */ React.createElement(Button$2, {
      type: "link",
      size: "small",
      disabled: getResetDisabled(),
      onClick: /* @__PURE__ */ __name(() => onReset(), "onClick")
    }, locale2.filterReset), /* @__PURE__ */ React.createElement(Button$2, {
      type: "primary",
      size: "small",
      onClick: onConfirm
    }, locale2.filterConfirm)));
  }
  column2.filterDropdown && (dropdownContent = /* @__PURE__ */ React.createElement(OverrideProvider, {
    selectable: void 0
  }, dropdownContent)), dropdownContent = /* @__PURE__ */ React.createElement(FilterDropdownMenuWrapper, {
    className: `${prefixCls}-dropdown`
  }, dropdownContent);
  const mergedDropdownProps = extendsObject({
    trigger: ["click"],
    placement: direction === "rtl" ? "bottomLeft" : "bottomRight",
    children: (/* @__PURE__ */ __name(() => {
      let filterIcon;
      return typeof column2.filterIcon == "function" ? filterIcon = column2.filterIcon(filtered) : column2.filterIcon ? filterIcon = column2.filterIcon : filterIcon = /* @__PURE__ */ React.createElement(RefIcon$7, null), /* @__PURE__ */ React.createElement("span", {
        role: "button",
        tabIndex: -1,
        className: cn(`${prefixCls}-trigger`, {
          active: filtered
        }),
        onClick: /* @__PURE__ */ __name((e2) => {
          e2.stopPropagation();
        }, "onClick")
      }, filterIcon);
    }, "getDropdownTrigger"))(),
    getPopupContainer
  }, Object.assign(Object.assign({}, filterDropdownProps), {
    rootClassName: cn(rootClassName, filterDropdownProps.rootClassName),
    open: mergedVisible,
    onOpenChange: onVisibleChange,
    dropdownRender: /* @__PURE__ */ __name(() => typeof (filterDropdownProps == null ? void 0 : filterDropdownProps.dropdownRender) == "function" ? filterDropdownProps.dropdownRender(dropdownContent) : dropdownContent, "dropdownRender")
  }));
  return /* @__PURE__ */ React.createElement("div", {
    className: `${prefixCls}-column`
  }, /* @__PURE__ */ React.createElement("span", {
    className: `${tablePrefixCls}-column-title`
  }, children), /* @__PURE__ */ React.createElement(Dropdown, Object.assign({}, mergedDropdownProps)));
}, "FilterDropdown"), collectFilterStates = /* @__PURE__ */ __name((columns, init, pos) => {
  let filterStates = [];
  return (columns || []).forEach((column2, index2) => {
    var _a;
    const columnPos = getColumnPos(index2, pos);
    if (column2.filters || "filterDropdown" in column2 || "onFilter" in column2)
      if ("filteredValue" in column2) {
        let filteredValues = column2.filteredValue;
        "filterDropdown" in column2 || (filteredValues = (_a = filteredValues == null ? void 0 : filteredValues.map(String)) !== null && _a !== void 0 ? _a : filteredValues), filterStates.push({
          column: column2,
          key: getColumnKey(column2, columnPos),
          filteredKeys: filteredValues,
          forceFiltered: column2.filtered
        });
      } else
        filterStates.push({
          column: column2,
          key: getColumnKey(column2, columnPos),
          filteredKeys: init && column2.defaultFilteredValue ? column2.defaultFilteredValue : void 0,
          forceFiltered: column2.filtered
        });
    "children" in column2 && (filterStates = [].concat(_toConsumableArray(filterStates), _toConsumableArray(collectFilterStates(column2.children, init, columnPos))));
  }), filterStates;
}, "collectFilterStates");
function injectFilter(prefixCls, dropdownPrefixCls, columns, filterStates, locale2, triggerFilter, getPopupContainer, pos, rootClassName) {
  return columns.map((column2, index2) => {
    const columnPos = getColumnPos(index2, pos), {
      filterOnClose = !0,
      filterMultiple = !0,
      filterMode,
      filterSearch
    } = column2;
    let newColumn = column2;
    if (newColumn.filters || newColumn.filterDropdown) {
      const columnKey = getColumnKey(newColumn, columnPos), filterState = filterStates.find((_ref) => {
        let {
          key
        } = _ref;
        return columnKey === key;
      });
      newColumn = Object.assign(Object.assign({}, newColumn), {
        title: /* @__PURE__ */ __name((renderProps) => /* @__PURE__ */ React.createElement(FilterDropdown, {
          tablePrefixCls: prefixCls,
          prefixCls: `${prefixCls}-filter`,
          dropdownPrefixCls,
          column: newColumn,
          columnKey,
          filterState,
          filterOnClose,
          filterMultiple,
          filterMode,
          filterSearch,
          triggerFilter,
          locale: locale2,
          getPopupContainer,
          rootClassName
        }, renderColumnTitle(column2.title, renderProps)), "title")
      });
    }
    return "children" in newColumn && (newColumn = Object.assign(Object.assign({}, newColumn), {
      children: injectFilter(prefixCls, dropdownPrefixCls, newColumn.children, filterStates, locale2, triggerFilter, getPopupContainer, columnPos, rootClassName)
    })), newColumn;
  });
}
__name(injectFilter, "injectFilter");
const generateFilterInfo = /* @__PURE__ */ __name((filterStates) => {
  const currentFilters = {};
  return filterStates.forEach((_ref2) => {
    let {
      key,
      filteredKeys,
      column: column2
    } = _ref2;
    const keyAsString = key, {
      filters,
      filterDropdown
    } = column2;
    if (filterDropdown)
      currentFilters[keyAsString] = filteredKeys || null;
    else if (Array.isArray(filteredKeys)) {
      const keys2 = flattenKeys$1(filters);
      currentFilters[keyAsString] = keys2.filter((originKey) => filteredKeys.includes(String(originKey)));
    } else
      currentFilters[keyAsString] = null;
  }), currentFilters;
}, "generateFilterInfo"), getFilterData = /* @__PURE__ */ __name((data, filterStates, childrenColumnName) => filterStates.reduce((currentData, filterState) => {
  const {
    column: {
      onFilter,
      filters
    },
    filteredKeys
  } = filterState;
  return onFilter && filteredKeys && filteredKeys.length ? currentData.map((record) => Object.assign({}, record)).filter((record) => filteredKeys.some((key) => {
    const keys2 = flattenKeys$1(filters), keyIndex = keys2.findIndex((k) => String(k) === String(key)), realKey = keyIndex !== -1 ? keys2[keyIndex] : key;
    return record[childrenColumnName] && (record[childrenColumnName] = getFilterData(record[childrenColumnName], filterStates, childrenColumnName)), onFilter(realKey, record);
  })) : currentData;
}, data), "getFilterData"), getMergedColumns = /* @__PURE__ */ __name((rawMergedColumns) => rawMergedColumns.flatMap((column2) => "children" in column2 ? [column2].concat(_toConsumableArray(getMergedColumns(column2.children || []))) : [column2]), "getMergedColumns"), useFilter = /* @__PURE__ */ __name((props) => {
  const {
    prefixCls,
    dropdownPrefixCls,
    mergedColumns: rawMergedColumns,
    onFilterChange,
    getPopupContainer,
    locale: tableLocale,
    rootClassName
  } = props, warning3 = devUseWarning("Table"), mergedColumns = React.useMemo(() => getMergedColumns(rawMergedColumns || []), [rawMergedColumns]), [filterStates, setFilterStates] = React.useState(() => collectFilterStates(mergedColumns, !0)), mergedFilterStates = React.useMemo(() => {
    const collectedStates = collectFilterStates(mergedColumns, !1);
    if (collectedStates.length === 0)
      return collectedStates;
    let filteredKeysIsAllNotControlled = !0, filteredKeysIsAllControlled = !0;
    if (collectedStates.forEach((_ref3) => {
      let {
        filteredKeys
      } = _ref3;
      filteredKeys !== void 0 ? filteredKeysIsAllNotControlled = !1 : filteredKeysIsAllControlled = !1;
    }), filteredKeysIsAllNotControlled) {
      const keyList = (mergedColumns || []).map((column2, index2) => getColumnKey(column2, getColumnPos(index2)));
      return filterStates.filter((_ref4) => {
        let {
          key
        } = _ref4;
        return keyList.includes(key);
      }).map((item) => {
        const col = mergedColumns[keyList.findIndex((key) => key === item.key)];
        return Object.assign(Object.assign({}, item), {
          column: Object.assign(Object.assign({}, item.column), col),
          forceFiltered: col.filtered
        });
      });
    }
    return process.env.NODE_ENV !== "production" && warning3(filteredKeysIsAllControlled, "usage", "Columns should all contain `filteredValue` or not contain `filteredValue`."), collectedStates;
  }, [mergedColumns, filterStates]), filters = React.useMemo(() => generateFilterInfo(mergedFilterStates), [mergedFilterStates]), triggerFilter = /* @__PURE__ */ __name((filterState) => {
    const newFilterStates = mergedFilterStates.filter((_ref5) => {
      let {
        key
      } = _ref5;
      return key !== filterState.key;
    });
    newFilterStates.push(filterState), setFilterStates(newFilterStates), onFilterChange(generateFilterInfo(newFilterStates), newFilterStates);
  }, "triggerFilter");
  return [/* @__PURE__ */ __name((innerColumns) => injectFilter(prefixCls, dropdownPrefixCls, innerColumns, mergedFilterStates, tableLocale, triggerFilter, getPopupContainer, void 0, rootClassName), "transformColumns"), mergedFilterStates, filters];
}, "useFilter"), useLazyKVMap = /* @__PURE__ */ __name((data, childrenColumnName, getRowKey) => {
  const mapCacheRef = React.useRef({});
  function getRecordByKey(key) {
    var _a;
    if (!mapCacheRef.current || mapCacheRef.current.data !== data || mapCacheRef.current.childrenColumnName !== childrenColumnName || mapCacheRef.current.getRowKey !== getRowKey) {
      let dig = function(records) {
        records.forEach((record, index2) => {
          const rowKey = getRowKey(record, index2);
          kvMap.set(rowKey, record), record && typeof record == "object" && childrenColumnName in record && dig(record[childrenColumnName] || []);
        });
      };
      __name(dig, "dig");
      const kvMap = /* @__PURE__ */ new Map();
      dig(data), mapCacheRef.current = {
        data,
        childrenColumnName,
        kvMap,
        getRowKey
      };
    }
    return (_a = mapCacheRef.current.kvMap) === null || _a === void 0 ? void 0 : _a.get(key);
  }
  return __name(getRecordByKey, "getRecordByKey"), [getRecordByKey];
}, "useLazyKVMap");
var __rest$7 = function(s, e2) {
  var t2 = {};
  for (var p in s) Object.prototype.hasOwnProperty.call(s, p) && e2.indexOf(p) < 0 && (t2[p] = s[p]);
  if (s != null && typeof Object.getOwnPropertySymbols == "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++)
    e2.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]) && (t2[p[i]] = s[p[i]]);
  return t2;
};
const DEFAULT_PAGE_SIZE = 10;
function getPaginationParam(mergedPagination, pagination) {
  const param = {
    current: mergedPagination.current,
    pageSize: mergedPagination.pageSize
  };
  return Object.keys(pagination && typeof pagination == "object" ? pagination : {}).forEach((pageProp) => {
    const value = mergedPagination[pageProp];
    typeof value != "function" && (param[pageProp] = value);
  }), param;
}
__name(getPaginationParam, "getPaginationParam");
function usePagination(total, onChange, pagination) {
  const _a = pagination && typeof pagination == "object" ? pagination : {}, {
    total: paginationTotal = 0
  } = _a, paginationObj = __rest$7(_a, ["total"]), [innerPagination, setInnerPagination] = useState(() => ({
    current: "defaultCurrent" in paginationObj ? paginationObj.defaultCurrent : 1,
    pageSize: "defaultPageSize" in paginationObj ? paginationObj.defaultPageSize : DEFAULT_PAGE_SIZE
  })), mergedPagination = extendsObject(innerPagination, paginationObj, {
    total: paginationTotal > 0 ? paginationTotal : total
  }), maxPage = Math.ceil((paginationTotal || total) / mergedPagination.pageSize);
  mergedPagination.current > maxPage && (mergedPagination.current = maxPage || 1);
  const refreshPagination = /* @__PURE__ */ __name((current, pageSize) => {
    setInnerPagination({
      current: current ?? 1,
      pageSize: pageSize || mergedPagination.pageSize
    });
  }, "refreshPagination"), onInternalChange = /* @__PURE__ */ __name((current, pageSize) => {
    var _a2;
    pagination && ((_a2 = pagination.onChange) === null || _a2 === void 0 || _a2.call(pagination, current, pageSize)), refreshPagination(current, pageSize), onChange(current, pageSize || (mergedPagination == null ? void 0 : mergedPagination.pageSize));
  }, "onInternalChange");
  return pagination === !1 ? [{}, () => {
  }] : [Object.assign(Object.assign({}, mergedPagination), {
    onChange: onInternalChange
  }), refreshPagination];
}
__name(usePagination, "usePagination");
const ASCEND = "ascend", DESCEND = "descend", getMultiplePriority = /* @__PURE__ */ __name((column2) => typeof column2.sorter == "object" && typeof column2.sorter.multiple == "number" ? column2.sorter.multiple : !1, "getMultiplePriority"), getSortFunction = /* @__PURE__ */ __name((sorter) => typeof sorter == "function" ? sorter : sorter && typeof sorter == "object" && sorter.compare ? sorter.compare : !1, "getSortFunction"), nextSortDirection = /* @__PURE__ */ __name((sortDirections, current) => current ? sortDirections[sortDirections.indexOf(current) + 1] : sortDirections[0], "nextSortDirection"), collectSortStates = /* @__PURE__ */ __name((columns, init, pos) => {
  let sortStates = [];
  const pushState = /* @__PURE__ */ __name((column2, columnPos) => {
    sortStates.push({
      column: column2,
      key: getColumnKey(column2, columnPos),
      multiplePriority: getMultiplePriority(column2),
      sortOrder: column2.sortOrder
    });
  }, "pushState");
  return (columns || []).forEach((column2, index2) => {
    const columnPos = getColumnPos(index2, pos);
    column2.children ? ("sortOrder" in column2 && pushState(column2, columnPos), sortStates = [].concat(_toConsumableArray(sortStates), _toConsumableArray(collectSortStates(column2.children, init, columnPos)))) : column2.sorter && ("sortOrder" in column2 ? pushState(column2, columnPos) : init && column2.defaultSortOrder && sortStates.push({
      column: column2,
      key: getColumnKey(column2, columnPos),
      multiplePriority: getMultiplePriority(column2),
      sortOrder: column2.defaultSortOrder
    }));
  }), sortStates;
}, "collectSortStates"), injectSorter = /* @__PURE__ */ __name((prefixCls, columns, sorterStates, triggerSorter, defaultSortDirections, tableLocale, tableShowSorterTooltip, pos) => (columns || []).map((column2, index2) => {
  const columnPos = getColumnPos(index2, pos);
  let newColumn = column2;
  if (newColumn.sorter) {
    const sortDirections = newColumn.sortDirections || defaultSortDirections, showSorterTooltip = newColumn.showSorterTooltip === void 0 ? tableShowSorterTooltip : newColumn.showSorterTooltip, columnKey = getColumnKey(newColumn, columnPos), sorterState = sorterStates.find((_ref) => {
      let {
        key
      } = _ref;
      return key === columnKey;
    }), sortOrder = sorterState ? sorterState.sortOrder : null, nextSortOrder = nextSortDirection(sortDirections, sortOrder);
    let sorter;
    if (column2.sortIcon)
      sorter = column2.sortIcon({
        sortOrder
      });
    else {
      const upNode = sortDirections.includes(ASCEND) && /* @__PURE__ */ React.createElement(RefIcon$f, {
        className: cn(`${prefixCls}-column-sorter-up`, {
          active: sortOrder === ASCEND
        })
      }), downNode = sortDirections.includes(DESCEND) && /* @__PURE__ */ React.createElement(RefIcon$g, {
        className: cn(`${prefixCls}-column-sorter-down`, {
          active: sortOrder === DESCEND
        })
      });
      sorter = /* @__PURE__ */ React.createElement("span", {
        className: cn(`${prefixCls}-column-sorter`, {
          [`${prefixCls}-column-sorter-full`]: !!(upNode && downNode)
        })
      }, /* @__PURE__ */ React.createElement("span", {
        className: `${prefixCls}-column-sorter-inner`,
        "aria-hidden": "true"
      }, upNode, downNode));
    }
    const {
      cancelSort,
      triggerAsc,
      triggerDesc
    } = tableLocale || {};
    let sortTip = cancelSort;
    nextSortOrder === DESCEND ? sortTip = triggerDesc : nextSortOrder === ASCEND && (sortTip = triggerAsc);
    const tooltipProps = typeof showSorterTooltip == "object" ? Object.assign({
      title: sortTip
    }, showSorterTooltip) : {
      title: sortTip
    };
    newColumn = Object.assign(Object.assign({}, newColumn), {
      className: cn(newColumn.className, {
        [`${prefixCls}-column-sort`]: sortOrder
      }),
      title: /* @__PURE__ */ __name((renderProps) => {
        const columnSortersClass = `${prefixCls}-column-sorters`, renderColumnTitleWrapper = /* @__PURE__ */ React.createElement("span", {
          className: `${prefixCls}-column-title`
        }, renderColumnTitle(column2.title, renderProps)), renderSortTitle = /* @__PURE__ */ React.createElement("div", {
          className: columnSortersClass
        }, renderColumnTitleWrapper, sorter);
        return showSorterTooltip ? typeof showSorterTooltip != "boolean" && (showSorterTooltip == null ? void 0 : showSorterTooltip.target) === "sorter-icon" ? /* @__PURE__ */ React.createElement("div", {
          className: `${columnSortersClass} ${prefixCls}-column-sorters-tooltip-target-sorter`
        }, renderColumnTitleWrapper, /* @__PURE__ */ React.createElement(Tooltip$1, Object.assign({}, tooltipProps), sorter)) : /* @__PURE__ */ React.createElement(Tooltip$1, Object.assign({}, tooltipProps), renderSortTitle) : renderSortTitle;
      }, "title"),
      onHeaderCell: /* @__PURE__ */ __name((col) => {
        var _a;
        const cell = ((_a = column2.onHeaderCell) === null || _a === void 0 ? void 0 : _a.call(column2, col)) || {}, originOnClick = cell.onClick, originOKeyDown = cell.onKeyDown;
        cell.onClick = (event) => {
          triggerSorter({
            column: column2,
            key: columnKey,
            sortOrder: nextSortOrder,
            multiplePriority: getMultiplePriority(column2)
          }), originOnClick == null || originOnClick(event);
        }, cell.onKeyDown = (event) => {
          event.keyCode === KeyCode.ENTER && (triggerSorter({
            column: column2,
            key: columnKey,
            sortOrder: nextSortOrder,
            multiplePriority: getMultiplePriority(column2)
          }), originOKeyDown == null || originOKeyDown(event));
        };
        const renderTitle = safeColumnTitle(column2.title, {}), displayTitle = renderTitle == null ? void 0 : renderTitle.toString();
        return sortOrder ? cell["aria-sort"] = sortOrder === "ascend" ? "ascending" : "descending" : cell["aria-label"] = displayTitle || "", cell.className = cn(cell.className, `${prefixCls}-column-has-sorters`), cell.tabIndex = 0, column2.ellipsis && (cell.title = (renderTitle ?? "").toString()), cell;
      }, "onHeaderCell")
    });
  }
  return "children" in newColumn && (newColumn = Object.assign(Object.assign({}, newColumn), {
    children: injectSorter(prefixCls, newColumn.children, sorterStates, triggerSorter, defaultSortDirections, tableLocale, tableShowSorterTooltip, columnPos)
  })), newColumn;
}), "injectSorter"), stateToInfo = /* @__PURE__ */ __name((sorterState) => {
  const {
    column: column2,
    sortOrder
  } = sorterState;
  return {
    column: column2,
    order: sortOrder,
    field: column2.dataIndex,
    columnKey: column2.key
  };
}, "stateToInfo"), generateSorterInfo = /* @__PURE__ */ __name((sorterStates) => {
  const activeSorters = sorterStates.filter((_ref2) => {
    let {
      sortOrder
    } = _ref2;
    return sortOrder;
  }).map(stateToInfo);
  if (activeSorters.length === 0 && sorterStates.length) {
    const lastIndex = sorterStates.length - 1;
    return Object.assign(Object.assign({}, stateToInfo(sorterStates[lastIndex])), {
      column: void 0,
      order: void 0,
      field: void 0,
      columnKey: void 0
    });
  }
  return activeSorters.length <= 1 ? activeSorters[0] || {} : activeSorters;
}, "generateSorterInfo"), getSortData = /* @__PURE__ */ __name((data, sortStates, childrenColumnName) => {
  const innerSorterStates = sortStates.slice().sort((a, b) => b.multiplePriority - a.multiplePriority), cloneData = data.slice(), runningSorters = innerSorterStates.filter((_ref3) => {
    let {
      column: {
        sorter
      },
      sortOrder
    } = _ref3;
    return getSortFunction(sorter) && sortOrder;
  });
  return runningSorters.length ? cloneData.sort((record1, record2) => {
    for (let i = 0; i < runningSorters.length; i += 1) {
      const sorterState = runningSorters[i], {
        column: {
          sorter
        },
        sortOrder
      } = sorterState, compareFn = getSortFunction(sorter);
      if (compareFn && sortOrder) {
        const compareResult = compareFn(record1, record2, sortOrder);
        if (compareResult !== 0)
          return sortOrder === ASCEND ? compareResult : -compareResult;
      }
    }
    return 0;
  }).map((record) => {
    const subRecords = record[childrenColumnName];
    return subRecords ? Object.assign(Object.assign({}, record), {
      [childrenColumnName]: getSortData(subRecords, sortStates, childrenColumnName)
    }) : record;
  }) : cloneData;
}, "getSortData"), useFilterSorter = /* @__PURE__ */ __name((props) => {
  const {
    prefixCls,
    mergedColumns,
    sortDirections,
    tableLocale,
    showSorterTooltip,
    onSorterChange
  } = props, [sortStates, setSortStates] = React.useState(collectSortStates(mergedColumns, !0)), getColumnKeys = /* @__PURE__ */ __name((columns, pos) => {
    const newKeys = [];
    return columns.forEach((item, index2) => {
      const columnPos = getColumnPos(index2, pos);
      if (newKeys.push(getColumnKey(item, columnPos)), Array.isArray(item.children)) {
        const childKeys = getColumnKeys(item.children, columnPos);
        newKeys.push.apply(newKeys, _toConsumableArray(childKeys));
      }
    }), newKeys;
  }, "getColumnKeys"), mergedSorterStates = React.useMemo(() => {
    let validate = !0;
    const collectedStates = collectSortStates(mergedColumns, !1);
    if (!collectedStates.length) {
      const mergedColumnsKeys = getColumnKeys(mergedColumns);
      return sortStates.filter((_ref4) => {
        let {
          key
        } = _ref4;
        return mergedColumnsKeys.includes(key);
      });
    }
    const validateStates = [];
    function patchStates(state) {
      validate ? validateStates.push(state) : validateStates.push(Object.assign(Object.assign({}, state), {
        sortOrder: null
      }));
    }
    __name(patchStates, "patchStates");
    let multipleMode = null;
    return collectedStates.forEach((state) => {
      multipleMode === null ? (patchStates(state), state.sortOrder && (state.multiplePriority === !1 ? validate = !1 : multipleMode = !0)) : (multipleMode && state.multiplePriority !== !1 || (validate = !1), patchStates(state));
    }), validateStates;
  }, [mergedColumns, sortStates]), columnTitleSorterProps = React.useMemo(() => {
    var _a, _b;
    const sortColumns = mergedSorterStates.map((_ref5) => {
      let {
        column: column2,
        sortOrder
      } = _ref5;
      return {
        column: column2,
        order: sortOrder
      };
    });
    return {
      sortColumns,
      // Legacy
      sortColumn: (_a = sortColumns[0]) === null || _a === void 0 ? void 0 : _a.column,
      sortOrder: (_b = sortColumns[0]) === null || _b === void 0 ? void 0 : _b.order
    };
  }, [mergedSorterStates]), triggerSorter = /* @__PURE__ */ __name((sortState) => {
    let newSorterStates;
    sortState.multiplePriority === !1 || !mergedSorterStates.length || mergedSorterStates[0].multiplePriority === !1 ? newSorterStates = [sortState] : newSorterStates = [].concat(_toConsumableArray(mergedSorterStates.filter((_ref6) => {
      let {
        key
      } = _ref6;
      return key !== sortState.key;
    })), [sortState]), setSortStates(newSorterStates), onSorterChange(generateSorterInfo(newSorterStates), newSorterStates);
  }, "triggerSorter");
  return [/* @__PURE__ */ __name((innerColumns) => injectSorter(prefixCls, innerColumns, mergedSorterStates, triggerSorter, sortDirections, tableLocale, showSorterTooltip), "transformColumns"), mergedSorterStates, columnTitleSorterProps, /* @__PURE__ */ __name(() => generateSorterInfo(mergedSorterStates), "getSorters")];
}, "useFilterSorter"), fillTitle = /* @__PURE__ */ __name((columns, columnTitleProps) => columns.map((column2) => {
  const cloneColumn = Object.assign({}, column2);
  return cloneColumn.title = renderColumnTitle(column2.title, columnTitleProps), "children" in cloneColumn && (cloneColumn.children = fillTitle(cloneColumn.children, columnTitleProps)), cloneColumn;
}), "fillTitle"), useTitleColumns = /* @__PURE__ */ __name((columnTitleProps) => [React.useCallback((columns) => fillTitle(columns, columnTitleProps), [columnTitleProps])], "useTitleColumns"), RcTable = genTable((prev2, next2) => {
  const {
    _renderTimes: prevRenderTimes
  } = prev2, {
    _renderTimes: nextRenderTimes
  } = next2;
  return prevRenderTimes !== nextRenderTimes;
}), RcVirtualTable = genVirtualTable((prev2, next2) => {
  const {
    _renderTimes: prevRenderTimes
  } = prev2, {
    _renderTimes: nextRenderTimes
  } = next2;
  return prevRenderTimes !== nextRenderTimes;
}), genBorderedStyle = /* @__PURE__ */ __name((token2) => {
  const {
    componentCls,
    lineWidth,
    lineType,
    tableBorderColor,
    tableHeaderBg,
    tablePaddingVertical,
    tablePaddingHorizontal,
    calc
  } = token2, tableBorder = `${unit$1(lineWidth)} ${lineType} ${tableBorderColor}`, getSizeBorderStyle = /* @__PURE__ */ __name((size, paddingVertical, paddingHorizontal) => ({
    [`&${componentCls}-${size}`]: {
      [`> ${componentCls}-container`]: {
        [`> ${componentCls}-content, > ${componentCls}-body`]: {
          "\n            > table > tbody > tr > th,\n            > table > tbody > tr > td\n          ": {
            [`> ${componentCls}-expanded-row-fixed`]: {
              margin: `${unit$1(calc(paddingVertical).mul(-1).equal())}
              ${unit$1(calc(calc(paddingHorizontal).add(lineWidth)).mul(-1).equal())}`
            }
          }
        }
      }
    }
  }), "getSizeBorderStyle");
  return {
    [`${componentCls}-wrapper`]: {
      [`${componentCls}${componentCls}-bordered`]: Object.assign(Object.assign(Object.assign({
        // ============================ Title =============================
        [`> ${componentCls}-title`]: {
          border: tableBorder,
          borderBottom: 0
        },
        // ============================ Content ============================
        [`> ${componentCls}-container`]: {
          borderInlineStart: tableBorder,
          borderTop: tableBorder,
          [`
            > ${componentCls}-content,
            > ${componentCls}-header,
            > ${componentCls}-body,
            > ${componentCls}-summary
          `]: {
            "> table": {
              // ============================= Cell =============================
              "\n                > thead > tr > th,\n                > thead > tr > td,\n                > tbody > tr > th,\n                > tbody > tr > td,\n                > tfoot > tr > th,\n                > tfoot > tr > td\n              ": {
                borderInlineEnd: tableBorder
              },
              // ============================ Header ============================
              "> thead": {
                "> tr:not(:last-child) > th": {
                  borderBottom: tableBorder
                },
                "> tr > th::before": {
                  backgroundColor: "transparent !important"
                }
              },
              // Fixed right should provides additional border
              "\n                > thead > tr,\n                > tbody > tr,\n                > tfoot > tr\n              ": {
                [`> ${componentCls}-cell-fix-right-first::after`]: {
                  borderInlineEnd: tableBorder
                }
              },
              // ========================== Expandable ==========================
              "\n                > tbody > tr > th,\n                > tbody > tr > td\n              ": {
                [`> ${componentCls}-expanded-row-fixed`]: {
                  margin: `${unit$1(calc(tablePaddingVertical).mul(-1).equal())} ${unit$1(calc(calc(tablePaddingHorizontal).add(lineWidth)).mul(-1).equal())}`,
                  "&::after": {
                    position: "absolute",
                    top: 0,
                    insetInlineEnd: lineWidth,
                    bottom: 0,
                    borderInlineEnd: tableBorder,
                    content: '""'
                  }
                }
              }
            }
          }
        },
        // ============================ Scroll ============================
        [`&${componentCls}-scroll-horizontal`]: {
          [`> ${componentCls}-container > ${componentCls}-body`]: {
            "> table > tbody": {
              [`
                > tr${componentCls}-expanded-row,
                > tr${componentCls}-placeholder
              `]: {
                "> th, > td": {
                  borderInlineEnd: 0
                }
              }
            }
          }
        }
      }, getSizeBorderStyle("middle", token2.tablePaddingVerticalMiddle, token2.tablePaddingHorizontalMiddle)), getSizeBorderStyle("small", token2.tablePaddingVerticalSmall, token2.tablePaddingHorizontalSmall)), {
        // ============================ Footer ============================
        [`> ${componentCls}-footer`]: {
          border: tableBorder,
          borderTop: 0
        }
      }),
      // ============================ Nested ============================
      [`${componentCls}-cell`]: {
        [`${componentCls}-container:first-child`]: {
          // :first-child to avoid the case when bordered and title is set
          borderTop: 0
        },
        // https://github.com/ant-design/ant-design/issues/35577
        "&-scrollbar:not([rowspan])": {
          boxShadow: `0 ${unit$1(lineWidth)} 0 ${unit$1(lineWidth)} ${tableHeaderBg}`
        }
      },
      [`${componentCls}-bordered ${componentCls}-cell-scrollbar`]: {
        borderInlineEnd: tableBorder
      }
    }
  };
}, "genBorderedStyle"), genEllipsisStyle = /* @__PURE__ */ __name((token2) => {
  const {
    componentCls
  } = token2;
  return {
    [`${componentCls}-wrapper`]: {
      [`${componentCls}-cell-ellipsis`]: Object.assign(Object.assign({}, textEllipsis), {
        wordBreak: "keep-all",
        // Fixed first or last should special process
        [`
          &${componentCls}-cell-fix-left-last,
          &${componentCls}-cell-fix-right-first
        `]: {
          overflow: "visible",
          [`${componentCls}-cell-content`]: {
            display: "block",
            overflow: "hidden",
            textOverflow: "ellipsis"
          }
        },
        [`${componentCls}-column-title`]: {
          overflow: "hidden",
          textOverflow: "ellipsis",
          wordBreak: "keep-all"
        }
      })
    }
  };
}, "genEllipsisStyle"), genEmptyStyle = /* @__PURE__ */ __name((token2) => {
  const {
    componentCls
  } = token2;
  return {
    [`${componentCls}-wrapper`]: {
      [`${componentCls}-tbody > tr${componentCls}-placeholder`]: {
        textAlign: "center",
        color: token2.colorTextDisabled,
        "\n          &:hover > th,\n          &:hover > td,\n        ": {
          background: token2.colorBgContainer
        }
      }
    }
  };
}, "genEmptyStyle"), genExpandStyle = /* @__PURE__ */ __name((token2) => {
  const {
    componentCls,
    antCls,
    motionDurationSlow,
    lineWidth,
    paddingXS,
    lineType,
    tableBorderColor,
    tableExpandIconBg,
    tableExpandColumnWidth,
    borderRadius,
    tablePaddingVertical,
    tablePaddingHorizontal,
    tableExpandedRowBg,
    paddingXXS,
    expandIconMarginTop,
    expandIconSize,
    expandIconHalfInner,
    expandIconScale,
    calc
  } = token2, tableBorder = `${unit$1(lineWidth)} ${lineType} ${tableBorderColor}`, expandIconLineOffset = calc(paddingXXS).sub(lineWidth).equal();
  return {
    [`${componentCls}-wrapper`]: {
      [`${componentCls}-expand-icon-col`]: {
        width: tableExpandColumnWidth
      },
      [`${componentCls}-row-expand-icon-cell`]: {
        textAlign: "center",
        [`${componentCls}-row-expand-icon`]: {
          display: "inline-flex",
          float: "none",
          verticalAlign: "sub"
        }
      },
      [`${componentCls}-row-indent`]: {
        height: 1,
        float: "left"
      },
      [`${componentCls}-row-expand-icon`]: Object.assign(Object.assign({}, operationUnit(token2)), {
        position: "relative",
        float: "left",
        width: expandIconSize,
        height: expandIconSize,
        color: "inherit",
        lineHeight: unit$1(expandIconSize),
        background: tableExpandIconBg,
        border: tableBorder,
        borderRadius,
        transform: `scale(${expandIconScale})`,
        "&:focus, &:hover, &:active": {
          borderColor: "currentcolor"
        },
        "&::before, &::after": {
          position: "absolute",
          background: "currentcolor",
          transition: `transform ${motionDurationSlow} ease-out`,
          content: '""'
        },
        "&::before": {
          top: expandIconHalfInner,
          insetInlineEnd: expandIconLineOffset,
          insetInlineStart: expandIconLineOffset,
          height: lineWidth
        },
        "&::after": {
          top: expandIconLineOffset,
          bottom: expandIconLineOffset,
          insetInlineStart: expandIconHalfInner,
          width: lineWidth,
          transform: "rotate(90deg)"
        },
        // Motion effect
        "&-collapsed::before": {
          transform: "rotate(-180deg)"
        },
        "&-collapsed::after": {
          transform: "rotate(0deg)"
        },
        "&-spaced": {
          "&::before, &::after": {
            display: "none",
            content: "none"
          },
          background: "transparent",
          border: 0,
          visibility: "hidden"
        }
      }),
      [`${componentCls}-row-indent + ${componentCls}-row-expand-icon`]: {
        marginTop: expandIconMarginTop,
        marginInlineEnd: paddingXS
      },
      [`tr${componentCls}-expanded-row`]: {
        "&, &:hover": {
          "> th, > td": {
            background: tableExpandedRowBg
          }
        },
        // https://github.com/ant-design/ant-design/issues/25573
        [`${antCls}-descriptions-view`]: {
          display: "flex",
          table: {
            flex: "auto",
            width: "100%"
          }
        }
      },
      // With fixed
      [`${componentCls}-expanded-row-fixed`]: {
        position: "relative",
        margin: `${unit$1(calc(tablePaddingVertical).mul(-1).equal())} ${unit$1(calc(tablePaddingHorizontal).mul(-1).equal())}`,
        padding: `${unit$1(tablePaddingVertical)} ${unit$1(tablePaddingHorizontal)}`
      }
    }
  };
}, "genExpandStyle"), genFilterStyle = /* @__PURE__ */ __name((token2) => {
  const {
    componentCls,
    antCls,
    iconCls,
    tableFilterDropdownWidth,
    tableFilterDropdownSearchWidth,
    paddingXXS,
    paddingXS,
    colorText,
    lineWidth,
    lineType,
    tableBorderColor,
    headerIconColor,
    fontSizeSM,
    tablePaddingHorizontal,
    borderRadius,
    motionDurationSlow,
    colorTextDescription,
    colorPrimary,
    tableHeaderFilterActiveBg,
    colorTextDisabled,
    tableFilterDropdownBg,
    tableFilterDropdownHeight,
    controlItemBgHover,
    controlItemBgActive,
    boxShadowSecondary,
    filterDropdownMenuBg,
    calc
  } = token2, dropdownPrefixCls = `${antCls}-dropdown`, tableFilterDropdownPrefixCls = `${componentCls}-filter-dropdown`, treePrefixCls = `${antCls}-tree`, tableBorder = `${unit$1(lineWidth)} ${lineType} ${tableBorderColor}`;
  return [
    {
      [`${componentCls}-wrapper`]: {
        [`${componentCls}-filter-column`]: {
          display: "flex",
          justifyContent: "space-between"
        },
        [`${componentCls}-filter-trigger`]: {
          position: "relative",
          display: "flex",
          alignItems: "center",
          marginBlock: calc(paddingXXS).mul(-1).equal(),
          marginInline: `${unit$1(paddingXXS)} ${unit$1(calc(tablePaddingHorizontal).div(2).mul(-1).equal())}`,
          padding: `0 ${unit$1(paddingXXS)}`,
          color: headerIconColor,
          fontSize: fontSizeSM,
          borderRadius,
          cursor: "pointer",
          transition: `all ${motionDurationSlow}`,
          "&:hover": {
            color: colorTextDescription,
            background: tableHeaderFilterActiveBg
          },
          "&.active": {
            color: colorPrimary
          }
        }
      }
    },
    {
      // Dropdown
      [`${antCls}-dropdown`]: {
        [tableFilterDropdownPrefixCls]: Object.assign(Object.assign({}, resetComponent(token2)), {
          minWidth: tableFilterDropdownWidth,
          backgroundColor: tableFilterDropdownBg,
          borderRadius,
          boxShadow: boxShadowSecondary,
          overflow: "hidden",
          // Reset menu
          [`${dropdownPrefixCls}-menu`]: {
            // https://github.com/ant-design/ant-design/issues/4916
            // https://github.com/ant-design/ant-design/issues/19542
            maxHeight: tableFilterDropdownHeight,
            overflowX: "hidden",
            border: 0,
            boxShadow: "none",
            borderRadius: "unset",
            backgroundColor: filterDropdownMenuBg,
            "&:empty::after": {
              display: "block",
              padding: `${unit$1(paddingXS)} 0`,
              color: colorTextDisabled,
              fontSize: fontSizeSM,
              textAlign: "center",
              content: '"Not Found"'
            }
          },
          [`${tableFilterDropdownPrefixCls}-tree`]: {
            paddingBlock: `${unit$1(paddingXS)} 0`,
            paddingInline: paddingXS,
            [treePrefixCls]: {
              padding: 0
            },
            [`${treePrefixCls}-treenode ${treePrefixCls}-node-content-wrapper:hover`]: {
              backgroundColor: controlItemBgHover
            },
            [`${treePrefixCls}-treenode-checkbox-checked ${treePrefixCls}-node-content-wrapper`]: {
              "&, &:hover": {
                backgroundColor: controlItemBgActive
              }
            }
          },
          [`${tableFilterDropdownPrefixCls}-search`]: {
            padding: paddingXS,
            borderBottom: tableBorder,
            "&-input": {
              input: {
                minWidth: tableFilterDropdownSearchWidth
              },
              [iconCls]: {
                color: colorTextDisabled
              }
            }
          },
          [`${tableFilterDropdownPrefixCls}-checkall`]: {
            width: "100%",
            marginBottom: paddingXXS,
            marginInlineStart: paddingXXS
          },
          // Operation
          [`${tableFilterDropdownPrefixCls}-btns`]: {
            display: "flex",
            justifyContent: "space-between",
            padding: `${unit$1(calc(paddingXS).sub(lineWidth).equal())} ${unit$1(paddingXS)}`,
            overflow: "hidden",
            borderTop: tableBorder
          }
        })
      }
    },
    // Dropdown Menu & SubMenu
    {
      // submenu of table filter dropdown
      [`${antCls}-dropdown ${tableFilterDropdownPrefixCls}, ${tableFilterDropdownPrefixCls}-submenu`]: {
        // Checkbox
        [`${antCls}-checkbox-wrapper + span`]: {
          paddingInlineStart: paddingXS,
          color: colorText
        },
        "> ul": {
          maxHeight: "calc(100vh - 130px)",
          overflowX: "hidden",
          overflowY: "auto"
        }
      }
    }
  ];
}, "genFilterStyle"), genFixedStyle = /* @__PURE__ */ __name((token2) => {
  const {
    componentCls,
    lineWidth,
    colorSplit,
    motionDurationSlow,
    zIndexTableFixed: zIndexTableFixed2,
    tableBg,
    zIndexTableSticky,
    calc
  } = token2, shadowColor = colorSplit;
  return {
    [`${componentCls}-wrapper`]: {
      [`
        ${componentCls}-cell-fix-left,
        ${componentCls}-cell-fix-right
      `]: {
        position: "sticky !important",
        zIndex: zIndexTableFixed2,
        background: tableBg
      },
      [`
        ${componentCls}-cell-fix-left-first::after,
        ${componentCls}-cell-fix-left-last::after
      `]: {
        position: "absolute",
        top: 0,
        right: {
          _skip_check_: !0,
          value: 0
        },
        bottom: calc(lineWidth).mul(-1).equal(),
        width: 30,
        transform: "translateX(100%)",
        transition: `box-shadow ${motionDurationSlow}`,
        content: '""',
        pointerEvents: "none"
      },
      [`${componentCls}-cell-fix-left-all::after`]: {
        display: "none"
      },
      [`
        ${componentCls}-cell-fix-right-first::after,
        ${componentCls}-cell-fix-right-last::after
      `]: {
        position: "absolute",
        top: 0,
        bottom: calc(lineWidth).mul(-1).equal(),
        left: {
          _skip_check_: !0,
          value: 0
        },
        width: 30,
        transform: "translateX(-100%)",
        transition: `box-shadow ${motionDurationSlow}`,
        content: '""',
        pointerEvents: "none"
      },
      [`${componentCls}-container`]: {
        position: "relative",
        "&::before, &::after": {
          position: "absolute",
          top: 0,
          bottom: 0,
          zIndex: calc(zIndexTableSticky).add(1).equal({
            unit: !1
          }),
          width: 30,
          transition: `box-shadow ${motionDurationSlow}`,
          content: '""',
          pointerEvents: "none"
        },
        "&::before": {
          insetInlineStart: 0
        },
        "&::after": {
          insetInlineEnd: 0
        }
      },
      [`${componentCls}-ping-left`]: {
        [`&:not(${componentCls}-has-fix-left) ${componentCls}-container::before`]: {
          boxShadow: `inset 10px 0 8px -8px ${shadowColor}`
        },
        [`
          ${componentCls}-cell-fix-left-first::after,
          ${componentCls}-cell-fix-left-last::after
        `]: {
          boxShadow: `inset 10px 0 8px -8px ${shadowColor}`
        },
        [`${componentCls}-cell-fix-left-last::before`]: {
          backgroundColor: "transparent !important"
        }
      },
      [`${componentCls}-ping-right`]: {
        [`&:not(${componentCls}-has-fix-right) ${componentCls}-container::after`]: {
          boxShadow: `inset -10px 0 8px -8px ${shadowColor}`
        },
        [`
          ${componentCls}-cell-fix-right-first::after,
          ${componentCls}-cell-fix-right-last::after
        `]: {
          boxShadow: `inset -10px 0 8px -8px ${shadowColor}`
        }
      },
      // Gapped fixed Columns do not show the shadow
      [`${componentCls}-fixed-column-gapped`]: {
        [`
        ${componentCls}-cell-fix-left-first::after,
        ${componentCls}-cell-fix-left-last::after,
        ${componentCls}-cell-fix-right-first::after,
        ${componentCls}-cell-fix-right-last::after
      `]: {
          boxShadow: "none"
        }
      }
    }
  };
}, "genFixedStyle"), genPaginationStyle = /* @__PURE__ */ __name((token2) => {
  const {
    componentCls,
    antCls,
    margin
  } = token2;
  return {
    [`${componentCls}-wrapper`]: {
      // ========================== Pagination ==========================
      [`${componentCls}-pagination${antCls}-pagination`]: {
        margin: `${unit$1(margin)} 0`
      },
      [`${componentCls}-pagination`]: {
        display: "flex",
        flexWrap: "wrap",
        rowGap: token2.paddingXS,
        "> *": {
          flex: "none"
        },
        "&-left": {
          justifyContent: "flex-start"
        },
        "&-center": {
          justifyContent: "center"
        },
        "&-right": {
          justifyContent: "flex-end"
        }
      }
    }
  };
}, "genPaginationStyle"), genRadiusStyle = /* @__PURE__ */ __name((token2) => {
  const {
    componentCls,
    tableRadius
  } = token2;
  return {
    [`${componentCls}-wrapper`]: {
      [componentCls]: {
        // https://github.com/ant-design/ant-design/issues/39115#issuecomment-1362314574
        [`${componentCls}-title, ${componentCls}-header`]: {
          borderRadius: `${unit$1(tableRadius)} ${unit$1(tableRadius)} 0 0`
        },
        [`${componentCls}-title + ${componentCls}-container`]: {
          borderStartStartRadius: 0,
          borderStartEndRadius: 0,
          // https://github.com/ant-design/ant-design/issues/41975
          [`${componentCls}-header, table`]: {
            borderRadius: 0
          },
          "table > thead > tr:first-child": {
            "th:first-child, th:last-child, td:first-child, td:last-child": {
              borderRadius: 0
            }
          }
        },
        "&-container": {
          borderStartStartRadius: tableRadius,
          borderStartEndRadius: tableRadius,
          "table > thead > tr:first-child": {
            "> *:first-child": {
              borderStartStartRadius: tableRadius
            },
            "> *:last-child": {
              borderStartEndRadius: tableRadius
            }
          }
        },
        "&-footer": {
          borderRadius: `0 0 ${unit$1(tableRadius)} ${unit$1(tableRadius)}`
        }
      }
    }
  };
}, "genRadiusStyle"), genStyle = /* @__PURE__ */ __name((token2) => {
  const {
    componentCls
  } = token2;
  return {
    [`${componentCls}-wrapper-rtl`]: {
      direction: "rtl",
      table: {
        direction: "rtl"
      },
      [`${componentCls}-pagination-left`]: {
        justifyContent: "flex-end"
      },
      [`${componentCls}-pagination-right`]: {
        justifyContent: "flex-start"
      },
      [`${componentCls}-row-expand-icon`]: {
        float: "right",
        "&::after": {
          transform: "rotate(-90deg)"
        },
        "&-collapsed::before": {
          transform: "rotate(180deg)"
        },
        "&-collapsed::after": {
          transform: "rotate(0deg)"
        }
      },
      [`${componentCls}-container`]: {
        "&::before": {
          insetInlineStart: "unset",
          insetInlineEnd: 0
        },
        "&::after": {
          insetInlineStart: 0,
          insetInlineEnd: "unset"
        },
        [`${componentCls}-row-indent`]: {
          float: "right"
        }
      }
    }
  };
}, "genStyle"), genSelectionStyle = /* @__PURE__ */ __name((token2) => {
  const {
    componentCls,
    antCls,
    iconCls,
    fontSizeIcon,
    padding,
    paddingXS,
    headerIconColor,
    headerIconHoverColor,
    tableSelectionColumnWidth,
    tableSelectedRowBg,
    tableSelectedRowHoverBg,
    tableRowHoverBg,
    tablePaddingHorizontal,
    calc
  } = token2;
  return {
    [`${componentCls}-wrapper`]: {
      // ========================== Selections ==========================
      [`${componentCls}-selection-col`]: {
        width: tableSelectionColumnWidth,
        [`&${componentCls}-selection-col-with-dropdown`]: {
          width: calc(tableSelectionColumnWidth).add(fontSizeIcon).add(calc(padding).div(4)).equal()
        }
      },
      [`${componentCls}-bordered ${componentCls}-selection-col`]: {
        width: calc(tableSelectionColumnWidth).add(calc(paddingXS).mul(2)).equal(),
        [`&${componentCls}-selection-col-with-dropdown`]: {
          width: calc(tableSelectionColumnWidth).add(fontSizeIcon).add(calc(padding).div(4)).add(calc(paddingXS).mul(2)).equal()
        }
      },
      [`
        table tr th${componentCls}-selection-column,
        table tr td${componentCls}-selection-column,
        ${componentCls}-selection-column
      `]: {
        paddingInlineEnd: token2.paddingXS,
        paddingInlineStart: token2.paddingXS,
        textAlign: "center",
        [`${antCls}-radio-wrapper`]: {
          marginInlineEnd: 0
        }
      },
      [`table tr th${componentCls}-selection-column${componentCls}-cell-fix-left`]: {
        zIndex: calc(token2.zIndexTableFixed).add(1).equal({
          unit: !1
        })
      },
      [`table tr th${componentCls}-selection-column::after`]: {
        backgroundColor: "transparent !important"
      },
      [`${componentCls}-selection`]: {
        position: "relative",
        display: "inline-flex",
        flexDirection: "column"
      },
      [`${componentCls}-selection-extra`]: {
        position: "absolute",
        top: 0,
        zIndex: 1,
        cursor: "pointer",
        transition: `all ${token2.motionDurationSlow}`,
        marginInlineStart: "100%",
        paddingInlineStart: unit$1(calc(tablePaddingHorizontal).div(4).equal()),
        [iconCls]: {
          color: headerIconColor,
          fontSize: fontSizeIcon,
          verticalAlign: "baseline",
          "&:hover": {
            color: headerIconHoverColor
          }
        }
      },
      // ============================= Rows =============================
      [`${componentCls}-tbody`]: {
        [`${componentCls}-row`]: {
          [`&${componentCls}-row-selected`]: {
            [`> ${componentCls}-cell`]: {
              background: tableSelectedRowBg,
              "&-row-hover": {
                background: tableSelectedRowHoverBg
              }
            }
          },
          [`> ${componentCls}-cell-row-hover`]: {
            background: tableRowHoverBg
          }
        }
      }
    }
  };
}, "genSelectionStyle"), genSizeStyle = /* @__PURE__ */ __name((token2) => {
  const {
    componentCls,
    tableExpandColumnWidth,
    calc
  } = token2, getSizeStyle = /* @__PURE__ */ __name((size, paddingVertical, paddingHorizontal, fontSize) => ({
    [`${componentCls}${componentCls}-${size}`]: {
      fontSize,
      [`
        ${componentCls}-title,
        ${componentCls}-footer,
        ${componentCls}-cell,
        ${componentCls}-thead > tr > th,
        ${componentCls}-tbody > tr > th,
        ${componentCls}-tbody > tr > td,
        tfoot > tr > th,
        tfoot > tr > td
      `]: {
        padding: `${unit$1(paddingVertical)} ${unit$1(paddingHorizontal)}`
      },
      [`${componentCls}-filter-trigger`]: {
        marginInlineEnd: unit$1(calc(paddingHorizontal).div(2).mul(-1).equal())
      },
      [`${componentCls}-expanded-row-fixed`]: {
        margin: `${unit$1(calc(paddingVertical).mul(-1).equal())} ${unit$1(calc(paddingHorizontal).mul(-1).equal())}`
      },
      [`${componentCls}-tbody`]: {
        // ========================= Nest Table ===========================
        [`${componentCls}-wrapper:only-child ${componentCls}`]: {
          marginBlock: unit$1(calc(paddingVertical).mul(-1).equal()),
          marginInline: `${unit$1(calc(tableExpandColumnWidth).sub(paddingHorizontal).equal())} ${unit$1(calc(paddingHorizontal).mul(-1).equal())}`
        }
      },
      // https://github.com/ant-design/ant-design/issues/35167
      [`${componentCls}-selection-extra`]: {
        paddingInlineStart: unit$1(calc(paddingHorizontal).div(4).equal())
      }
    }
  }), "getSizeStyle");
  return {
    [`${componentCls}-wrapper`]: Object.assign(Object.assign({}, getSizeStyle("middle", token2.tablePaddingVerticalMiddle, token2.tablePaddingHorizontalMiddle, token2.tableFontSizeMiddle)), getSizeStyle("small", token2.tablePaddingVerticalSmall, token2.tablePaddingHorizontalSmall, token2.tableFontSizeSmall))
  };
}, "genSizeStyle"), genSorterStyle = /* @__PURE__ */ __name((token2) => {
  const {
    componentCls,
    marginXXS,
    fontSizeIcon,
    headerIconColor,
    headerIconHoverColor
  } = token2;
  return {
    [`${componentCls}-wrapper`]: {
      [`${componentCls}-thead th${componentCls}-column-has-sorters`]: {
        outline: "none",
        cursor: "pointer",
        // why left 0s? Avoid column header move with transition when left is changed
        // https://github.com/ant-design/ant-design/issues/50588
        transition: `all ${token2.motionDurationSlow}, left 0s`,
        "&:hover": {
          background: token2.tableHeaderSortHoverBg,
          "&::before": {
            backgroundColor: "transparent !important"
          }
        },
        "&:focus-visible": {
          color: token2.colorPrimary
        },
        // https://github.com/ant-design/ant-design/issues/30969
        [`
          &${componentCls}-cell-fix-left:hover,
          &${componentCls}-cell-fix-right:hover
        `]: {
          background: token2.tableFixedHeaderSortActiveBg
        }
      },
      [`${componentCls}-thead th${componentCls}-column-sort`]: {
        background: token2.tableHeaderSortBg,
        "&::before": {
          backgroundColor: "transparent !important"
        }
      },
      [`td${componentCls}-column-sort`]: {
        background: token2.tableBodySortBg
      },
      [`${componentCls}-column-title`]: {
        position: "relative",
        zIndex: 1,
        flex: 1
      },
      [`${componentCls}-column-sorters`]: {
        display: "flex",
        flex: "auto",
        alignItems: "center",
        justifyContent: "space-between",
        "&::after": {
          position: "absolute",
          inset: 0,
          width: "100%",
          height: "100%",
          content: '""'
        }
      },
      [`${componentCls}-column-sorters-tooltip-target-sorter`]: {
        "&::after": {
          content: "none"
        }
      },
      [`${componentCls}-column-sorter`]: {
        marginInlineStart: marginXXS,
        color: headerIconColor,
        fontSize: 0,
        transition: `color ${token2.motionDurationSlow}`,
        "&-inner": {
          display: "inline-flex",
          flexDirection: "column",
          alignItems: "center"
        },
        "&-up, &-down": {
          fontSize: fontSizeIcon,
          "&.active": {
            color: token2.colorPrimary
          }
        },
        [`${componentCls}-column-sorter-up + ${componentCls}-column-sorter-down`]: {
          marginTop: "-0.3em"
        }
      },
      [`${componentCls}-column-sorters:hover ${componentCls}-column-sorter`]: {
        color: headerIconHoverColor
      }
    }
  };
}, "genSorterStyle"), genStickyStyle = /* @__PURE__ */ __name((token2) => {
  const {
    componentCls,
    opacityLoading,
    tableScrollThumbBg,
    tableScrollThumbBgHover,
    tableScrollThumbSize,
    tableScrollBg,
    zIndexTableSticky,
    stickyScrollBarBorderRadius,
    lineWidth,
    lineType,
    tableBorderColor
  } = token2, tableBorder = `${unit$1(lineWidth)} ${lineType} ${tableBorderColor}`;
  return {
    [`${componentCls}-wrapper`]: {
      [`${componentCls}-sticky`]: {
        "&-holder": {
          position: "sticky",
          zIndex: zIndexTableSticky,
          background: token2.colorBgContainer
        },
        "&-scroll": {
          position: "sticky",
          bottom: 0,
          height: `${unit$1(tableScrollThumbSize)} !important`,
          zIndex: zIndexTableSticky,
          display: "flex",
          alignItems: "center",
          background: tableScrollBg,
          borderTop: tableBorder,
          opacity: opacityLoading,
          "&:hover": {
            transformOrigin: "center bottom"
          },
          // fake scrollbar style of sticky
          "&-bar": {
            height: tableScrollThumbSize,
            backgroundColor: tableScrollThumbBg,
            borderRadius: stickyScrollBarBorderRadius,
            transition: `all ${token2.motionDurationSlow}, transform none`,
            position: "absolute",
            bottom: 0,
            "&:hover, &-active": {
              backgroundColor: tableScrollThumbBgHover
            }
          }
        }
      }
    }
  };
}, "genStickyStyle"), genSummaryStyle = /* @__PURE__ */ __name((token2) => {
  const {
    componentCls,
    lineWidth,
    tableBorderColor,
    calc
  } = token2, tableBorder = `${unit$1(lineWidth)} ${token2.lineType} ${tableBorderColor}`;
  return {
    [`${componentCls}-wrapper`]: {
      [`${componentCls}-summary`]: {
        position: "relative",
        zIndex: token2.zIndexTableFixed,
        background: token2.tableBg,
        "> tr": {
          "> th, > td": {
            borderBottom: tableBorder
          }
        }
      },
      [`div${componentCls}-summary`]: {
        boxShadow: `0 ${unit$1(calc(lineWidth).mul(-1).equal())} 0 ${tableBorderColor}`
      }
    }
  };
}, "genSummaryStyle"), genVirtualStyle = /* @__PURE__ */ __name((token2) => {
  const {
    componentCls,
    motionDurationMid,
    lineWidth,
    lineType,
    tableBorderColor,
    calc
  } = token2, tableBorder = `${unit$1(lineWidth)} ${lineType} ${tableBorderColor}`, rowCellCls = `${componentCls}-expanded-row-cell`;
  return {
    [`${componentCls}-wrapper`]: {
      // ========================== Row ==========================
      [`${componentCls}-tbody-virtual`]: {
        [`${componentCls}-tbody-virtual-holder-inner`]: {
          [`
            & > ${componentCls}-row, 
            & > div:not(${componentCls}-row) > ${componentCls}-row
          `]: {
            display: "flex",
            boxSizing: "border-box",
            width: "100%"
          }
        },
        [`${componentCls}-cell`]: {
          borderBottom: tableBorder,
          transition: `background ${motionDurationMid}`
        },
        [`${componentCls}-expanded-row`]: {
          [`${rowCellCls}${rowCellCls}-fixed`]: {
            position: "sticky",
            insetInlineStart: 0,
            overflow: "hidden",
            width: `calc(var(--virtual-width) - ${unit$1(lineWidth)})`,
            borderInlineEnd: "none"
          }
        }
      },
      // ======================== Border =========================
      [`${componentCls}-bordered`]: {
        [`${componentCls}-tbody-virtual`]: {
          "&:after": {
            content: '""',
            insetInline: 0,
            bottom: 0,
            borderBottom: tableBorder,
            position: "absolute"
          },
          [`${componentCls}-cell`]: {
            borderInlineEnd: tableBorder,
            [`&${componentCls}-cell-fix-right-first:before`]: {
              content: '""',
              position: "absolute",
              insetBlock: 0,
              insetInlineStart: calc(lineWidth).mul(-1).equal(),
              borderInlineStart: tableBorder
            }
          }
        },
        // Empty placeholder
        [`&${componentCls}-virtual`]: {
          [`${componentCls}-placeholder ${componentCls}-cell`]: {
            borderInlineEnd: tableBorder,
            borderBottom: tableBorder
          }
        }
      }
    }
  };
}, "genVirtualStyle"), genTableStyle = /* @__PURE__ */ __name((token2) => {
  const {
    componentCls,
    fontWeightStrong,
    tablePaddingVertical,
    tablePaddingHorizontal,
    tableExpandColumnWidth,
    lineWidth,
    lineType,
    tableBorderColor,
    tableFontSize,
    tableBg,
    tableRadius,
    tableHeaderTextColor,
    motionDurationMid,
    tableHeaderBg,
    tableHeaderCellSplitColor,
    tableFooterTextColor,
    tableFooterBg,
    calc
  } = token2, tableBorder = `${unit$1(lineWidth)} ${lineType} ${tableBorderColor}`;
  return {
    [`${componentCls}-wrapper`]: Object.assign(Object.assign({
      clear: "both",
      maxWidth: "100%"
    }, clearFix()), {
      [componentCls]: Object.assign(Object.assign({}, resetComponent(token2)), {
        fontSize: tableFontSize,
        background: tableBg,
        borderRadius: `${unit$1(tableRadius)} ${unit$1(tableRadius)} 0 0`,
        // https://github.com/ant-design/ant-design/issues/47486
        scrollbarColor: `${token2.tableScrollThumbBg} ${token2.tableScrollBg}`
      }),
      // https://github.com/ant-design/ant-design/issues/17611
      table: {
        width: "100%",
        textAlign: "start",
        borderRadius: `${unit$1(tableRadius)} ${unit$1(tableRadius)} 0 0`,
        borderCollapse: "separate",
        borderSpacing: 0
      },
      // ============================= Cell ==============================
      [`
          ${componentCls}-cell,
          ${componentCls}-thead > tr > th,
          ${componentCls}-tbody > tr > th,
          ${componentCls}-tbody > tr > td,
          tfoot > tr > th,
          tfoot > tr > td
        `]: {
        position: "relative",
        padding: `${unit$1(tablePaddingVertical)} ${unit$1(tablePaddingHorizontal)}`,
        overflowWrap: "break-word"
      },
      // ============================ Title =============================
      [`${componentCls}-title`]: {
        padding: `${unit$1(tablePaddingVertical)} ${unit$1(tablePaddingHorizontal)}`
      },
      // ============================ Header ============================
      [`${componentCls}-thead`]: {
        "\n          > tr > th,\n          > tr > td\n        ": {
          position: "relative",
          color: tableHeaderTextColor,
          fontWeight: fontWeightStrong,
          textAlign: "start",
          background: tableHeaderBg,
          borderBottom: tableBorder,
          transition: `background ${motionDurationMid} ease`,
          "&[colspan]:not([colspan='1'])": {
            textAlign: "center"
          },
          [`&:not(:last-child):not(${componentCls}-selection-column):not(${componentCls}-row-expand-icon-cell):not([colspan])::before`]: {
            position: "absolute",
            top: "50%",
            insetInlineEnd: 0,
            width: 1,
            height: "1.6em",
            backgroundColor: tableHeaderCellSplitColor,
            transform: "translateY(-50%)",
            transition: `background-color ${motionDurationMid}`,
            content: '""'
          }
        },
        "> tr:not(:last-child) > th[colspan]": {
          borderBottom: 0
        }
      },
      // ============================ Body ============================
      [`${componentCls}-tbody`]: {
        "> tr": {
          "> th, > td": {
            transition: `background ${motionDurationMid}, border-color ${motionDurationMid}`,
            borderBottom: tableBorder,
            // ========================= Nest Table ===========================
            [`
              > ${componentCls}-wrapper:only-child,
              > ${componentCls}-expanded-row-fixed > ${componentCls}-wrapper:only-child
            `]: {
              [componentCls]: {
                marginBlock: unit$1(calc(tablePaddingVertical).mul(-1).equal()),
                marginInline: `${unit$1(calc(tableExpandColumnWidth).sub(tablePaddingHorizontal).equal())}
                ${unit$1(calc(tablePaddingHorizontal).mul(-1).equal())}`,
                [`${componentCls}-tbody > tr:last-child > td`]: {
                  borderBottom: 0,
                  "&:first-child, &:last-child": {
                    borderRadius: 0
                  }
                }
              }
            }
          },
          "> th": {
            position: "relative",
            color: tableHeaderTextColor,
            fontWeight: fontWeightStrong,
            textAlign: "start",
            background: tableHeaderBg,
            borderBottom: tableBorder,
            transition: `background ${motionDurationMid} ease`
          }
        }
      },
      // ============================ Footer ============================
      [`${componentCls}-footer`]: {
        padding: `${unit$1(tablePaddingVertical)} ${unit$1(tablePaddingHorizontal)}`,
        color: tableFooterTextColor,
        background: tableFooterBg
      }
    })
  };
}, "genTableStyle"), prepareComponentToken$3 = /* @__PURE__ */ __name((token2) => {
  const {
    colorFillAlter,
    colorBgContainer,
    colorTextHeading,
    colorFillSecondary,
    colorFillContent,
    controlItemBgActive,
    controlItemBgActiveHover,
    padding,
    paddingSM,
    paddingXS,
    colorBorderSecondary,
    borderRadiusLG,
    controlHeight,
    colorTextPlaceholder,
    fontSize,
    fontSizeSM,
    lineHeight,
    lineWidth,
    colorIcon,
    colorIconHover,
    opacityLoading,
    controlInteractiveSize
  } = token2, colorFillSecondarySolid = new TinyColor(colorFillSecondary).onBackground(colorBgContainer).toHexShortString(), colorFillContentSolid = new TinyColor(colorFillContent).onBackground(colorBgContainer).toHexShortString(), colorFillAlterSolid = new TinyColor(colorFillAlter).onBackground(colorBgContainer).toHexShortString(), baseColorAction = new TinyColor(colorIcon), baseColorActionHover = new TinyColor(colorIconHover), expandIconHalfInner = controlInteractiveSize / 2 - lineWidth, expandIconSize = expandIconHalfInner * 2 + lineWidth * 3;
  return {
    headerBg: colorFillAlterSolid,
    headerColor: colorTextHeading,
    headerSortActiveBg: colorFillSecondarySolid,
    headerSortHoverBg: colorFillContentSolid,
    bodySortBg: colorFillAlterSolid,
    rowHoverBg: colorFillAlterSolid,
    rowSelectedBg: controlItemBgActive,
    rowSelectedHoverBg: controlItemBgActiveHover,
    rowExpandedBg: colorFillAlter,
    cellPaddingBlock: padding,
    cellPaddingInline: padding,
    cellPaddingBlockMD: paddingSM,
    cellPaddingInlineMD: paddingXS,
    cellPaddingBlockSM: paddingXS,
    cellPaddingInlineSM: paddingXS,
    borderColor: colorBorderSecondary,
    headerBorderRadius: borderRadiusLG,
    footerBg: colorFillAlterSolid,
    footerColor: colorTextHeading,
    cellFontSize: fontSize,
    cellFontSizeMD: fontSize,
    cellFontSizeSM: fontSize,
    headerSplitColor: colorBorderSecondary,
    fixedHeaderSortActiveBg: colorFillSecondarySolid,
    headerFilterHoverBg: colorFillContent,
    filterDropdownMenuBg: colorBgContainer,
    filterDropdownBg: colorBgContainer,
    expandIconBg: colorBgContainer,
    selectionColumnWidth: controlHeight,
    stickyScrollBarBg: colorTextPlaceholder,
    stickyScrollBarBorderRadius: 100,
    expandIconMarginTop: (fontSize * lineHeight - lineWidth * 3) / 2 - Math.ceil((fontSizeSM * 1.4 - lineWidth * 3) / 2),
    headerIconColor: baseColorAction.clone().setAlpha(baseColorAction.getAlpha() * opacityLoading).toRgbString(),
    headerIconHoverColor: baseColorActionHover.clone().setAlpha(baseColorActionHover.getAlpha() * opacityLoading).toRgbString(),
    expandIconHalfInner,
    expandIconSize,
    expandIconScale: controlInteractiveSize / expandIconSize
  };
}, "prepareComponentToken$3"), zIndexTableFixed = 2, useStyle$3 = genStyleHooks("Table", (token2) => {
  const {
    colorTextHeading,
    colorSplit,
    colorBgContainer,
    controlInteractiveSize: checkboxSize,
    headerBg,
    headerColor,
    headerSortActiveBg,
    headerSortHoverBg,
    bodySortBg,
    rowHoverBg,
    rowSelectedBg,
    rowSelectedHoverBg,
    rowExpandedBg,
    cellPaddingBlock,
    cellPaddingInline,
    cellPaddingBlockMD,
    cellPaddingInlineMD,
    cellPaddingBlockSM,
    cellPaddingInlineSM,
    borderColor,
    footerBg,
    footerColor,
    headerBorderRadius,
    cellFontSize,
    cellFontSizeMD,
    cellFontSizeSM,
    headerSplitColor,
    fixedHeaderSortActiveBg,
    headerFilterHoverBg,
    filterDropdownBg,
    expandIconBg,
    selectionColumnWidth,
    stickyScrollBarBg,
    calc
  } = token2, tableToken = merge(token2, {
    tableFontSize: cellFontSize,
    tableBg: colorBgContainer,
    tableRadius: headerBorderRadius,
    tablePaddingVertical: cellPaddingBlock,
    tablePaddingHorizontal: cellPaddingInline,
    tablePaddingVerticalMiddle: cellPaddingBlockMD,
    tablePaddingHorizontalMiddle: cellPaddingInlineMD,
    tablePaddingVerticalSmall: cellPaddingBlockSM,
    tablePaddingHorizontalSmall: cellPaddingInlineSM,
    tableBorderColor: borderColor,
    tableHeaderTextColor: headerColor,
    tableHeaderBg: headerBg,
    tableFooterTextColor: footerColor,
    tableFooterBg: footerBg,
    tableHeaderCellSplitColor: headerSplitColor,
    tableHeaderSortBg: headerSortActiveBg,
    tableHeaderSortHoverBg: headerSortHoverBg,
    tableBodySortBg: bodySortBg,
    tableFixedHeaderSortActiveBg: fixedHeaderSortActiveBg,
    tableHeaderFilterActiveBg: headerFilterHoverBg,
    tableFilterDropdownBg: filterDropdownBg,
    tableRowHoverBg: rowHoverBg,
    tableSelectedRowBg: rowSelectedBg,
    tableSelectedRowHoverBg: rowSelectedHoverBg,
    zIndexTableFixed,
    zIndexTableSticky: calc(zIndexTableFixed).add(1).equal({
      unit: !1
    }),
    tableFontSizeMiddle: cellFontSizeMD,
    tableFontSizeSmall: cellFontSizeSM,
    tableSelectionColumnWidth: selectionColumnWidth,
    tableExpandIconBg: expandIconBg,
    tableExpandColumnWidth: calc(checkboxSize).add(calc(token2.padding).mul(2)).equal(),
    tableExpandedRowBg: rowExpandedBg,
    // Dropdown
    tableFilterDropdownWidth: 120,
    tableFilterDropdownHeight: 264,
    tableFilterDropdownSearchWidth: 140,
    // Virtual Scroll Bar
    tableScrollThumbSize: 8,
    // Mac scroll bar size
    tableScrollThumbBg: stickyScrollBarBg,
    tableScrollThumbBgHover: colorTextHeading,
    tableScrollBg: colorSplit
  });
  return [genTableStyle(tableToken), genPaginationStyle(tableToken), genSummaryStyle(tableToken), genSorterStyle(tableToken), genFilterStyle(tableToken), genBorderedStyle(tableToken), genRadiusStyle(tableToken), genExpandStyle(tableToken), genSummaryStyle(tableToken), genEmptyStyle(tableToken), genSelectionStyle(tableToken), genFixedStyle(tableToken), genStickyStyle(tableToken), genEllipsisStyle(tableToken), genSizeStyle(tableToken), genStyle(tableToken), genVirtualStyle(tableToken)];
}, prepareComponentToken$3, {
  unitless: {
    expandIconScale: !0
  }
}), EMPTY_LIST = [], InternalTable = /* @__PURE__ */ __name((props, ref) => {
  var _a, _b;
  const {
    prefixCls: customizePrefixCls,
    className,
    rootClassName,
    style: style2,
    size: customizeSize,
    bordered,
    dropdownPrefixCls: customizeDropdownPrefixCls,
    dataSource,
    pagination,
    rowSelection,
    rowKey = "key",
    rowClassName,
    columns,
    children,
    childrenColumnName: legacyChildrenColumnName,
    onChange,
    getPopupContainer,
    loading,
    expandIcon,
    expandable,
    expandedRowRender,
    expandIconColumnIndex,
    indentSize,
    scroll,
    sortDirections,
    locale: locale2,
    showSorterTooltip = {
      target: "full-header"
    },
    virtual
  } = props, warning3 = devUseWarning("Table");
  process.env.NODE_ENV !== "production" && process.env.NODE_ENV !== "production" && warning3(!(typeof rowKey == "function" && rowKey.length > 1), "usage", "`index` parameter of `rowKey` function is deprecated. There is no guarantee that it will work as expected.");
  const baseColumns = React.useMemo(() => columns || convertChildrenToColumns(children), [columns, children]), needResponsive = React.useMemo(() => baseColumns.some((col) => col.responsive), [baseColumns]), screens = useBreakpoint(needResponsive), mergedColumns = React.useMemo(() => {
    const matched = new Set(Object.keys(screens).filter((m2) => screens[m2]));
    return baseColumns.filter((c) => !c.responsive || c.responsive.some((r2) => matched.has(r2)));
  }, [baseColumns, screens]), tableProps = omit(props, ["className", "style", "columns"]), {
    locale: contextLocale = localeValues$1,
    direction,
    table,
    renderEmpty,
    getPrefixCls,
    getPopupContainer: getContextPopupContainer
  } = React.useContext(ConfigContext), mergedSize = useSize(customizeSize), tableLocale = Object.assign(Object.assign({}, contextLocale.Table), locale2), rawData = dataSource || EMPTY_LIST, prefixCls = getPrefixCls("table", customizePrefixCls), dropdownPrefixCls = getPrefixCls("dropdown", customizeDropdownPrefixCls), [, token2] = useToken(), rootCls = useCSSVarCls(prefixCls), [wrapCSSVar, hashId, cssVarCls] = useStyle$3(prefixCls, rootCls), mergedExpandable = Object.assign(Object.assign({
    childrenColumnName: legacyChildrenColumnName,
    expandIconColumnIndex
  }, expandable), {
    expandIcon: (_a = expandable == null ? void 0 : expandable.expandIcon) !== null && _a !== void 0 ? _a : (_b = table == null ? void 0 : table.expandable) === null || _b === void 0 ? void 0 : _b.expandIcon
  }), {
    childrenColumnName = "children"
  } = mergedExpandable, expandType = React.useMemo(() => rawData.some((item) => item == null ? void 0 : item[childrenColumnName]) ? "nest" : expandedRowRender || expandable != null && expandable.expandedRowRender ? "row" : null, [rawData]), internalRefs = {
    body: React.useRef(null)
  }, getContainerWidth = useContainerWidth(prefixCls), rootRef = React.useRef(null), tblRef = React.useRef(null);
  useProxyImperativeHandle(ref, () => Object.assign(Object.assign({}, tblRef.current), {
    nativeElement: rootRef.current
  }));
  const getRowKey = React.useMemo(() => typeof rowKey == "function" ? rowKey : (record) => record == null ? void 0 : record[rowKey], [rowKey]), [getRecordByKey] = useLazyKVMap(rawData, childrenColumnName, getRowKey), changeEventInfo = {}, triggerOnChange = /* @__PURE__ */ __name(function(info, action) {
    let reset = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !1;
    var _a2, _b2, _c, _d;
    const changeInfo = Object.assign(Object.assign({}, changeEventInfo), info);
    reset && ((_a2 = changeEventInfo.resetPagination) === null || _a2 === void 0 || _a2.call(changeEventInfo), !((_b2 = changeInfo.pagination) === null || _b2 === void 0) && _b2.current && (changeInfo.pagination.current = 1), pagination && ((_c = pagination.onChange) === null || _c === void 0 || _c.call(pagination, 1, (_d = changeInfo.pagination) === null || _d === void 0 ? void 0 : _d.pageSize))), scroll && scroll.scrollToFirstRowOnChange !== !1 && internalRefs.body.current && scrollTo(0, {
      getContainer: /* @__PURE__ */ __name(() => internalRefs.body.current, "getContainer")
    }), onChange == null || onChange(changeInfo.pagination, changeInfo.filters, changeInfo.sorter, {
      currentDataSource: getFilterData(getSortData(rawData, changeInfo.sorterStates, childrenColumnName), changeInfo.filterStates, childrenColumnName),
      action
    });
  }, "triggerOnChange"), onSorterChange = /* @__PURE__ */ __name((sorter, sorterStates) => {
    triggerOnChange({
      sorter,
      sorterStates
    }, "sort", !1);
  }, "onSorterChange"), [transformSorterColumns, sortStates, sorterTitleProps, getSorters] = useFilterSorter({
    prefixCls,
    mergedColumns,
    onSorterChange,
    sortDirections: sortDirections || ["ascend", "descend"],
    tableLocale,
    showSorterTooltip
  }), sortedData = React.useMemo(() => getSortData(rawData, sortStates, childrenColumnName), [rawData, sortStates]);
  changeEventInfo.sorter = getSorters(), changeEventInfo.sorterStates = sortStates;
  const onFilterChange = /* @__PURE__ */ __name((filters2, filterStates2) => {
    triggerOnChange({
      filters: filters2,
      filterStates: filterStates2
    }, "filter", !0);
  }, "onFilterChange"), [transformFilterColumns, filterStates, filters] = useFilter({
    prefixCls,
    locale: tableLocale,
    dropdownPrefixCls,
    mergedColumns,
    onFilterChange,
    getPopupContainer: getPopupContainer || getContextPopupContainer,
    rootClassName: cn(rootClassName, rootCls)
  }), mergedData = getFilterData(sortedData, filterStates, childrenColumnName);
  changeEventInfo.filters = filters, changeEventInfo.filterStates = filterStates;
  const columnTitleProps = React.useMemo(() => {
    const mergedFilters = {};
    return Object.keys(filters).forEach((filterKey) => {
      filters[filterKey] !== null && (mergedFilters[filterKey] = filters[filterKey]);
    }), Object.assign(Object.assign({}, sorterTitleProps), {
      filters: mergedFilters
    });
  }, [sorterTitleProps, filters]), [transformTitleColumns] = useTitleColumns(columnTitleProps), onPaginationChange = /* @__PURE__ */ __name((current, pageSize) => {
    triggerOnChange({
      pagination: Object.assign(Object.assign({}, changeEventInfo.pagination), {
        current,
        pageSize
      })
    }, "paginate");
  }, "onPaginationChange"), [mergedPagination, resetPagination] = usePagination(mergedData.length, onPaginationChange, pagination);
  changeEventInfo.pagination = pagination === !1 ? {} : getPaginationParam(mergedPagination, pagination), changeEventInfo.resetPagination = resetPagination;
  const pageData = React.useMemo(() => {
    if (pagination === !1 || !mergedPagination.pageSize)
      return mergedData;
    const {
      current = 1,
      total,
      pageSize = DEFAULT_PAGE_SIZE
    } = mergedPagination;
    return process.env.NODE_ENV !== "production" && warning3(current > 0, "usage", "`current` should be positive number."), mergedData.length < total ? mergedData.length > pageSize ? (process.env.NODE_ENV !== "production" && warning3(!1, "usage", "`dataSource` length is less than `pagination.total` but large than `pagination.pageSize`. Please make sure your config correct data with async mode."), mergedData.slice((current - 1) * pageSize, current * pageSize)) : mergedData : mergedData.slice((current - 1) * pageSize, current * pageSize);
  }, [!!pagination, mergedData, mergedPagination == null ? void 0 : mergedPagination.current, mergedPagination == null ? void 0 : mergedPagination.pageSize, mergedPagination == null ? void 0 : mergedPagination.total]), [transformSelectionColumns, selectedKeySet] = useSelection$1({
    prefixCls,
    data: mergedData,
    pageData,
    getRowKey,
    getRecordByKey,
    expandType,
    childrenColumnName,
    locale: tableLocale,
    getPopupContainer: getPopupContainer || getContextPopupContainer
  }, rowSelection), internalRowClassName = /* @__PURE__ */ __name((record, index2, indent) => {
    let mergedRowClassName;
    return typeof rowClassName == "function" ? mergedRowClassName = cn(rowClassName(record, index2, indent)) : mergedRowClassName = cn(rowClassName), cn({
      [`${prefixCls}-row-selected`]: selectedKeySet.has(getRowKey(record, index2))
    }, mergedRowClassName);
  }, "internalRowClassName");
  mergedExpandable.__PARENT_RENDER_ICON__ = mergedExpandable.expandIcon, mergedExpandable.expandIcon = mergedExpandable.expandIcon || expandIcon || renderExpandIcon(tableLocale), expandType === "nest" && mergedExpandable.expandIconColumnIndex === void 0 ? mergedExpandable.expandIconColumnIndex = rowSelection ? 1 : 0 : mergedExpandable.expandIconColumnIndex > 0 && rowSelection && (mergedExpandable.expandIconColumnIndex -= 1), typeof mergedExpandable.indentSize != "number" && (mergedExpandable.indentSize = typeof indentSize == "number" ? indentSize : 15);
  const transformColumns = React.useCallback((innerColumns) => transformTitleColumns(transformSelectionColumns(transformFilterColumns(transformSorterColumns(innerColumns)))), [transformSorterColumns, transformFilterColumns, transformSelectionColumns]);
  let topPaginationNode, bottomPaginationNode;
  if (pagination !== !1 && (mergedPagination != null && mergedPagination.total)) {
    let paginationSize;
    mergedPagination.size ? paginationSize = mergedPagination.size : paginationSize = mergedSize === "small" || mergedSize === "middle" ? "small" : void 0;
    const renderPagination = /* @__PURE__ */ __name((position3) => /* @__PURE__ */ React.createElement(Pagination2, Object.assign({}, mergedPagination, {
      className: cn(`${prefixCls}-pagination ${prefixCls}-pagination-${position3}`, mergedPagination.className),
      size: paginationSize
    })), "renderPagination"), defaultPosition = direction === "rtl" ? "left" : "right", {
      position: position2
    } = mergedPagination;
    if (position2 !== null && Array.isArray(position2)) {
      const topPos = position2.find((p) => p.includes("top")), bottomPos = position2.find((p) => p.includes("bottom")), isDisable = position2.every((p) => `${p}` == "none");
      !topPos && !bottomPos && !isDisable && (bottomPaginationNode = renderPagination(defaultPosition)), topPos && (topPaginationNode = renderPagination(topPos.toLowerCase().replace("top", ""))), bottomPos && (bottomPaginationNode = renderPagination(bottomPos.toLowerCase().replace("bottom", "")));
    } else
      bottomPaginationNode = renderPagination(defaultPosition);
  }
  let spinProps;
  typeof loading == "boolean" ? spinProps = {
    spinning: loading
  } : typeof loading == "object" && (spinProps = Object.assign({
    spinning: !0
  }, loading));
  const wrapperClassNames = cn(cssVarCls, rootCls, `${prefixCls}-wrapper`, table == null ? void 0 : table.className, {
    [`${prefixCls}-wrapper-rtl`]: direction === "rtl"
  }, className, rootClassName, hashId), mergedStyle = Object.assign(Object.assign({}, table == null ? void 0 : table.style), style2), emptyText = typeof (locale2 == null ? void 0 : locale2.emptyText) < "u" ? locale2.emptyText : (renderEmpty == null ? void 0 : renderEmpty("Table")) || /* @__PURE__ */ React.createElement(DefaultRenderEmpty, {
    componentName: "Table"
  }), TableComponent = virtual ? RcVirtualTable : RcTable, virtualProps = {}, listItemHeight = React.useMemo(() => {
    const {
      fontSize,
      lineHeight,
      padding,
      paddingXS,
      paddingSM
    } = token2, fontHeight = Math.floor(fontSize * lineHeight);
    switch (mergedSize) {
      case "large":
        return padding * 2 + fontHeight;
      case "small":
        return paddingXS * 2 + fontHeight;
      default:
        return paddingSM * 2 + fontHeight;
    }
  }, [token2, mergedSize]);
  return virtual && (virtualProps.listItemHeight = listItemHeight), wrapCSSVar(/* @__PURE__ */ React.createElement("div", {
    ref: rootRef,
    className: wrapperClassNames,
    style: mergedStyle
  }, /* @__PURE__ */ React.createElement(Spin, Object.assign({
    spinning: !1
  }, spinProps), topPaginationNode, /* @__PURE__ */ React.createElement(TableComponent, Object.assign({}, virtualProps, tableProps, {
    ref: tblRef,
    columns: mergedColumns,
    direction,
    expandable: mergedExpandable,
    prefixCls,
    className: cn({
      [`${prefixCls}-middle`]: mergedSize === "middle",
      [`${prefixCls}-small`]: mergedSize === "small",
      [`${prefixCls}-bordered`]: bordered,
      [`${prefixCls}-empty`]: rawData.length === 0
    }, cssVarCls, rootCls, hashId),
    data: pageData,
    rowKey: getRowKey,
    rowClassName: internalRowClassName,
    emptyText,
    // Internal
    internalHooks: INTERNAL_HOOKS,
    internalRefs,
    transformColumns,
    getContainerWidth
  })), bottomPaginationNode)));
}, "InternalTable"), InternalTable$1 = /* @__PURE__ */ React.forwardRef(InternalTable), Table$1 = /* @__PURE__ */ __name((props, ref) => {
  const renderTimesRef = React.useRef(0);
  return renderTimesRef.current += 1, /* @__PURE__ */ React.createElement(InternalTable$1, Object.assign({}, props, {
    ref,
    _renderTimes: renderTimesRef.current
  }));
}, "Table$1"), ForwardTable = /* @__PURE__ */ React.forwardRef(Table$1);
ForwardTable.SELECTION_COLUMN = SELECTION_COLUMN;
ForwardTable.EXPAND_COLUMN = EXPAND_COLUMN;
ForwardTable.SELECTION_ALL = SELECTION_ALL;
ForwardTable.SELECTION_INVERT = SELECTION_INVERT;
ForwardTable.SELECTION_NONE = SELECTION_NONE;
ForwardTable.Column = Column;
ForwardTable.ColumnGroup = ColumnGroup;
ForwardTable.Summary = FooterComponents;
process.env.NODE_ENV !== "production" && (ForwardTable.displayName = "Table");
const getAlphaColor = /* @__PURE__ */ __name((baseColor, alpha) => new TinyColor(baseColor).setAlpha(alpha).toRgbString(), "getAlphaColor"), getSolidColor = /* @__PURE__ */ __name((baseColor, brightness) => new TinyColor(baseColor).lighten(brightness).toHexString(), "getSolidColor"), generateColorPalettes = /* @__PURE__ */ __name((baseColor) => {
  const colors = generate$1(baseColor, {
    theme: "dark"
  });
  return {
    1: colors[0],
    2: colors[1],
    3: colors[2],
    4: colors[3],
    5: colors[6],
    6: colors[5],
    7: colors[4],
    8: colors[6],
    9: colors[5],
    10: colors[4]
    // 8: colors[9],
    // 9: colors[8],
    // 10: colors[7],
  };
}, "generateColorPalettes"), generateNeutralColorPalettes = /* @__PURE__ */ __name((bgBaseColor, textBaseColor) => {
  const colorBgBase = bgBaseColor || "#000", colorTextBase = textBaseColor || "#fff";
  return {
    colorBgBase,
    colorTextBase,
    colorText: getAlphaColor(colorTextBase, 0.85),
    colorTextSecondary: getAlphaColor(colorTextBase, 0.65),
    colorTextTertiary: getAlphaColor(colorTextBase, 0.45),
    colorTextQuaternary: getAlphaColor(colorTextBase, 0.25),
    colorFill: getAlphaColor(colorTextBase, 0.18),
    colorFillSecondary: getAlphaColor(colorTextBase, 0.12),
    colorFillTertiary: getAlphaColor(colorTextBase, 0.08),
    colorFillQuaternary: getAlphaColor(colorTextBase, 0.04),
    colorBgSolid: getAlphaColor(colorTextBase, 0.95),
    colorBgSolidHover: getAlphaColor(colorTextBase, 1),
    colorBgSolidActive: getAlphaColor(colorTextBase, 0.9),
    colorBgElevated: getSolidColor(colorBgBase, 12),
    colorBgContainer: getSolidColor(colorBgBase, 8),
    colorBgLayout: getSolidColor(colorBgBase, 0),
    colorBgSpotlight: getSolidColor(colorBgBase, 26),
    colorBgBlur: getAlphaColor(colorTextBase, 0.04),
    colorBorder: getSolidColor(colorBgBase, 26),
    colorBorderSecondary: getSolidColor(colorBgBase, 19)
  };
}, "generateNeutralColorPalettes"), derivative = /* @__PURE__ */ __name((token2, mapToken) => {
  const colorPalettes = Object.keys(defaultPresetColors).map((colorKey) => {
    const colors = generate$1(token2[colorKey], {
      theme: "dark"
    });
    return new Array(10).fill(1).reduce((prev2, _2, i) => (prev2[`${colorKey}-${i + 1}`] = colors[i], prev2[`${colorKey}${i + 1}`] = colors[i], prev2), {});
  }).reduce((prev2, cur) => (prev2 = Object.assign(Object.assign({}, prev2), cur), prev2), {}), mergedMapToken = mapToken ?? derivative$1(token2);
  return Object.assign(Object.assign(Object.assign({}, mergedMapToken), colorPalettes), genColorMapToken(token2, {
    generateColorPalettes,
    generateNeutralColorPalettes
  }));
}, "derivative"), theme = {
  /** Default seedToken */
  defaultSeed: defaultConfig.token,
  defaultAlgorithm: derivative$1,
  darkAlgorithm: derivative
};
var __rest$6 = function(s, e2) {
  var t2 = {};
  for (var p in s) Object.prototype.hasOwnProperty.call(s, p) && e2.indexOf(p) < 0 && (t2[p] = s[p]);
  if (s != null && typeof Object.getOwnPropertySymbols == "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++)
    e2.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]) && (t2[p[i]] = s[p[i]]);
  return t2;
};
const {
  TimePicker: InternalTimePicker,
  RangePicker: InternalRangePicker
} = DatePicker$1, RangePicker$1 = /* @__PURE__ */ React.forwardRef((props, ref) => /* @__PURE__ */ React.createElement(InternalRangePicker, Object.assign({}, props, {
  picker: "time",
  mode: void 0,
  ref
}))), TimePicker$1 = /* @__PURE__ */ React.forwardRef((_a, ref) => {
  var {
    addon,
    renderExtraFooter,
    variant,
    bordered
  } = _a, restProps = __rest$6(_a, ["addon", "renderExtraFooter", "variant", "bordered"]);
  process.env.NODE_ENV !== "production" && devUseWarning("TimePicker").deprecated(!addon, "addon", "renderExtraFooter");
  const [mergedVariant] = useVariant("timePicker", variant, bordered), internalRenderExtraFooter = React.useMemo(() => {
    if (renderExtraFooter)
      return renderExtraFooter;
    if (addon)
      return addon;
  }, [addon, renderExtraFooter]);
  return /* @__PURE__ */ React.createElement(InternalTimePicker, Object.assign({}, restProps, {
    mode: void 0,
    ref,
    renderExtraFooter: internalRenderExtraFooter,
    variant: mergedVariant
  }));
});
process.env.NODE_ENV !== "production" && (TimePicker$1.displayName = "TimePicker");
const PurePanel = genPurePanel(TimePicker$1, "picker");
TimePicker$1._InternalPanelDoNotUseOrYouWillBeFired = PurePanel;
TimePicker$1.RangePicker = RangePicker$1;
TimePicker$1._InternalPanelDoNotUseOrYouWillBeFired = PurePanel;
const groupKeysMap = /* @__PURE__ */ __name((keys2) => {
  const map = /* @__PURE__ */ new Map();
  return keys2.forEach((key, index2) => {
    map.set(key, index2);
  }), map;
}, "groupKeysMap"), groupDisabledKeysMap = /* @__PURE__ */ __name((dataSource) => {
  const map = /* @__PURE__ */ new Map();
  return dataSource.forEach((_ref, index2) => {
    let {
      disabled,
      key
    } = _ref;
    disabled && map.set(key, index2);
  }), map;
}, "groupDisabledKeysMap"), useData = /* @__PURE__ */ __name((dataSource, rowKey, targetKeys) => {
  const mergedDataSource = React.useMemo(() => (dataSource || []).map((record) => rowKey ? Object.assign(Object.assign({}, record), {
    key: rowKey(record)
  }) : record), [dataSource, rowKey]), [leftDataSource, rightDataSource] = React.useMemo(() => {
    const leftData = [], rightData = new Array((targetKeys || []).length), targetKeysMap = groupKeysMap(targetKeys || []);
    return mergedDataSource.forEach((record) => {
      targetKeysMap.has(record.key) ? rightData[targetKeysMap.get(record.key)] = record : leftData.push(record);
    }), [leftData, rightData];
  }, [mergedDataSource, targetKeys, rowKey]);
  return [mergedDataSource, leftDataSource, rightDataSource];
}, "useData"), EMPTY_KEYS = [];
function filterKeys(keys2, dataKeys) {
  const filteredKeys = keys2.filter((key) => dataKeys.has(key));
  return keys2.length === filteredKeys.length ? keys2 : filteredKeys;
}
__name(filterKeys, "filterKeys");
function flattenKeys(keys2) {
  return Array.from(keys2).join(";");
}
__name(flattenKeys, "flattenKeys");
function useSelection(leftDataSource, rightDataSource, selectedKeys) {
  const [leftKeys, rightKeys] = React.useMemo(() => [new Set(leftDataSource.map((src) => src.key)), new Set(rightDataSource.map((src) => src.key))], [leftDataSource, rightDataSource]), [mergedSelectedKeys, setMergedSelectedKeys] = useMergedState(EMPTY_KEYS, {
    value: selectedKeys
  }), sourceSelectedKeys = React.useMemo(() => filterKeys(mergedSelectedKeys, leftKeys), [mergedSelectedKeys, leftKeys]), targetSelectedKeys = React.useMemo(() => filterKeys(mergedSelectedKeys, rightKeys), [mergedSelectedKeys, rightKeys]);
  React.useEffect(() => {
    setMergedSelectedKeys([].concat(_toConsumableArray(filterKeys(mergedSelectedKeys, leftKeys)), _toConsumableArray(filterKeys(mergedSelectedKeys, rightKeys))));
  }, [flattenKeys(leftKeys), flattenKeys(rightKeys)]);
  const setSourceSelectedKeys = useEvent((nextSrcKeys) => {
    setMergedSelectedKeys([].concat(_toConsumableArray(nextSrcKeys), _toConsumableArray(targetSelectedKeys)));
  }), setTargetSelectedKeys = useEvent((nextTargetKeys) => {
    setMergedSelectedKeys([].concat(_toConsumableArray(sourceSelectedKeys), _toConsumableArray(nextTargetKeys)));
  });
  return [
    // Keys
    sourceSelectedKeys,
    targetSelectedKeys,
    // Updater
    setSourceSelectedKeys,
    setTargetSelectedKeys
  ];
}
__name(useSelection, "useSelection");
const ListItem$1 = /* @__PURE__ */ __name((props) => {
  const {
    renderedText,
    renderedEl,
    item,
    checked,
    disabled,
    prefixCls,
    onClick,
    onRemove,
    showRemove
  } = props, className = cn(`${prefixCls}-content-item`, {
    [`${prefixCls}-content-item-disabled`]: disabled || item.disabled,
    [`${prefixCls}-content-item-checked`]: checked && !item.disabled
  });
  let title2;
  (typeof renderedText == "string" || typeof renderedText == "number") && (title2 = String(renderedText));
  const [contextLocale] = useLocale$1("Transfer", localeValues$1.Transfer), liProps = {
    className,
    title: title2
  }, labelNode = /* @__PURE__ */ React.createElement("span", {
    className: `${prefixCls}-content-item-text`
  }, renderedEl);
  return showRemove ? /* @__PURE__ */ React.createElement("li", Object.assign({}, liProps), labelNode, /* @__PURE__ */ React.createElement("button", {
    type: "button",
    disabled: disabled || item.disabled,
    className: `${prefixCls}-content-item-remove`,
    "aria-label": contextLocale == null ? void 0 : contextLocale.remove,
    onClick: /* @__PURE__ */ __name(() => onRemove == null ? void 0 : onRemove(item), "onClick")
  }, /* @__PURE__ */ React.createElement(RefIcon$d, null))) : (liProps.onClick = disabled || item.disabled ? void 0 : (event) => onClick(item, event), /* @__PURE__ */ React.createElement("li", Object.assign({}, liProps), /* @__PURE__ */ React.createElement(Checkbox$1, {
    className: `${prefixCls}-checkbox`,
    checked,
    disabled: disabled || item.disabled
  }), labelNode));
}, "ListItem$1"), ListItem$2 = /* @__PURE__ */ React.memo(ListItem$1), OmitProps = ["handleFilter", "handleClear", "checkedKeys"], parsePagination = /* @__PURE__ */ __name((pagination) => Object.assign(Object.assign({}, {
  simple: !0,
  showSizeChanger: !1,
  showLessItems: !1
}), pagination), "parsePagination"), TransferListBody = /* @__PURE__ */ __name((props, ref) => {
  const {
    prefixCls,
    filteredRenderItems,
    selectedKeys,
    disabled: globalDisabled,
    showRemove,
    pagination,
    onScroll,
    onItemSelect,
    onItemRemove
  } = props, [current, setCurrent] = React.useState(1), mergedPagination = React.useMemo(() => pagination ? parsePagination(typeof pagination == "object" ? pagination : {}) : null, [pagination]), [pageSize, setPageSize] = useMergedState(10, {
    value: mergedPagination == null ? void 0 : mergedPagination.pageSize
  });
  React.useEffect(() => {
    if (mergedPagination) {
      const maxPageCount = Math.ceil(filteredRenderItems.length / pageSize);
      setCurrent(Math.min(current, maxPageCount));
    }
  }, [filteredRenderItems, mergedPagination, pageSize]);
  const onInternalClick = /* @__PURE__ */ __name((item, e2) => {
    onItemSelect(item.key, !selectedKeys.includes(item.key), e2);
  }, "onInternalClick"), onRemove = /* @__PURE__ */ __name((item) => {
    onItemRemove == null || onItemRemove([item.key]);
  }, "onRemove"), onPageChange = /* @__PURE__ */ __name((cur) => {
    setCurrent(cur);
  }, "onPageChange"), onSizeChange = /* @__PURE__ */ __name((cur, size) => {
    setCurrent(cur), setPageSize(size);
  }, "onSizeChange"), memoizedItems = React.useMemo(() => mergedPagination ? filteredRenderItems.slice((current - 1) * pageSize, current * pageSize) : filteredRenderItems, [current, filteredRenderItems, mergedPagination, pageSize]);
  React.useImperativeHandle(ref, () => ({
    items: memoizedItems
  }));
  const paginationNode = mergedPagination ? /* @__PURE__ */ React.createElement(Pagination2, {
    size: "small",
    disabled: globalDisabled,
    simple: mergedPagination.simple,
    pageSize,
    showLessItems: mergedPagination.showLessItems,
    showSizeChanger: mergedPagination.showSizeChanger,
    className: `${prefixCls}-pagination`,
    total: filteredRenderItems.length,
    current,
    onChange: onPageChange,
    onShowSizeChange: onSizeChange
  }) : null, cls = cn(`${prefixCls}-content`, {
    [`${prefixCls}-content-show-remove`]: showRemove
  });
  return /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement("ul", {
    className: cls,
    onScroll
  }, (memoizedItems || []).map((_ref) => {
    let {
      renderedEl,
      renderedText,
      item
    } = _ref;
    return /* @__PURE__ */ React.createElement(ListItem$2, {
      key: item.key,
      item,
      renderedText,
      renderedEl,
      prefixCls,
      showRemove,
      onClick: onInternalClick,
      onRemove,
      checked: selectedKeys.includes(item.key),
      disabled: globalDisabled || item.disabled
    });
  })), paginationNode);
}, "TransferListBody");
process.env.NODE_ENV !== "production" && (TransferListBody.displayName = "TransferListBody");
const DefaultListBody = /* @__PURE__ */ React.forwardRef(TransferListBody), Search = /* @__PURE__ */ __name((props) => {
  const {
    placeholder = "",
    value,
    prefixCls,
    disabled,
    onChange,
    handleClear
  } = props, handleChange = React.useCallback((e2) => {
    onChange == null || onChange(e2), e2.target.value === "" && (handleClear == null || handleClear());
  }, [onChange]);
  return /* @__PURE__ */ React.createElement(Input$1, {
    placeholder,
    className: prefixCls,
    value,
    onChange: handleChange,
    disabled,
    allowClear: !0,
    prefix: /* @__PURE__ */ React.createElement(RefIcon$v, null)
  });
}, "Search");
process.env.NODE_ENV !== "production" && (Search.displayName = "Search");
const defaultRender = /* @__PURE__ */ __name(() => null, "defaultRender");
function isRenderResultPlainObject(result) {
  return !!(result && !/* @__PURE__ */ React__default.isValidElement(result) && Object.prototype.toString.call(result) === "[object Object]");
}
__name(isRenderResultPlainObject, "isRenderResultPlainObject");
function getEnabledItemKeys(items) {
  return items.filter((data) => !data.disabled).map((data) => data.key);
}
__name(getEnabledItemKeys, "getEnabledItemKeys");
const isValidIcon = /* @__PURE__ */ __name((icon) => icon !== void 0, "isValidIcon"), TransferList = /* @__PURE__ */ __name((props) => {
  const {
    prefixCls,
    dataSource = [],
    titleText = "",
    checkedKeys,
    disabled,
    showSearch = !1,
    style: style2,
    searchPlaceholder,
    notFoundContent,
    selectAll,
    deselectAll,
    selectCurrent,
    selectInvert,
    removeAll,
    removeCurrent,
    showSelectAll = !0,
    showRemove,
    pagination,
    direction,
    itemsUnit,
    itemUnit,
    selectAllLabel,
    selectionsIcon,
    footer,
    renderList,
    onItemSelectAll,
    onItemRemove,
    handleFilter,
    handleClear,
    filterOption,
    render: render4 = defaultRender
  } = props, [filterValue, setFilterValue] = useState(""), listBodyRef = useRef({}), internalHandleFilter = /* @__PURE__ */ __name((e2) => {
    setFilterValue(e2.target.value), handleFilter(e2);
  }, "internalHandleFilter"), internalHandleClear = /* @__PURE__ */ __name(() => {
    setFilterValue(""), handleClear();
  }, "internalHandleClear"), matchFilter = /* @__PURE__ */ __name((text, item) => filterOption ? filterOption(filterValue, item, direction) : text.includes(filterValue), "matchFilter"), renderListBody = /* @__PURE__ */ __name((listProps) => {
    let bodyContent = renderList ? renderList(Object.assign(Object.assign({}, listProps), {
      onItemSelect: /* @__PURE__ */ __name((key, check) => listProps.onItemSelect(key, check), "onItemSelect")
    })) : null;
    const customize = !!bodyContent;
    return customize || (bodyContent = /* @__PURE__ */ React__default.createElement(DefaultListBody, Object.assign({
      ref: listBodyRef
    }, listProps))), {
      customize,
      bodyContent
    };
  }, "renderListBody"), renderItem = /* @__PURE__ */ __name((item) => {
    const renderResult = render4(item), isRenderResultPlain = isRenderResultPlainObject(renderResult);
    return {
      item,
      renderedEl: isRenderResultPlain ? renderResult.label : renderResult,
      renderedText: isRenderResultPlain ? renderResult.value : renderResult
    };
  }, "renderItem"), notFoundContentEle = useMemo$1(() => Array.isArray(notFoundContent) ? notFoundContent[direction === "left" ? 0 : 1] : notFoundContent, [notFoundContent, direction]), [filteredItems, filteredRenderItems] = useMemo$1(() => {
    const filterItems = [], filterRenderItems = [];
    return dataSource.forEach((item) => {
      const renderedItem = renderItem(item);
      filterValue && !matchFilter(renderedItem.renderedText, item) || (filterItems.push(item), filterRenderItems.push(renderedItem));
    }), [filterItems, filterRenderItems];
  }, [dataSource, filterValue]), checkedActiveItems = useMemo$1(() => filteredItems.filter((item) => checkedKeys.includes(item.key) && !item.disabled), [checkedKeys, filteredItems]), checkStatus = useMemo$1(() => {
    if (checkedActiveItems.length === 0)
      return "none";
    const checkedKeysMap = groupKeysMap(checkedKeys);
    return filteredItems.every((item) => checkedKeysMap.has(item.key) || !!item.disabled) ? "all" : "part";
  }, [checkedKeys, checkedActiveItems]), listBody = useMemo$1(() => {
    const search = showSearch ? /* @__PURE__ */ React__default.createElement("div", {
      className: `${prefixCls}-body-search-wrapper`
    }, /* @__PURE__ */ React__default.createElement(Search, {
      prefixCls: `${prefixCls}-search`,
      onChange: internalHandleFilter,
      handleClear: internalHandleClear,
      placeholder: searchPlaceholder,
      value: filterValue,
      disabled
    })) : null, {
      customize,
      bodyContent
    } = renderListBody(Object.assign(Object.assign({}, omit(props, OmitProps)), {
      filteredItems,
      filteredRenderItems,
      selectedKeys: checkedKeys
    }));
    let bodyNode;
    return customize ? bodyNode = /* @__PURE__ */ React__default.createElement("div", {
      className: `${prefixCls}-body-customize-wrapper`
    }, bodyContent) : bodyNode = filteredItems.length ? bodyContent : /* @__PURE__ */ React__default.createElement("div", {
      className: `${prefixCls}-body-not-found`
    }, notFoundContentEle), /* @__PURE__ */ React__default.createElement("div", {
      className: cn(showSearch ? `${prefixCls}-body ${prefixCls}-body-with-search` : `${prefixCls}-body`)
    }, search, bodyNode);
  }, [showSearch, prefixCls, searchPlaceholder, filterValue, disabled, checkedKeys, filteredItems, filteredRenderItems, notFoundContentEle]), checkBox = /* @__PURE__ */ React__default.createElement(Checkbox$1, {
    disabled: dataSource.filter((d) => !d.disabled).length === 0 || disabled,
    checked: checkStatus === "all",
    indeterminate: checkStatus === "part",
    className: `${prefixCls}-checkbox`,
    onChange: /* @__PURE__ */ __name(() => {
      onItemSelectAll == null || onItemSelectAll(filteredItems.filter((item) => !item.disabled).map((_ref) => {
        let {
          key
        } = _ref;
        return key;
      }), checkStatus !== "all");
    }, "onChange")
  }), getSelectAllLabel = /* @__PURE__ */ __name((selectedCount, totalCount) => {
    if (selectAllLabel)
      return typeof selectAllLabel == "function" ? selectAllLabel({
        selectedCount,
        totalCount
      }) : selectAllLabel;
    const unit2 = totalCount > 1 ? itemsUnit : itemUnit;
    return /* @__PURE__ */ React__default.createElement(React__default.Fragment, null, (selectedCount > 0 ? `${selectedCount}/` : "") + totalCount, " ", unit2);
  }, "getSelectAllLabel"), footerDom = footer && (footer.length < 2 ? footer(props) : footer(props, {
    direction
  })), listCls = cn(prefixCls, {
    [`${prefixCls}-with-pagination`]: !!pagination,
    [`${prefixCls}-with-footer`]: !!footerDom
  }), listFooter = footerDom ? /* @__PURE__ */ React__default.createElement("div", {
    className: `${prefixCls}-footer`
  }, footerDom) : null, checkAllCheckbox = !showRemove && !pagination && checkBox;
  let items;
  showRemove ? items = [
    /* Remove Current Page */
    pagination ? {
      key: "removeCurrent",
      label: removeCurrent,
      onClick() {
        var _a;
        const pageKeys = getEnabledItemKeys((((_a = listBodyRef.current) === null || _a === void 0 ? void 0 : _a.items) || []).map((entity) => entity.item));
        onItemRemove == null || onItemRemove(pageKeys);
      }
    } : null,
    /* Remove All */
    {
      key: "removeAll",
      label: removeAll,
      onClick() {
        onItemRemove == null || onItemRemove(getEnabledItemKeys(filteredItems));
      }
    }
  ].filter(Boolean) : items = [{
    key: "selectAll",
    label: checkStatus === "all" ? deselectAll : selectAll,
    onClick() {
      const keys2 = getEnabledItemKeys(filteredItems);
      onItemSelectAll == null || onItemSelectAll(keys2, keys2.length !== checkedKeys.length);
    }
  }, pagination ? {
    key: "selectCurrent",
    label: selectCurrent,
    onClick() {
      var _a;
      const pageItems = ((_a = listBodyRef.current) === null || _a === void 0 ? void 0 : _a.items) || [];
      onItemSelectAll == null || onItemSelectAll(getEnabledItemKeys(pageItems.map((entity) => entity.item)), !0);
    }
  } : null, {
    key: "selectInvert",
    label: selectInvert,
    onClick() {
      var _a;
      const availablePageItemKeys = getEnabledItemKeys((((_a = listBodyRef.current) === null || _a === void 0 ? void 0 : _a.items) || []).map((entity) => entity.item)), checkedKeySet = new Set(checkedKeys), newCheckedKeysSet = new Set(checkedKeySet);
      availablePageItemKeys.forEach((key) => {
        checkedKeySet.has(key) ? newCheckedKeysSet.delete(key) : newCheckedKeysSet.add(key);
      }), onItemSelectAll == null || onItemSelectAll(Array.from(newCheckedKeysSet), "replace");
    }
  }];
  const dropdown = /* @__PURE__ */ React__default.createElement(Dropdown, {
    className: `${prefixCls}-header-dropdown`,
    menu: {
      items
    },
    disabled
  }, isValidIcon(selectionsIcon) ? selectionsIcon : /* @__PURE__ */ React__default.createElement(RefIcon$w, null));
  return /* @__PURE__ */ React__default.createElement("div", {
    className: listCls,
    style: style2
  }, /* @__PURE__ */ React__default.createElement("div", {
    className: `${prefixCls}-header`
  }, showSelectAll ? /* @__PURE__ */ React__default.createElement(React__default.Fragment, null, checkAllCheckbox, dropdown) : null, /* @__PURE__ */ React__default.createElement("span", {
    className: `${prefixCls}-header-selected`
  }, getSelectAllLabel(checkedActiveItems.length, filteredItems.length)), /* @__PURE__ */ React__default.createElement("span", {
    className: `${prefixCls}-header-title`
  }, titleText)), listBody, listFooter);
}, "TransferList");
process.env.NODE_ENV !== "production" && (TransferList.displayName = "TransferList");
const Operation = /* @__PURE__ */ __name((props) => {
  const {
    disabled,
    moveToLeft,
    moveToRight,
    leftArrowText = "",
    rightArrowText = "",
    leftActive,
    rightActive,
    className,
    style: style2,
    direction,
    oneWay
  } = props;
  return /* @__PURE__ */ React.createElement("div", {
    className,
    style: style2
  }, /* @__PURE__ */ React.createElement(Button$2, {
    type: "primary",
    size: "small",
    disabled: disabled || !rightActive,
    onClick: moveToRight,
    icon: direction !== "rtl" ? /* @__PURE__ */ React.createElement(RefIcon$y, null) : /* @__PURE__ */ React.createElement(RefIcon$t, null)
  }, rightArrowText), !oneWay && /* @__PURE__ */ React.createElement(Button$2, {
    type: "primary",
    size: "small",
    disabled: disabled || !leftActive,
    onClick: moveToLeft,
    icon: direction !== "rtl" ? /* @__PURE__ */ React.createElement(RefIcon$t, null) : /* @__PURE__ */ React.createElement(RefIcon$y, null)
  }, leftArrowText));
}, "Operation");
process.env.NODE_ENV !== "production" && (Operation.displayName = "Operation");
const genTransferCustomizeStyle = /* @__PURE__ */ __name((token2) => {
  const {
    antCls,
    componentCls,
    listHeight,
    controlHeightLG
  } = token2, tableCls = `${antCls}-table`, inputCls = `${antCls}-input`;
  return {
    [`${componentCls}-customize-list`]: {
      [`${componentCls}-list`]: {
        flex: "1 1 50%",
        width: "auto",
        height: "auto",
        minHeight: listHeight,
        minWidth: 0
      },
      // =================== Hook Components ===================
      [`${tableCls}-wrapper`]: {
        [`${tableCls}-small`]: {
          border: 0,
          borderRadius: 0,
          [`${tableCls}-selection-column`]: {
            width: controlHeightLG,
            minWidth: controlHeightLG
          }
        },
        [`${tableCls}-pagination${tableCls}-pagination`]: {
          margin: 0,
          padding: token2.paddingXS
        }
      },
      [`${inputCls}[disabled]`]: {
        backgroundColor: "transparent"
      }
    }
  };
}, "genTransferCustomizeStyle"), genTransferStatusColor = /* @__PURE__ */ __name((token2, color) => {
  const {
    componentCls,
    colorBorder
  } = token2;
  return {
    [`${componentCls}-list`]: {
      borderColor: color,
      "&-search:not([disabled])": {
        borderColor: colorBorder
      }
    }
  };
}, "genTransferStatusColor"), genTransferStatusStyle = /* @__PURE__ */ __name((token2) => {
  const {
    componentCls
  } = token2;
  return {
    [`${componentCls}-status-error`]: Object.assign({}, genTransferStatusColor(token2, token2.colorError)),
    [`${componentCls}-status-warning`]: Object.assign({}, genTransferStatusColor(token2, token2.colorWarning))
  };
}, "genTransferStatusStyle"), genTransferListStyle = /* @__PURE__ */ __name((token2) => {
  const {
    componentCls,
    colorBorder,
    colorSplit,
    lineWidth,
    itemHeight,
    headerHeight,
    transferHeaderVerticalPadding,
    itemPaddingBlock,
    controlItemBgActive,
    colorTextDisabled,
    colorTextSecondary,
    listHeight,
    listWidth,
    listWidthLG,
    fontSizeIcon,
    marginXS,
    paddingSM,
    lineType,
    antCls,
    iconCls,
    motionDurationSlow,
    controlItemBgHover,
    borderRadiusLG,
    colorBgContainer,
    colorText,
    controlItemBgActiveHover
  } = token2, contentBorderRadius = unit$1(token2.calc(borderRadiusLG).sub(lineWidth).equal());
  return {
    display: "flex",
    flexDirection: "column",
    width: listWidth,
    height: listHeight,
    border: `${unit$1(lineWidth)} ${lineType} ${colorBorder}`,
    borderRadius: token2.borderRadiusLG,
    "&-with-pagination": {
      width: listWidthLG,
      height: "auto"
    },
    "&-search": {
      [`${iconCls}-search`]: {
        color: colorTextDisabled
      }
    },
    "&-header": {
      display: "flex",
      flex: "none",
      alignItems: "center",
      height: headerHeight,
      // border-top is on the transfer dom. We should minus 1px for this
      padding: `${unit$1(token2.calc(transferHeaderVerticalPadding).sub(lineWidth).equal())} ${unit$1(paddingSM)} ${unit$1(transferHeaderVerticalPadding)}`,
      color: colorText,
      background: colorBgContainer,
      borderBottom: `${unit$1(lineWidth)} ${lineType} ${colorSplit}`,
      borderRadius: `${unit$1(borderRadiusLG)} ${unit$1(borderRadiusLG)} 0 0`,
      "> *:not(:last-child)": {
        marginInlineEnd: 4
        // This is magic and fixed number, DO NOT use token since it may change.
      },
      "> *": {
        flex: "none"
      },
      "&-title": Object.assign(Object.assign({}, textEllipsis), {
        flex: "auto",
        textAlign: "end"
      }),
      "&-dropdown": Object.assign(Object.assign({}, resetIcon()), {
        fontSize: fontSizeIcon,
        transform: "translateY(10%)",
        cursor: "pointer",
        "&[disabled]": {
          cursor: "not-allowed"
        }
      })
    },
    "&-body": {
      display: "flex",
      flex: "auto",
      flexDirection: "column",
      fontSize: token2.fontSize,
      // https://blog.csdn.net/qq449245884/article/details/107373672/
      minHeight: 0,
      "&-search-wrapper": {
        position: "relative",
        flex: "none",
        padding: paddingSM
      }
    },
    "&-content": {
      flex: "auto",
      margin: 0,
      padding: 0,
      overflow: "auto",
      listStyle: "none",
      borderRadius: `0 0 ${contentBorderRadius} ${contentBorderRadius}`,
      "&-item": {
        display: "flex",
        alignItems: "center",
        minHeight: itemHeight,
        padding: `${unit$1(itemPaddingBlock)} ${unit$1(paddingSM)}`,
        transition: `all ${motionDurationSlow}`,
        "> *:not(:last-child)": {
          marginInlineEnd: marginXS
        },
        "> *": {
          flex: "none"
        },
        "&-text": Object.assign(Object.assign({}, textEllipsis), {
          flex: "auto"
        }),
        "&-remove": Object.assign(Object.assign({}, operationUnit(token2)), {
          color: colorBorder,
          "&:hover, &:focus": {
            color: colorTextSecondary
          }
        }),
        [`&:not(${componentCls}-list-content-item-disabled)`]: {
          "&:hover": {
            backgroundColor: controlItemBgHover,
            cursor: "pointer"
          },
          [`&${componentCls}-list-content-item-checked:hover`]: {
            backgroundColor: controlItemBgActiveHover
          }
        },
        "&-checked": {
          backgroundColor: controlItemBgActive
        },
        "&-disabled": {
          color: colorTextDisabled,
          cursor: "not-allowed"
        }
      },
      // Do not change hover style when `oneWay` mode
      [`&-show-remove ${componentCls}-list-content-item:not(${componentCls}-list-content-item-disabled):hover`]: {
        background: "transparent",
        cursor: "default"
      }
    },
    "&-pagination": {
      padding: token2.paddingXS,
      textAlign: "end",
      borderTop: `${unit$1(lineWidth)} ${lineType} ${colorSplit}`,
      [`${antCls}-pagination-options`]: {
        paddingInlineEnd: token2.paddingXS
      }
    },
    "&-body-not-found": {
      flex: "none",
      width: "100%",
      margin: "auto 0",
      color: colorTextDisabled,
      textAlign: "center"
    },
    "&-footer": {
      borderTop: `${unit$1(lineWidth)} ${lineType} ${colorSplit}`
    },
    // fix: https://github.com/ant-design/ant-design/issues/44489
    "&-checkbox": {
      lineHeight: 1
    }
  };
}, "genTransferListStyle"), genTransferStyle = /* @__PURE__ */ __name((token2) => {
  const {
    antCls,
    iconCls,
    componentCls,
    marginXS,
    marginXXS,
    fontSizeIcon,
    colorBgContainerDisabled
  } = token2;
  return {
    [componentCls]: Object.assign(Object.assign({}, resetComponent(token2)), {
      position: "relative",
      display: "flex",
      alignItems: "stretch",
      [`${componentCls}-disabled`]: {
        [`${componentCls}-list`]: {
          background: colorBgContainerDisabled
        }
      },
      [`${componentCls}-list`]: genTransferListStyle(token2),
      [`${componentCls}-operation`]: {
        display: "flex",
        flex: "none",
        flexDirection: "column",
        alignSelf: "center",
        margin: `0 ${unit$1(marginXS)}`,
        verticalAlign: "middle",
        gap: marginXXS,
        [`${antCls}-btn ${iconCls}`]: {
          fontSize: fontSizeIcon
        }
      }
    })
  };
}, "genTransferStyle"), genTransferRTLStyle = /* @__PURE__ */ __name((token2) => {
  const {
    componentCls
  } = token2;
  return {
    [`${componentCls}-rtl`]: {
      direction: "rtl"
    }
  };
}, "genTransferRTLStyle"), prepareComponentToken$2 = /* @__PURE__ */ __name((token2) => {
  const {
    fontSize,
    lineHeight,
    controlHeight,
    controlHeightLG,
    lineWidth
  } = token2, fontHeight = Math.round(fontSize * lineHeight);
  return {
    listWidth: 180,
    listHeight: 200,
    listWidthLG: 250,
    headerHeight: controlHeightLG,
    itemHeight: controlHeight,
    itemPaddingBlock: (controlHeight - fontHeight) / 2,
    transferHeaderVerticalPadding: Math.ceil((controlHeightLG - lineWidth - fontHeight) / 2)
  };
}, "prepareComponentToken$2"), useStyle$2 = genStyleHooks("Transfer", (token2) => {
  const transferToken = merge(token2);
  return [genTransferStyle(transferToken), genTransferCustomizeStyle(transferToken), genTransferStatusStyle(transferToken), genTransferRTLStyle(transferToken)];
}, prepareComponentToken$2), Transfer$1 = /* @__PURE__ */ __name((props) => {
  const {
    dataSource,
    targetKeys = [],
    selectedKeys,
    selectAllLabels = [],
    operations = [],
    style: style2 = {},
    listStyle = {},
    locale: locale2 = {},
    titles: titles2,
    disabled,
    showSearch = !1,
    operationStyle,
    showSelectAll,
    oneWay,
    pagination,
    status: customStatus,
    prefixCls: customizePrefixCls,
    className,
    rootClassName,
    selectionsIcon,
    filterOption,
    render: render4,
    footer,
    children,
    rowKey,
    onScroll,
    onChange,
    onSearch,
    onSelectChange
  } = props, {
    getPrefixCls,
    renderEmpty,
    direction: dir,
    transfer
  } = useContext$1(ConfigContext), prefixCls = getPrefixCls("transfer", customizePrefixCls), [wrapCSSVar, hashId, cssVarCls] = useStyle$2(prefixCls), [mergedDataSource, leftDataSource, rightDataSource] = useData(dataSource, rowKey, targetKeys), [
    // Keys
    sourceSelectedKeys,
    targetSelectedKeys,
    // Setters
    setSourceSelectedKeys,
    setTargetSelectedKeys
  ] = useSelection(leftDataSource, rightDataSource, selectedKeys), [leftMultipleSelect, updateLeftPrevSelectedIndex] = useMultipleSelect((item) => item.key), [rightMultipleSelect, updateRightPrevSelectedIndex] = useMultipleSelect((item) => item.key);
  if (process.env.NODE_ENV !== "production") {
    const warning3 = devUseWarning("Transfer");
    process.env.NODE_ENV !== "production" && warning3(!pagination || !children, "usage", "`pagination` not support customize render list.");
  }
  const setStateKeys = useCallback((direction, keys2) => {
    if (direction === "left") {
      const nextKeys = typeof keys2 == "function" ? keys2(sourceSelectedKeys || []) : keys2;
      setSourceSelectedKeys(nextKeys);
    } else {
      const nextKeys = typeof keys2 == "function" ? keys2(targetSelectedKeys || []) : keys2;
      setTargetSelectedKeys(nextKeys);
    }
  }, [sourceSelectedKeys, targetSelectedKeys]), setPrevSelectedIndex = /* @__PURE__ */ __name((direction, value) => {
    (direction === "left" ? updateLeftPrevSelectedIndex : updateRightPrevSelectedIndex)(value);
  }, "setPrevSelectedIndex"), handleSelectChange = useCallback((direction, holder) => {
    direction === "left" ? onSelectChange == null || onSelectChange(holder, targetSelectedKeys) : onSelectChange == null || onSelectChange(sourceSelectedKeys, holder);
  }, [sourceSelectedKeys, targetSelectedKeys]), getTitles = /* @__PURE__ */ __name((transferLocale) => {
    var _a;
    return (_a = titles2 ?? transferLocale.titles) !== null && _a !== void 0 ? _a : [];
  }, "getTitles"), handleLeftScroll = /* @__PURE__ */ __name((e2) => {
    onScroll == null || onScroll("left", e2);
  }, "handleLeftScroll"), handleRightScroll = /* @__PURE__ */ __name((e2) => {
    onScroll == null || onScroll("right", e2);
  }, "handleRightScroll"), moveTo = /* @__PURE__ */ __name((direction) => {
    const moveKeys = direction === "right" ? sourceSelectedKeys : targetSelectedKeys, dataSourceDisabledKeysMap = groupDisabledKeysMap(mergedDataSource), newMoveKeys = moveKeys.filter((key) => !dataSourceDisabledKeysMap.has(key)), newMoveKeysMap = groupKeysMap(newMoveKeys), newTargetKeys = direction === "right" ? newMoveKeys.concat(targetKeys) : targetKeys.filter((targetKey) => !newMoveKeysMap.has(targetKey)), oppositeDirection = direction === "right" ? "left" : "right";
    setStateKeys(oppositeDirection, []), handleSelectChange(oppositeDirection, []), onChange == null || onChange(newTargetKeys, direction, newMoveKeys);
  }, "moveTo"), moveToLeft = /* @__PURE__ */ __name(() => {
    moveTo("left"), setPrevSelectedIndex("left", null);
  }, "moveToLeft"), moveToRight = /* @__PURE__ */ __name(() => {
    moveTo("right"), setPrevSelectedIndex("right", null);
  }, "moveToRight"), onItemSelectAll = /* @__PURE__ */ __name((direction, keys2, checkAll) => {
    setStateKeys(direction, (prevKeys) => {
      let mergedCheckedKeys = [];
      if (checkAll === "replace")
        mergedCheckedKeys = keys2;
      else if (checkAll)
        mergedCheckedKeys = Array.from(new Set([].concat(_toConsumableArray(prevKeys), _toConsumableArray(keys2))));
      else {
        const selectedKeysMap = groupKeysMap(keys2);
        mergedCheckedKeys = prevKeys.filter((key) => !selectedKeysMap.has(key));
      }
      return handleSelectChange(direction, mergedCheckedKeys), mergedCheckedKeys;
    }), setPrevSelectedIndex(direction, null);
  }, "onItemSelectAll"), onLeftItemSelectAll = /* @__PURE__ */ __name((keys2, checkAll) => {
    onItemSelectAll("left", keys2, checkAll);
  }, "onLeftItemSelectAll"), onRightItemSelectAll = /* @__PURE__ */ __name((keys2, checkAll) => {
    onItemSelectAll("right", keys2, checkAll);
  }, "onRightItemSelectAll"), leftFilter = /* @__PURE__ */ __name((e2) => onSearch == null ? void 0 : onSearch("left", e2.target.value), "leftFilter"), rightFilter = /* @__PURE__ */ __name((e2) => onSearch == null ? void 0 : onSearch("right", e2.target.value), "rightFilter"), handleLeftClear = /* @__PURE__ */ __name(() => onSearch == null ? void 0 : onSearch("left", ""), "handleLeftClear"), handleRightClear = /* @__PURE__ */ __name(() => onSearch == null ? void 0 : onSearch("right", ""), "handleRightClear"), handleSingleSelect = /* @__PURE__ */ __name((direction, holder, selectedKey, checked, currentSelectedIndex) => {
    holder.has(selectedKey) && (holder.delete(selectedKey), setPrevSelectedIndex(direction, null)), checked && (holder.add(selectedKey), setPrevSelectedIndex(direction, currentSelectedIndex));
  }, "handleSingleSelect"), handleMultipleSelect = /* @__PURE__ */ __name((direction, data, holder, currentSelectedIndex) => {
    (direction === "left" ? leftMultipleSelect : rightMultipleSelect)(currentSelectedIndex, data, holder);
  }, "handleMultipleSelect"), onItemSelect = /* @__PURE__ */ __name((direction, selectedKey, checked, multiple) => {
    const isLeftDirection = direction === "left", holder = _toConsumableArray(isLeftDirection ? sourceSelectedKeys : targetSelectedKeys), holderSet = new Set(holder), data = _toConsumableArray(isLeftDirection ? leftDataSource : rightDataSource).filter((item) => !(item != null && item.disabled)), currentSelectedIndex = data.findIndex((item) => item.key === selectedKey);
    multiple && holder.length > 0 ? handleMultipleSelect(direction, data, holderSet, currentSelectedIndex) : handleSingleSelect(direction, holderSet, selectedKey, checked, currentSelectedIndex);
    const holderArr = Array.from(holderSet);
    handleSelectChange(direction, holderArr), props.selectedKeys || setStateKeys(direction, holderArr);
  }, "onItemSelect"), onLeftItemSelect = /* @__PURE__ */ __name((selectedKey, checked, e2) => {
    onItemSelect("left", selectedKey, checked, e2 == null ? void 0 : e2.shiftKey);
  }, "onLeftItemSelect"), onRightItemSelect = /* @__PURE__ */ __name((selectedKey, checked, e2) => {
    onItemSelect("right", selectedKey, checked, e2 == null ? void 0 : e2.shiftKey);
  }, "onRightItemSelect"), onRightItemRemove = /* @__PURE__ */ __name((keys2) => {
    setStateKeys("right", []), onChange == null || onChange(targetKeys.filter((key) => !keys2.includes(key)), "left", _toConsumableArray(keys2));
  }, "onRightItemRemove"), handleListStyle = /* @__PURE__ */ __name((direction) => typeof listStyle == "function" ? listStyle({
    direction
  }) : listStyle || {}, "handleListStyle"), formItemContext = useContext$1(FormItemInputContext), {
    hasFeedback,
    status
  } = formItemContext, getLocale = /* @__PURE__ */ __name((transferLocale) => Object.assign(Object.assign(Object.assign({}, transferLocale), {
    notFoundContent: (renderEmpty == null ? void 0 : renderEmpty("Transfer")) || /* @__PURE__ */ React__default.createElement(DefaultRenderEmpty, {
      componentName: "Transfer"
    })
  }), locale2), "getLocale"), mergedStatus = getMergedStatus(status, customStatus), mergedPagination = !children && pagination, leftActive = rightDataSource.filter((d) => targetSelectedKeys.includes(d.key) && !d.disabled).length > 0, rightActive = leftDataSource.filter((d) => sourceSelectedKeys.includes(d.key) && !d.disabled).length > 0, cls = cn(prefixCls, {
    [`${prefixCls}-disabled`]: disabled,
    [`${prefixCls}-customize-list`]: !!children,
    [`${prefixCls}-rtl`]: dir === "rtl"
  }, getStatusClassNames(prefixCls, mergedStatus, hasFeedback), transfer == null ? void 0 : transfer.className, className, rootClassName, hashId, cssVarCls), [contextLocale] = useLocale$1("Transfer", localeValues$1.Transfer), listLocale = getLocale(contextLocale), [leftTitle, rightTitle] = getTitles(listLocale), mergedSelectionsIcon = selectionsIcon ?? (transfer == null ? void 0 : transfer.selectionsIcon);
  return wrapCSSVar(/* @__PURE__ */ React__default.createElement("div", {
    className: cls,
    style: Object.assign(Object.assign({}, transfer == null ? void 0 : transfer.style), style2)
  }, /* @__PURE__ */ React__default.createElement(TransferList, Object.assign({
    prefixCls: `${prefixCls}-list`,
    titleText: leftTitle,
    dataSource: leftDataSource,
    filterOption,
    style: handleListStyle("left"),
    checkedKeys: sourceSelectedKeys,
    handleFilter: leftFilter,
    handleClear: handleLeftClear,
    onItemSelect: onLeftItemSelect,
    onItemSelectAll: onLeftItemSelectAll,
    render: render4,
    showSearch,
    renderList: children,
    footer,
    onScroll: handleLeftScroll,
    disabled,
    direction: dir === "rtl" ? "right" : "left",
    showSelectAll,
    selectAllLabel: selectAllLabels[0],
    pagination: mergedPagination,
    selectionsIcon: mergedSelectionsIcon
  }, listLocale)), /* @__PURE__ */ React__default.createElement(Operation, {
    className: `${prefixCls}-operation`,
    rightActive,
    rightArrowText: operations[0],
    moveToRight,
    leftActive,
    leftArrowText: operations[1],
    moveToLeft,
    style: operationStyle,
    disabled,
    direction: dir,
    oneWay
  }), /* @__PURE__ */ React__default.createElement(TransferList, Object.assign({
    prefixCls: `${prefixCls}-list`,
    titleText: rightTitle,
    dataSource: rightDataSource,
    filterOption,
    style: handleListStyle("right"),
    checkedKeys: targetSelectedKeys,
    handleFilter: rightFilter,
    handleClear: handleRightClear,
    onItemSelect: onRightItemSelect,
    onItemSelectAll: onRightItemSelectAll,
    onItemRemove: onRightItemRemove,
    render: render4,
    showSearch,
    renderList: children,
    footer,
    onScroll: handleRightScroll,
    disabled,
    direction: dir === "rtl" ? "left" : "right",
    showSelectAll,
    selectAllLabel: selectAllLabels[1],
    showRemove: oneWay,
    pagination: mergedPagination,
    selectionsIcon: mergedSelectionsIcon
  }, listLocale))));
}, "Transfer$1");
process.env.NODE_ENV !== "production" && (Transfer$1.displayName = "Transfer");
Transfer$1.List = TransferList;
Transfer$1.Search = Search;
Transfer$1.Operation = Operation;
const getTitleStyle = /* @__PURE__ */ __name((fontSize, lineHeight, color, token2) => {
  const {
    titleMarginBottom,
    fontWeightStrong
  } = token2;
  return {
    marginBottom: titleMarginBottom,
    color,
    fontWeight: fontWeightStrong,
    fontSize,
    lineHeight
  };
}, "getTitleStyle"), getTitleStyles = /* @__PURE__ */ __name((token2) => {
  const headings = [1, 2, 3, 4, 5], styles2 = {};
  return headings.forEach((headingLevel) => {
    styles2[`
      h${headingLevel}&,
      div&-h${headingLevel},
      div&-h${headingLevel} > textarea,
      h${headingLevel}
    `] = getTitleStyle(token2[`fontSizeHeading${headingLevel}`], token2[`lineHeightHeading${headingLevel}`], token2.colorTextHeading, token2);
  }), styles2;
}, "getTitleStyles"), getLinkStyles = /* @__PURE__ */ __name((token2) => {
  const {
    componentCls
  } = token2;
  return {
    "a&, a": Object.assign(Object.assign({}, operationUnit(token2)), {
      userSelect: "text",
      [`&[disabled], &${componentCls}-disabled`]: {
        color: token2.colorTextDisabled,
        cursor: "not-allowed",
        "&:active, &:hover": {
          color: token2.colorTextDisabled
        },
        "&:active": {
          pointerEvents: "none"
        }
      }
    })
  };
}, "getLinkStyles"), getResetStyles = /* @__PURE__ */ __name((token2) => ({
  code: {
    margin: "0 0.2em",
    paddingInline: "0.4em",
    paddingBlock: "0.2em 0.1em",
    fontSize: "85%",
    fontFamily: token2.fontFamilyCode,
    background: "rgba(150, 150, 150, 0.1)",
    border: "1px solid rgba(100, 100, 100, 0.2)",
    borderRadius: 3
  },
  kbd: {
    margin: "0 0.2em",
    paddingInline: "0.4em",
    paddingBlock: "0.15em 0.1em",
    fontSize: "90%",
    fontFamily: token2.fontFamilyCode,
    background: "rgba(150, 150, 150, 0.06)",
    border: "1px solid rgba(100, 100, 100, 0.2)",
    borderBottomWidth: 2,
    borderRadius: 3
  },
  mark: {
    padding: 0,
    // FIXME hardcode in v4
    backgroundColor: gold[2]
  },
  "u, ins": {
    textDecoration: "underline",
    textDecorationSkipInk: "auto"
  },
  "s, del": {
    textDecoration: "line-through"
  },
  strong: {
    fontWeight: 600
  },
  // list
  "ul, ol": {
    marginInline: 0,
    marginBlock: "0 1em",
    padding: 0,
    li: {
      marginInline: "20px 0",
      marginBlock: 0,
      paddingInline: "4px 0",
      paddingBlock: 0
    }
  },
  ul: {
    listStyleType: "circle",
    ul: {
      listStyleType: "disc"
    }
  },
  ol: {
    listStyleType: "decimal"
  },
  // pre & block
  "pre, blockquote": {
    margin: "1em 0"
  },
  pre: {
    padding: "0.4em 0.6em",
    whiteSpace: "pre-wrap",
    wordWrap: "break-word",
    background: "rgba(150, 150, 150, 0.1)",
    border: "1px solid rgba(100, 100, 100, 0.2)",
    borderRadius: 3,
    fontFamily: token2.fontFamilyCode,
    // Compatible for marked
    code: {
      display: "inline",
      margin: 0,
      padding: 0,
      fontSize: "inherit",
      fontFamily: "inherit",
      background: "transparent",
      border: 0
    }
  },
  blockquote: {
    paddingInline: "0.6em 0",
    paddingBlock: 0,
    borderInlineStart: "4px solid rgba(100, 100, 100, 0.2)",
    opacity: 0.85
  }
}), "getResetStyles"), getEditableStyles = /* @__PURE__ */ __name((token2) => {
  const {
    componentCls,
    paddingSM
  } = token2, inputShift = paddingSM;
  return {
    "&-edit-content": {
      position: "relative",
      "div&": {
        insetInlineStart: token2.calc(token2.paddingSM).mul(-1).equal(),
        marginTop: token2.calc(inputShift).mul(-1).equal(),
        marginBottom: `calc(1em - ${unit$1(inputShift)})`
      },
      [`${componentCls}-edit-content-confirm`]: {
        position: "absolute",
        insetInlineEnd: token2.calc(token2.marginXS).add(2).equal(),
        insetBlockEnd: token2.marginXS,
        color: token2.colorTextDescription,
        // default style
        fontWeight: "normal",
        fontSize: token2.fontSize,
        fontStyle: "normal",
        pointerEvents: "none"
      },
      textarea: {
        margin: "0!important",
        // Fix Editable Textarea flash in Firefox
        MozTransition: "none",
        height: "1em"
      }
    }
  };
}, "getEditableStyles"), getCopyableStyles = /* @__PURE__ */ __name((token2) => ({
  [`${token2.componentCls}-copy-success`]: {
    "\n    &,\n    &:hover,\n    &:focus": {
      color: token2.colorSuccess
    }
  },
  [`${token2.componentCls}-copy-icon-only`]: {
    marginInlineStart: 0
  }
}), "getCopyableStyles"), getEllipsisStyles = /* @__PURE__ */ __name(() => ({
  "\n  a&-ellipsis,\n  span&-ellipsis\n  ": {
    display: "inline-block",
    maxWidth: "100%"
  },
  "&-ellipsis-single-line": {
    whiteSpace: "nowrap",
    overflow: "hidden",
    textOverflow: "ellipsis",
    // https://blog.csdn.net/iefreer/article/details/50421025
    "a&, span&": {
      verticalAlign: "bottom"
    },
    "> code": {
      paddingBlock: 0,
      maxWidth: "calc(100% - 1.2em)",
      display: "inline-block",
      overflow: "hidden",
      textOverflow: "ellipsis",
      verticalAlign: "bottom",
      // https://github.com/ant-design/ant-design/issues/45953
      boxSizing: "content-box"
    }
  },
  "&-ellipsis-multiple-line": {
    display: "-webkit-box",
    overflow: "hidden",
    WebkitLineClamp: 3,
    WebkitBoxOrient: "vertical"
  }
}), "getEllipsisStyles"), genTypographyStyle = /* @__PURE__ */ __name((token2) => {
  const {
    componentCls,
    titleMarginTop
  } = token2;
  return {
    [componentCls]: Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({
      color: token2.colorText,
      wordBreak: "break-word",
      lineHeight: token2.lineHeight,
      [`&${componentCls}-secondary`]: {
        color: token2.colorTextDescription
      },
      [`&${componentCls}-success`]: {
        color: token2.colorSuccess
      },
      [`&${componentCls}-warning`]: {
        color: token2.colorWarning
      },
      [`&${componentCls}-danger`]: {
        color: token2.colorError,
        "a&:active, a&:focus": {
          color: token2.colorErrorActive
        },
        "a&:hover": {
          color: token2.colorErrorHover
        }
      },
      [`&${componentCls}-disabled`]: {
        color: token2.colorTextDisabled,
        cursor: "not-allowed",
        userSelect: "none"
      },
      "\n        div&,\n        p\n      ": {
        marginBottom: "1em"
      }
    }, getTitleStyles(token2)), {
      [`
      & + h1${componentCls},
      & + h2${componentCls},
      & + h3${componentCls},
      & + h4${componentCls},
      & + h5${componentCls}
      `]: {
        marginTop: titleMarginTop
      },
      "\n      div,\n      ul,\n      li,\n      p,\n      h1,\n      h2,\n      h3,\n      h4,\n      h5": {
        "\n        + h1,\n        + h2,\n        + h3,\n        + h4,\n        + h5\n        ": {
          marginTop: titleMarginTop
        }
      }
    }), getResetStyles(token2)), getLinkStyles(token2)), {
      // Operation
      [`
        ${componentCls}-expand,
        ${componentCls}-collapse,
        ${componentCls}-edit,
        ${componentCls}-copy
      `]: Object.assign(Object.assign({}, operationUnit(token2)), {
        marginInlineStart: token2.marginXXS
      })
    }), getEditableStyles(token2)), getCopyableStyles(token2)), getEllipsisStyles()), {
      "&-rtl": {
        direction: "rtl"
      }
    })
  };
}, "genTypographyStyle"), prepareComponentToken$1 = /* @__PURE__ */ __name(() => ({
  titleMarginTop: "1.2em",
  titleMarginBottom: "0.5em"
}), "prepareComponentToken$1"), useStyle$1 = genStyleHooks("Typography", (token2) => [genTypographyStyle(token2)], prepareComponentToken$1), Editable = /* @__PURE__ */ __name((props) => {
  const {
    prefixCls,
    "aria-label": ariaLabel,
    className,
    style: style2,
    direction,
    maxLength,
    autoSize = !0,
    value,
    onSave,
    onCancel,
    onEnd,
    component,
    enterIcon = /* @__PURE__ */ React.createElement(RefIcon$a, null)
  } = props, ref = React.useRef(null), inComposition = React.useRef(!1), lastKeyCode = React.useRef(null), [current, setCurrent] = React.useState(value);
  React.useEffect(() => {
    setCurrent(value);
  }, [value]), React.useEffect(() => {
    var _a;
    if (!((_a = ref.current) === null || _a === void 0) && _a.resizableTextArea) {
      const {
        textArea
      } = ref.current.resizableTextArea;
      textArea.focus();
      const {
        length: length2
      } = textArea.value;
      textArea.setSelectionRange(length2, length2);
    }
  }, []);
  const onChange = /* @__PURE__ */ __name((_ref) => {
    let {
      target
    } = _ref;
    setCurrent(target.value.replace(/[\n\r]/g, ""));
  }, "onChange"), onCompositionStart = /* @__PURE__ */ __name(() => {
    inComposition.current = !0;
  }, "onCompositionStart"), onCompositionEnd = /* @__PURE__ */ __name(() => {
    inComposition.current = !1;
  }, "onCompositionEnd"), onKeyDown2 = /* @__PURE__ */ __name((_ref2) => {
    let {
      keyCode
    } = _ref2;
    inComposition.current || (lastKeyCode.current = keyCode);
  }, "onKeyDown"), confirmChange = /* @__PURE__ */ __name(() => {
    onSave(current.trim());
  }, "confirmChange"), onKeyUp = /* @__PURE__ */ __name((_ref3) => {
    let {
      keyCode,
      ctrlKey,
      altKey,
      metaKey,
      shiftKey
    } = _ref3;
    lastKeyCode.current !== keyCode || inComposition.current || ctrlKey || altKey || metaKey || shiftKey || (keyCode === KeyCode.ENTER ? (confirmChange(), onEnd == null || onEnd()) : keyCode === KeyCode.ESC && onCancel());
  }, "onKeyUp"), onBlur = /* @__PURE__ */ __name(() => {
    confirmChange();
  }, "onBlur"), [wrapCSSVar, hashId, cssVarCls] = useStyle$1(prefixCls), textAreaClassName = cn(prefixCls, `${prefixCls}-edit-content`, {
    [`${prefixCls}-rtl`]: direction === "rtl",
    [`${prefixCls}-${component}`]: !!component
  }, className, hashId, cssVarCls);
  return wrapCSSVar(/* @__PURE__ */ React.createElement("div", {
    className: textAreaClassName,
    style: style2
  }, /* @__PURE__ */ React.createElement(TextArea$1, {
    ref,
    maxLength,
    value: current,
    onChange,
    onKeyDown: onKeyDown2,
    onKeyUp,
    onCompositionStart,
    onCompositionEnd,
    onBlur,
    "aria-label": ariaLabel,
    rows: 1,
    autoSize
  }), enterIcon !== null ? cloneElement(enterIcon, {
    className: `${prefixCls}-edit-content-confirm`
  }) : null));
}, "Editable");
var toggleSelection = /* @__PURE__ */ __name(function() {
  var selection = document.getSelection();
  if (!selection.rangeCount)
    return function() {
    };
  for (var active = document.activeElement, ranges = [], i = 0; i < selection.rangeCount; i++)
    ranges.push(selection.getRangeAt(i));
  switch (active.tagName.toUpperCase()) {
    case "INPUT":
    case "TEXTAREA":
      active.blur();
      break;
    default:
      active = null;
      break;
  }
  return selection.removeAllRanges(), function() {
    selection.type === "Caret" && selection.removeAllRanges(), selection.rangeCount || ranges.forEach(function(range3) {
      selection.addRange(range3);
    }), active && active.focus();
  };
}, "toggleSelection"), deselectCurrent = toggleSelection, clipboardToIE11Formatting = {
  "text/plain": "Text",
  "text/html": "Url",
  default: "Text"
}, defaultMessage = "Copy to clipboard: #{key}, Enter";
function format2(message) {
  var copyKey = (/mac os x/i.test(navigator.userAgent) ? "⌘" : "Ctrl") + "+C";
  return message.replace(/#{\s*key\s*}/g, copyKey);
}
__name(format2, "format");
function copy(text, options) {
  var debug, message, reselectPrevious, range3, selection, mark, success = !1;
  options || (options = {}), debug = options.debug || !1;
  try {
    reselectPrevious = deselectCurrent(), range3 = document.createRange(), selection = document.getSelection(), mark = document.createElement("span"), mark.textContent = text, mark.ariaHidden = "true", mark.style.all = "unset", mark.style.position = "fixed", mark.style.top = 0, mark.style.clip = "rect(0, 0, 0, 0)", mark.style.whiteSpace = "pre", mark.style.webkitUserSelect = "text", mark.style.MozUserSelect = "text", mark.style.msUserSelect = "text", mark.style.userSelect = "text", mark.addEventListener("copy", function(e2) {
      if (e2.stopPropagation(), options.format)
        if (e2.preventDefault(), typeof e2.clipboardData > "u") {
          debug && console.warn("unable to use e.clipboardData"), debug && console.warn("trying IE specific stuff"), window.clipboardData.clearData();
          var format3 = clipboardToIE11Formatting[options.format] || clipboardToIE11Formatting.default;
          window.clipboardData.setData(format3, text);
        } else
          e2.clipboardData.clearData(), e2.clipboardData.setData(options.format, text);
      options.onCopy && (e2.preventDefault(), options.onCopy(e2.clipboardData));
    }), document.body.appendChild(mark), range3.selectNodeContents(mark), selection.addRange(range3);
    var successful = document.execCommand("copy");
    if (!successful)
      throw new Error("copy command was unsuccessful");
    success = !0;
  } catch (err) {
    debug && console.error("unable to copy using execCommand: ", err), debug && console.warn("trying IE specific stuff");
    try {
      window.clipboardData.setData(options.format || "text", text), options.onCopy && options.onCopy(window.clipboardData), success = !0;
    } catch (err2) {
      debug && console.error("unable to copy using clipboardData: ", err2), debug && console.error("falling back to prompt"), message = format2("message" in options ? options.message : defaultMessage), window.prompt(message, text);
    }
  } finally {
    selection && (typeof selection.removeRange == "function" ? selection.removeRange(range3) : selection.removeAllRanges()), mark && document.body.removeChild(mark), reselectPrevious();
  }
  return success;
}
__name(copy, "copy");
var copyToClipboard = copy;
const copy$1 = /* @__PURE__ */ getDefaultExportFromCjs(copyToClipboard);
var __awaiter$1 = function(thisArg, _arguments, P, generator2) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return __name(adopt, "adopt"), new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator2.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    __name(fulfilled, "fulfilled");
    function rejected(value) {
      try {
        step(generator2.throw(value));
      } catch (e2) {
        reject(e2);
      }
    }
    __name(rejected, "rejected");
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    __name(step, "step"), step((generator2 = generator2.apply(thisArg, _arguments || [])).next());
  });
};
const useCopyClick = /* @__PURE__ */ __name((_ref) => {
  let {
    copyConfig,
    children
  } = _ref;
  const [copied, setCopied] = React.useState(!1), [copyLoading, setCopyLoading] = React.useState(!1), copyIdRef = React.useRef(null), cleanCopyId = /* @__PURE__ */ __name(() => {
    copyIdRef.current && clearTimeout(copyIdRef.current);
  }, "cleanCopyId"), copyOptions = {};
  copyConfig.format && (copyOptions.format = copyConfig.format), React.useEffect(() => cleanCopyId, []);
  const onClick = useEvent((e2) => __awaiter$1(void 0, void 0, void 0, function* () {
    var _a;
    e2 == null || e2.preventDefault(), e2 == null || e2.stopPropagation(), setCopyLoading(!0);
    try {
      const text = typeof copyConfig.text == "function" ? yield copyConfig.text() : copyConfig.text;
      copy$1(text || toList$1(children, !0).join("") || "", copyOptions), setCopyLoading(!1), setCopied(!0), cleanCopyId(), copyIdRef.current = setTimeout(() => {
        setCopied(!1);
      }, 3e3), (_a = copyConfig.onCopy) === null || _a === void 0 || _a.call(copyConfig, e2);
    } catch (error) {
      throw setCopyLoading(!1), error;
    }
  }));
  return {
    copied,
    copyLoading,
    onClick
  };
}, "useCopyClick");
function useMergedConfig(propConfig, templateConfig) {
  return React.useMemo(() => {
    const support = !!propConfig;
    return [support, Object.assign(Object.assign({}, templateConfig), support && typeof propConfig == "object" ? propConfig : null)];
  }, [propConfig]);
}
__name(useMergedConfig, "useMergedConfig");
const usePrevious$1 = /* @__PURE__ */ __name((value) => {
  const ref = useRef(void 0);
  return useEffect(() => {
    ref.current = value;
  }), ref.current;
}, "usePrevious$1"), useTooltipProps = /* @__PURE__ */ __name((tooltip, editConfigText, children) => useMemo$1(() => tooltip === !0 ? {
  title: editConfigText ?? children
} : /* @__PURE__ */ isValidElement(tooltip) ? {
  title: tooltip
} : typeof tooltip == "object" ? Object.assign({
  title: editConfigText ?? children
}, tooltip) : {
  title: tooltip
}, [tooltip, editConfigText, children]), "useTooltipProps");
var __rest$5 = function(s, e2) {
  var t2 = {};
  for (var p in s) Object.prototype.hasOwnProperty.call(s, p) && e2.indexOf(p) < 0 && (t2[p] = s[p]);
  if (s != null && typeof Object.getOwnPropertySymbols == "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++)
    e2.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]) && (t2[p[i]] = s[p[i]]);
  return t2;
};
const Typography$1 = /* @__PURE__ */ React.forwardRef((props, ref) => {
  const {
    prefixCls: customizePrefixCls,
    component: Component2 = "article",
    className,
    rootClassName,
    setContentRef,
    children,
    direction: typographyDirection,
    style: style2
  } = props, restProps = __rest$5(props, ["prefixCls", "component", "className", "rootClassName", "setContentRef", "children", "direction", "style"]), {
    getPrefixCls,
    direction: contextDirection,
    typography
  } = React.useContext(ConfigContext), direction = typographyDirection ?? contextDirection, mergedRef = setContentRef ? composeRef(ref, setContentRef) : ref, prefixCls = getPrefixCls("typography", customizePrefixCls);
  process.env.NODE_ENV !== "production" && devUseWarning("Typography").deprecated(!setContentRef, "setContentRef", "ref");
  const [wrapCSSVar, hashId, cssVarCls] = useStyle$1(prefixCls), componentClassName = cn(prefixCls, typography == null ? void 0 : typography.className, {
    [`${prefixCls}-rtl`]: direction === "rtl"
  }, className, rootClassName, hashId, cssVarCls), mergedStyle = Object.assign(Object.assign({}, typography == null ? void 0 : typography.style), style2);
  return wrapCSSVar(
    // @ts-expect-error: Expression produces a union type that is too complex to represent.
    /* @__PURE__ */ React.createElement(Component2, Object.assign({
      className: componentClassName,
      style: mergedStyle,
      ref: mergedRef
    }, restProps), children)
  );
});
process.env.NODE_ENV !== "production" && (Typography$1.displayName = "Typography");
function toList(val) {
  return val === !1 ? [!1, !1] : Array.isArray(val) ? val : [val];
}
__name(toList, "toList");
function getNode(dom, defaultNode, needDom) {
  return dom === !0 || dom === void 0 ? defaultNode : dom || needDom && defaultNode;
}
__name(getNode, "getNode");
function isEleEllipsis(ele) {
  const childDiv = document.createElement("em");
  ele.appendChild(childDiv), process.env.NODE_ENV !== "production" && (childDiv.className = "ant-typography-css-ellipsis-content-measure");
  const rect = ele.getBoundingClientRect(), childRect = childDiv.getBoundingClientRect();
  return ele.removeChild(childDiv), // Horizontal out of range
  rect.left > childRect.left || childRect.right > rect.right || // Vertical out of range
  rect.top > childRect.top || childRect.bottom > rect.bottom;
}
__name(isEleEllipsis, "isEleEllipsis");
const isValidText = /* @__PURE__ */ __name((val) => ["string", "number"].includes(typeof val), "isValidText"), CopyBtn = /* @__PURE__ */ __name((_ref) => {
  let {
    prefixCls,
    copied,
    locale: locale2,
    iconOnly,
    tooltips,
    icon,
    tabIndex,
    onCopy,
    loading: btnLoading
  } = _ref;
  const tooltipNodes = toList(tooltips), iconNodes = toList(icon), {
    copied: copiedText,
    copy: copyText
  } = locale2 ?? {}, systemStr = copied ? copiedText : copyText, copyTitle = getNode(tooltipNodes[copied ? 1 : 0], systemStr), ariaLabel = typeof copyTitle == "string" ? copyTitle : systemStr;
  return /* @__PURE__ */ React.createElement(Tooltip$1, {
    title: copyTitle
  }, /* @__PURE__ */ React.createElement("button", {
    type: "button",
    className: cn(`${prefixCls}-copy`, {
      [`${prefixCls}-copy-success`]: copied,
      [`${prefixCls}-copy-icon-only`]: iconOnly
    }),
    onClick: onCopy,
    "aria-label": ariaLabel,
    tabIndex
  }, copied ? getNode(iconNodes[1], /* @__PURE__ */ React.createElement(RefIcon$x, null), !0) : getNode(iconNodes[0], btnLoading ? /* @__PURE__ */ React.createElement(RefIcon$z, null) : /* @__PURE__ */ React.createElement(RefIcon$e, null), !0)));
}, "CopyBtn"), MeasureText = /* @__PURE__ */ React.forwardRef((_ref, ref) => {
  let {
    style: style2,
    children
  } = _ref;
  const spanRef = React.useRef(null);
  return React.useImperativeHandle(ref, () => ({
    isExceed: /* @__PURE__ */ __name(() => {
      const span = spanRef.current;
      return span.scrollHeight > span.clientHeight;
    }, "isExceed"),
    getHeight: /* @__PURE__ */ __name(() => spanRef.current.clientHeight, "getHeight")
  })), /* @__PURE__ */ React.createElement("span", {
    "aria-hidden": !0,
    ref: spanRef,
    style: Object.assign({
      position: "fixed",
      display: "block",
      left: 0,
      top: 0,
      pointerEvents: "none",
      backgroundColor: "rgba(255, 0, 0, 0.65)"
    }, style2)
  }, children);
}), getNodesLen = /* @__PURE__ */ __name((nodeList) => nodeList.reduce((totalLen, node2) => totalLen + (isValidText(node2) ? String(node2).length : 1), 0), "getNodesLen");
function sliceNodes(nodeList, len) {
  let currLen = 0;
  const currentNodeList = [];
  for (let i = 0; i < nodeList.length; i += 1) {
    if (currLen === len)
      return currentNodeList;
    const node2 = nodeList[i], nodeLen = isValidText(node2) ? String(node2).length : 1, nextLen = currLen + nodeLen;
    if (nextLen > len) {
      const restLen = len - currLen;
      return currentNodeList.push(String(node2).slice(0, restLen)), currentNodeList;
    }
    currentNodeList.push(node2), currLen = nextLen;
  }
  return nodeList;
}
__name(sliceNodes, "sliceNodes");
const STATUS_MEASURE_NONE = 0, STATUS_MEASURE_PREPARE = 1, STATUS_MEASURE_START = 2, STATUS_MEASURE_NEED_ELLIPSIS = 3, STATUS_MEASURE_NO_NEED_ELLIPSIS = 4, lineClipStyle = {
  display: "-webkit-box",
  overflow: "hidden",
  WebkitBoxOrient: "vertical"
};
function EllipsisMeasure(props) {
  const {
    enableMeasure,
    width,
    text,
    children,
    rows,
    expanded,
    miscDeps,
    onEllipsis
  } = props, nodeList = React.useMemo(() => toArray$7(text), [text]), nodeLen = React.useMemo(() => getNodesLen(nodeList), [text]), fullContent = React.useMemo(() => children(nodeList, !1), [text]), [ellipsisCutIndex, setEllipsisCutIndex] = React.useState(null), cutMidRef = React.useRef(null), measureWhiteSpaceRef = React.useRef(null), needEllipsisRef = React.useRef(null), descRowsEllipsisRef = React.useRef(null), symbolRowEllipsisRef = React.useRef(null), [canEllipsis, setCanEllipsis] = React.useState(!1), [needEllipsis, setNeedEllipsis] = React.useState(STATUS_MEASURE_NONE), [ellipsisHeight, setEllipsisHeight] = React.useState(0), [parentWhiteSpace, setParentWhiteSpace] = React.useState(null);
  useLayoutEffect$1(() => {
    setNeedEllipsis(enableMeasure && width && nodeLen ? STATUS_MEASURE_PREPARE : STATUS_MEASURE_NONE);
  }, [width, text, rows, enableMeasure, nodeList]), useLayoutEffect$1(() => {
    var _a, _b, _c, _d;
    if (needEllipsis === STATUS_MEASURE_PREPARE) {
      setNeedEllipsis(STATUS_MEASURE_START);
      const nextWhiteSpace = measureWhiteSpaceRef.current && getComputedStyle(measureWhiteSpaceRef.current).whiteSpace;
      setParentWhiteSpace(nextWhiteSpace);
    } else if (needEllipsis === STATUS_MEASURE_START) {
      const isOverflow = !!(!((_a = needEllipsisRef.current) === null || _a === void 0) && _a.isExceed());
      setNeedEllipsis(isOverflow ? STATUS_MEASURE_NEED_ELLIPSIS : STATUS_MEASURE_NO_NEED_ELLIPSIS), setEllipsisCutIndex(isOverflow ? [0, nodeLen] : null), setCanEllipsis(isOverflow);
      const baseRowsEllipsisHeight = ((_b = needEllipsisRef.current) === null || _b === void 0 ? void 0 : _b.getHeight()) || 0, descRowsEllipsisHeight = rows === 1 ? 0 : ((_c = descRowsEllipsisRef.current) === null || _c === void 0 ? void 0 : _c.getHeight()) || 0, symbolRowEllipsisHeight = ((_d = symbolRowEllipsisRef.current) === null || _d === void 0 ? void 0 : _d.getHeight()) || 0, maxRowsHeight = Math.max(
        baseRowsEllipsisHeight,
        // height of rows with ellipsis
        descRowsEllipsisHeight + symbolRowEllipsisHeight
      );
      setEllipsisHeight(maxRowsHeight + 1), onEllipsis(isOverflow);
    }
  }, [needEllipsis]);
  const cutMidIndex = ellipsisCutIndex ? Math.ceil((ellipsisCutIndex[0] + ellipsisCutIndex[1]) / 2) : 0;
  useLayoutEffect$1(() => {
    var _a;
    const [minIndex, maxIndex] = ellipsisCutIndex || [0, 0];
    if (minIndex !== maxIndex) {
      const isOverflow = (((_a = cutMidRef.current) === null || _a === void 0 ? void 0 : _a.getHeight()) || 0) > ellipsisHeight;
      let targetMidIndex = cutMidIndex;
      maxIndex - minIndex === 1 && (targetMidIndex = isOverflow ? minIndex : maxIndex), setEllipsisCutIndex(isOverflow ? [minIndex, targetMidIndex] : [targetMidIndex, maxIndex]);
    }
  }, [ellipsisCutIndex, cutMidIndex]);
  const finalContent = React.useMemo(() => {
    if (!enableMeasure)
      return children(nodeList, !1);
    if (needEllipsis !== STATUS_MEASURE_NEED_ELLIPSIS || !ellipsisCutIndex || ellipsisCutIndex[0] !== ellipsisCutIndex[1]) {
      const content = children(nodeList, !1);
      return [STATUS_MEASURE_NO_NEED_ELLIPSIS, STATUS_MEASURE_NONE].includes(needEllipsis) ? content : /* @__PURE__ */ React.createElement("span", {
        style: Object.assign(Object.assign({}, lineClipStyle), {
          WebkitLineClamp: rows
        })
      }, content);
    }
    return children(expanded ? nodeList : sliceNodes(nodeList, ellipsisCutIndex[0]), canEllipsis);
  }, [expanded, needEllipsis, ellipsisCutIndex, nodeList].concat(_toConsumableArray(miscDeps))), measureStyle = {
    width,
    margin: 0,
    padding: 0,
    whiteSpace: parentWhiteSpace === "nowrap" ? "normal" : "inherit"
  };
  return /* @__PURE__ */ React.createElement(React.Fragment, null, finalContent, needEllipsis === STATUS_MEASURE_START && /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement(MeasureText, {
    style: Object.assign(Object.assign(Object.assign({}, measureStyle), lineClipStyle), {
      WebkitLineClamp: rows
    }),
    ref: needEllipsisRef
  }, fullContent), /* @__PURE__ */ React.createElement(MeasureText, {
    style: Object.assign(Object.assign(Object.assign({}, measureStyle), lineClipStyle), {
      WebkitLineClamp: rows - 1
    }),
    ref: descRowsEllipsisRef
  }, fullContent), /* @__PURE__ */ React.createElement(MeasureText, {
    style: Object.assign(Object.assign(Object.assign({}, measureStyle), lineClipStyle), {
      WebkitLineClamp: 1
    }),
    ref: symbolRowEllipsisRef
  }, children([], !0))), needEllipsis === STATUS_MEASURE_NEED_ELLIPSIS && ellipsisCutIndex && ellipsisCutIndex[0] !== ellipsisCutIndex[1] && /* @__PURE__ */ React.createElement(MeasureText, {
    style: Object.assign(Object.assign({}, measureStyle), {
      top: 400
    }),
    ref: cutMidRef
  }, children(sliceNodes(nodeList, cutMidIndex), !0)), needEllipsis === STATUS_MEASURE_PREPARE && /* @__PURE__ */ React.createElement("span", {
    style: {
      whiteSpace: "inherit"
    },
    ref: measureWhiteSpaceRef
  }));
}
__name(EllipsisMeasure, "EllipsisMeasure");
const EllipsisTooltip = /* @__PURE__ */ __name((_ref) => {
  let {
    enableEllipsis,
    isEllipsis,
    children,
    tooltipProps
  } = _ref;
  return !(tooltipProps != null && tooltipProps.title) || !enableEllipsis ? children : /* @__PURE__ */ React.createElement(Tooltip$1, Object.assign({
    open: isEllipsis ? void 0 : !1
  }, tooltipProps), children);
}, "EllipsisTooltip");
process.env.NODE_ENV !== "production" && (EllipsisTooltip.displayName = "EllipsisTooltip");
var __rest$4 = function(s, e2) {
  var t2 = {};
  for (var p in s) Object.prototype.hasOwnProperty.call(s, p) && e2.indexOf(p) < 0 && (t2[p] = s[p]);
  if (s != null && typeof Object.getOwnPropertySymbols == "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++)
    e2.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]) && (t2[p[i]] = s[p[i]]);
  return t2;
};
function wrapperDecorations(_ref, content) {
  let {
    mark,
    code,
    underline,
    delete: del,
    strong,
    keyboard,
    italic
  } = _ref, currentContent = content;
  function wrap(tag, needed) {
    needed && (currentContent = /* @__PURE__ */ React.createElement(tag, {}, currentContent));
  }
  return __name(wrap, "wrap"), wrap("strong", strong), wrap("u", underline), wrap("del", del), wrap("code", code), wrap("mark", mark), wrap("kbd", keyboard), wrap("i", italic), currentContent;
}
__name(wrapperDecorations, "wrapperDecorations");
const ELLIPSIS_STR = "...", Base = /* @__PURE__ */ React.forwardRef((props, ref) => {
  var _a;
  const {
    prefixCls: customizePrefixCls,
    className,
    style: style2,
    type: type4,
    disabled,
    children,
    ellipsis,
    editable,
    copyable,
    component,
    title: title2
  } = props, restProps = __rest$4(props, ["prefixCls", "className", "style", "type", "disabled", "children", "ellipsis", "editable", "copyable", "component", "title"]), {
    getPrefixCls,
    direction
  } = React.useContext(ConfigContext), [textLocale] = useLocale$1("Text"), typographyRef = React.useRef(null), editIconRef = React.useRef(null), prefixCls = getPrefixCls("typography", customizePrefixCls), textProps = omit(restProps, ["mark", "code", "delete", "underline", "strong", "keyboard", "italic"]), [enableEdit, editConfig] = useMergedConfig(editable), [editing, setEditing] = useMergedState(!1, {
    value: editConfig.editing
  }), {
    triggerType = ["icon"]
  } = editConfig, triggerEdit = /* @__PURE__ */ __name((edit) => {
    var _a2;
    edit && ((_a2 = editConfig.onStart) === null || _a2 === void 0 || _a2.call(editConfig)), setEditing(edit);
  }, "triggerEdit"), prevEditing = usePrevious$1(editing);
  useLayoutEffect$1(() => {
    var _a2;
    !editing && prevEditing && ((_a2 = editIconRef.current) === null || _a2 === void 0 || _a2.focus());
  }, [editing]);
  const onEditClick = /* @__PURE__ */ __name((e2) => {
    e2 == null || e2.preventDefault(), triggerEdit(!0);
  }, "onEditClick"), onEditChange = /* @__PURE__ */ __name((value) => {
    var _a2;
    (_a2 = editConfig.onChange) === null || _a2 === void 0 || _a2.call(editConfig, value), triggerEdit(!1);
  }, "onEditChange"), onEditCancel = /* @__PURE__ */ __name(() => {
    var _a2;
    (_a2 = editConfig.onCancel) === null || _a2 === void 0 || _a2.call(editConfig), triggerEdit(!1);
  }, "onEditCancel"), [enableCopy, copyConfig] = useMergedConfig(copyable), {
    copied,
    copyLoading,
    onClick: onCopyClick
  } = useCopyClick({
    copyConfig,
    children
  }), [isLineClampSupport, setIsLineClampSupport] = React.useState(!1), [isTextOverflowSupport, setIsTextOverflowSupport] = React.useState(!1), [isJsEllipsis, setIsJsEllipsis] = React.useState(!1), [isNativeEllipsis, setIsNativeEllipsis] = React.useState(!1), [isNativeVisible, setIsNativeVisible] = React.useState(!0), [enableEllipsis, ellipsisConfig] = useMergedConfig(ellipsis, {
    expandable: !1,
    symbol: /* @__PURE__ */ __name((isExpanded) => isExpanded ? textLocale == null ? void 0 : textLocale.collapse : textLocale == null ? void 0 : textLocale.expand, "symbol")
  }), [expanded, setExpanded] = useMergedState(ellipsisConfig.defaultExpanded || !1, {
    value: ellipsisConfig.expanded
  }), mergedEnableEllipsis = enableEllipsis && (!expanded || ellipsisConfig.expandable === "collapsible"), {
    rows = 1
  } = ellipsisConfig, needMeasureEllipsis = React.useMemo(() => (
    // Disable ellipsis
    mergedEnableEllipsis && // Provide suffix
    (ellipsisConfig.suffix !== void 0 || ellipsisConfig.onEllipsis || // Can't use css ellipsis since we need to provide the place for button
    ellipsisConfig.expandable || enableEdit || enableCopy)
  ), [mergedEnableEllipsis, ellipsisConfig, enableEdit, enableCopy]);
  useLayoutEffect$1(() => {
    enableEllipsis && !needMeasureEllipsis && (setIsLineClampSupport(isStyleSupport("webkitLineClamp")), setIsTextOverflowSupport(isStyleSupport("textOverflow")));
  }, [needMeasureEllipsis, enableEllipsis]);
  const [cssEllipsis, setCssEllipsis] = React.useState(mergedEnableEllipsis), canUseCssEllipsis = React.useMemo(() => needMeasureEllipsis ? !1 : rows === 1 ? isTextOverflowSupport : isLineClampSupport, [needMeasureEllipsis, isTextOverflowSupport, isLineClampSupport]);
  useLayoutEffect$1(() => {
    setCssEllipsis(canUseCssEllipsis && mergedEnableEllipsis);
  }, [canUseCssEllipsis, mergedEnableEllipsis]);
  const isMergedEllipsis = mergedEnableEllipsis && (cssEllipsis ? isNativeEllipsis : isJsEllipsis), cssTextOverflow = mergedEnableEllipsis && rows === 1 && cssEllipsis, cssLineClamp = mergedEnableEllipsis && rows > 1 && cssEllipsis, onExpandClick = /* @__PURE__ */ __name((e2, info) => {
    var _a2;
    setExpanded(info.expanded), (_a2 = ellipsisConfig.onExpand) === null || _a2 === void 0 || _a2.call(ellipsisConfig, e2, info);
  }, "onExpandClick"), [ellipsisWidth, setEllipsisWidth] = React.useState(0), onResize2 = /* @__PURE__ */ __name((_ref2) => {
    let {
      offsetWidth
    } = _ref2;
    setEllipsisWidth(offsetWidth);
  }, "onResize"), onJsEllipsis = /* @__PURE__ */ __name((jsEllipsis) => {
    var _a2;
    setIsJsEllipsis(jsEllipsis), isJsEllipsis !== jsEllipsis && ((_a2 = ellipsisConfig.onEllipsis) === null || _a2 === void 0 || _a2.call(ellipsisConfig, jsEllipsis));
  }, "onJsEllipsis");
  React.useEffect(() => {
    const textEle = typographyRef.current;
    if (enableEllipsis && cssEllipsis && textEle) {
      const currentEllipsis = isEleEllipsis(textEle);
      isNativeEllipsis !== currentEllipsis && setIsNativeEllipsis(currentEllipsis);
    }
  }, [enableEllipsis, cssEllipsis, children, cssLineClamp, isNativeVisible, ellipsisWidth]), React.useEffect(() => {
    const textEle = typographyRef.current;
    if (typeof IntersectionObserver > "u" || !textEle || !cssEllipsis || !mergedEnableEllipsis)
      return;
    const observer = new IntersectionObserver(() => {
      setIsNativeVisible(!!textEle.offsetParent);
    });
    return observer.observe(textEle), () => {
      observer.disconnect();
    };
  }, [cssEllipsis, mergedEnableEllipsis]);
  const tooltipProps = useTooltipProps(ellipsisConfig.tooltip, editConfig.text, children), topAriaLabel = React.useMemo(() => {
    if (!(!enableEllipsis || cssEllipsis))
      return [editConfig.text, children, title2, tooltipProps.title].find(isValidText);
  }, [enableEllipsis, cssEllipsis, title2, tooltipProps.title, isMergedEllipsis]);
  if (editing)
    return /* @__PURE__ */ React.createElement(Editable, {
      value: (_a = editConfig.text) !== null && _a !== void 0 ? _a : typeof children == "string" ? children : "",
      onSave: onEditChange,
      onCancel: onEditCancel,
      onEnd: editConfig.onEnd,
      prefixCls,
      className,
      style: style2,
      direction,
      component,
      maxLength: editConfig.maxLength,
      autoSize: editConfig.autoSize,
      enterIcon: editConfig.enterIcon
    });
  const renderExpand = /* @__PURE__ */ __name(() => {
    const {
      expandable,
      symbol
    } = ellipsisConfig;
    return expandable ? /* @__PURE__ */ React.createElement("button", {
      type: "button",
      key: "expand",
      className: `${prefixCls}-${expanded ? "collapse" : "expand"}`,
      onClick: /* @__PURE__ */ __name((e2) => onExpandClick(e2, {
        expanded: !expanded
      }), "onClick"),
      "aria-label": expanded ? textLocale.collapse : textLocale == null ? void 0 : textLocale.expand
    }, typeof symbol == "function" ? symbol(expanded) : symbol) : null;
  }, "renderExpand"), renderEdit = /* @__PURE__ */ __name(() => {
    if (!enableEdit)
      return;
    const {
      icon,
      tooltip,
      tabIndex
    } = editConfig, editTitle = toArray$7(tooltip)[0] || (textLocale == null ? void 0 : textLocale.edit), ariaLabel = typeof editTitle == "string" ? editTitle : "";
    return triggerType.includes("icon") ? /* @__PURE__ */ React.createElement(Tooltip$1, {
      key: "edit",
      title: tooltip === !1 ? "" : editTitle
    }, /* @__PURE__ */ React.createElement("button", {
      type: "button",
      ref: editIconRef,
      className: `${prefixCls}-edit`,
      onClick: onEditClick,
      "aria-label": ariaLabel,
      tabIndex
    }, icon || /* @__PURE__ */ React.createElement(RefIcon$b, {
      role: "button"
    }))) : null;
  }, "renderEdit"), renderCopy = /* @__PURE__ */ __name(() => enableCopy ? /* @__PURE__ */ React.createElement(CopyBtn, Object.assign({
    key: "copy"
  }, copyConfig, {
    prefixCls,
    copied,
    locale: textLocale,
    onCopy: onCopyClick,
    loading: copyLoading,
    iconOnly: children == null
  })) : null, "renderCopy"), renderOperations = /* @__PURE__ */ __name((canEllipsis) => [canEllipsis && renderExpand(), renderEdit(), renderCopy()], "renderOperations"), renderEllipsis = /* @__PURE__ */ __name((canEllipsis) => [canEllipsis && !expanded && /* @__PURE__ */ React.createElement("span", {
    "aria-hidden": !0,
    key: "ellipsis"
  }, ELLIPSIS_STR), ellipsisConfig.suffix, renderOperations(canEllipsis)], "renderEllipsis");
  return /* @__PURE__ */ React.createElement(RefResizeObserver, {
    onResize: onResize2,
    disabled: !mergedEnableEllipsis
  }, (resizeRef) => /* @__PURE__ */ React.createElement(EllipsisTooltip, {
    tooltipProps,
    enableEllipsis: mergedEnableEllipsis,
    isEllipsis: isMergedEllipsis
  }, /* @__PURE__ */ React.createElement(Typography$1, Object.assign({
    className: cn({
      [`${prefixCls}-${type4}`]: type4,
      [`${prefixCls}-disabled`]: disabled,
      [`${prefixCls}-ellipsis`]: enableEllipsis,
      [`${prefixCls}-ellipsis-single-line`]: cssTextOverflow,
      [`${prefixCls}-ellipsis-multiple-line`]: cssLineClamp
    }, className),
    prefixCls: customizePrefixCls,
    style: Object.assign(Object.assign({}, style2), {
      WebkitLineClamp: cssLineClamp ? rows : void 0
    }),
    component,
    ref: composeRef(resizeRef, typographyRef, ref),
    direction,
    onClick: triggerType.includes("text") ? onEditClick : void 0,
    "aria-label": topAriaLabel == null ? void 0 : topAriaLabel.toString(),
    title: title2
  }, textProps), /* @__PURE__ */ React.createElement(EllipsisMeasure, {
    enableMeasure: mergedEnableEllipsis && !cssEllipsis,
    text: children,
    rows,
    width: ellipsisWidth,
    onEllipsis: onJsEllipsis,
    expanded,
    miscDeps: [copied, expanded, copyLoading, enableEdit, enableCopy, textLocale]
  }, (node2, canEllipsis) => wrapperDecorations(props, /* @__PURE__ */ React.createElement(React.Fragment, null, node2.length > 0 && canEllipsis && !expanded && topAriaLabel ? /* @__PURE__ */ React.createElement("span", {
    key: "show-content",
    "aria-hidden": !0
  }, node2) : node2, renderEllipsis(canEllipsis)))))));
});
var __rest$3 = function(s, e2) {
  var t2 = {};
  for (var p in s) Object.prototype.hasOwnProperty.call(s, p) && e2.indexOf(p) < 0 && (t2[p] = s[p]);
  if (s != null && typeof Object.getOwnPropertySymbols == "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++)
    e2.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]) && (t2[p[i]] = s[p[i]]);
  return t2;
};
const Link = /* @__PURE__ */ React.forwardRef((_a, ref) => {
  var {
    ellipsis,
    rel
  } = _a, restProps = __rest$3(_a, ["ellipsis", "rel"]);
  if (process.env.NODE_ENV !== "production") {
    const warning3 = devUseWarning("Typography.Link");
    process.env.NODE_ENV !== "production" && warning3(typeof ellipsis != "object", "usage", "`ellipsis` only supports boolean value.");
  }
  const mergedProps = Object.assign(Object.assign({}, restProps), {
    rel: rel === void 0 && restProps.target === "_blank" ? "noopener noreferrer" : rel
  });
  return delete mergedProps.navigate, /* @__PURE__ */ React.createElement(Base, Object.assign({}, mergedProps, {
    ref,
    ellipsis: !!ellipsis,
    component: "a"
  }));
}), Paragraph = /* @__PURE__ */ React.forwardRef((props, ref) => /* @__PURE__ */ React.createElement(Base, Object.assign({
  ref
}, props, {
  component: "div"
})));
var __rest$2 = function(s, e2) {
  var t2 = {};
  for (var p in s) Object.prototype.hasOwnProperty.call(s, p) && e2.indexOf(p) < 0 && (t2[p] = s[p]);
  if (s != null && typeof Object.getOwnPropertySymbols == "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++)
    e2.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]) && (t2[p[i]] = s[p[i]]);
  return t2;
};
const Text = /* @__PURE__ */ __name((_a, ref) => {
  var {
    ellipsis
  } = _a, restProps = __rest$2(_a, ["ellipsis"]);
  const mergedEllipsis = React.useMemo(() => ellipsis && typeof ellipsis == "object" ? omit(ellipsis, ["expandable", "rows"]) : ellipsis, [ellipsis]);
  if (process.env.NODE_ENV !== "production") {
    const warning3 = devUseWarning("Typography.Text");
    process.env.NODE_ENV !== "production" && warning3(typeof ellipsis != "object" || !ellipsis || !("expandable" in ellipsis) && !("rows" in ellipsis), "usage", "`ellipsis` do not support `expandable` or `rows` props.");
  }
  return /* @__PURE__ */ React.createElement(Base, Object.assign({
    ref
  }, restProps, {
    ellipsis: mergedEllipsis,
    component: "span"
  }));
}, "Text"), Text$1 = /* @__PURE__ */ React.forwardRef(Text);
var __rest$1 = function(s, e2) {
  var t2 = {};
  for (var p in s) Object.prototype.hasOwnProperty.call(s, p) && e2.indexOf(p) < 0 && (t2[p] = s[p]);
  if (s != null && typeof Object.getOwnPropertySymbols == "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++)
    e2.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]) && (t2[p[i]] = s[p[i]]);
  return t2;
};
const TITLE_ELE_LIST = [1, 2, 3, 4, 5], Title$1 = /* @__PURE__ */ React.forwardRef((props, ref) => {
  const {
    level = 1
  } = props, restProps = __rest$1(props, ["level"]);
  if (process.env.NODE_ENV !== "production") {
    const warning3 = devUseWarning("Typography.Title");
    process.env.NODE_ENV !== "production" && warning3(TITLE_ELE_LIST.includes(level), "usage", "Title only accept `1 | 2 | 3 | 4 | 5` as `level` value. And `5` need 4.6.0+ version.");
  }
  const component = TITLE_ELE_LIST.includes(level) ? `h${level}` : "h1";
  return /* @__PURE__ */ React.createElement(Base, Object.assign({
    ref
  }, restProps, {
    component
  }));
}), Typography = Typography$1;
Typography.Text = Text$1;
Typography.Link = Link;
Typography.Title = Title$1;
Typography.Paragraph = Paragraph;
const attrAccept = /* @__PURE__ */ __name(function(file, acceptedFiles) {
  if (file && acceptedFiles) {
    var acceptedFilesArray = Array.isArray(acceptedFiles) ? acceptedFiles : acceptedFiles.split(","), fileName = file.name || "", mimeType = file.type || "", baseMimeType = mimeType.replace(/\/.*$/, "");
    return acceptedFilesArray.some(function(type4) {
      var validType = type4.trim();
      if (/^\*(\/\*)?$/.test(type4))
        return !0;
      if (validType.charAt(0) === ".") {
        var lowerFileName = fileName.toLowerCase(), lowerType = validType.toLowerCase(), affixList = [lowerType];
        return (lowerType === ".jpg" || lowerType === ".jpeg") && (affixList = [".jpg", ".jpeg"]), affixList.some(function(affix) {
          return lowerFileName.endsWith(affix);
        });
      }
      return /\/\*$/.test(validType) ? baseMimeType === validType.replace(/\/.*$/, "") : mimeType === validType ? !0 : /^\w+$/.test(validType) ? (warningOnce(!1, "Upload takes an invalidate 'accept' type '".concat(validType, "'.Skip for check.")), !0) : !1;
    });
  }
  return !0;
}, "attrAccept");
function getError(option, xhr) {
  var msg = "cannot ".concat(option.method, " ").concat(option.action, " ").concat(xhr.status, "'"), err = new Error(msg);
  return err.status = xhr.status, err.method = option.method, err.url = option.action, err;
}
__name(getError, "getError");
function getBody(xhr) {
  var text = xhr.responseText || xhr.response;
  if (!text)
    return text;
  try {
    return JSON.parse(text);
  } catch {
    return text;
  }
}
__name(getBody, "getBody");
function upload(option) {
  var xhr = new XMLHttpRequest();
  option.onProgress && xhr.upload && (xhr.upload.onprogress = /* @__PURE__ */ __name(function(e2) {
    e2.total > 0 && (e2.percent = e2.loaded / e2.total * 100), option.onProgress(e2);
  }, "progress"));
  var formData = new FormData();
  option.data && Object.keys(option.data).forEach(function(key) {
    var value = option.data[key];
    if (Array.isArray(value)) {
      value.forEach(function(item) {
        formData.append("".concat(key, "[]"), item);
      });
      return;
    }
    formData.append(key, value);
  }), option.file instanceof Blob ? formData.append(option.filename, option.file, option.file.name) : formData.append(option.filename, option.file), xhr.onerror = /* @__PURE__ */ __name(function(e2) {
    option.onError(e2);
  }, "error"), xhr.onload = /* @__PURE__ */ __name(function() {
    return xhr.status < 200 || xhr.status >= 300 ? option.onError(getError(option, xhr), getBody(xhr)) : option.onSuccess(getBody(xhr), xhr);
  }, "onload"), xhr.open(option.method, option.action, !0), option.withCredentials && "withCredentials" in xhr && (xhr.withCredentials = !0);
  var headers = option.headers || {};
  return headers["X-Requested-With"] !== null && xhr.setRequestHeader("X-Requested-With", "XMLHttpRequest"), Object.keys(headers).forEach(function(h) {
    headers[h] !== null && xhr.setRequestHeader(h, headers[h]);
  }), xhr.send(formData), {
    abort: /* @__PURE__ */ __name(function() {
      xhr.abort();
    }, "abort")
  };
}
__name(upload, "upload");
var traverseFileTree = /* @__PURE__ */ function() {
  var _ref = _asyncToGenerator(/* @__PURE__ */ _regeneratorRuntime().mark(/* @__PURE__ */ __name(function _callee4(files, isAccepted) {
    var flattenFileList, progressFileList, readDirectory, _readDirectory, readFile, _readFile, _traverseFileTree, wipIndex;
    return _regeneratorRuntime().wrap(/* @__PURE__ */ __name(function(_context4) {
      for (; ; ) switch (_context4.prev = _context4.next) {
        case 0:
          _readFile = /* @__PURE__ */ __name(function() {
            return _readFile = _asyncToGenerator(/* @__PURE__ */ _regeneratorRuntime().mark(/* @__PURE__ */ __name(function _callee3(item) {
              return _regeneratorRuntime().wrap(/* @__PURE__ */ __name(function(_context3) {
                for (; ; ) switch (_context3.prev = _context3.next) {
                  case 0:
                    return _context3.abrupt("return", new Promise(function(reslove) {
                      item.file(function(file) {
                        isAccepted(file) ? (item.fullPath && !file.webkitRelativePath && (Object.defineProperties(file, {
                          webkitRelativePath: {
                            writable: !0
                          }
                        }), file.webkitRelativePath = item.fullPath.replace(/^\//, ""), Object.defineProperties(file, {
                          webkitRelativePath: {
                            writable: !1
                          }
                        })), reslove(file)) : reslove(null);
                      });
                    }));
                  case 1:
                  case "end":
                    return _context3.stop();
                }
              }, "_callee3$"), _callee3);
            }, "_callee3"))), _readFile.apply(this, arguments);
          }, "_readFile3"), readFile = /* @__PURE__ */ __name(function(_x4) {
            return _readFile.apply(this, arguments);
          }, "_readFile2"), _readDirectory = /* @__PURE__ */ __name(function() {
            return _readDirectory = _asyncToGenerator(/* @__PURE__ */ _regeneratorRuntime().mark(/* @__PURE__ */ __name(function _callee2(directory) {
              var dirReader, entries, results, n2, i;
              return _regeneratorRuntime().wrap(/* @__PURE__ */ __name(function(_context2) {
                for (; ; ) switch (_context2.prev = _context2.next) {
                  case 0:
                    dirReader = directory.createReader(), entries = [];
                  case 2:
                    return _context2.next = 5, new Promise(function(resolve) {
                      dirReader.readEntries(resolve, function() {
                        return resolve([]);
                      });
                    });
                  case 5:
                    if (results = _context2.sent, n2 = results.length, n2) {
                      _context2.next = 9;
                      break;
                    }
                    return _context2.abrupt("break", 12);
                  case 9:
                    for (i = 0; i < n2; i++)
                      entries.push(results[i]);
                    _context2.next = 2;
                    break;
                  case 12:
                    return _context2.abrupt("return", entries);
                  case 13:
                  case "end":
                    return _context2.stop();
                }
              }, "_callee2$"), _callee2);
            }, "_callee2"))), _readDirectory.apply(this, arguments);
          }, "_readDirectory3"), readDirectory = /* @__PURE__ */ __name(function(_x3) {
            return _readDirectory.apply(this, arguments);
          }, "_readDirectory2"), flattenFileList = [], progressFileList = [], files.forEach(function(file) {
            return progressFileList.push(file.webkitGetAsEntry());
          }), _traverseFileTree = /* @__PURE__ */ function() {
            var _ref2 = _asyncToGenerator(/* @__PURE__ */ _regeneratorRuntime().mark(/* @__PURE__ */ __name(function _callee(item, path2) {
              var _file, entries;
              return _regeneratorRuntime().wrap(/* @__PURE__ */ __name(function(_context) {
                for (; ; ) switch (_context.prev = _context.next) {
                  case 0:
                    if (item) {
                      _context.next = 2;
                      break;
                    }
                    return _context.abrupt("return");
                  case 2:
                    if (item.path = path2 || "", !item.isFile) {
                      _context.next = 10;
                      break;
                    }
                    return _context.next = 6, readFile(item);
                  case 6:
                    _file = _context.sent, _file && flattenFileList.push(_file), _context.next = 15;
                    break;
                  case 10:
                    if (!item.isDirectory) {
                      _context.next = 15;
                      break;
                    }
                    return _context.next = 13, readDirectory(item);
                  case 13:
                    entries = _context.sent, progressFileList.push.apply(progressFileList, _toConsumableArray(entries));
                  case 15:
                  case "end":
                    return _context.stop();
                }
              }, "_callee$"), _callee);
            }, "_callee")));
            return /* @__PURE__ */ __name(function(_x5, _x6) {
              return _ref2.apply(this, arguments);
            }, "_traverseFileTree");
          }(), wipIndex = 0;
        case 9:
          if (!(wipIndex < progressFileList.length)) {
            _context4.next = 15;
            break;
          }
          return _context4.next = 12, _traverseFileTree(progressFileList[wipIndex]);
        case 12:
          wipIndex++, _context4.next = 9;
          break;
        case 15:
          return _context4.abrupt("return", flattenFileList);
        case 16:
        case "end":
          return _context4.stop();
      }
    }, "_callee4$"), _callee4);
  }, "_callee4")));
  return /* @__PURE__ */ __name(function(_x, _x2) {
    return _ref.apply(this, arguments);
  }, "traverseFileTree");
}(), now = +/* @__PURE__ */ new Date(), index = 0;
function uid() {
  return "rc-upload-".concat(now, "-").concat(++index);
}
__name(uid, "uid");
var _excluded = ["component", "prefixCls", "className", "classNames", "disabled", "id", "name", "style", "styles", "multiple", "accept", "capture", "children", "directory", "openFileDialogOnClick", "onMouseEnter", "onMouseLeave", "hasControlInside"], AjaxUploader = /* @__PURE__ */ function(_Component) {
  _inherits(AjaxUploader2, _Component);
  var _super = _createSuper(AjaxUploader2);
  function AjaxUploader2() {
    var _this;
    _classCallCheck$1(this, AjaxUploader2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++)
      args[_key] = arguments[_key];
    return _this = _super.call.apply(_super, [this].concat(args)), _defineProperty$2(_assertThisInitialized(_this), "state", {
      uid: uid()
    }), _defineProperty$2(_assertThisInitialized(_this), "reqs", {}), _defineProperty$2(_assertThisInitialized(_this), "fileInput", void 0), _defineProperty$2(_assertThisInitialized(_this), "_isMounted", void 0), _defineProperty$2(_assertThisInitialized(_this), "onChange", function(e2) {
      var _this$props = _this.props, accept = _this$props.accept, directory = _this$props.directory, files = e2.target.files, acceptedFiles = _toConsumableArray(files).filter(function(file) {
        return !directory || attrAccept(file, accept);
      });
      _this.uploadFiles(acceptedFiles), _this.reset();
    }), _defineProperty$2(_assertThisInitialized(_this), "onClick", function(event) {
      var el = _this.fileInput;
      if (el) {
        var target = event.target, onClick = _this.props.onClick;
        if (target && target.tagName === "BUTTON") {
          var parent = el.parentNode;
          parent.focus(), target.blur();
        }
        el.click(), onClick && onClick(event);
      }
    }), _defineProperty$2(_assertThisInitialized(_this), "onKeyDown", function(e2) {
      e2.key === "Enter" && _this.onClick(e2);
    }), _defineProperty$2(_assertThisInitialized(_this), "onFileDrop", /* @__PURE__ */ function() {
      var _ref = _asyncToGenerator(/* @__PURE__ */ _regeneratorRuntime().mark(/* @__PURE__ */ __name(function _callee(e2) {
        var multiple, files, _files;
        return _regeneratorRuntime().wrap(/* @__PURE__ */ __name(function(_context) {
          for (; ; ) switch (_context.prev = _context.next) {
            case 0:
              if (multiple = _this.props.multiple, e2.preventDefault(), e2.type !== "dragover") {
                _context.next = 4;
                break;
              }
              return _context.abrupt("return");
            case 4:
              if (!_this.props.directory) {
                _context.next = 11;
                break;
              }
              return _context.next = 7, traverseFileTree(Array.prototype.slice.call(e2.dataTransfer.items), function(_file) {
                return attrAccept(_file, _this.props.accept);
              });
            case 7:
              files = _context.sent, _this.uploadFiles(files), _context.next = 14;
              break;
            case 11:
              _files = _toConsumableArray(e2.dataTransfer.files).filter(function(file) {
                return attrAccept(file, _this.props.accept);
              }), multiple === !1 && (_files = _files.slice(0, 1)), _this.uploadFiles(_files);
            case 14:
            case "end":
              return _context.stop();
          }
        }, "_callee$"), _callee);
      }, "_callee")));
      return function(_x) {
        return _ref.apply(this, arguments);
      };
    }()), _defineProperty$2(_assertThisInitialized(_this), "uploadFiles", function(files) {
      var originFiles = _toConsumableArray(files), postFiles = originFiles.map(function(file) {
        return file.uid = uid(), _this.processFile(file, originFiles);
      });
      Promise.all(postFiles).then(function(fileList) {
        var onBatchStart = _this.props.onBatchStart;
        onBatchStart == null || onBatchStart(fileList.map(function(_ref2) {
          var origin = _ref2.origin, parsedFile = _ref2.parsedFile;
          return {
            file: origin,
            parsedFile
          };
        })), fileList.filter(function(file) {
          return file.parsedFile !== null;
        }).forEach(function(file) {
          _this.post(file);
        });
      });
    }), _defineProperty$2(_assertThisInitialized(_this), "processFile", /* @__PURE__ */ function() {
      var _ref3 = _asyncToGenerator(/* @__PURE__ */ _regeneratorRuntime().mark(/* @__PURE__ */ __name(function _callee2(file, fileList) {
        var beforeUpload, transformedFile, action, mergedAction, data, mergedData, parsedData, parsedFile, mergedParsedFile;
        return _regeneratorRuntime().wrap(/* @__PURE__ */ __name(function(_context2) {
          for (; ; ) switch (_context2.prev = _context2.next) {
            case 0:
              if (beforeUpload = _this.props.beforeUpload, transformedFile = file, !beforeUpload) {
                _context2.next = 14;
                break;
              }
              return _context2.prev = 3, _context2.next = 6, beforeUpload(file, fileList);
            case 6:
              transformedFile = _context2.sent, _context2.next = 12;
              break;
            case 9:
              _context2.prev = 9, _context2.t0 = _context2.catch(3), transformedFile = !1;
            case 12:
              if (transformedFile !== !1) {
                _context2.next = 14;
                break;
              }
              return _context2.abrupt("return", {
                origin: file,
                parsedFile: null,
                action: null,
                data: null
              });
            case 14:
              if (action = _this.props.action, typeof action != "function") {
                _context2.next = 21;
                break;
              }
              return _context2.next = 18, action(file);
            case 18:
              mergedAction = _context2.sent, _context2.next = 22;
              break;
            case 21:
              mergedAction = action;
            case 22:
              if (data = _this.props.data, typeof data != "function") {
                _context2.next = 29;
                break;
              }
              return _context2.next = 26, data(file);
            case 26:
              mergedData = _context2.sent, _context2.next = 30;
              break;
            case 29:
              mergedData = data;
            case 30:
              return parsedData = // string type is from legacy `transformFile`.
              // Not sure if this will work since no related test case works with it
              (_typeof$4(transformedFile) === "object" || typeof transformedFile == "string") && transformedFile ? transformedFile : file, parsedData instanceof File ? parsedFile = parsedData : parsedFile = new File([parsedData], file.name, {
                type: file.type
              }), mergedParsedFile = parsedFile, mergedParsedFile.uid = file.uid, _context2.abrupt("return", {
                origin: file,
                data: mergedData,
                parsedFile: mergedParsedFile,
                action: mergedAction
              });
            case 35:
            case "end":
              return _context2.stop();
          }
        }, "_callee2$"), _callee2, null, [[3, 9]]);
      }, "_callee2")));
      return function(_x2, _x3) {
        return _ref3.apply(this, arguments);
      };
    }()), _defineProperty$2(_assertThisInitialized(_this), "saveFileInput", function(node2) {
      _this.fileInput = node2;
    }), _this;
  }
  return __name(AjaxUploader2, "AjaxUploader"), _createClass$1(AjaxUploader2, [{
    key: "componentDidMount",
    value: /* @__PURE__ */ __name(function() {
      this._isMounted = !0;
    }, "componentDidMount")
  }, {
    key: "componentWillUnmount",
    value: /* @__PURE__ */ __name(function() {
      this._isMounted = !1, this.abort();
    }, "componentWillUnmount")
  }, {
    key: "post",
    value: /* @__PURE__ */ __name(function(_ref4) {
      var _this2 = this, data = _ref4.data, origin = _ref4.origin, action = _ref4.action, parsedFile = _ref4.parsedFile;
      if (this._isMounted) {
        var _this$props2 = this.props, onStart = _this$props2.onStart, customRequest = _this$props2.customRequest, name = _this$props2.name, headers = _this$props2.headers, withCredentials = _this$props2.withCredentials, method4 = _this$props2.method, uid2 = origin.uid, request3 = customRequest || upload, requestOption = {
          action,
          filename: name,
          data,
          file: parsedFile,
          headers,
          withCredentials,
          method: method4 || "post",
          onProgress: /* @__PURE__ */ __name(function(e2) {
            var onProgress2 = _this2.props.onProgress;
            onProgress2 == null || onProgress2(e2, parsedFile);
          }, "onProgress"),
          onSuccess: /* @__PURE__ */ __name(function(ret, xhr) {
            var onSuccess2 = _this2.props.onSuccess;
            onSuccess2 == null || onSuccess2(ret, parsedFile, xhr), delete _this2.reqs[uid2];
          }, "onSuccess"),
          onError: /* @__PURE__ */ __name(function(err, ret) {
            var onError2 = _this2.props.onError;
            onError2 == null || onError2(err, ret, parsedFile), delete _this2.reqs[uid2];
          }, "onError")
        };
        onStart(origin), this.reqs[uid2] = request3(requestOption);
      }
    }, "post")
  }, {
    key: "reset",
    value: /* @__PURE__ */ __name(function() {
      this.setState({
        uid: uid()
      });
    }, "reset")
  }, {
    key: "abort",
    value: /* @__PURE__ */ __name(function(file) {
      var reqs = this.reqs;
      if (file) {
        var uid2 = file.uid ? file.uid : file;
        reqs[uid2] && reqs[uid2].abort && reqs[uid2].abort(), delete reqs[uid2];
      } else
        Object.keys(reqs).forEach(function(uid3) {
          reqs[uid3] && reqs[uid3].abort && reqs[uid3].abort(), delete reqs[uid3];
        });
    }, "abort")
  }, {
    key: "render",
    value: /* @__PURE__ */ __name(function() {
      var _this$props3 = this.props, Tag = _this$props3.component, prefixCls = _this$props3.prefixCls, className = _this$props3.className, _this$props3$classNam = _this$props3.classNames, classNames = _this$props3$classNam === void 0 ? {} : _this$props3$classNam, disabled = _this$props3.disabled, id2 = _this$props3.id, name = _this$props3.name, style2 = _this$props3.style, _this$props3$styles = _this$props3.styles, styles2 = _this$props3$styles === void 0 ? {} : _this$props3$styles, multiple = _this$props3.multiple, accept = _this$props3.accept, capture = _this$props3.capture, children = _this$props3.children, directory = _this$props3.directory, openFileDialogOnClick = _this$props3.openFileDialogOnClick, onMouseEnter = _this$props3.onMouseEnter, onMouseLeave = _this$props3.onMouseLeave, hasControlInside = _this$props3.hasControlInside, otherProps = _objectWithoutProperties(_this$props3, _excluded), cls = cn(_defineProperty$2(_defineProperty$2(_defineProperty$2({}, prefixCls, !0), "".concat(prefixCls, "-disabled"), disabled), className, className)), dirProps = directory ? {
        directory: "directory",
        webkitdirectory: "webkitdirectory"
      } : {}, events = disabled ? {} : {
        onClick: openFileDialogOnClick ? this.onClick : function() {
        },
        onKeyDown: openFileDialogOnClick ? this.onKeyDown : function() {
        },
        onMouseEnter,
        onMouseLeave,
        onDrop: this.onFileDrop,
        onDragOver: this.onFileDrop,
        tabIndex: hasControlInside ? void 0 : "0"
      };
      return /* @__PURE__ */ React__default.createElement(Tag, _extends({}, events, {
        className: cls,
        role: hasControlInside ? void 0 : "button",
        style: style2
      }), /* @__PURE__ */ React__default.createElement("input", _extends({}, pickAttrs(otherProps, {
        aria: !0,
        data: !0
      }), {
        id: id2,
        name,
        disabled,
        type: "file",
        ref: this.saveFileInput,
        onClick: /* @__PURE__ */ __name(function(e2) {
          return e2.stopPropagation();
        }, "onClick"),
        key: this.state.uid,
        style: _objectSpread2$1({
          display: "none"
        }, styles2.input),
        className: classNames.input,
        accept
      }, dirProps, {
        multiple,
        onChange: this.onChange
      }, capture != null ? {
        capture
      } : {})), children);
    }, "render")
  }]), AjaxUploader2;
}(Component$1);
function empty() {
}
__name(empty, "empty");
var Upload$2 = /* @__PURE__ */ function(_Component) {
  _inherits(Upload2, _Component);
  var _super = _createSuper(Upload2);
  function Upload2() {
    var _this;
    _classCallCheck$1(this, Upload2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++)
      args[_key] = arguments[_key];
    return _this = _super.call.apply(_super, [this].concat(args)), _defineProperty$2(_assertThisInitialized(_this), "uploader", void 0), _defineProperty$2(_assertThisInitialized(_this), "saveUploader", function(node2) {
      _this.uploader = node2;
    }), _this;
  }
  return __name(Upload2, "Upload"), _createClass$1(Upload2, [{
    key: "abort",
    value: /* @__PURE__ */ __name(function(file) {
      this.uploader.abort(file);
    }, "abort")
  }, {
    key: "render",
    value: /* @__PURE__ */ __name(function() {
      return /* @__PURE__ */ React__default.createElement(AjaxUploader, _extends({}, this.props, {
        ref: this.saveUploader
      }));
    }, "render")
  }]), Upload2;
}(Component$1);
_defineProperty$2(Upload$2, "defaultProps", {
  component: "span",
  prefixCls: "rc-upload",
  data: {},
  headers: {},
  name: "file",
  multipart: !1,
  onStart: empty,
  onError: empty,
  onSuccess: empty,
  multiple: !1,
  beforeUpload: null,
  customRequest: null,
  withCredentials: !1,
  openFileDialogOnClick: !0,
  hasControlInside: !1
});
const genDraggerStyle = /* @__PURE__ */ __name((token2) => {
  const {
    componentCls,
    iconCls
  } = token2;
  return {
    [`${componentCls}-wrapper`]: {
      [`${componentCls}-drag`]: {
        position: "relative",
        width: "100%",
        height: "100%",
        textAlign: "center",
        background: token2.colorFillAlter,
        border: `${unit$1(token2.lineWidth)} dashed ${token2.colorBorder}`,
        borderRadius: token2.borderRadiusLG,
        cursor: "pointer",
        transition: `border-color ${token2.motionDurationSlow}`,
        [componentCls]: {
          padding: token2.padding
        },
        [`${componentCls}-btn`]: {
          display: "table",
          width: "100%",
          height: "100%",
          outline: "none",
          borderRadius: token2.borderRadiusLG,
          "&:focus-visible": {
            outline: `${unit$1(token2.lineWidthFocus)} solid ${token2.colorPrimaryBorder}`
          }
        },
        [`${componentCls}-drag-container`]: {
          display: "table-cell",
          verticalAlign: "middle"
        },
        [`
          &:not(${componentCls}-disabled):hover,
          &-hover:not(${componentCls}-disabled)
        `]: {
          borderColor: token2.colorPrimaryHover
        },
        [`p${componentCls}-drag-icon`]: {
          marginBottom: token2.margin,
          [iconCls]: {
            color: token2.colorPrimary,
            fontSize: token2.uploadThumbnailSize
          }
        },
        [`p${componentCls}-text`]: {
          margin: `0 0 ${unit$1(token2.marginXXS)}`,
          color: token2.colorTextHeading,
          fontSize: token2.fontSizeLG
        },
        [`p${componentCls}-hint`]: {
          color: token2.colorTextDescription,
          fontSize: token2.fontSize
        },
        // ===================== Disabled =====================
        [`&${componentCls}-disabled`]: {
          [`p${componentCls}-drag-icon ${iconCls},
            p${componentCls}-text,
            p${componentCls}-hint
          `]: {
            color: token2.colorTextDisabled
          }
        }
      }
    }
  };
}, "genDraggerStyle"), genListStyle = /* @__PURE__ */ __name((token2) => {
  const {
    componentCls,
    iconCls,
    fontSize,
    lineHeight,
    calc
  } = token2, itemCls = `${componentCls}-list-item`, actionsCls = `${itemCls}-actions`, actionCls = `${itemCls}-action`;
  return {
    [`${componentCls}-wrapper`]: {
      [`${componentCls}-list`]: Object.assign(Object.assign({}, clearFix()), {
        lineHeight: token2.lineHeight,
        [itemCls]: {
          position: "relative",
          height: calc(token2.lineHeight).mul(fontSize).equal(),
          marginTop: token2.marginXS,
          fontSize,
          display: "flex",
          alignItems: "center",
          transition: `background-color ${token2.motionDurationSlow}`,
          borderRadius: token2.borderRadiusSM,
          "&:hover": {
            backgroundColor: token2.controlItemBgHover
          },
          [`${itemCls}-name`]: Object.assign(Object.assign({}, textEllipsis), {
            padding: `0 ${unit$1(token2.paddingXS)}`,
            lineHeight,
            flex: "auto",
            transition: `all ${token2.motionDurationSlow}`
          }),
          [actionsCls]: {
            whiteSpace: "nowrap",
            [actionCls]: {
              opacity: 0
            },
            [iconCls]: {
              color: token2.actionsColor,
              transition: `all ${token2.motionDurationSlow}`
            },
            [`
              ${actionCls}:focus-visible,
              &.picture ${actionCls}
            `]: {
              opacity: 1
            }
          },
          [`${componentCls}-icon ${iconCls}`]: {
            color: token2.colorTextDescription,
            fontSize
          },
          [`${itemCls}-progress`]: {
            position: "absolute",
            bottom: token2.calc(token2.uploadProgressOffset).mul(-1).equal(),
            width: "100%",
            paddingInlineStart: calc(fontSize).add(token2.paddingXS).equal(),
            fontSize,
            lineHeight: 0,
            pointerEvents: "none",
            "> div": {
              margin: 0
            }
          }
        },
        [`${itemCls}:hover ${actionCls}`]: {
          opacity: 1
        },
        [`${itemCls}-error`]: {
          color: token2.colorError,
          [`${itemCls}-name, ${componentCls}-icon ${iconCls}`]: {
            color: token2.colorError
          },
          [actionsCls]: {
            [`${iconCls}, ${iconCls}:hover`]: {
              color: token2.colorError
            },
            [actionCls]: {
              opacity: 1
            }
          }
        },
        [`${componentCls}-list-item-container`]: {
          transition: `opacity ${token2.motionDurationSlow}, height ${token2.motionDurationSlow}`,
          // For smooth removing animation
          "&::before": {
            display: "table",
            width: 0,
            height: 0,
            content: '""'
          }
        }
      })
    }
  };
}, "genListStyle"), genMotionStyle = /* @__PURE__ */ __name((token2) => {
  const {
    componentCls
  } = token2, uploadAnimateInlineIn = new Keyframe("uploadAnimateInlineIn", {
    from: {
      width: 0,
      height: 0,
      padding: 0,
      opacity: 0,
      margin: token2.calc(token2.marginXS).div(-2).equal()
    }
  }), uploadAnimateInlineOut = new Keyframe("uploadAnimateInlineOut", {
    to: {
      width: 0,
      height: 0,
      padding: 0,
      opacity: 0,
      margin: token2.calc(token2.marginXS).div(-2).equal()
    }
  }), inlineCls = `${componentCls}-animate-inline`;
  return [{
    [`${componentCls}-wrapper`]: {
      [`${inlineCls}-appear, ${inlineCls}-enter, ${inlineCls}-leave`]: {
        animationDuration: token2.motionDurationSlow,
        animationTimingFunction: token2.motionEaseInOutCirc,
        animationFillMode: "forwards"
      },
      [`${inlineCls}-appear, ${inlineCls}-enter`]: {
        animationName: uploadAnimateInlineIn
      },
      [`${inlineCls}-leave`]: {
        animationName: uploadAnimateInlineOut
      }
    }
  }, {
    [`${componentCls}-wrapper`]: initFadeMotion(token2)
  }, uploadAnimateInlineIn, uploadAnimateInlineOut];
}, "genMotionStyle"), genPictureStyle = /* @__PURE__ */ __name((token2) => {
  const {
    componentCls,
    iconCls,
    uploadThumbnailSize,
    uploadProgressOffset,
    calc
  } = token2, listCls = `${componentCls}-list`, itemCls = `${listCls}-item`;
  return {
    [`${componentCls}-wrapper`]: {
      // ${listCls} 增加优先级
      [`
        ${listCls}${listCls}-picture,
        ${listCls}${listCls}-picture-card,
        ${listCls}${listCls}-picture-circle
      `]: {
        [itemCls]: {
          position: "relative",
          height: calc(uploadThumbnailSize).add(calc(token2.lineWidth).mul(2)).add(calc(token2.paddingXS).mul(2)).equal(),
          padding: token2.paddingXS,
          border: `${unit$1(token2.lineWidth)} ${token2.lineType} ${token2.colorBorder}`,
          borderRadius: token2.borderRadiusLG,
          "&:hover": {
            background: "transparent"
          },
          [`${itemCls}-thumbnail`]: Object.assign(Object.assign({}, textEllipsis), {
            width: uploadThumbnailSize,
            height: uploadThumbnailSize,
            lineHeight: unit$1(calc(uploadThumbnailSize).add(token2.paddingSM).equal()),
            textAlign: "center",
            flex: "none",
            [iconCls]: {
              fontSize: token2.fontSizeHeading2,
              color: token2.colorPrimary
            },
            img: {
              display: "block",
              width: "100%",
              height: "100%",
              overflow: "hidden"
            }
          }),
          [`${itemCls}-progress`]: {
            bottom: uploadProgressOffset,
            width: `calc(100% - ${unit$1(calc(token2.paddingSM).mul(2).equal())})`,
            marginTop: 0,
            paddingInlineStart: calc(uploadThumbnailSize).add(token2.paddingXS).equal()
          }
        },
        [`${itemCls}-error`]: {
          borderColor: token2.colorError,
          // Adjust the color of the error icon : https://github.com/ant-design/ant-design/pull/24160
          [`${itemCls}-thumbnail ${iconCls}`]: {
            [`svg path[fill='${blue[0]}']`]: {
              fill: token2.colorErrorBg
            },
            [`svg path[fill='${blue.primary}']`]: {
              fill: token2.colorError
            }
          }
        },
        [`${itemCls}-uploading`]: {
          borderStyle: "dashed",
          [`${itemCls}-name`]: {
            marginBottom: uploadProgressOffset
          }
        }
      },
      [`${listCls}${listCls}-picture-circle ${itemCls}`]: {
        [`&, &::before, ${itemCls}-thumbnail`]: {
          borderRadius: "50%"
        }
      }
    }
  };
}, "genPictureStyle"), genPictureCardStyle = /* @__PURE__ */ __name((token2) => {
  const {
    componentCls,
    iconCls,
    fontSizeLG,
    colorTextLightSolid,
    calc
  } = token2, listCls = `${componentCls}-list`, itemCls = `${listCls}-item`, uploadPictureCardSize = token2.uploadPicCardSize;
  return {
    [`
      ${componentCls}-wrapper${componentCls}-picture-card-wrapper,
      ${componentCls}-wrapper${componentCls}-picture-circle-wrapper
    `]: Object.assign(Object.assign({}, clearFix()), {
      display: "block",
      [`${componentCls}${componentCls}-select`]: {
        width: uploadPictureCardSize,
        height: uploadPictureCardSize,
        textAlign: "center",
        verticalAlign: "top",
        backgroundColor: token2.colorFillAlter,
        border: `${unit$1(token2.lineWidth)} dashed ${token2.colorBorder}`,
        borderRadius: token2.borderRadiusLG,
        cursor: "pointer",
        transition: `border-color ${token2.motionDurationSlow}`,
        [`> ${componentCls}`]: {
          display: "flex",
          alignItems: "center",
          justifyContent: "center",
          height: "100%",
          textAlign: "center"
        },
        [`&:not(${componentCls}-disabled):hover`]: {
          borderColor: token2.colorPrimary
        }
      },
      // list
      [`${listCls}${listCls}-picture-card, ${listCls}${listCls}-picture-circle`]: {
        display: "flex",
        flexWrap: "wrap",
        "@supports not (gap: 1px)": {
          "& > *": {
            marginBlockEnd: token2.marginXS,
            marginInlineEnd: token2.marginXS
          }
        },
        "@supports (gap: 1px)": {
          gap: token2.marginXS
        },
        [`${listCls}-item-container`]: {
          display: "inline-block",
          width: uploadPictureCardSize,
          height: uploadPictureCardSize,
          verticalAlign: "top"
        },
        "&::after": {
          display: "none"
        },
        "&::before": {
          display: "none"
        },
        [itemCls]: {
          height: "100%",
          margin: 0,
          "&::before": {
            position: "absolute",
            zIndex: 1,
            width: `calc(100% - ${unit$1(calc(token2.paddingXS).mul(2).equal())})`,
            height: `calc(100% - ${unit$1(calc(token2.paddingXS).mul(2).equal())})`,
            backgroundColor: token2.colorBgMask,
            opacity: 0,
            transition: `all ${token2.motionDurationSlow}`,
            content: '" "'
          }
        },
        [`${itemCls}:hover`]: {
          [`&::before, ${itemCls}-actions`]: {
            opacity: 1
          }
        },
        [`${itemCls}-actions`]: {
          position: "absolute",
          insetInlineStart: 0,
          zIndex: 10,
          width: "100%",
          whiteSpace: "nowrap",
          textAlign: "center",
          opacity: 0,
          transition: `all ${token2.motionDurationSlow}`,
          [`
            ${iconCls}-eye,
            ${iconCls}-download,
            ${iconCls}-delete
          `]: {
            zIndex: 10,
            width: fontSizeLG,
            margin: `0 ${unit$1(token2.marginXXS)}`,
            fontSize: fontSizeLG,
            cursor: "pointer",
            transition: `all ${token2.motionDurationSlow}`,
            color: colorTextLightSolid,
            "&:hover": {
              color: colorTextLightSolid
            },
            svg: {
              verticalAlign: "baseline"
            }
          }
        },
        [`${itemCls}-thumbnail, ${itemCls}-thumbnail img`]: {
          position: "static",
          display: "block",
          width: "100%",
          height: "100%",
          objectFit: "contain"
        },
        [`${itemCls}-name`]: {
          display: "none",
          textAlign: "center"
        },
        [`${itemCls}-file + ${itemCls}-name`]: {
          position: "absolute",
          bottom: token2.margin,
          display: "block",
          width: `calc(100% - ${unit$1(calc(token2.paddingXS).mul(2).equal())})`
        },
        [`${itemCls}-uploading`]: {
          [`&${itemCls}`]: {
            backgroundColor: token2.colorFillAlter
          },
          [`&::before, ${iconCls}-eye, ${iconCls}-download, ${iconCls}-delete`]: {
            display: "none"
          }
        },
        [`${itemCls}-progress`]: {
          bottom: token2.marginXL,
          width: `calc(100% - ${unit$1(calc(token2.paddingXS).mul(2).equal())})`,
          paddingInlineStart: 0
        }
      }
    }),
    [`${componentCls}-wrapper${componentCls}-picture-circle-wrapper`]: {
      [`${componentCls}${componentCls}-select`]: {
        borderRadius: "50%"
      }
    }
  };
}, "genPictureCardStyle"), genRtlStyle = /* @__PURE__ */ __name((token2) => {
  const {
    componentCls
  } = token2;
  return {
    [`${componentCls}-rtl`]: {
      direction: "rtl"
    }
  };
}, "genRtlStyle"), genBaseStyle = /* @__PURE__ */ __name((token2) => {
  const {
    componentCls,
    colorTextDisabled
  } = token2;
  return {
    [`${componentCls}-wrapper`]: Object.assign(Object.assign({}, resetComponent(token2)), {
      [componentCls]: {
        outline: 0,
        "input[type='file']": {
          cursor: "pointer"
        }
      },
      [`${componentCls}-select`]: {
        display: "inline-block"
      },
      [`${componentCls}-hidden`]: {
        display: "none"
      },
      [`${componentCls}-disabled`]: {
        color: colorTextDisabled,
        cursor: "not-allowed"
      }
    })
  };
}, "genBaseStyle"), prepareComponentToken = /* @__PURE__ */ __name((token2) => ({
  actionsColor: token2.colorTextDescription
}), "prepareComponentToken"), useStyle = genStyleHooks("Upload", (token2) => {
  const {
    fontSizeHeading3,
    fontHeight,
    lineWidth,
    controlHeightLG,
    calc
  } = token2, uploadToken = merge(token2, {
    uploadThumbnailSize: calc(fontSizeHeading3).mul(2).equal(),
    uploadProgressOffset: calc(calc(fontHeight).div(2)).add(lineWidth).equal(),
    uploadPicCardSize: calc(controlHeightLG).mul(2.55).equal()
  });
  return [genBaseStyle(uploadToken), genDraggerStyle(uploadToken), genPictureStyle(uploadToken), genPictureCardStyle(uploadToken), genListStyle(uploadToken), genMotionStyle(uploadToken), genRtlStyle(uploadToken), genCollapseMotion(uploadToken)];
}, prepareComponentToken);
function file2Obj(file) {
  return Object.assign(Object.assign({}, file), {
    lastModified: file.lastModified,
    lastModifiedDate: file.lastModifiedDate,
    name: file.name,
    size: file.size,
    type: file.type,
    uid: file.uid,
    percent: 0,
    originFileObj: file
  });
}
__name(file2Obj, "file2Obj");
function updateFileList(file, fileList) {
  const nextFileList = _toConsumableArray(fileList), fileIndex = nextFileList.findIndex((_ref) => {
    let {
      uid: uid2
    } = _ref;
    return uid2 === file.uid;
  });
  return fileIndex === -1 ? nextFileList.push(file) : nextFileList[fileIndex] = file, nextFileList;
}
__name(updateFileList, "updateFileList");
function getFileItem(file, fileList) {
  const matchKey = file.uid !== void 0 ? "uid" : "name";
  return fileList.filter((item) => item[matchKey] === file[matchKey])[0];
}
__name(getFileItem, "getFileItem");
function removeFileItem(file, fileList) {
  const matchKey = file.uid !== void 0 ? "uid" : "name", removed = fileList.filter((item) => item[matchKey] !== file[matchKey]);
  return removed.length === fileList.length ? null : removed;
}
__name(removeFileItem, "removeFileItem");
const extname = /* @__PURE__ */ __name(function() {
  const temp = (arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "").split("/"), filenameWithoutSuffix = temp[temp.length - 1].split(/#|\?/)[0];
  return (/\.[^./\\]*$/.exec(filenameWithoutSuffix) || [""])[0];
}, "extname"), isImageFileType = /* @__PURE__ */ __name((type4) => type4.indexOf("image/") === 0, "isImageFileType"), isImageUrl = /* @__PURE__ */ __name((file) => {
  if (file.type && !file.thumbUrl)
    return isImageFileType(file.type);
  const url2 = file.thumbUrl || file.url || "", extension = extname(url2);
  return /^data:image\//.test(url2) || /(webp|svg|png|gif|jpg|jpeg|jfif|bmp|dpg|ico|heic|heif)$/i.test(extension) ? !0 : !(/^data:/.test(url2) || extension);
}, "isImageUrl"), MEASURE_SIZE = 200;
function previewImage(file) {
  return new Promise((resolve) => {
    if (!file.type || !isImageFileType(file.type)) {
      resolve("");
      return;
    }
    const canvas = document.createElement("canvas");
    canvas.width = MEASURE_SIZE, canvas.height = MEASURE_SIZE, canvas.style.cssText = `position: fixed; left: 0; top: 0; width: ${MEASURE_SIZE}px; height: ${MEASURE_SIZE}px; z-index: 9999; display: none;`, document.body.appendChild(canvas);
    const ctx = canvas.getContext("2d"), img = new Image();
    if (img.onload = () => {
      const {
        width,
        height
      } = img;
      let drawWidth = MEASURE_SIZE, drawHeight = MEASURE_SIZE, offsetX = 0, offsetY = 0;
      width > height ? (drawHeight = height * (MEASURE_SIZE / width), offsetY = -(drawHeight - drawWidth) / 2) : (drawWidth = width * (MEASURE_SIZE / height), offsetX = -(drawWidth - drawHeight) / 2), ctx.drawImage(img, offsetX, offsetY, drawWidth, drawHeight);
      const dataURL = canvas.toDataURL();
      document.body.removeChild(canvas), window.URL.revokeObjectURL(img.src), resolve(dataURL);
    }, img.crossOrigin = "anonymous", file.type.startsWith("image/svg+xml")) {
      const reader = new FileReader();
      reader.onload = () => {
        reader.result && typeof reader.result == "string" && (img.src = reader.result);
      }, reader.readAsDataURL(file);
    } else if (file.type.startsWith("image/gif")) {
      const reader = new FileReader();
      reader.onload = () => {
        reader.result && resolve(reader.result);
      }, reader.readAsDataURL(file);
    } else
      img.src = window.URL.createObjectURL(file);
  });
}
__name(previewImage, "previewImage");
const ListItem = /* @__PURE__ */ React.forwardRef((_ref, ref) => {
  let {
    prefixCls,
    className,
    style: style2,
    locale: locale2,
    listType,
    file,
    items,
    progress: progressProps,
    iconRender,
    actionIconRender,
    itemRender,
    isImgUrl,
    showPreviewIcon,
    showRemoveIcon,
    showDownloadIcon,
    previewIcon: customPreviewIcon,
    removeIcon: customRemoveIcon,
    downloadIcon: customDownloadIcon,
    extra: customExtra,
    onPreview,
    onDownload,
    onClose
  } = _ref;
  var _a, _b;
  const {
    status
  } = file, [mergedStatus, setMergedStatus] = React.useState(status);
  React.useEffect(() => {
    status !== "removed" && setMergedStatus(status);
  }, [status]);
  const [showProgress, setShowProgress] = React.useState(!1);
  React.useEffect(() => {
    const timer = setTimeout(() => {
      setShowProgress(!0);
    }, 300);
    return () => {
      clearTimeout(timer);
    };
  }, []);
  const iconNode = iconRender(file);
  let icon = /* @__PURE__ */ React.createElement("div", {
    className: `${prefixCls}-icon`
  }, iconNode);
  if (listType === "picture" || listType === "picture-card" || listType === "picture-circle")
    if (mergedStatus === "uploading" || !file.thumbUrl && !file.url) {
      const uploadingClassName = cn(`${prefixCls}-list-item-thumbnail`, {
        [`${prefixCls}-list-item-file`]: mergedStatus !== "uploading"
      });
      icon = /* @__PURE__ */ React.createElement("div", {
        className: uploadingClassName
      }, iconNode);
    } else {
      const thumbnail = isImgUrl != null && isImgUrl(file) ? /* @__PURE__ */ React.createElement("img", {
        src: file.thumbUrl || file.url,
        alt: file.name,
        className: `${prefixCls}-list-item-image`,
        crossOrigin: file.crossOrigin
      }) : iconNode, aClassName = cn(`${prefixCls}-list-item-thumbnail`, {
        [`${prefixCls}-list-item-file`]: isImgUrl && !isImgUrl(file)
      });
      icon = /* @__PURE__ */ React.createElement("a", {
        className: aClassName,
        onClick: /* @__PURE__ */ __name((e2) => onPreview(file, e2), "onClick"),
        href: file.url || file.thumbUrl,
        target: "_blank",
        rel: "noopener noreferrer"
      }, thumbnail);
    }
  const listItemClassName = cn(`${prefixCls}-list-item`, `${prefixCls}-list-item-${mergedStatus}`), linkProps = typeof file.linkProps == "string" ? JSON.parse(file.linkProps) : file.linkProps, removeIcon = (typeof showRemoveIcon == "function" ? showRemoveIcon(file) : showRemoveIcon) ? actionIconRender(
    (typeof customRemoveIcon == "function" ? customRemoveIcon(file) : customRemoveIcon) || /* @__PURE__ */ React.createElement(RefIcon$d, null),
    () => onClose(file),
    prefixCls,
    locale2.removeFile,
    // acceptUploadDisabled is true, only remove icon will follow Upload disabled prop
    // https://github.com/ant-design/ant-design/issues/46171
    !0
  ) : null, downloadIcon = (typeof showDownloadIcon == "function" ? showDownloadIcon(file) : showDownloadIcon) && mergedStatus === "done" ? actionIconRender((typeof customDownloadIcon == "function" ? customDownloadIcon(file) : customDownloadIcon) || /* @__PURE__ */ React.createElement(RefIcon$c, null), () => onDownload(file), prefixCls, locale2.downloadFile) : null, downloadOrDelete = listType !== "picture-card" && listType !== "picture-circle" && /* @__PURE__ */ React.createElement("span", {
    key: "download-delete",
    className: cn(`${prefixCls}-list-item-actions`, {
      picture: listType === "picture"
    })
  }, downloadIcon, removeIcon), extraContent = typeof customExtra == "function" ? customExtra(file) : customExtra, extra = extraContent && /* @__PURE__ */ React.createElement("span", {
    className: `${prefixCls}-list-item-extra`
  }, extraContent), listItemNameClass = cn(`${prefixCls}-list-item-name`), fileName = file.url ? /* @__PURE__ */ React.createElement("a", Object.assign({
    key: "view",
    target: "_blank",
    rel: "noopener noreferrer",
    className: listItemNameClass,
    title: file.name
  }, linkProps, {
    href: file.url,
    onClick: /* @__PURE__ */ __name((e2) => onPreview(file, e2), "onClick")
  }), file.name, extra) : /* @__PURE__ */ React.createElement("span", {
    key: "view",
    className: listItemNameClass,
    onClick: /* @__PURE__ */ __name((e2) => onPreview(file, e2), "onClick"),
    title: file.name
  }, file.name, extra), previewIcon = (typeof showPreviewIcon == "function" ? showPreviewIcon(file) : showPreviewIcon) && (file.url || file.thumbUrl) ? /* @__PURE__ */ React.createElement("a", {
    href: file.url || file.thumbUrl,
    target: "_blank",
    rel: "noopener noreferrer",
    onClick: /* @__PURE__ */ __name((e2) => onPreview(file, e2), "onClick"),
    title: locale2.previewFile
  }, typeof customPreviewIcon == "function" ? customPreviewIcon(file) : customPreviewIcon || /* @__PURE__ */ React.createElement(RefIcon$o, null)) : null, pictureCardActions = (listType === "picture-card" || listType === "picture-circle") && mergedStatus !== "uploading" && /* @__PURE__ */ React.createElement("span", {
    className: `${prefixCls}-list-item-actions`
  }, previewIcon, mergedStatus === "done" && downloadIcon, removeIcon), {
    getPrefixCls
  } = React.useContext(ConfigContext), rootPrefixCls = getPrefixCls(), dom = /* @__PURE__ */ React.createElement("div", {
    className: listItemClassName
  }, icon, fileName, downloadOrDelete, pictureCardActions, showProgress && /* @__PURE__ */ React.createElement(CSSMotion, {
    motionName: `${rootPrefixCls}-fade`,
    visible: mergedStatus === "uploading",
    motionDeadline: 2e3
  }, (_ref2) => {
    let {
      className: motionClassName
    } = _ref2;
    const loadingProgress = "percent" in file ? /* @__PURE__ */ React.createElement(Progress, Object.assign({}, progressProps, {
      type: "line",
      percent: file.percent,
      "aria-label": file["aria-label"],
      "aria-labelledby": file["aria-labelledby"]
    })) : null;
    return /* @__PURE__ */ React.createElement("div", {
      className: cn(`${prefixCls}-list-item-progress`, motionClassName)
    }, loadingProgress);
  })), message = file.response && typeof file.response == "string" ? file.response : ((_a = file.error) === null || _a === void 0 ? void 0 : _a.statusText) || ((_b = file.error) === null || _b === void 0 ? void 0 : _b.message) || locale2.uploadError, item = mergedStatus === "error" ? /* @__PURE__ */ React.createElement(Tooltip$1, {
    title: message,
    getPopupContainer: /* @__PURE__ */ __name((node2) => node2.parentNode, "getPopupContainer")
  }, dom) : dom;
  return /* @__PURE__ */ React.createElement("div", {
    className: cn(`${prefixCls}-list-item-container`, className),
    style: style2,
    ref
  }, itemRender ? itemRender(item, file, items, {
    download: onDownload.bind(null, file),
    preview: onPreview.bind(null, file),
    remove: onClose.bind(null, file)
  }) : item);
}), InternalUploadList = /* @__PURE__ */ __name((props, ref) => {
  const {
    listType = "text",
    previewFile = previewImage,
    onPreview,
    onDownload,
    onRemove,
    locale: locale2,
    iconRender,
    isImageUrl: isImgUrl = isImageUrl,
    prefixCls: customizePrefixCls,
    items = [],
    showPreviewIcon = !0,
    showRemoveIcon = !0,
    showDownloadIcon = !1,
    removeIcon,
    previewIcon,
    downloadIcon,
    extra,
    progress = {
      size: [-1, 2],
      showInfo: !1
    },
    appendAction,
    appendActionVisible = !0,
    itemRender,
    disabled
  } = props, forceUpdate = useForceUpdate(), [motionAppear, setMotionAppear] = React.useState(!1), isPictureCardOrCirle = ["picture-card", "picture-circle"].includes(listType);
  React.useEffect(() => {
    listType.startsWith("picture") && (items || []).forEach((file) => {
      !(file.originFileObj instanceof File || file.originFileObj instanceof Blob) || file.thumbUrl !== void 0 || (file.thumbUrl = "", previewFile == null || previewFile(file.originFileObj).then((previewDataUrl) => {
        file.thumbUrl = previewDataUrl || "", forceUpdate();
      }));
    });
  }, [listType, items, previewFile]), React.useEffect(() => {
    setMotionAppear(!0);
  }, []);
  const onInternalPreview = /* @__PURE__ */ __name((file, e2) => {
    if (onPreview)
      return e2 == null || e2.preventDefault(), onPreview(file);
  }, "onInternalPreview"), onInternalDownload = /* @__PURE__ */ __name((file) => {
    typeof onDownload == "function" ? onDownload(file) : file.url && window.open(file.url);
  }, "onInternalDownload"), onInternalClose = /* @__PURE__ */ __name((file) => {
    onRemove == null || onRemove(file);
  }, "onInternalClose"), internalIconRender = /* @__PURE__ */ __name((file) => {
    if (iconRender)
      return iconRender(file, listType);
    const isLoading = file.status === "uploading";
    if (listType.startsWith("picture")) {
      const loadingIcon = listType === "picture" ? /* @__PURE__ */ React.createElement(RefIcon$z, null) : locale2.uploading, fileIcon = isImgUrl != null && isImgUrl(file) ? /* @__PURE__ */ React.createElement(RefIcon$1, null) : /* @__PURE__ */ React.createElement(RefIcon$8, null);
      return isLoading ? loadingIcon : fileIcon;
    }
    return isLoading ? /* @__PURE__ */ React.createElement(RefIcon$z, null) : /* @__PURE__ */ React.createElement(RefIcon$2, null);
  }, "internalIconRender"), actionIconRender = /* @__PURE__ */ __name((customIcon, callback, prefixCls2, title2, acceptUploadDisabled) => {
    const btnProps = {
      type: "text",
      size: "small",
      title: title2,
      onClick: /* @__PURE__ */ __name((e2) => {
        var _a, _b;
        callback(), /* @__PURE__ */ React.isValidElement(customIcon) && ((_b = (_a = customIcon.props).onClick) === null || _b === void 0 || _b.call(_a, e2));
      }, "onClick"),
      className: `${prefixCls2}-list-item-action`
    };
    return acceptUploadDisabled && (btnProps.disabled = disabled), /* @__PURE__ */ React.isValidElement(customIcon) ? /* @__PURE__ */ React.createElement(Button$2, Object.assign({}, btnProps, {
      icon: cloneElement(customIcon, Object.assign(Object.assign({}, customIcon.props), {
        onClick: /* @__PURE__ */ __name(() => {
        }, "onClick")
      }))
    })) : /* @__PURE__ */ React.createElement(Button$2, Object.assign({}, btnProps), /* @__PURE__ */ React.createElement("span", null, customIcon));
  }, "actionIconRender");
  React.useImperativeHandle(ref, () => ({
    handlePreview: onInternalPreview,
    handleDownload: onInternalDownload
  }));
  const {
    getPrefixCls
  } = React.useContext(ConfigContext), prefixCls = getPrefixCls("upload", customizePrefixCls), rootPrefixCls = getPrefixCls(), listClassNames = cn(`${prefixCls}-list`, `${prefixCls}-list-${listType}`), listItemMotion = React.useMemo(() => omit(initCollapseMotion(rootPrefixCls), ["onAppearEnd", "onEnterEnd", "onLeaveEnd"]), [rootPrefixCls]), motionConfig = Object.assign(Object.assign({}, isPictureCardOrCirle ? {} : listItemMotion), {
    motionDeadline: 2e3,
    motionName: `${prefixCls}-${isPictureCardOrCirle ? "animate-inline" : "animate"}`,
    keys: _toConsumableArray(items.map((file) => ({
      key: file.uid,
      file
    }))),
    motionAppear
  });
  return /* @__PURE__ */ React.createElement("div", {
    className: listClassNames
  }, /* @__PURE__ */ React.createElement(CSSMotionList, Object.assign({}, motionConfig, {
    component: !1
  }), (_ref) => {
    let {
      key,
      file,
      className: motionClassName,
      style: motionStyle
    } = _ref;
    return /* @__PURE__ */ React.createElement(ListItem, {
      key,
      locale: locale2,
      prefixCls,
      className: motionClassName,
      style: motionStyle,
      file,
      items,
      progress,
      listType,
      isImgUrl,
      showPreviewIcon,
      showRemoveIcon,
      showDownloadIcon,
      removeIcon,
      previewIcon,
      downloadIcon,
      extra,
      iconRender: internalIconRender,
      actionIconRender,
      itemRender,
      onPreview: onInternalPreview,
      onDownload: onInternalDownload,
      onClose: onInternalClose
    });
  }), appendAction && /* @__PURE__ */ React.createElement(CSSMotion, Object.assign({}, motionConfig, {
    visible: appendActionVisible,
    forceRender: !0
  }), (_ref2) => {
    let {
      className: motionClassName,
      style: motionStyle
    } = _ref2;
    return cloneElement(appendAction, (oriProps) => ({
      className: cn(oriProps.className, motionClassName),
      style: Object.assign(Object.assign(Object.assign({}, motionStyle), {
        // prevent the element has hover css pseudo-class that may cause animation to end prematurely.
        pointerEvents: motionClassName ? "none" : void 0
      }), oriProps.style)
    }));
  }));
}, "InternalUploadList"), UploadList = /* @__PURE__ */ React.forwardRef(InternalUploadList);
process.env.NODE_ENV !== "production" && (UploadList.displayName = "UploadList");
var __awaiter = function(thisArg, _arguments, P, generator2) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return __name(adopt, "adopt"), new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator2.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    __name(fulfilled, "fulfilled");
    function rejected(value) {
      try {
        step(generator2.throw(value));
      } catch (e2) {
        reject(e2);
      }
    }
    __name(rejected, "rejected");
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    __name(step, "step"), step((generator2 = generator2.apply(thisArg, _arguments || [])).next());
  });
};
const LIST_IGNORE = `__LIST_IGNORE_${Date.now()}__`, InternalUpload = /* @__PURE__ */ __name((props, ref) => {
  const {
    fileList,
    defaultFileList,
    onRemove,
    showUploadList = !0,
    listType = "text",
    onPreview,
    onDownload,
    onChange,
    onDrop,
    previewFile,
    disabled: customDisabled,
    locale: propLocale,
    iconRender,
    isImageUrl: isImageUrl2,
    progress,
    prefixCls: customizePrefixCls,
    className,
    type: type4 = "select",
    children,
    style: style2,
    itemRender,
    maxCount,
    data = {},
    multiple = !1,
    hasControlInside = !0,
    action = "",
    accept = "",
    supportServerRender = !0,
    rootClassName
  } = props, disabled = React.useContext(DisabledContext), mergedDisabled = customDisabled ?? disabled, [mergedFileList, setMergedFileList] = useMergedState(defaultFileList || [], {
    value: fileList,
    postState: /* @__PURE__ */ __name((list) => list ?? [], "postState")
  }), [dragState, setDragState] = React.useState("drop"), upload2 = React.useRef(null), wrapRef = React.useRef(null);
  if (process.env.NODE_ENV !== "production") {
    const warning3 = devUseWarning("Upload");
    process.env.NODE_ENV !== "production" && warning3("fileList" in props || !("value" in props), "usage", "`value` is not a valid prop, do you mean `fileList`?"), warning3.deprecated(!("transformFile" in props), "transformFile", "beforeUpload");
  }
  React.useMemo(() => {
    const timestamp = Date.now();
    (fileList || []).forEach((file, index2) => {
      !file.uid && !Object.isFrozen(file) && (file.uid = `__AUTO__${timestamp}_${index2}__`);
    });
  }, [fileList]);
  const onInternalChange = /* @__PURE__ */ __name((file, changedFileList, event) => {
    let cloneList = _toConsumableArray(changedFileList), exceedMaxCount = !1;
    maxCount === 1 ? cloneList = cloneList.slice(-1) : maxCount && (exceedMaxCount = cloneList.length > maxCount, cloneList = cloneList.slice(0, maxCount)), flushSync(() => {
      setMergedFileList(cloneList);
    });
    const changeInfo = {
      file,
      fileList: cloneList
    };
    event && (changeInfo.event = event), (!exceedMaxCount || file.status === "removed" || // We should ignore event if current file is exceed `maxCount`
    cloneList.some((f) => f.uid === file.uid)) && flushSync(() => {
      onChange == null || onChange(changeInfo);
    });
  }, "onInternalChange"), mergedBeforeUpload = /* @__PURE__ */ __name((file, fileListArgs) => __awaiter(void 0, void 0, void 0, function* () {
    const {
      beforeUpload,
      transformFile
    } = props;
    let parsedFile = file;
    if (beforeUpload) {
      const result = yield beforeUpload(file, fileListArgs);
      if (result === !1)
        return !1;
      if (delete file[LIST_IGNORE], result === LIST_IGNORE)
        return Object.defineProperty(file, LIST_IGNORE, {
          value: !0,
          configurable: !0
        }), !1;
      typeof result == "object" && result && (parsedFile = result);
    }
    return transformFile && (parsedFile = yield transformFile(parsedFile)), parsedFile;
  }), "mergedBeforeUpload"), onBatchStart = /* @__PURE__ */ __name((batchFileInfoList) => {
    const filteredFileInfoList = batchFileInfoList.filter((info) => !info.file[LIST_IGNORE]);
    if (!filteredFileInfoList.length)
      return;
    const objectFileList = filteredFileInfoList.map((info) => file2Obj(info.file));
    let newFileList = _toConsumableArray(mergedFileList);
    objectFileList.forEach((fileObj) => {
      newFileList = updateFileList(fileObj, newFileList);
    }), objectFileList.forEach((fileObj, index2) => {
      let triggerFileObj = fileObj;
      if (filteredFileInfoList[index2].parsedFile)
        fileObj.status = "uploading";
      else {
        const {
          originFileObj
        } = fileObj;
        let clone;
        try {
          clone = new File([originFileObj], originFileObj.name, {
            type: originFileObj.type
          });
        } catch {
          clone = new Blob([originFileObj], {
            type: originFileObj.type
          }), clone.name = originFileObj.name, clone.lastModifiedDate = /* @__PURE__ */ new Date(), clone.lastModified = (/* @__PURE__ */ new Date()).getTime();
        }
        clone.uid = fileObj.uid, triggerFileObj = clone;
      }
      onInternalChange(triggerFileObj, newFileList);
    });
  }, "onBatchStart"), onSuccess = /* @__PURE__ */ __name((response, file, xhr) => {
    try {
      typeof response == "string" && (response = JSON.parse(response));
    } catch {
    }
    if (!getFileItem(file, mergedFileList))
      return;
    const targetItem = file2Obj(file);
    targetItem.status = "done", targetItem.percent = 100, targetItem.response = response, targetItem.xhr = xhr;
    const nextFileList = updateFileList(targetItem, mergedFileList);
    onInternalChange(targetItem, nextFileList);
  }, "onSuccess"), onProgress = /* @__PURE__ */ __name((e2, file) => {
    if (!getFileItem(file, mergedFileList))
      return;
    const targetItem = file2Obj(file);
    targetItem.status = "uploading", targetItem.percent = e2.percent;
    const nextFileList = updateFileList(targetItem, mergedFileList);
    onInternalChange(targetItem, nextFileList, e2);
  }, "onProgress"), onError = /* @__PURE__ */ __name((error, response, file) => {
    if (!getFileItem(file, mergedFileList))
      return;
    const targetItem = file2Obj(file);
    targetItem.error = error, targetItem.response = response, targetItem.status = "error";
    const nextFileList = updateFileList(targetItem, mergedFileList);
    onInternalChange(targetItem, nextFileList);
  }, "onError"), handleRemove = /* @__PURE__ */ __name((file) => {
    let currentFile;
    Promise.resolve(typeof onRemove == "function" ? onRemove(file) : onRemove).then((ret) => {
      var _a;
      if (ret === !1)
        return;
      const removedFileList = removeFileItem(file, mergedFileList);
      removedFileList && (currentFile = Object.assign(Object.assign({}, file), {
        status: "removed"
      }), mergedFileList == null || mergedFileList.forEach((item) => {
        const matchKey = currentFile.uid !== void 0 ? "uid" : "name";
        item[matchKey] === currentFile[matchKey] && !Object.isFrozen(item) && (item.status = "removed");
      }), (_a = upload2.current) === null || _a === void 0 || _a.abort(currentFile), onInternalChange(currentFile, removedFileList));
    });
  }, "handleRemove"), onFileDrop = /* @__PURE__ */ __name((e2) => {
    setDragState(e2.type), e2.type === "drop" && (onDrop == null || onDrop(e2));
  }, "onFileDrop");
  React.useImperativeHandle(ref, () => ({
    onBatchStart,
    onSuccess,
    onProgress,
    onError,
    fileList: mergedFileList,
    upload: upload2.current,
    nativeElement: wrapRef.current
  }));
  const {
    getPrefixCls,
    direction,
    upload: ctxUpload
  } = React.useContext(ConfigContext), prefixCls = getPrefixCls("upload", customizePrefixCls), rcUploadProps = Object.assign(Object.assign({
    onBatchStart,
    onError,
    onProgress,
    onSuccess
  }, props), {
    data,
    multiple,
    action,
    accept,
    supportServerRender,
    prefixCls,
    disabled: mergedDisabled,
    beforeUpload: mergedBeforeUpload,
    onChange: void 0,
    hasControlInside
  });
  delete rcUploadProps.className, delete rcUploadProps.style, (!children || mergedDisabled) && delete rcUploadProps.id;
  const wrapperCls = `${prefixCls}-wrapper`, [wrapCSSVar, hashId, cssVarCls] = useStyle(prefixCls, wrapperCls), [contextLocale] = useLocale$1("Upload", localeValues$1.Upload), {
    showRemoveIcon,
    showPreviewIcon,
    showDownloadIcon,
    removeIcon,
    previewIcon,
    downloadIcon,
    extra
  } = typeof showUploadList == "boolean" ? {} : showUploadList, realShowRemoveIcon = typeof showRemoveIcon > "u" ? !mergedDisabled : showRemoveIcon, renderUploadList = /* @__PURE__ */ __name((button2, buttonVisible) => showUploadList ? /* @__PURE__ */ React.createElement(UploadList, {
    prefixCls,
    listType,
    items: mergedFileList,
    previewFile,
    onPreview,
    onDownload,
    onRemove: handleRemove,
    showRemoveIcon: realShowRemoveIcon,
    showPreviewIcon,
    showDownloadIcon,
    removeIcon,
    previewIcon,
    downloadIcon,
    iconRender,
    extra,
    locale: Object.assign(Object.assign({}, contextLocale), propLocale),
    isImageUrl: isImageUrl2,
    progress,
    appendAction: button2,
    appendActionVisible: buttonVisible,
    itemRender,
    disabled: mergedDisabled
  }) : button2, "renderUploadList"), mergedCls = cn(wrapperCls, className, rootClassName, hashId, cssVarCls, ctxUpload == null ? void 0 : ctxUpload.className, {
    [`${prefixCls}-rtl`]: direction === "rtl",
    [`${prefixCls}-picture-card-wrapper`]: listType === "picture-card",
    [`${prefixCls}-picture-circle-wrapper`]: listType === "picture-circle"
  }), mergedStyle = Object.assign(Object.assign({}, ctxUpload == null ? void 0 : ctxUpload.style), style2);
  if (type4 === "drag") {
    const dragCls = cn(hashId, prefixCls, `${prefixCls}-drag`, {
      [`${prefixCls}-drag-uploading`]: mergedFileList.some((file) => file.status === "uploading"),
      [`${prefixCls}-drag-hover`]: dragState === "dragover",
      [`${prefixCls}-disabled`]: mergedDisabled,
      [`${prefixCls}-rtl`]: direction === "rtl"
    });
    return wrapCSSVar(/* @__PURE__ */ React.createElement("span", {
      className: mergedCls,
      ref: wrapRef
    }, /* @__PURE__ */ React.createElement("div", {
      className: dragCls,
      style: mergedStyle,
      onDrop: onFileDrop,
      onDragOver: onFileDrop,
      onDragLeave: onFileDrop
    }, /* @__PURE__ */ React.createElement(Upload$2, Object.assign({}, rcUploadProps, {
      ref: upload2,
      className: `${prefixCls}-btn`
    }), /* @__PURE__ */ React.createElement("div", {
      className: `${prefixCls}-drag-container`
    }, children))), renderUploadList()));
  }
  const uploadBtnCls = cn(prefixCls, `${prefixCls}-select`, {
    [`${prefixCls}-disabled`]: mergedDisabled,
    [`${prefixCls}-hidden`]: !children
  }), uploadButton = /* @__PURE__ */ React.createElement("div", {
    className: uploadBtnCls
  }, /* @__PURE__ */ React.createElement(Upload$2, Object.assign({}, rcUploadProps, {
    ref: upload2
  })));
  return wrapCSSVar(listType === "picture-card" || listType === "picture-circle" ? /* @__PURE__ */ React.createElement("span", {
    className: mergedCls,
    ref: wrapRef
  }, renderUploadList(uploadButton, !!children)) : /* @__PURE__ */ React.createElement("span", {
    className: mergedCls,
    ref: wrapRef
  }, uploadButton, renderUploadList()));
}, "InternalUpload"), Upload$1 = /* @__PURE__ */ React.forwardRef(InternalUpload);
process.env.NODE_ENV !== "production" && (Upload$1.displayName = "Upload");
var __rest = function(s, e2) {
  var t2 = {};
  for (var p in s) Object.prototype.hasOwnProperty.call(s, p) && e2.indexOf(p) < 0 && (t2[p] = s[p]);
  if (s != null && typeof Object.getOwnPropertySymbols == "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++)
    e2.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]) && (t2[p[i]] = s[p[i]]);
  return t2;
};
const Dragger = /* @__PURE__ */ React.forwardRef((_a, ref) => {
  var {
    style: style2,
    height,
    hasControlInside = !1
  } = _a, restProps = __rest(_a, ["style", "height", "hasControlInside"]);
  return /* @__PURE__ */ React.createElement(Upload$1, Object.assign({
    ref,
    hasControlInside
  }, restProps, {
    type: "drag",
    style: Object.assign(Object.assign({}, style2), {
      height
    })
  }));
});
process.env.NODE_ENV !== "production" && (Dragger.displayName = "Dragger");
const Upload = Upload$1;
Upload.Dragger = Dragger;
Upload.LIST_IGNORE = LIST_IGNORE;
const $schema = "../../../theme.schema.json", algorithm = "light", id = "axenix-ui-default-theme", token = {
  scrollThumbColor: "rgba(0, 0, 0, 0.2)",
  scrollThumbColorHover: "rgba(0, 0, 0, 0.3)",
  scrollThumbColorActive: "rgba(0, 0, 0, 0.4)",
  scrollThumbPadding: 2,
  orange: "#F37022",
  borderRadius: 6,
  borderRadiusLG: 8,
  borderRadiusSM: 4,
  borderRadiusXS: 2,
  colorBgBase: "#ffffff",
  colorBgContainer: "#ffffff",
  colorBgContainerDisabled: "#ffffff",
  colorBgElevated: "#ffffff",
  colorBgLayout: "#ffffff",
  colorBgMask: "rgba(0, 0, 0, 0.45)",
  colorBgSpotlight: "rgba(0, 0, 0, 0.85)",
  colorBgTextActive: "rgba(0, 0, 0, 0.15)",
  colorBgTextHover: "rgba(0, 0, 0, 0.06)",
  colorBorder: "#d9d9d9",
  colorBorderBg: "#ffffff",
  colorBorderSecondary: "#f0f0f0",
  colorError: "#ff4d4f",
  colorErrorActive: "#d9363e",
  colorErrorBg: "#fff2f0",
  colorErrorBgHover: "#fff1f0",
  colorErrorBorder: "#ffccc7",
  colorErrorBorderHover: "#ffa39e",
  colorErrorHover: "#ff7875",
  colorErrorOutline: "rgba(255, 38, 6, 0.06)",
  colorErrorText: "#ff4d4f",
  colorErrorTextActive: "#d9363e",
  colorErrorTextHover: "#ff7875",
  colorFill: "rgba(0, 0, 0, 0.15)",
  colorFillAlter: "rgba(0, 0, 0, 0.02)",
  colorFillAlterSolid: "#fafafa",
  colorFillContent: "rgba(0, 0, 0, 0.06)",
  colorFillContentHover: "rgba(0, 0, 0, 0.15)",
  colorFillQuaternary: "rgba(0, 0, 0, 0.02)",
  colorFillSecondary: "rgba(0, 0, 0, 0.06)",
  colorFillTertiary: "rgba(0, 0, 0, 0.04)",
  colorIcon: "rgba(0, 0, 0, 0.65)",
  colorIconDisabled: "rgba(0, 0, 0, 0.25)",
  colorIconHover: "rgba(0, 0, 0, 0.88)",
  colorInfo: "#f37022",
  colorInfoActive: "#cc5012",
  colorInfoBg: "#fff8f0",
  colorInfoBgHover: "#ffe3c7",
  colorInfoBorder: "#ffcb9e",
  colorInfoBorderHover: "#ffb175",
  colorInfoHover: "#ff944d",
  colorInfoText: "#f37022",
  colorInfoTextActive: "#cc5012",
  colorInfoTextHover: "#ff944d",
  colorLink: "#f37022",
  colorLinkActive: "#cc5012",
  colorLinkHover: "#ff944d",
  colorPrimary: "#f37022",
  colorPrimaryActive: "#cc5012",
  colorPrimaryBg: "#fff8f0",
  colorPrimaryBgHover: "#ffe3c7",
  colorPrimaryBorder: "#ffcb9e",
  colorPrimaryBorderHover: "#ffb175",
  colorPrimaryHover: "#ff944d",
  colorPrimaryText: "#f37022",
  colorPrimaryTextActive: "#cc5012",
  colorPrimaryTextHover: "#ff944d",
  colorSplit: "rgba(0, 0, 0, 0.06)",
  colorSuccess: "#52c41a",
  colorSuccessActive: "#389e0d",
  colorSuccessBg: "#f6ffed",
  colorSuccessBgHover: "#d9f7be",
  colorSuccessBorder: "#b7eb8f",
  colorSuccessBorderHover: "#95de64",
  colorSuccessHover: "#95de64",
  colorSuccessText: "#52c41a",
  colorSuccessTextActive: "#389e0d",
  colorSuccessTextHover: "#73d13d",
  colorText: "rgba(0, 0, 0, 0.88)",
  colorTextBase: "#000000",
  colorTextDescription: "rgba(0, 0, 0, 0.45)",
  colorTextDisabled: "rgba(0, 0, 0, 0.25)",
  colorTextHeading: "rgba(0, 0, 0, 0.88)",
  colorTextLabel: "rgba(0, 0, 0, 0.65)",
  colorTextLightSolid: "#ffffff",
  colorTextPlaceholder: "rgba(0, 0, 0, 0.45)",
  colorTextQuaternary: "rgba(0, 0, 0, 0.25)",
  colorTextSecondary: "rgba(0, 0, 0, 0.65)",
  colorTextTertiary: "rgba(0, 0, 0, 0.45)",
  colorWarning: "#faad14",
  colorWarningActive: "#d48806",
  colorWarningBg: "#fffbe6",
  colorWarningBgHover: "#fff1b8",
  colorWarningBorder: "#ffe58f",
  colorWarningBorderHover: "#ffd666",
  colorWarningHover: "#ffd666",
  colorWarningOutline: "rgba(255, 215, 5, 0.1)",
  colorWarningText: "#faad14",
  colorWarningTextActive: "#d48806",
  colorWarningTextHover: "#ffc53d",
  colorWhite: "#ffffff",
  controlHeight: 32,
  controlHeightLG: 40,
  controlHeightSM: 24,
  controlHeightXS: 16,
  controlInteractiveSize: 16,
  controlItemBgActive: "#fff8f0",
  controlItemBgActiveDisabled: "rgba(0, 0, 0, 0.15)",
  controlItemBgActiveHover: "#ffe3c7",
  controlItemBgHover: "rgba(0, 0, 0, 0.04)",
  controlOutline: "rgba(243, 112, 34, 0.1)",
  controlOutlineWidth: 2,
  controlPaddingHorizontal: 12,
  controlPaddingHorizontalSM: 8,
  controlTmpOutline: "rgba(0, 0, 0, 0.02)",
  fontFamily: "Inter",
  fontFamilyCode: "Courier Prime",
  fontSize: 14,
  fontSizeHeading1: 38,
  fontSizeHeading2: 30,
  fontSizeHeading3: 24,
  fontSizeHeading4: 20,
  fontSizeHeading5: 16,
  fontSizeIcon: 12,
  fontSizeLG: 16,
  fontSizeSM: 12,
  fontSizeXL: 20,
  fontWeightNormal: "400",
  fontWeightStrong: 600,
  lineHeight: 1.5714285714285714,
  lineHeightHeading5: 1.5,
  lineHeightHeading4: 1.4,
  lineHeightHeading3: 1.3333333333333333,
  lineHeightHeading2: 1.2666666666666666,
  lineHeightHeading1: 1.2105263157894737,
  lineHeightLG: 1.5,
  lineHeightSM: 20,
  lineWidth: 1,
  lineWidthBold: 2,
  lineWidthFocus: 4,
  margin: 16,
  marginLG: 24,
  marginMD: 20,
  marginSM: 12,
  marginXL: 32,
  marginXS: 8,
  marginXXL: 48,
  marginXXS: 4,
  padding: 16,
  paddingContentHorizontal: 16,
  paddingContentHorizontalLG: 24,
  paddingContentHorizontalSM: 16,
  paddingContentVertical: 12,
  paddingContentVerticalLG: 16,
  paddingContentVerticalSM: 8,
  paddingLG: 24,
  paddingMD: 20,
  paddingSM: 12,
  paddingXL: 32,
  paddingXS: 8,
  paddingXXS: 4,
  screenLG: 992,
  screenLGMax: 1199,
  screenLGMin: 992,
  screenMD: 768,
  screenMDMax: 991,
  screenMDMin: 768,
  screenSM: 576,
  screenSMMax: 767,
  screenSMMin: 576,
  screenXL: 1200,
  screenXLMax: 1599,
  screenXLMin: 1200,
  screenXS: 480,
  screenXSMax: 575,
  screenXSMin: 480,
  screenXXL: 1600,
  screenXXLMin: 1600,
  size: 16,
  sizeLG: 24,
  sizeMD: 20,
  sizeMS: 16,
  sizePopupArrow: 16,
  sizeSM: 12,
  sizeStep: 4,
  sizeUnit: 4,
  sizeXL: 32,
  sizeXS: 8,
  sizeXXL: 48,
  sizeXXS: 4,
  tableMinWidth: 1,
  transparent: "rgba(0, 0, 0, 0)"
}, components = {
  Input: {
    paddingInlineSM: 7,
    paddingInlineLG: 11,
    paddingInline: 11,
    paddingBlockSM: 0,
    paddingBlockLG: 7,
    paddingBlock: 4,
    paddingXXS: 4,
    paddingXS: 8,
    paddingSM: 12,
    paddingLG: 24,
    lineWidth: 1,
    lineHeightLG: 1.4,
    lineHeight: 1.5714285714285714,
    fontSizeLG: 16,
    fontSizeIcon: 12,
    fontSize: 14,
    controlPaddingHorizontalSM: 8,
    controlPaddingHorizontal: 12,
    controlOutlineWidth: 2,
    controlOutline: "rgba(243, 112, 34, 0.1)",
    controlHeightSM: 24,
    controlHeightLG: 40,
    controlHeight: 32,
    borderRadiusSM: 4,
    borderRadiusLG: 8,
    borderRadius: 6,
    colorWarningOutline: "rgba(255, 215, 5, 0.1)",
    colorWarningBorderHover: "#ffd666",
    colorWarning: "#faad14",
    colorTextTertiary: "rgba(0, 0, 0, 0.45)",
    colorTextQuaternary: "rgba(0, 0, 0, 0.25)",
    colorTextPlaceholder: "rgba(0, 0, 0, 0.25)",
    colorTextDisabled: "rgba(0, 0, 0, 0.25)",
    colorTextDescription: "rgba(0, 0, 0, 0.45)",
    colorText: "rgba(0, 0, 0, 0.88)",
    colorPrimary: "#f37022",
    colorIconHover: "rgba(0, 0, 0, 0.88)",
    colorIcon: "rgba(0, 0, 0, 0.45)",
    colorFillAlter: "rgba(0, 0, 0, 0.02)",
    colorErrorOutline: "rgba(255, 38, 6, 0.06)",
    colorErrorBorderHover: "#ffa39e",
    colorError: "#ff4d4f",
    colorBorder: "#d9d9d9",
    colorBgContainerDisabled: "rgba(0, 0, 0, 0.04)",
    colorBgContainer: "#ffffff",
    hoverBorderColor: "#ff944d",
    addonBg: "rgba(0, 0, 0, 0.02)",
    activeBorderColor: "#f37022",
    colorFillTertiary: "rgba(0, 0, 0, 0.04)",
    colorFillSecondary: "rgba(0, 0, 0, 0.06)",
    colorErrorBgHover: "#fff1f0",
    colorErrorBg: "#fff2f0",
    colorWarningBg: "#fffbe6",
    colorWarningBgHover: "#fff1b8",
    colorWarningText: "#faad14",
    colorErrorText: "#ff4d4f",
    activeBg: "#ffffff",
    hoverBg: "#ffffff",
    inputFontSize: 14,
    inputFontSizeLG: 16,
    inputFontSizeSM: 12,
    fontFamily: "Inter",
    labelFontSize: "14",
    labelColor: "#a6a6a6",
    labelLineHeight: 1.2,
    labelHeight: 10
  },
  Transfer: {
    headerHeight: 48,
    headerPaddingVertical: 16,
    headerPaddingHorizontal: 16,
    headerFontSize: 16,
    headerBg: "#fafafa",
    headerBorderColor: "#d9d9d9",
    panelBorderRadius: 6,
    panelBorderColor: "#d9d9d9",
    panelLeftMaxWidth: "550px",
    panelRightMaxWidth: "100%",
    maxHeight: 800
  },
  Segmented: {
    segmentedBgColorSelected: "#ffffff",
    paddingXXS: 4,
    marginSM: 12,
    lineWidthBold: 2,
    lineWidth: 1,
    lineHeight: 1.2,
    fontSizeLG: 16,
    fontSize: 14,
    controlPaddingHorizontalSM: 8,
    controlPaddingHorizontal: 12,
    controlHeightSM: 24,
    controlHeightLG: 40,
    controlHeight: 32,
    borderRadiusXS: 2,
    borderRadiusSM: 4,
    borderRadiusLG: 8,
    borderRadius: 6,
    colorTextLabel: "rgba(0, 0, 0, 0.65)",
    colorTextDisabled: "rgba(0, 0, 0, 0.25)",
    colorText: "rgba(0, 0, 0, 0.88)",
    colorFillSecondary: "rgba(0, 0, 0, 0.06)",
    colorFill: "rgba(0, 0, 0, 0.15)",
    colorBgLayout: "#f5f5f5",
    colorBgElevated: "#ffffff",
    segmentedGroupBg: "rgba(0, 0, 0, 0.04)",
    itemSelectedColor: "rgba(0, 0, 0, 0.88)",
    itemSelectedBg: "#ffffff",
    itemHoverColor: "rgba(0, 0, 0, 0.88)",
    itemHoverBg: "rgba(0, 0, 0, 0.06)",
    itemColor: "rgba(0, 0, 0, 0.65)",
    itemActiveBg: "rgba(0, 0, 0, 0.15)",
    trackPadding: 2,
    trackBg: "#f5f5f5",
    fontFamily: "Inter"
  },
  Switch: {
    trackPadding: 2,
    trackMinWidthSM: 28,
    trackMinWidth: 44,
    trackHeightSM: 16,
    trackHeight: 22,
    handleSizeSM: 12,
    handleSize: 18,
    marginXXS: 4,
    lineWidthFocus: 4,
    lineHeight: 1.2,
    fontSizeSM: 12,
    fontSizeIcon: 12,
    fontSize: 14,
    controlHeight: 32,
    colorWhite: "#ffffff",
    colorTextTertiary: "rgba(0, 0, 0, 0.45)",
    colorTextQuaternary: "rgba(0, 0, 0, 0.25)",
    colorTextLightSolid: "#ffffff",
    colorText: "rgba(0, 0, 0, 0.88)",
    colorPrimaryHover: "#ff944d",
    colorPrimaryBorder: "#ffcb9e",
    colorPrimary: "#f37022",
    handleBg: "#ffffff",
    fontFamily: "Inter"
  },
  TimePicker: {
    timeColumnWidth: 56,
    timeColumnHeight: 224,
    timeCellHeight: 28,
    borderRadiusSM: 4,
    borderRadiusLG: 8,
    sizePopupArrow: 16,
    paddingXXS: 4,
    paddingXS: 8,
    paddingSM: 12,
    padding: 16,
    marginXXS: 4,
    marginXS: 8,
    lineWidthBold: 2,
    lineWidth: 1,
    lineHeightLG: 1.4,
    lineHeight: 1.5714285714285714,
    fontWeightStrong: 600,
    fontSizeLG: 16,
    fontSize: 14,
    controlPaddingHorizontalSM: 8,
    controlPaddingHorizontal: 12,
    controlOutlineWidth: 2,
    controlOutline: "rgba(243, 112, 34, 0.1)",
    controlItemBgHover: "rgba(0, 0, 0, 0.04)",
    controlItemBgActive: "#fff8f0",
    controlHeightSM: 24,
    controlHeightLG: 40,
    controlHeight: 32,
    borderRadiusXS: 2,
    borderRadius: 6,
    colorWarningOutline: "rgba(255, 215, 5, 0.1)",
    colorWarning: "#faad14",
    colorTextQuaternary: "rgba(0, 0, 0, 0.25)",
    colorTextPlaceholder: "rgba(0, 0, 0, 0.25)",
    colorTextLightSolid: "#ffffff",
    colorTextHeading: "rgba(0, 0, 0, 0.88)",
    colorTextDisabled: "rgba(0, 0, 0, 0.25)",
    colorTextDescription: "rgba(0, 0, 0, 0.45)",
    colorText: "rgba(0, 0, 0, 0.88)",
    colorSplit: "rgba(0, 0, 0, 0.06)",
    colorPrimaryHover: "#ff944d",
    colorPrimaryBorder: "#ffcb9e",
    colorPrimary: "#f37022",
    colorLinkHover: "#ff944d",
    colorLinkActive: "#cc5012",
    colorLink: "#f37022",
    colorIconHover: "rgba(0, 0, 0, 0.88)",
    colorIcon: "rgba(0, 0, 0, 0.45)",
    colorFillAlter: "rgba(0, 0, 0, 0.02)",
    colorErrorOutline: "rgba(255, 38, 6, 0.06)",
    colorError: "#ff4d4f",
    colorBorder: "#d9d9d9",
    colorBgElevated: "#ffffff",
    colorBgContainerDisabled: "rgba(0, 0, 0, 0.04)",
    colorBgContainer: "#ffffff",
    hoverBorderColor: "#ff944d",
    cellHoverBg: "rgba(0, 0, 0, 0.04)",
    cellHeight: 24,
    activeBorderColor: "#f37022",
    paddingInline: 11,
    paddingInlineLG: 11,
    paddingInlineSM: 7,
    activeBg: "#ffffff",
    hoverBg: "#ffffff",
    cellBgDisabled: "rgba(0, 0, 0, 0.04)",
    cellActiveWithRangeBg: "#fff8f0",
    cellHoverWithRangeBg: "#c8dfff",
    cellRangeBorderColor: "#7cb3ff",
    multipleItemBg: "rgba(0, 0, 0, 0.06)",
    multipleItemBorderColor: "rgba(0, 0, 0, 0)",
    multipleItemBorderColorDisabled: "rgba(0, 0, 0, 0)",
    multipleItemColorDisabled: "rgba(0, 0, 0, 0.25)",
    multipleSelectorBgDisabled: "rgba(0, 0, 0, 0.04)",
    cellWidth: 36,
    multipleItemHeight: 24,
    multipleItemHeightLG: 32,
    multipleItemHeightSM: 16,
    paddingBlock: 4,
    paddingBlockLG: 7,
    paddingBlockSM: 0,
    presetsMaxWidth: 200,
    presetsWidth: 120,
    textHeight: 40,
    withoutTimeCellHeight: 66,
    inputFontSize: 14,
    inputFontSizeLG: 16,
    inputFontSizeSM: 12,
    fontFamily: "Inter"
  },
  Timeline: {
    itemPaddingBottom: 20,
    paddingXXS: 4,
    padding: 16,
    marginXXS: 4,
    marginXS: 8,
    marginSM: 12,
    margin: 16,
    lineWidthBold: 2,
    lineWidth: 1,
    lineHeight: 1.2,
    fontSizeSM: 12,
    fontSize: 14,
    controlHeightLG: 40,
    colorTextDisabled: "rgba(0, 0, 0, 0.25)",
    colorText: "rgba(0, 0, 0, 0.88)",
    colorSuccess: "#52c41a",
    colorPrimary: "#f37022",
    colorError: "#ff4d4f",
    colorBgContainer: "#ffffff",
    tailColor: "rgba(0, 0, 0, 0.06)",
    dotBg: "#ffffff",
    fontFamily: "Inter"
  },
  Tabs: {
    horizontalItemGutter: 32,
    cardGutter: 2,
    paddingXXS: 4,
    paddingXS: 8,
    paddingSM: 12,
    paddingLG: 24,
    padding: 16,
    marginXXS: 4,
    marginXS: 8,
    marginSM: 12,
    margin: 16,
    lineWidthFocus: 4,
    lineWidthBold: 2,
    lineWidth: 1,
    lineHeight: 1.2,
    fontSizeSM: 12,
    fontSizeLG: 16,
    fontSize: 14,
    controlItemBgHover: "rgba(0, 0, 0, 0.04)",
    controlHeightLG: 40,
    controlHeight: 32,
    borderRadiusLG: 8,
    borderRadius: 6,
    colorTextHeading: "rgba(0, 0, 0, 0.88)",
    colorTextDisabled: "rgba(0, 0, 0, 0.25)",
    colorTextDescription: "rgba(0, 0, 0, 0.45)",
    colorText: "rgba(0, 0, 0, 0.88)",
    colorPrimaryHover: "#ff944d",
    colorPrimaryBorder: "#ffcb9e",
    colorPrimaryActive: "#cc5012",
    colorPrimary: "#f37022",
    colorFillAlter: "rgba(0, 0, 0, 0.02)",
    colorBorderSecondary: "#f0f0f0",
    colorBorder: "#d9d9d9",
    colorBgContainer: "#ffffff",
    itemSelectedColor: "#f37022",
    itemHoverColor: "#ff944d",
    itemColor: "rgba(0, 0, 0, 0.88)",
    itemActiveColor: "#cc5012",
    inkBarColor: "#f37022",
    cardHeight: 40,
    cardBg: "rgba(0, 0, 0, 0.02)",
    titleFontSize: 14,
    titleFontSizeLG: 16,
    titleFontSizeSM: 14,
    fontFamily: "Inter",
    iconSize: 14,
    iconSizeSM: 14,
    iconSizeLG: 16
  },
  Table: {
    stickyScrollBarBorderRadius: 100,
    headerSplitColor: "#f0f0f0",
    headerBg: "#fafafa",
    footerBg: "#fafafa",
    paddingXXS: 4,
    paddingXS: 8,
    paddingSM: 12,
    padding: 16,
    marginXXS: 4,
    margin: 16,
    lineWidth: 1,
    lineHeight: 1.2,
    fontWeightStrong: 600,
    fontSizeSM: 12,
    fontSizeIcon: 12,
    fontSize: 14,
    controlItemBgHover: "rgba(0, 0, 0, 0.04)",
    controlItemBgActiveHover: "#ffe3c7",
    controlItemBgActive: "#fff8f0",
    controlInteractiveSize: 16,
    controlHeight: 32,
    borderRadiusLG: 8,
    borderRadius: 6,
    colorTextPlaceholder: "rgba(0, 0, 0, 0.25)",
    colorTextHeading: "rgba(0, 0, 0, 0.88)",
    colorTextDisabled: "rgba(0, 0, 0, 0.25)",
    colorTextDescription: "rgba(0, 0, 0, 0.45)",
    colorText: "rgba(0, 0, 0, 0.88)",
    colorSplit: "rgba(0, 0, 0, 0.06)",
    colorPrimary: "#f37022",
    colorLinkHover: "#ff944d",
    colorLinkActive: "#cc5012",
    colorLink: "#f37022",
    colorIconHover: "rgba(0, 0, 0, 0.88)",
    colorIcon: "rgba(0, 0, 0, 0.45)",
    colorFillSecondary: "rgba(0, 0, 0, 0.06)",
    colorFillContent: "rgba(0, 0, 0, 0.06)",
    colorFillAlter: "rgba(0, 0, 0, 0.02)",
    colorBorderSecondary: "#f0f0f0",
    colorBgContainer: "#ffffff",
    rowSelectedHoverBg: "#ffe3c7",
    headerFilterHoverBg: "rgba(0, 0, 0, 0.06)",
    headerColor: "rgba(0, 0, 0, 0.88)",
    headerBorderRadius: 8,
    footerColor: "rgba(0, 0, 0, 0.88)",
    filterDropdownMenuBg: "#ffffff",
    filterDropdownBg: "#ffffff",
    cellPaddingInlineSM: 8,
    cellPaddingInlineMD: 8,
    cellPaddingInline: 16,
    cellPaddingBlockSM: 8,
    cellPaddingBlockMD: 12,
    cellPaddingBlock: 16,
    borderColor: "#f0f0f0",
    rowHoverBg: "#fafafa",
    headerSortActiveBg: "rgba(0, 0, 0, 0.06)",
    bodySortBg: "#fafafa",
    headerSortHoverBg: "rgba(0, 0, 0, 0.06)",
    cellFontSize: 14,
    cellFontSizeMD: 14,
    cellFontSizeSM: 14,
    fontFamily: "Inter",
    rowSelectedBg: "#fff8f0",
    subtextFontSize: 12,
    subtextFontWeight: 400,
    subtextColor: "rgba(0, 0, 0, 0.45)",
    columnChooserOptionColor: "rgba(0, 0, 0, 0.88)",
    columnChooserOptionFontSize: 14,
    columnChooserOptionHoverBg: "rgba(0, 0, 0, 0.04)",
    columnChooserOptionSelectedFontWeight: 600,
    columnChooserOptionFontWeight: 400,
    columnChooserOptionPaddingHorizontal: 12,
    columnChooserOptionPaddingVertical: 5,
    columnChooserOptionIconColor: "#f37022",
    columnChooserOptionDisabledColor: "rgba(0, 0, 0, 0.35)",
    columnChooserOptionIconWidth: 16,
    columnChooserOptionIconHeight: 16,
    columnChooserPaddingVertical: 4,
    columnChooserPaddingHorizontal: 4,
    columnChooserMaxHeight: 294
  },
  Steps: {
    dotSize: 8,
    dotCurrentSize: 10,
    descriptionMaxWidth: 140,
    paddingXXS: 4,
    paddingXS: 8,
    paddingSM: 12,
    paddingLG: 24,
    padding: 16,
    marginXXS: 4,
    marginXS: 8,
    marginSM: 12,
    marginLG: 24,
    margin: 16,
    lineWidthFocus: 4,
    lineWidthBold: 2,
    lineWidth: 1,
    lineHeightSM: 20,
    lineHeight: 1.2,
    fontWeightStrong: 600,
    fontSizeSM: 12,
    fontSizeLG: 16,
    fontSizeIcon: 12,
    fontSizeHeading3: 24,
    fontSize: 14,
    controlItemBgHover: "rgba(0, 0, 0, 0.04)",
    controlItemBgActive: "#fff8f0",
    controlHeightLG: 40,
    borderRadiusSM: 4,
    colorTextQuaternary: "rgba(0, 0, 0, 0.25)",
    colorTextLightSolid: "#ffffff",
    colorTextLabel: "rgba(0, 0, 0, 0.65)",
    colorTextDisabled: "rgba(0, 0, 0, 0.25)",
    colorTextDescription: "rgba(0, 0, 0, 0.45)",
    colorText: "rgba(0, 0, 0, 0.88)",
    colorSplit: "rgba(0, 0, 0, 0.06)",
    colorPrimaryBorder: "#ffcb9e",
    colorPrimary: "#f37022",
    colorFillContent: "rgba(0, 0, 0, 0.06)",
    colorError: "#ff4d4f",
    colorBorderSecondary: "#f0f0f0",
    colorBorderBg: "#ffffff",
    colorBgContainer: "#ffffff",
    titleLineHeight: 32,
    iconSizeSM: 24,
    iconSize: 32,
    finishIconBorderColor: "#1677ff",
    customIconFontSize: 24,
    iconFontSize: 14,
    fontFamily: "Inter"
  },
  Spin: {
    dotSizeSM: 14,
    dotSize: 20,
    contentHeight: 400,
    marginXXS: 4,
    lineHeight: 1.2,
    fontSize: 14,
    controlHeightLG: 40,
    controlHeight: 32,
    colorTextDescription: "rgba(0, 0, 0, 0.45)",
    colorText: "rgba(0, 0, 0, 0.88)",
    colorPrimary: "#f37022",
    colorBgContainer: "#ffffff",
    dotSizeLG: 32,
    fontFamily: "Inter"
  },
  Slider: {
    railSize: 4,
    handleSizeHover: 12,
    dotSize: 8,
    controlSize: 10,
    handleSize: 10,
    lineWidth: 1,
    lineHeight: 1.2,
    fontSize: 14,
    controlHeightSM: 24,
    controlHeightLG: 40,
    controlHeight: 32,
    borderRadiusXS: 2,
    colorTextDisabled: "rgba(0, 0, 0, 0.25)",
    colorTextDescription: "rgba(0, 0, 0, 0.45)",
    colorText: "rgba(0, 0, 0, 0.88)",
    colorPrimaryBorderHover: "#ffb175",
    colorPrimaryBorder: "#ffcb9e",
    colorPrimary: "#f37022",
    colorFillTertiary: "rgba(0, 0, 0, 0.04)",
    colorFillSecondary: "rgba(0, 0, 0, 0.06)",
    colorFillContentHover: "rgba(0, 0, 0, 0.15)",
    colorBorderSecondary: "#f0f0f0",
    colorBgElevated: "#ffffff",
    colorBgContainerDisabled: "rgba(0, 0, 0, 0.04)",
    colorBgContainer: "#ffffff",
    trackHoverBg: "#ffb175",
    trackBgDisabled: "rgba(0, 0, 0, 0.04)",
    trackBg: "#ffcb9e",
    railHoverBg: "rgba(0, 0, 0, 0.06)",
    railBg: "rgba(0, 0, 0, 0.04)",
    handleColor: "#ffcb9e",
    handleActiveColor: "#f37022",
    dotBorderColor: "#f0f0f0",
    dotActiveBorderColor: "#ffcb9e",
    handleColorDisabled: "#bfbfbf",
    fontFamily: "Inter"
  },
  Rate: {
    rateStarSize: 20,
    marginXS: 8,
    lineWidth: 1,
    lineHeight: 1.2,
    fontSize: 14,
    controlHeightLG: 40,
    colorText: "rgba(0, 0, 0, 0.88)",
    colorFillContent: "rgba(0, 0, 0, 0.06)",
    fontFamily: "Inter"
  },
  Radio: {
    radioSize: 16,
    dotSize: 8,
    buttonPaddingInline: 15,
    paddingXS: 8,
    padding: 16,
    marginXS: 8,
    lineWidthFocus: 4,
    lineWidth: 1,
    lineHeight: 1.2,
    fontSizeLG: 16,
    fontSize: 14,
    controlOutlineWidth: 2,
    controlOutline: "rgba(243, 112, 34, 0.1)",
    controlItemBgActiveDisabled: "rgba(0, 0, 0, 0.15)",
    controlHeightSM: 24,
    controlHeightLG: 40,
    controlHeight: 32,
    borderRadiusSM: 4,
    borderRadiusLG: 8,
    borderRadius: 6,
    colorWhite: "#ffffff",
    colorTextLightSolid: "#ffffff",
    colorTextDisabled: "rgba(0, 0, 0, 0.25)",
    colorText: "rgba(0, 0, 0, 0.88)",
    colorPrimaryHover: "#ff944d",
    colorPrimaryBorder: "#ffcb9e",
    colorPrimaryActive: "#cc5012",
    colorPrimary: "#f37022",
    colorBorder: "#d9d9d9",
    colorBgContainerDisabled: "rgba(0, 0, 0, 0.04)",
    colorBgContainer: "#ffffff",
    wrapperMarginInlineEnd: 8,
    dotColorDisabled: "rgba(0, 0, 0, 0.25)",
    buttonSolidCheckedHoverBg: "#ff944d",
    buttonSolidCheckedColor: "#ffffff",
    buttonSolidCheckedBg: "#f37022",
    buttonSolidCheckedActiveBg: "#cc5012",
    buttonColor: "rgba(0, 0, 0, 0.88)",
    buttonCheckedColorDisabled: "rgba(0, 0, 0, 0.25)",
    buttonCheckedBgDisabled: "rgba(0, 0, 0, 0.15)",
    buttonCheckedBg: "#ffffff",
    buttonBg: "#ffffff",
    fontFamily: "Inter"
  },
  Popover: {
    titleMinWidth: 265,
    sizePopupArrow: 16,
    paddingSM: 12,
    padding: 16,
    marginXS: 8,
    lineWidth: 1,
    lineHeight: 1.2,
    fontWeightStrong: 600,
    fontSize: 14,
    controlHeight: 32,
    borderRadiusXS: 2,
    borderRadiusLG: 8,
    colorTextHeading: "rgba(0, 0, 0, 0.88)",
    colorText: "rgba(0, 0, 0, 0.88)",
    colorSplit: "rgba(0, 0, 0, 0.06)",
    colorBgElevated: "#ffffff",
    fontFamily: "Inter",
    maxWidth: 600,
    maxHeight: 450
  },
  Notification: {
    width: 384,
    paddingMD: 20,
    paddingLG: 24,
    paddingContentHorizontalLG: 24,
    marginXS: 8,
    marginSM: 12,
    marginLG: 24,
    margin: 16,
    lineHeight: 1.2,
    fontSizeLG: 16,
    fontSize: 14,
    controlHeightLG: 40,
    borderRadiusSM: 4,
    borderRadiusLG: 8,
    colorWarning: "#faad14",
    colorTextHeading: "rgba(0, 0, 0, 0.88)",
    colorText: "rgba(0, 0, 0, 0.88)",
    colorSuccess: "#52c41a",
    colorInfo: "rgba(0, 0, 0, 0.3)",
    colorIconHover: "rgba(0, 0, 0, 0.88)",
    colorIcon: "rgba(0, 0, 0, 0.45)",
    colorError: "#ff4d4f",
    colorBgElevated: "#ffffff",
    lineHeightLG: 1.4,
    lineWidthFocus: 4,
    fontFamily: "Inter"
  },
  Tooltip: {
    paddingSM: 12,
    sizePopupArrow: 16,
    paddingXS: 8,
    fontSize: 14,
    fontWeight: 400,
    controlHeight: 32,
    borderRadiusXS: 2,
    borderRadius: 6,
    colorTextLightSolid: "#ffffff",
    colorText: "rgba(0, 0, 0, 0.88)",
    colorBgSpotlight: "rgba(0, 0, 0, 0.85)",
    fontFamily: "Inter"
  },
  Menu: {
    subMenuItemBg: "rgba(0, 0, 0, 0.02)",
    darkSubMenuItemBg: "#212121",
    darkItemDisabledColor: "rgba(255, 255, 255, 0.25)",
    darkItemColor: "rgba(255, 255, 255, 0.65)",
    darkGroupTitleColor: "rgba(255, 255, 255, 0.65)",
    darkItemBg: "#212121",
    paddingXS: 8,
    paddingXL: 32,
    padding: 16,
    marginXXS: 4,
    marginXS: 8,
    margin: 16,
    lineWidthFocus: 4,
    lineWidthBold: 2,
    lineWidth: 1,
    lineHeight: 1.2,
    fontSizeLG: 16,
    fontSize: 14,
    controlItemBgActive: "#fff8f0",
    controlHeightSM: 24,
    controlHeightLG: 40,
    borderRadius: 6,
    colorSplit: "rgba(0, 0, 0, 0.06)",
    colorPrimaryBorder: "#ffcb9e",
    colorPrimary: "#f37022",
    colorFillContent: "rgba(0, 0, 0, 0.06)",
    colorErrorHover: "#ff7875",
    colorErrorBg: "#fff2f0",
    colorError: "#ff4d4f",
    colorBgElevated: "#ffffff",
    colorBgContainer: "#ffffff",
    subMenuItemBorderRadius: 4,
    popupBg: "#ffffff",
    itemSelectedColor: "#f37022",
    itemSelectedBg: "#fff8f0",
    itemHoverColor: "rgba(0, 0, 0, 0.88)",
    itemHoverBg: "rgba(0, 0, 0, 0.06)",
    itemHeight: 40,
    itemDisabledColor: "rgba(0, 0, 0, 0.25)",
    itemColor: "rgba(0, 0, 0, 0.88)",
    itemBorderRadius: 3,
    itemBg: "#ffffff",
    iconSize: 16,
    horizontalItemSelectedColor: "#f37022",
    horizontalItemSelectedBg: "rgba(0, 0, 0, 0)",
    horizontalItemHoverColor: "#f37022",
    horizontalItemHoverBg: "rgba(0, 0, 0, 0)",
    groupTitleColor: "rgba(0, 0, 0, 0.45)",
    darkItemSelectedColor: "#ffffff",
    darkItemSelectedBg: "#f37022",
    darkItemHoverColor: "#ffffff",
    darkItemHoverBg: "rgba(0, 0, 0, 0)",
    collapsedIconSize: 16,
    darkPopupBg: "#212121",
    activeBarBorderWidth: 1,
    collapsedWidth: 80,
    dropdownWidth: 160,
    itemMarginBlock: 4,
    itemMarginInline: 4,
    iconMarginInlineEnd: 10,
    groupTitleFontSize: 14,
    groupTitleLineHeight: 1.2,
    fontFamily: "Inter"
  },
  InputNumber: {
    paddingInlineSM: 7,
    paddingInlineLG: 11,
    paddingInline: 11,
    paddingBlockSM: 0,
    paddingBlockLG: 7,
    paddingBlock: 4,
    handleWidth: 22,
    controlWidth: 90,
    paddingXXS: 4,
    paddingXS: 8,
    paddingSM: 12,
    lineWidth: 1,
    lineHeightLG: 1.4,
    lineHeight: 1.2,
    fontSizeLG: 16,
    fontSize: 14,
    controlPaddingHorizontalSM: 8,
    controlPaddingHorizontal: 12,
    controlHeightSM: 24,
    controlHeightLG: 40,
    controlHeight: 32,
    borderRadiusSM: 4,
    borderRadiusLG: 8,
    borderRadius: 6,
    colorWarningBorderHover: "#ffd666",
    colorWarning: "#faad14",
    colorTextPlaceholder: "rgba(0, 0, 0, 0.25)",
    colorTextDisabled: "rgba(0, 0, 0, 0.25)",
    colorTextDescription: "rgba(0, 0, 0, 0.45)",
    colorText: "rgba(0, 0, 0, 0.88)",
    colorPrimaryHover: "#ff944d",
    colorPrimary: "#f37022",
    colorFillAlter: "rgba(0, 0, 0, 0.02)",
    colorErrorBorderHover: "#ffa39e",
    colorError: "#ff4d4f",
    colorBorder: "#d9d9d9",
    colorBgContainerDisabled: "rgba(0, 0, 0, 0.04)",
    colorBgContainer: "#ffffff",
    hoverBorderColor: "#ff944d",
    handleHoverColor: "#f37022",
    handleBorderColor: "#d9d9d9",
    handleBg: "#ffffff",
    handleActiveBg: "rgba(0, 0, 0, 0.02)",
    addonBg: "rgba(0, 0, 0, 0.02)",
    activeBorderColor: "#f37022",
    activeBg: "#ffffff",
    hoverBg: "#ffffff",
    inputFontSize: 14,
    inputFontSizeLG: 16,
    inputFontSizeSM: 12,
    fontFamily: "Inter"
  },
  Image: {
    previewOperationSize: 18,
    previewOperationHoverColor: "rgba(255, 255, 255, 0.85)",
    previewOperationColorDisabled: "rgba(255, 255, 255, 0.25)",
    previewOperationColor: "rgba(255, 255, 255, 0.65)",
    paddingXXS: 4,
    paddingSM: 12,
    paddingLG: 24,
    marginXXS: 4,
    marginXL: 32,
    marginSM: 12,
    margin: 16,
    fontSizeIcon: 12,
    controlHeightLG: 40,
    colorTextLightSolid: "#ffffff",
    colorBgMask: "rgba(0, 0, 0, 0.45)",
    colorBgContainerDisabled: "rgba(0, 0, 0, 0.04)"
  },
  Card: {
    headerHeightSM: 38,
    headerHeight: 56,
    paddingXS: 8,
    paddingSM: 12,
    paddingLG: 24,
    padding: 16,
    marginXXS: 4,
    marginXS: 8,
    lineWidth: 1,
    lineHeightLG: 1.4,
    lineHeight: 1.2,
    fontWeightStrong: 600,
    fontSize: 14,
    borderRadiusLG: 8,
    colorTextHeading: "rgba(0, 0, 0, 0.88)",
    colorTextDescription: "rgba(0, 0, 0, 0.45)",
    colorText: "rgba(0, 0, 0, 0.88)",
    colorPrimary: "#f37022",
    colorFillAlter: "rgba(0, 0, 0, 0.02)",
    colorBorderSecondary: "#d9d9d9",
    colorBgContainer: "#ffffff",
    headerBg: "rgba(0, 0, 0, 0)",
    headerFontSize: 16,
    headerFontSizeSM: 14,
    fontHeight: 22,
    fontSizeLG: 16,
    fontFamily: "Inter",
    innerHeaderFontSize: 16,
    innerHeaderHeight: 48,
    innerHeaderBg: "rgba(0, 0, 0, 0.02)",
    innerHeaderLineHeight: "1.5",
    innerHeaderPaddingHorizontal: 16,
    innerContentPaddingVertical: 16,
    innerContentPaddingHorizontal: 16
  },
  Carousel: {
    dotWidth: 16,
    dotHeight: 3,
    dotActiveWidth: 24,
    marginXXS: 4,
    lineHeight: 1.2,
    fontSize: 14,
    controlHeightSM: 24,
    controlHeightLG: 40,
    colorText: "rgba(0, 0, 0, 0.88)",
    colorBgContainer: "#ffffff",
    fontFamily: "Inter"
  },
  Cascader: {
    dropdownHeight: 180,
    controlWidth: 184,
    controlItemWidth: 111,
    paddingXXS: 4,
    paddingXS: 8,
    paddingSM: 12,
    marginXS: 8,
    lineWidthFocus: 4,
    lineWidthBold: 2,
    lineWidth: 1,
    lineHeight: 1.2,
    fontWeightStrong: 600,
    fontSizeLG: 16,
    fontSizeIcon: 12,
    fontSize: 14,
    controlItemBgHover: "rgba(0, 0, 0, 0.04)",
    controlItemBgActive: "#fff8f0",
    controlInteractiveSize: 16,
    controlHeight: 32,
    borderRadiusSM: 4,
    colorWhite: "#ffffff",
    colorTextDisabled: "rgba(0, 0, 0, 0.25)",
    colorTextDescription: "rgba(0, 0, 0, 0.45)",
    colorText: "rgba(0, 0, 0, 0.88)",
    colorSplit: "rgba(0, 0, 0, 0.06)",
    colorPrimaryHover: "#ff944d",
    colorPrimaryBorder: "#ffcb9e",
    colorPrimary: "#f37022",
    colorBorder: "#d9d9d9",
    colorBgContainerDisabled: "rgba(0, 0, 0, 0.04)",
    colorBgContainer: "#ffffff",
    optionSelectedBg: "#fff8f0",
    menuPadding: 4,
    optionSelectedFontWeight: 600,
    fontFamily: "Inter"
  },
  Calendar: {
    yearControlWidth: 80,
    monthControlWidth: 70,
    controlHeight: 32,
    screenXS: 480,
    paddingXXS: 4,
    paddingXS: 8,
    paddingSM: 12,
    padding: 16,
    marginXXS: 4,
    marginXS: 8,
    lineWidthBold: 2,
    lineWidth: 1,
    lineHeightSM: 20,
    lineHeight: 1.2,
    fontWeightStrong: 600,
    fontSizeSM: 12,
    fontSize: 14,
    controlItemBgHover: "rgba(0, 0, 0, 0.04)",
    controlItemBgActive: "#fff8f0",
    controlHeightSM: 24,
    controlHeightLG: 40,
    borderRadiusSM: 4,
    borderRadiusLG: 8,
    colorTextLightSolid: "#ffffff",
    colorTextHeading: "rgba(0, 0, 0, 0.88)",
    colorTextDisabled: "rgba(0, 0, 0, 0.25)",
    colorText: "rgba(0, 0, 0, 0.88)",
    colorSplit: "rgba(0, 0, 0, 0.06)",
    colorPrimary: "#f37022",
    colorLinkHover: "#ff944d",
    colorLinkActive: "#cc5012",
    colorLink: "#f37022",
    colorIconHover: "rgba(0, 0, 0, 0.88)",
    colorIcon: "rgba(0, 0, 0, 0.45)",
    colorBgContainerDisabled: "rgba(0, 0, 0, 0.04)",
    colorBgContainer: "#ffffff",
    itemActiveBg: "#fff8f0",
    fullPanelBg: "#ffffff",
    fullBg: "#ffffff",
    fontHeightSM: 20,
    fontFamily: "Inter"
  },
  Button: {
    borderRadius: 3,
    borderRadiusLG: 3,
    borderRadiusSM: 3,
    colorBgContainer: "#ffffff",
    colorBgContainerDisabled: "rgba(0, 0, 0, 0.04)",
    contentFontSize: 14,
    contentFontSizeLG: 16,
    contentFontSizeSM: 14,
    contentLineHeight: 1.2,
    contentLineHeightLG: 1.4,
    contentLineHeightSM: 1.2,
    controlHeight: 32,
    controlHeightLG: 40,
    controlHeightSM: 24,
    controlOutline: "rgba(243, 112, 34, 0.1)",
    controlOutlineWidth: 2,
    dashedBg: "#ffffff",
    dashedBorderColor: "#d9d9d9",
    dashedColor: "rgba(0, 0, 0, 0.88)",
    dashedDangerBg: "#ffffff",
    dashedDangerBorderColor: "#ff4d4f",
    dashedDangerColor: "#ff4d4f",
    dashedDangerDisabledBg: "rgba(0, 0, 0, 0)",
    dashedDangerDisabledBorderColor: "#d9d9d9",
    dashedDangerDisabledColor: "rgba(0, 0, 0, 0.25)",
    dashedDangerFocusedBg: "#ffffff",
    dashedDangerFocusedBorderColor: "#ff7875",
    dashedDangerFocusedColor: "#ff7875",
    dashedDangerHoverBg: "#ffffff",
    dashedDangerHoverBorderColor: "#ff7875",
    dashedDangerHoverColor: "#ff7875",
    dashedDangerPressedBg: "#ffffff",
    dashedDangerPressedBorderColor: "#f5222d",
    dashedDangerPressedColor: "#f5222d",
    dashedDisabledBg: "rgba(0, 0, 0, 0)",
    dashedDisabledBorderColor: "#d9d9d9",
    dashedDisabledColor: "rgba(0, 0, 0, 0.25)",
    dashedFocusedBg: "#ffffff",
    dashedFocusedBorderColor: "#ff944d",
    dashedFocusedColor: "#ff944d",
    dashedGhostBg: "rgba(0, 0, 0, 0)",
    dashedGhostBorderColor: "#f37022",
    dashedGhostColor: "#f37022",
    dashedGhostDangerBg: "rgba(0, 0, 0, 0)",
    dashedGhostDangerBorderColor: "#ff4d4f",
    dashedGhostDangerColor: "#ff4d4f",
    dashedGhostDangerDisabledBg: "rgba(0, 0, 0, 0)",
    dashedGhostDangerDisabledBorderColor: "rgba(0, 0, 0, 0.25)",
    dashedGhostDangerDisabledColor: "rgba(0, 0, 0, 0.25)",
    dashedGhostDangerFocusedBg: "rgba(0, 0, 0, 0)",
    dashedGhostDangerFocusedBorderColor: "#FF7875",
    dashedGhostDangerFocusedColor: "#FF7875",
    dashedGhostDangerHoverBg: "rgba(0, 0, 0, 0)",
    dashedGhostDangerHoverBorderColor: "#FF7875",
    dashedGhostDangerHoverColor: "#FF7875",
    dashedGhostDangerPressedBg: "rgba(0, 0, 0, 0)",
    dashedGhostDangerPressedBorderColor: "#D9363E",
    dashedGhostDangerPressedColor: "#D9363E",
    dashedGhostDisabledBg: "rgba(0, 0, 0, 0)",
    dashedGhostDisabledBorderColor: "rgba(0, 0, 0, 0.25)",
    dashedGhostDisabledColor: "rgba(0, 0, 0, 0.25)",
    dashedGhostFocusedBg: "rgba(0, 0, 0, 0)",
    dashedGhostFocusedBorderColor: "#FF944D",
    dashedGhostFocusedColor: "#FF944D",
    dashedGhostHoverBg: "rgba(0, 0, 0, 0)",
    dashedGhostHoverBorderColor: "#FF944D",
    dashedGhostHoverColor: "#FF944D",
    dashedGhostPressedBg: "rgba(0, 0, 0, 0)",
    dashedGhostPressedBorderColor: "#cc5012",
    dashedGhostPressedColor: "#cc5012",
    dashedHoverBg: "#ffffff",
    dashedHoverBorderColor: "#ff944d",
    dashedHoverColor: "#ff944d",
    dashedPressedBg: "#ffffff",
    dashedPressedBorderColor: "#cc5012",
    dashedPressedColor: "#cc5012",
    defaultBg: "#ffffff",
    defaultBorderColor: "#d9d9d9",
    defaultColor: "#000000",
    defaultDangerBg: "#ffffff",
    defaultDangerBorderColor: "#ff4d4f",
    defaultDangerColor: "#ff4d4f",
    defaultDangerDisabledBg: "rgba(0, 0, 0, 0)",
    defaultDangerDisabledBorderColor: "#d9d9d9",
    defaultDangerDisabledColor: "rgba(0, 0, 0, 0.25)",
    defaultDangerFocusedBg: "#ffffff",
    defaultDangerFocusedBorderColor: "#ff7875",
    defaultDangerFocusedColor: "#ff7875",
    defaultDangerHoverBg: "#ffffff",
    defaultDangerHoverBorderColor: "#ff4d4f",
    defaultDangerHoverColor: "#ff7875",
    defaultDangerPressedBg: "#ffffff",
    defaultDangerPressedBorderColor: "#f5222d",
    defaultDangerPressedColor: "#f5222d",
    defaultDisabledBg: "rgba(0, 0, 0, 0)",
    defaultDisabledBorderColor: "#d9d9d9",
    defaultDisabledColor: "rgba(0, 0, 0, 0.25)",
    defaultFocusedBg: "#ffffff",
    defaultFocusedBorderColor: "#ff944d",
    defaultFocusedColor: "#ff944d",
    defaultHoverBg: "#ffffff",
    defaultGhostBg: "rgba(0, 0, 0, 0)",
    defaultGhostBorderColor: "#f37022",
    defaultGhostColor: "#f37022",
    defaultGhostDangerBg: "rgba(0, 0, 0, 0)",
    defaultGhostDangerBorderColor: "#ff4d4f",
    defaultGhostDangerColor: "#ff4d4f",
    defaultGhostDangerDisabledBg: "rgba(0, 0, 0, 0)",
    defaultGhostDangerDisabledBorderColor: "rgba(0, 0, 0, 0.25)",
    defaultGhostDangerDisabledColor: "rgba(0, 0, 0, 0.25)",
    defaultGhostDangerFocusedBg: "rgba(0, 0, 0, 0)",
    defaultGhostDangerFocusedBorderColor: "#FF7875",
    defaultGhostDangerFocusedColor: "#FF7875",
    defaultGhostDangerHoverBg: "rgba(0, 0, 0, 0)",
    defaultGhostDangerHoverBorderColor: "#FF7875",
    defaultGhostDangerHoverColor: "#FF7875",
    defaultGhostDangerPressedBg: "rgba(0, 0, 0, 0)",
    defaultGhostDangerPressedBorderColor: "#D9363E",
    defaultGhostDangerPressedColor: "#D9363E",
    defaultGhostDisabledBg: "rgba(0, 0, 0, 0)",
    defaultGhostDisabledBorderColor: "#d9d9d9",
    defaultGhostDisabledColor: "rgba(0, 0, 0, 0.25)",
    defaultGhostFocusedBg: "rgba(0, 0, 0, 0)",
    defaultGhostFocusedBorderColor: "#FF944D",
    defaultGhostFocusedColor: "#FF944D",
    defaultGhostHoverBg: "rgba(0, 0, 0, 0)",
    defaultGhostHoverBorderColor: "#FF944D",
    defaultGhostHoverColor: "#FF944D",
    defaultGhostPressedBg: "rgba(0, 0, 0, 0)",
    defaultGhostPressedBorderColor: "#cc5012",
    defaultGhostPressedColor: "#cc5012",
    defaultHoverBorderColor: "#ff944d",
    defaultHoverColor: "#ff944d",
    defaultPressedBg: "#ffffff",
    defaultPressedBorderColor: "#cc5012",
    defaultPressedColor: "#cc5012",
    fontWeight: 400,
    groupBorderColor: "#ff944d",
    iconDashedColor: "rgba(0, 0, 0, 0.65)",
    iconDashedDangerColor: "#ff4d4f",
    iconDashedDangerDisabledColor: "rgba(0, 0, 0, 0.25)",
    iconDashedDangerFocusedColor: "#ff7875",
    iconDashedDangerHoverColor: "#ff7875",
    iconDashedDangerPressedColor: "#f5222d",
    iconDashedDisabledColor: "rgba(0, 0, 0, 0.25)",
    iconDashedFocusedColor: "#ff944d",
    iconDashedGhostColor: "#f37022",
    iconDashedGhostDangerColor: "#ff4d4f",
    iconDashedGhostDangerDisabledColor: "rgba(0, 0, 0, 0.25)",
    iconDashedGhostDangerFocusedColor: "#FF7875",
    iconDashedGhostDangerHoverColor: "#FF7875",
    iconDashedGhostDangerPressedColor: "#D9363E",
    iconDashedGhostDisabledColor: "rgba(0, 0, 0, 0.25)",
    iconDashedGhostFocusedColor: "#FF944D",
    iconDashedGhostHoverColor: "#FF944D",
    iconDashedGhostPressedColor: "#cc5012",
    iconDashedHoverColor: "#ff944d",
    iconDashedPressedColor: "#cc5012",
    iconDefaultColor: "rgba(0, 0, 0, 0.65)",
    iconDefaultDangerColor: "#f5222d",
    iconDefaultDangerDisabledColor: "rgba(0, 0, 0, 0.25)",
    iconDefaultDangerFocusedColor: "#ff7875",
    iconDefaultDangerHoverColor: "#ff7875",
    iconDefaultDangerPressedColor: "#f5222d",
    iconDefaultDisabledColor: "rgba(0, 0, 0, 0.25)",
    iconDefaultFocusedColor: "#ff944d",
    iconDefaultGhostColor: "#f37022",
    iconDefaultGhostDangerColor: "#f5222d",
    iconDefaultGhostDangerDisabledColor: "rgba(0, 0, 0, 0.25)",
    iconDefaultGhostDangerFocusedColor: "#FF7875",
    iconDefaultGhostDangerHoverColor: "#FF7875",
    iconDefaultGhostDangerPressedColor: "#D9363E",
    iconDefaultGhostDisabledColor: "rgba(0, 0, 0, 0.25)",
    iconDefaultGhostFocusedColor: "#FF944D",
    iconDefaultGhostHoverColor: "#FF944D",
    iconDefaultGhostPressedColor: "#cc5012",
    iconDefaultHoverColor: "#ff944d",
    iconDefaultPressedColor: "#cc5012",
    iconLinkColor: "#f37022",
    iconLinkDangerColor: "#ff4d4f",
    iconLinkDangerDisabledColor: "#ffa39e",
    iconLinkDangerFocusedColor: "#ff7875",
    iconLinkDangerHoverColor: "#ff7875",
    iconLinkDangerPressedColor: "#f5222d",
    iconLinkDisabledColor: "#ffb175",
    iconLinkFocusedColor: "#ff944d",
    iconLinkHoverColor: "#ff944d",
    iconLinkPressedColor: "#f37022",
    iconPrimaryColor: "#ffffff",
    iconPrimaryDangerColor: "#ffffff",
    iconPrimaryDangerDisabledColor: "#ffffff",
    iconPrimaryDangerFocusedColor: "#ffffff",
    iconPrimaryDangerHoverColor: "#ffffff",
    iconPrimaryDangerPressedColor: "#ffffff",
    iconPrimaryDisabledColor: "#ffffff",
    iconPrimaryFocusedColor: "#ffffff",
    iconPrimaryGhostColor: "#f37022",
    iconPrimaryGhostDangerColor: "#ff4d4f",
    iconPrimaryGhostDangerDisabledColor: "rgba(0, 0, 0, 0.25)",
    iconPrimaryGhostDangerFocusedColor: "#FF7875",
    iconPrimaryGhostDangerHoverColor: "#FF7875",
    iconPrimaryGhostDangerPressedColor: "#D9363E",
    iconPrimaryGhostDisabledColor: "rgba(0, 0, 0, 0.25)",
    iconPrimaryGhostFocusedColor: "#FF944D",
    iconPrimaryGhostHoverColor: "#FF944D",
    iconPrimaryGhostPressedColor: "#cc5012",
    iconPrimaryHoverColor: "#ffffff",
    iconPrimaryPressedColor: "#ffffff",
    iconSize: 16,
    iconSizeLG: 24,
    iconSizeSM: 14,
    iconTextColor: "rgba(0, 0, 0, 0.65)",
    iconTextDangerColor: "#ff4d4f",
    iconTextDangerDisabledColor: "rgba(0, 0, 0, 0.25)",
    iconTextDangerFocusedColor: "#ff7875",
    iconTextDangerHoverColor: "#ff7875",
    iconTextDangerPressedColor: "#f5222d",
    iconTextDisabledColor: "rgba(0, 0, 0, 0.25)",
    iconTextFocusedColor: "rgba(0, 0, 0, 0.65)",
    iconTextHoverColor: "rgba(0, 0, 0, 0.65)",
    iconTextPressedColor: "rgba(0, 0, 0, 0.65)",
    lineWidth: 1,
    lineWidthFocus: 4,
    linkBg: "rgba(0, 0, 0, 0)",
    linkBorderColor: "rgba(0, 0, 0, 0)",
    linkColor: "#f37022",
    linkDangerBg: "rgba(0, 0, 0, 0)",
    linkDangerBorderColor: "rgba(0, 0, 0, 0)",
    linkDangerColor: "#ff4d4f",
    linkDangerDisabledBg: "rgba(0, 0, 0, 0)",
    linkDangerDisabledBorderColor: "rgba(0, 0, 0, 0)",
    linkDangerDisabledColor: "#ffa39e",
    linkDangerFocusedBg: "rgba(0, 0, 0, 0)",
    linkDangerFocusedBorderColor: "rgba(0, 0, 0, 0)",
    linkDangerFocusedColor: "#ff7875",
    linkDangerHoverBg: "rgba(0, 0, 0, 0)",
    linkDangerHoverBorderColor: "rgba(0, 0, 0, 0)",
    linkDangerHoverColor: "#ff7875",
    linkDangerPressedBg: "rgba(0, 0, 0, 0)",
    linkDangerPressedBorderColor: "rgba(0, 0, 0, 0)",
    linkDangerPressedColor: "#f5222d",
    linkDisabledBg: "rgba(0, 0, 0, 0)",
    linkDisabledBorderColor: "rgba(0, 0, 0, 0)",
    linkDisabledColor: "#ffb175",
    linkFocusedBg: "rgba(0, 0, 0, 0)",
    linkFocusedBorderColor: "rgba(0, 0, 0, 0)",
    linkFocusedColor: "#ff944d",
    linkHoverBg: "rgba(0, 0, 0, 0)",
    linkHoverBorderColor: "rgba(0, 0, 0, 0)",
    linkHoverColor: "#ff944d",
    linkPressedBg: "rgba(0, 0, 0, 0)",
    linkPressedBorderColor: "rgba(0, 0, 0, 0)",
    linkPressedColor: "#f37022",
    marginXS: 8,
    onlyIconSize: 16,
    onlyIconSizeLG: 24,
    onlyIconSizeSM: 14,
    paddingContentHorizontal: 16,
    paddingInline: 15,
    paddingInlineLG: 15,
    paddingInlineSM: 7,
    paddingXS: 8,
    primaryBg: "#f37022",
    primaryBorderColor: "#f37022",
    primaryColor: "#ffffff",
    primaryDangerBg: "#ff4d4f",
    primaryDangerBorderColor: "#ff4d4f",
    primaryDangerColor: "#ffffff",
    primaryDangerDisabledBg: "#ffa39e",
    primaryDangerDisabledBorderColor: "#ffa39e",
    primaryDangerDisabledColor: "#ffffff",
    primaryDangerFocusedBg: "#ff7875",
    primaryDangerFocusedBorderColor: "#ff7875",
    primaryDangerFocusedColor: "#ffffff",
    primaryDangerHoverBg: "#ff7875",
    primaryDangerHoverBorderColor: "#ff7875",
    primaryDangerHoverColor: "#ffffff",
    primaryDangerPressedBg: "#f5222d",
    primaryDangerPressedBorderColor: "#f5222d",
    primaryDangerPressedColor: "#ffffff",
    primaryDisabledBg: "#ffb175",
    primaryDisabledBorderColor: "#ffb175",
    primaryDisabledColor: "#ffffff",
    primaryFocusedBg: "#ff944d",
    primaryFocusedBorderColor: "#ff944d",
    primaryFocusedColor: "#ffffff",
    primaryGhostBg: "rgba(0, 0, 0, 0)",
    primaryGhostBorderColor: "#f37022",
    primaryGhostColor: "#f37022",
    primaryGhostDangerBg: "rgba(0, 0, 0, 0)",
    primaryGhostDangerBorderColor: "#ff7875",
    primaryGhostDangerColor: "#ff4d4f",
    primaryGhostDangerDisabledBg: "rgba(0, 0, 0, 0)",
    primaryGhostDangerDisabledBorderColor: "#d9d9d9",
    primaryGhostDangerDisabledColor: "rgba(0, 0, 0, 0.25)",
    primaryGhostDangerFocusedBg: "rgba(0, 0, 0, 0)",
    primaryGhostDangerFocusedBorderColor: "#FF7875",
    primaryGhostDangerFocusedColor: "#FF7875",
    primaryGhostDangerHoverBg: "rgba(0, 0, 0, 0)",
    primaryGhostDangerHoverBorderColor: "#FF7875",
    primaryGhostDangerHoverColor: "#FF7875",
    primaryGhostDangerPressedBg: "rgba(0, 0, 0, 0)",
    primaryGhostDangerPressedBorderColor: "#D9363E",
    primaryGhostDangerPressedColor: "#D9363E",
    primaryGhostDisabledBg: "rgba(0, 0, 0, 0)",
    primaryGhostDisabledBorderColor: "rgba(0, 0, 0, 0.25)",
    primaryGhostDisabledColor: "rgba(0, 0, 0, 0.25)",
    primaryGhostFocusedBg: "rgba(0, 0, 0, 0)",
    primaryGhostFocusedBorderColor: "#FF944D",
    primaryGhostFocusedColor: "#FF944D",
    primaryGhostHoverBg: "rgba(0, 0, 0, 0)",
    primaryGhostHoverBorderColor: "#FF944D",
    primaryGhostHoverColor: "#FF944D",
    primaryGhostPressedBg: "rgba(0, 0, 0, 0)",
    primaryGhostPressedBorderColor: "#cc5012",
    primaryGhostPressedColor: "#cc5012",
    primaryHoverBg: "#ff944d",
    primaryHoverBorderColor: "#ff944d",
    primaryHoverColor: "#ffffff",
    primaryPressedBg: "#cc5012",
    primaryPressedBorderColor: "#cc5012",
    primaryPressedColor: "#ffffff",
    textBg: "rgba(0, 0, 0, 0)",
    textBorderColor: "rgba(0, 0, 0, 0)",
    textColor: "rgba(0, 0, 0, 0.88)",
    textDangerBg: "rgba(0, 0, 0, 0)",
    textDangerBorderColor: "rgba(0, 0, 0, 0)",
    textDangerColor: "#ff4d4f",
    textDangerDisabledBg: "rgba(0, 0, 0, 0)",
    textDangerDisabledBorderColor: "rgba(0, 0, 0, 0)",
    textDangerDisabledColor: "rgba(0, 0, 0, 0.25)",
    textDangerFocusedBg: "rgba(255, 77, 79, 0.06)",
    textDangerFocusedBorderColor: "rgba(0, 0, 0, 0)",
    textDangerFocusedColor: "#ff7875",
    textDangerHoverBg: "rgba(255, 77, 79, 0.06)",
    textDangerHoverBorderColor: "rgba(0, 0, 0, 0)",
    textDangerHoverColor: "#ff7875",
    textDangerPressedBg: "rgba(255, 77, 79, 0.15)",
    textDangerPressedBorderColor: "rgba(0, 0, 0, 0)",
    textDangerPressedColor: "#f5222d",
    textDisabledBg: "rgba(0, 0, 0, 0)",
    textDisabledBorderColor: "rgba(0, 0, 0, 0)",
    textDisabledColor: "rgba(0, 0, 0, 0.25)",
    textFocusedBg: "rgba(0, 0, 0, 0.06)",
    textFocusedBorderColor: "rgba(0, 0, 0, 0)",
    textFocusedColor: "rgba(0, 0, 0, 0.88)",
    textHoverBg: "rgba(0, 0, 0, 0.06)",
    textHoverBorderColor: "rgba(0, 0, 0, 0)",
    textHoverColor: "rgba(0, 0, 0, 0.88)",
    textPressedBg: "rgba(0, 0, 0, 0.15)",
    textPressedBorderColor: "rgba(0, 0, 0, 0)",
    textPressedColor: "rgba(0, 0, 0, 0.88)"
  },
  Badge: {
    statusSize: 6,
    indicatorHeight: 20,
    dotSize: 6,
    paddingXS: 8,
    marginXS: 8,
    lineWidth: 1,
    borderRadiusSM: 4,
    fontSizeSM: 14,
    fontSize: 14,
    colorWarning: "#faad14",
    colorTextPlaceholder: "rgba(0, 0, 0, 0.25)",
    colorTextLightSolid: "#ffffff",
    colorText: "rgba(0, 0, 0, 0.88)",
    colorSuccess: "#52c41a",
    colorPrimary: "#f37022",
    colorErrorHover: "#ff7875",
    colorError: "#ff4d4f",
    colorBorderBg: "#ffffff",
    colorBgContainer: "#ffffff",
    indicatorHeightSM: 14,
    textFontSize: 14,
    textFontSizeSM: 14,
    fontHeight: 22,
    lineHeight: 1.2,
    fontFamily: "Inter",
    dangerIndicatorBg: "#fe6963",
    primaryIndicatorBg: "#f37022",
    defaultIndicatorBg: "#f0f0f0",
    primaryTextColor: "#ffffff",
    defaultTextColor: "#1f1f1f",
    dangerTextColor: "#ffffff"
  },
  Form: {
    screenXSMax: 575,
    screenSMMax: 767,
    screenMDMax: 991,
    screenLGMax: 1199,
    paddingXS: 8,
    paddingSM: 12,
    marginXXS: 4,
    marginXS: 8,
    marginLG: 24,
    margin: 16,
    lineWidth: 1,
    lineHeight: 1.2,
    fontSizeLG: 16,
    fontSize: 14,
    controlOutlineWidth: 2,
    controlOutline: "rgba(243, 112, 34, 0.1)",
    controlHeightSM: 24,
    controlHeightLG: 40,
    controlHeight: 32,
    colorWarning: "#faad14",
    colorTextHeading: "rgba(0, 0, 0, 0.88)",
    colorTextDescription: "#ff4d4f",
    colorText: "rgba(0, 0, 0, 0.88)",
    colorSuccess: "#52c41a",
    colorPrimary: "#f37022",
    colorError: "#ff4d4f",
    colorBorder: "#d9d9d9",
    labelRequiredMarkColor: "#ff4d4f",
    labelColor: "rgba(0, 0, 0, 0.88)",
    itemMarginBottom: 24,
    labelColonMarginInlineEnd: 8,
    labelColonMarginInlineStart: 2,
    labelHeight: 32,
    labelFontSize: 14,
    fontFamily: "Inter"
  },
  Avatar: {
    marginXXS: 4,
    marginXS: 8,
    lineWidth: 1,
    lineHeight: 1.2,
    fontSizeXL: 20,
    fontSizeLG: 16,
    fontSizeHeading3: 24,
    fontSize: 14,
    borderRadiusSM: 4,
    borderRadiusLG: 8,
    borderRadius: 6,
    colorTextPlaceholder: "rgba(0, 0, 0, 0.25)",
    colorTextLightSolid: "#ffffff",
    colorText: "rgba(0, 0, 0, 0.88)",
    colorBorderBg: "#ffffff",
    containerSizeSM: 24,
    containerSizeLG: 40,
    containerSize: 32,
    textFontSize: 18,
    textFontSizeLG: 24,
    textFontSizeSM: 14,
    fontFamily: "Inter"
  },
  Tour: {
    sizePopupArrow: 16,
    paddingXS: 8,
    padding: 16,
    marginXS: 8,
    lineHeight: 1.2,
    fontWeightStrong: 600,
    fontSize: 14,
    borderRadiusXS: 2,
    borderRadiusSM: 4,
    borderRadiusLG: 8,
    borderRadius: 6,
    colorWhite: "#ffffff",
    colorTextLightSolid: "#ffffff",
    colorText: "rgba(0, 0, 0, 0.88)",
    colorPrimary: "#f37022",
    colorIconHover: "rgba(0, 0, 0, 0.88)",
    colorIcon: "rgba(0, 0, 0, 0.45)",
    colorFill: "rgba(0, 0, 0, 0.15)",
    colorBgTextHover: "rgba(0, 0, 0, 0.06)",
    colorBgElevated: "#ffffff",
    closeBtnSize: 22,
    primaryNextBtnHoverBg: "#f0f0f0",
    primaryPrevBtnBg: "rgba(255, 255, 255, 0.15)",
    fontFamily: "Inter",
    lineWidthFocus: 4
  },
  QRCode: {
    paddingSM: 12,
    marginXS: 8,
    lineWidth: 1,
    lineHeight: 1.2,
    fontSize: 14,
    controlHeight: 32,
    borderRadiusLG: 8,
    colorWhite: "#ffffff",
    colorText: "rgba(0, 0, 0, 0.88)",
    colorSplit: "rgba(0, 0, 0, 0.06)",
    fontFamily: "Inter"
  },
  Upload: {
    paddingXS: 8,
    paddingSM: 12,
    padding: 16,
    marginXXS: 4,
    marginXS: 8,
    marginXL: 32,
    margin: 16,
    lineWidth: 1,
    lineHeight: 1.375,
    fontSizeLG: 16,
    fontSizeHeading3: 24,
    fontSizeHeading2: 30,
    fontSize: 14,
    controlItemBgHover: "rgba(0, 0, 0, 0.04)",
    controlHeightLG: 40,
    borderRadiusLG: 8,
    colorTextLightSolid: "#ffffff",
    colorTextHeading: "rgba(0, 0, 0, 0.88)",
    colorTextDisabled: "rgba(0, 0, 0, 0.25)",
    colorTextDescription: "rgba(0, 0, 0, 0.45)",
    colorText: "rgba(0, 0, 0, 0.88)",
    colorPrimaryHover: "#ff944d",
    colorPrimary: "#f37022",
    colorFillAlter: "rgba(0, 0, 0, 0.02)",
    colorErrorBg: "#fff2f0",
    colorError: "#ff4d4f",
    colorBorder: "#d9d9d9",
    colorBgMask: "rgba(0, 0, 0, 0.45)",
    fontHeight: 22,
    fontHeightSM: 20,
    lineWidthFocus: 4,
    fontFamily: "Inter",
    controlItemBgError: "#fff1f0"
  },
  Typography: {
    paddingSM: 12,
    marginXXS: 4,
    marginXS: 8,
    lineWidth: 1,
    lineHeightHeading5: 1.5,
    lineHeightHeading4: 1.4,
    lineHeightHeading3: 1.3333333333333333,
    lineHeightHeading2: 1.2666666666666666,
    lineHeightHeading1: 1.2105263157894737,
    lineHeight: 1.5714285714285714,
    fontWeightStrong: 600,
    fontSizeHeading5: 16,
    fontSizeHeading4: 20,
    fontSizeHeading3: 24,
    fontSizeHeading2: 30,
    fontSizeHeading1: 38,
    fontSize: 14,
    colorWarning: "#faad14",
    colorTextHeading: "rgba(0, 0, 0, 0.88)",
    colorTextDisabled: "rgba(0, 0, 0, 0.25)",
    colorTextDescription: "rgba(0, 0, 0, 0.45)",
    colorText: "rgba(0, 0, 0, 0.88)",
    colorSuccess: "#52c41a",
    colorLinkHover: "#ff944d",
    colorLinkActive: "#cc5012",
    colorLink: "#f37022",
    colorErrorHover: "#ff7875",
    colorErrorActive: "#d9363e",
    colorError: "#ff4d4f",
    fontFamilyCode: "Courier Prime"
  },
  TreeSelect: {
    paddingXS: 8,
    marginXXS: 4,
    marginXS: 8,
    lineWidthFocus: 4,
    lineWidthBold: 2,
    lineWidth: 1,
    lineHeight: 1.2,
    fontSizeLG: 16,
    fontSize: 14,
    controlItemBgHover: "rgba(0, 0, 0, 0.04)",
    controlItemBgActive: "#fff8f0",
    controlInteractiveSize: 16,
    controlHeightSM: 24,
    borderRadiusSM: 4,
    borderRadius: 6,
    colorWhite: "#ffffff",
    colorTextDisabled: "rgba(0, 0, 0, 0.25)",
    colorText: "rgba(0, 0, 0, 0.88)",
    colorPrimaryHover: "#ff944d",
    colorPrimaryBorder: "#ffcb9e",
    colorPrimary: "#f37022",
    colorBorder: "#d9d9d9",
    colorBgElevated: "#ffffff",
    colorBgContainerDisabled: "rgba(0, 0, 0, 0.04)",
    colorBgContainer: "#ffffff",
    titleHeight: 24,
    nodeSelectedBg: "#fff8f0",
    nodeHoverBg: "rgba(0, 0, 0, 0.04)",
    fontFamily: "Inter",
    iconSize: 16,
    menuItemPaddingHorizontal: 4,
    menuItemPaddingVertical: 5,
    subtextFontSize: 13,
    menuItemDefaultColor: "#1f1f1f",
    menuItemSubtleColor: "#a6a6a6",
    menuMaxHeight: 294,
    inputMaxHeightSM: 105,
    inputMaxHeight: 145,
    inputMaxHeightLG: 185,
    multipleItemMaxWidth: 150
  },
  Tree: {
    paddingSM: 12,
    borderRadiusLG: 8,
    paddingXS: 8,
    marginXXS: 4,
    marginXS: 8,
    lineWidthFocus: 4,
    lineWidthBold: 2,
    lineWidth: 1,
    lineHeight: 1.2,
    fontSizeLG: 16,
    fontSize: 14,
    controlItemBgHover: "rgba(0, 0, 0, 0.04)",
    controlItemBgActive: "#fff8f0",
    controlInteractiveSize: 16,
    controlHeightSM: 24,
    borderRadiusSM: 4,
    borderRadius: 6,
    colorWhite: "#ffffff",
    colorTextLightSolid: "#ffffff",
    colorTextDisabled: "rgba(0, 0, 0, 0.25)",
    colorText: "rgba(0, 0, 0, 0.88)",
    colorPrimaryHover: "#ff944d",
    colorPrimaryBorder: "#ffcb9e",
    colorPrimary: "#f37022",
    colorBorder: "#d9d9d9",
    colorBgContainerDisabled: "rgba(0, 0, 0, 0.04)",
    colorBgContainer: "#ffffff",
    titleHeight: 24,
    titleHeightLg: 40,
    nodeSelectedBg: "#fff8f0",
    nodeHoverBg: "rgba(0, 0, 0, 0.04)",
    directoryNodeSelectedColor: "#ffffff",
    directoryNodeSelectedBg: "#f37022",
    fontFamily: "Inter"
  },
  Tag: {
    paddingXXS: 4,
    marginXS: 8,
    lineWidth: 1,
    lineHeightSM: 1.4,
    fontSizeSM: 14,
    fontSizeIcon: 12,
    fontSize: 14,
    borderRadiusSM: 4,
    colorTextLightSolid: "#ffffff",
    colorTextHeading: "rgba(0, 0, 0, 0.88)",
    colorTextDescription: "rgba(0, 0, 0, 0.45)",
    colorText: "rgba(0, 0, 0, 0.88)",
    colorPrimaryHover: "#ff944d",
    colorPrimaryActive: "#cc5012",
    colorPrimary: "#f37022",
    colorFillTertiary: "rgba(0, 0, 0, 0.04)",
    colorFillSecondary: "rgba(0, 0, 0, 0.06)",
    colorFillQuaternary: "rgba(0, 0, 0, 0.02)",
    fontFamily: "Inter",
    statusDefaultBg: "rgba(0, 0, 0, 0.02)",
    statusDefaultBorder: "#d9d9d9",
    statusDefaultText: "rgba(0, 0, 0, 0.88)",
    statusErrorBg: "#fff1f0",
    statusErrorBorder: "#ffccc7",
    statusErrorText: "#ff4d4f",
    statusProcessingBg: "#e6f4ff",
    statusProcessingBorder: "#91caff",
    statusProcessingText: "#1677ff",
    statusWarningBg: "#fffbe6",
    statusWarningBorder: "#ffe58f",
    statusWarningText: "#d48806",
    statusSuccessBg: "#f6ffed",
    statusSuccessBorder: "#b7eb8f",
    statusSuccessText: "#389e0d",
    colorfulMagentaText: "#eb2f96",
    colorfulMagentaBg: "#fff0f6",
    colorfulMagentaBorder: "#ffadd2",
    colorfulRedText: "#f5222d",
    colorfulRedBg: "#fff1f0",
    colorfulRedBorder: "#ffa39e",
    colorfulVolcanoText: "#fa541c",
    colorfulVolcanoBg: "#fff2e8",
    colorfulVolcanoBorder: "#ffbb96",
    colorfulOrangeText: "#f37022",
    colorfulOrangeBg: "#fff8f0",
    colorfulOrangeBorder: "#ffcb9e",
    colorfulGoldText: "#d48806",
    colorfulGoldBg: "#fffbe6",
    colorfulGoldBorder: "#ffe58f",
    colorfulLimeText: "#7cb305",
    colorfulLimeBg: "#fcffe6",
    colorfulLimeBorder: "#eaff8f",
    colorfulGreenText: "#389e0d",
    colorfulGreenBg: "#f6ffed",
    colorfulGreenBorder: "#b7eb8f",
    colorfulCyanText: "#08979c",
    colorfulCyanBg: "#e6fffb",
    colorfulCyanBorder: "#87e8de",
    colorfulBlueText: "#1677ff",
    colorfulBlueBg: "#e6f4ff",
    colorfulBlueBorder: "#91caff",
    colorfulGeekblueText: "#2f54eb",
    colorfulGeekblueBg: "#f0f5ff",
    colorfulGeekblueBorder: "#adc6ff",
    colorfulPurpleText: "#722ed1",
    colorfulPurpleBg: "#f9f0ff",
    colorfulPurpleBorder: "#d3adf7"
  },
  Filter: {
    controlMaxWidth: 450
  },
  Statistic: {
    padding: 16,
    marginXXS: 4,
    lineHeight: 1.2,
    fontSizeHeading3: 24,
    fontSize: 14,
    colorTextHeading: "rgba(0, 0, 0, 0.88)",
    colorTextDescription: "rgba(0, 0, 0, 0.45)",
    colorText: "rgba(0, 0, 0, 0.88)",
    contentFontSize: 24,
    titleFontSize: 14,
    fontFamily: "Inter"
  },
  Skeleton: {
    padding: 16,
    marginXXS: 4,
    marginSM: 12,
    marginLG: 24,
    controlHeightXS: 16,
    controlHeightSM: 24,
    controlHeightLG: 40,
    controlHeight: 32,
    borderRadiusSM: 4,
    colorFillContent: "rgba(0, 0, 0, 0.06)",
    colorFill: "rgba(0, 0, 0, 0.15)"
  },
  Select: {
    paddingXXS: 4,
    paddingXS: 8,
    paddingSM: 12,
    lineWidth: 1,
    lineHeight: 1.5714285714285714,
    fontWeightStrong: 600,
    fontSizeSM: 12,
    fontSizeLG: 16,
    fontSizeIcon: 16,
    fontSize: 14,
    controlPaddingHorizontalSM: 8,
    controlPaddingHorizontal: 12,
    controlOutlineWidth: 2,
    controlOutline: "rgba(243, 112, 34, 0.1)",
    controlItemBgHover: "rgba(0, 0, 0, 0.04)",
    controlItemBgActive: "#ffffff",
    controlHeightXS: 16,
    controlHeightSM: 24,
    controlHeightLG: 40,
    controlHeight: 32,
    borderRadiusXS: 2,
    borderRadiusSM: 4,
    borderRadiusLG: 8,
    borderRadius: 6,
    colorWarningOutline: "rgba(255, 215, 5, 0.1)",
    colorWarningHover: "#ffd666",
    colorTextTertiary: "rgba(0, 0, 0, 0.45)",
    colorTextQuaternary: "rgba(0, 0, 0, 0.25)",
    colorTextPlaceholder: "rgba(0, 0, 0, 0.25)",
    colorTextDisabled: "rgba(0, 0, 0, 0.25)",
    colorTextDescription: "rgba(0, 0, 0, 0.45)",
    colorText: "rgba(0, 0, 0, 0.88)",
    colorPrimaryHover: "#ff944d",
    colorPrimary: "#f37022",
    colorIconHover: "rgba(0, 0, 0, 0.88)",
    colorIcon: "rgba(0, 0, 0, 0.45)",
    colorFillSecondary: "rgba(0, 0, 0, 0.06)",
    colorErrorOutline: "rgba(255, 38, 6, 0.06)",
    colorErrorHover: "#ff7875",
    colorBorder: "#d9d9d9",
    colorBgElevated: "#ffffff",
    colorBgContainerDisabled: "rgba(0, 0, 0, 0.04)",
    colorBgContainer: "#ffffff",
    hoverBorderColor: "#ff944d",
    singleItemHeightLG: 40,
    selectorBg: "#ffffff",
    optionSelectedColor: "rgba(0, 0, 0, 0.88)",
    optionSelectedBg: "#ffffff",
    optionLineHeight: 1.5714285714285714,
    optionHeight: 32,
    optionActiveBg: "rgba(0, 0, 0, 0.04)",
    optionFontSize: 14,
    optionSelectedFontWeight: 600,
    optionFontSizeIcon: 16,
    multipleSelectorBgDisabled: "rgba(0, 0, 0, 0.04)",
    multipleItemHeightLG: 32,
    multipleItemHeight: 24,
    multipleItemColorDisabled: "rgba(0, 0, 0, 0.25)",
    multipleItemBorderColorDisabled: "rgba(0, 0, 0, 0)",
    multipleItemBorderColor: "rgba(0, 0, 0, 0)",
    multipleItemBg: "rgba(0, 0, 0, 0.06)",
    clearBg: "#ffffff",
    fontFamily: "Inter",
    subtextFontSize: 13,
    menuItemSubtleColor: "rgba(0, 0, 0, 0.45)",
    menuItemDefaultColor: "rgba(0, 0, 0, 0.88)",
    customValueDescriptionColor: "rgba(0, 0, 0, 0.45)",
    customValueDefaultColor: "rgba(0, 0, 0, 0.88)",
    menuMaxHeight: 294,
    inputMaxHeightSM: 105,
    inputMaxHeight: 145,
    inputMaxHeightLG: 185,
    multipleItemMaxWidth: 150,
    selectIconSize: 16,
    selectBg: "rgba(0, 0, 0, 0.02)",
    selectIconColor: "rgba(0, 0, 0, 0.65)",
    selectMenuIconColor: "rgba(0, 0, 0, 0.65)",
    selectMenuIconActiveColor: "#1f1f1f",
    selectMenuIconSize: 16
  },
  Result: {
    paddingXS: 8,
    paddingXL: 32,
    paddingLG: 24,
    padding: 16,
    marginXS: 8,
    lineHeightHeading3: 32,
    lineHeight: 1.2,
    fontSizeHeading3: 24,
    fontSize: 14,
    colorWarning: "#faad14",
    colorTextHeading: "rgba(0, 0, 0, 0.88)",
    colorTextDescription: "rgba(0, 0, 0, 0.45)",
    colorSuccess: "#52c41a",
    colorInfo: "#f37022",
    colorFillAlter: "rgba(0, 0, 0, 0.02)",
    colorError: "#ff4d4f",
    iconFontSize: 72,
    subtitleFontSize: 14,
    titleFontSize: 24
  },
  Progress: {
    paddingXS: 8,
    marginXXS: 4,
    marginXS: 8,
    lineHeight: 1.2,
    fontSizeSM: 12,
    fontSize: 14,
    colorText: "rgba(0, 0, 0, 0.88)",
    colorSuccess: "#52c41a",
    colorFillSecondary: "rgba(0, 0, 0, 0.06)",
    colorError: "#ff4d4f",
    colorBgContainer: "#ffffff",
    remainingColor: "rgba(0, 0, 0, 0.06)",
    defaultColor: "#f37022",
    circleTextColor: "rgba(0, 0, 0, 0.88)",
    fontFamily: "Inter"
  },
  Popconfirm: {
    marginXXS: 4,
    marginXS: 8,
    fontWeightStrong: 600,
    fontSize: 14,
    colorWarning: "#faad14",
    colorTextHeading: "rgba(0, 0, 0, 0.88)",
    colorText: "rgba(0, 0, 0, 0.88)"
  },
  Pagination: {
    screenSM: 576,
    screenLG: 992,
    paddingXXS: 4,
    paddingSM: 12,
    marginXXS: 4,
    marginXS: 8,
    marginSM: 12,
    margin: 16,
    lineWidthFocus: 4,
    lineWidth: 1,
    lineHeightLG: 1.4,
    lineHeight: 1.2,
    fontWeightStrong: 600,
    fontSizeSM: 12,
    fontSizeLG: 16,
    fontSize: 14,
    controlPaddingHorizontalSM: 8,
    controlPaddingHorizontal: 12,
    controlOutlineWidth: 2,
    controlOutline: "rgba(243, 112, 34, 0.1)",
    controlItemBgActiveDisabled: "rgba(0, 0, 0, 0.15)",
    controlHeightSM: 24,
    controlHeightLG: 40,
    controlHeight: 32,
    borderRadiusSM: 4,
    borderRadiusLG: 8,
    borderRadius: 6,
    colorWarningOutline: "rgba(255, 215, 5, 0.1)",
    colorTextPlaceholder: "rgba(0, 0, 0, 0.25)",
    colorTextDisabled: "rgba(0, 0, 0, 0.25)",
    colorText: "rgba(0, 0, 0, 0.88)",
    colorPrimaryHover: "#ff944d",
    colorPrimaryBorder: "#ffcb9e",
    colorPrimary: "#f37022",
    colorFillAlter: "rgba(0, 0, 0, 0.02)",
    colorErrorOutline: "rgba(255, 38, 6, 0.06)",
    colorBorder: "#d9d9d9",
    colorBgTextHover: "rgba(0, 0, 0, 0.06)",
    colorBgTextActive: "rgba(0, 0, 0, 0.15)",
    colorBgContainerDisabled: "rgba(0, 0, 0, 0.04)",
    colorBgContainer: "#ffffff",
    itemSizeSM: 24,
    itemSize: 32,
    itemLinkBg: "#ffffff",
    itemInputBg: "#ffffff",
    itemBg: "#ffffff",
    itemActiveColorDisabled: "rgba(0, 0, 0, 0.25)",
    itemActiveBgDisabled: "rgba(0, 0, 0, 0.15)",
    itemActiveBg: "#ffffff",
    fontFamily: "Inter"
  },
  Modal: {
    screenSMMax: 767,
    paddingXS: 8,
    paddingMD: 20,
    paddingLG: 24,
    paddingContentHorizontalLG: 24,
    padding: 16,
    marginXS: 8,
    marginSM: 12,
    marginLG: 24,
    margin: 16,
    lineWidthFocus: 4,
    lineWidth: 1,
    lineHeightHeading5: 1.4,
    lineHeight: 1.375,
    fontWeightStrong: 600,
    fontSizeLG: 16,
    fontSizeHeading5: 16,
    fontSize: 14,
    borderRadiusSM: 4,
    borderRadiusLG: 8,
    colorWarning: "#faad14",
    colorTextHeading: "rgba(0, 0, 0, 0.88)",
    colorText: "rgba(0, 0, 0, 0.88)",
    colorSuccess: "#52c41a",
    colorPrimaryBorder: "#ffcb9e",
    colorIconHover: "rgba(0, 0, 0, 0.88)",
    colorIcon: "rgba(0, 0, 0, 0.45)",
    colorBgMask: "rgba(0, 0, 0, 0.45)",
    titleColor: "rgba(0, 0, 0, 0.88)",
    headerBg: "#ffffff",
    footerBg: "rgba(0, 0, 0, 0)",
    contentBg: "#ffffff",
    titleFontSize: 16,
    titleLineHeight: 1.375,
    fontFamily: "Inter",
    iconInfoColor: "rgba(0, 0, 0, 0.3)",
    iconErrorColor: "#ff4d4f",
    iconSuccessColor: "#52c41a",
    iconWarningColor: "#faad14",
    iconSize: 32
  },
  Message: {
    paddingXS: 8,
    paddingSM: 12,
    marginXS: 8,
    lineHeight: 1.2,
    fontSizeLG: 16,
    fontSize: 14,
    controlHeightLG: 40,
    borderRadiusLG: 8,
    colorWarning: "#faad14",
    colorText: "rgba(0, 0, 0, 0.88)",
    colorSuccess: "#52c41a",
    colorInfo: "#f37022",
    colorError: "#ff4d4f",
    contentBg: "#ffffff",
    fontFamily: "Inter"
  },
  List: {
    screenSM: 576,
    screenMD: 768,
    paddingXS: 8,
    paddingSM: 12,
    paddingLG: 24,
    paddingContentVerticalSM: 8,
    paddingContentVerticalLG: 16,
    paddingContentVertical: 12,
    paddingContentHorizontalLG: 24,
    paddingContentHorizontal: 16,
    padding: 16,
    marginXXS: 4,
    marginXXL: 48,
    marginSM: 12,
    marginLG: 24,
    margin: 16,
    lineWidth: 1,
    lineHeightLG: 1.4,
    lineHeight: 1.2,
    fontSizeSM: 12,
    fontSizeLG: 16,
    fontSize: 14,
    controlHeightLG: 40,
    controlHeight: 32,
    borderRadiusLG: 8,
    colorTextDisabled: "rgba(0, 0, 0, 0.25)",
    colorTextDescription: "rgba(0, 0, 0, 0.45)",
    colorText: "rgba(0, 0, 0, 0.88)",
    colorSplit: "rgba(0, 0, 0, 0.06)",
    colorPrimary: "#f37022",
    colorBorder: "#d9d9d9",
    headerBg: "rgba(0, 0, 0, 0)",
    footerBg: "rgba(0, 0, 0, 0)",
    avatarMarginRight: 16,
    descriptionFontSize: 14,
    fontFamily: "Inter"
  },
  FloatButton: {
    paddingXXS: 4,
    marginXXL: 48,
    marginLG: 24,
    margin: 16,
    lineWidth: 1,
    lineHeight: 1.2,
    fontSizeSM: 12,
    fontSizeLG: 16,
    fontSizeIcon: 12,
    fontSize: 14,
    controlItemBgHover: "rgba(0, 0, 0, 0.04)",
    controlHeightLG: 40,
    borderRadiusSM: 4,
    borderRadiusLG: 8,
    colorTextLightSolid: "#ffffff",
    colorText: "rgba(0, 0, 0, 0.88)",
    colorSplit: "rgba(0, 0, 0, 0.06)",
    colorPrimaryHover: "#ff944d",
    colorPrimary: "#f37022",
    colorFillContent: "rgba(0, 0, 0, 0.06)",
    colorBgElevated: "#ffffff",
    fontFamily: "Inter"
  },
  Empty: {
    borderRadiusSM: 3,
    colorBgContainer: "#ffffff",
    colorBgContainerDisabled: "#ffffff",
    colorBorder: "#d9d9d9",
    colorPrimary: "#f37022",
    colorPrimaryBorder: "#ffcb9e",
    colorPrimaryHover: "#ff944d",
    colorText: "rgba(0, 0, 0, 0.88)",
    colorTextDescription: "rgba(0, 0, 0, 0.45)",
    colorTextDisabled: "rgba(0, 0, 0, 0.25)",
    colorWhite: "#ffffff",
    controlInteractiveSize: 16,
    fontFamily: "Inter",
    fontSize: 14,
    fontSizeLG: 16,
    lineHeight: 1.2,
    lineWidth: 1,
    lineWidthBold: 2,
    lineWidthFocus: 4,
    marginXS: 8,
    paddingXS: 8
  },
  Dropdown: {
    sizePopupArrow: 16,
    paddingXXS: 4,
    paddingXS: 8,
    marginXXS: 4,
    marginXS: 8,
    lineWidthFocus: 4,
    lineHeight: 1.2,
    fontSizeSM: 12,
    fontSizeIcon: 12,
    fontSize: 14,
    controlPaddingHorizontal: 12,
    controlItemBgHover: "rgba(0, 0, 0, 0.04)",
    controlItemBgActiveHover: "#ffe3c7",
    controlItemBgActive: "#fff8f0",
    controlHeight: 32,
    borderRadiusXS: 2,
    borderRadiusSM: 4,
    borderRadiusLG: 8,
    colorTextLightSolid: "#ffffff",
    colorTextDisabled: "rgba(0, 0, 0, 0.25)",
    colorTextDescription: "rgba(0, 0, 0, 0.45)",
    colorText: "rgba(0, 0, 0, 0.88)",
    colorSplit: "rgba(0, 0, 0, 0.06)",
    colorPrimaryBorder: "#ffcb9e",
    colorPrimary: "#f37022",
    colorError: "#ff4d4f",
    colorBgElevated: "#ffffff",
    paddingBlock: 5,
    fontFamily: "Inter"
  },
  Drawer: {
    paddingXS: 8,
    paddingLG: 24,
    padding: 16,
    marginSM: 12,
    lineWidth: 1,
    lineHeightLG: 1.4,
    fontWeightStrong: 600,
    fontSizeLG: 16,
    colorText: "rgba(0, 0, 0, 0.88)",
    colorSplit: "rgba(0, 0, 0, 0.06)",
    colorIconHover: "rgba(0, 0, 0, 0.88)",
    colorIcon: "rgba(0, 0, 0, 0.45)",
    colorBgMask: "rgba(0, 0, 0, 0.45)",
    colorBgElevated: "#ffffff",
    lineWidthFocus: 4,
    width: 500,
    widthLG: 800,
    widthSM: 350,
    height: 450,
    heightSM: 300,
    heightLG: 600,
    maxWidth: 1e3,
    maxWidthSM: 800,
    maxWidthLG: 600,
    maxHeight: 900,
    maxHeightSM: 600,
    maxHeightLG: 1200,
    minWidth: 250,
    minWidthSM: 200,
    minWidthLG: 400,
    minHeight: 250,
    minHeightSM: 300,
    minHeightLG: 300,
    resizerWidth: 8,
    resizerBg: "#f0f0f0",
    resizerGutterBg: "rgba(0, 0, 0, 0.15)",
    resizerGutterHeight: 28,
    resizerGutterWidth: 2,
    resizerGutterBorderRadius: 1,
    iconSize: 20
  },
  Divider: {
    marginXS: 8,
    marginLG: 24,
    margin: 16,
    lineWidth: 1,
    fontSizeLG: 16,
    fontSize: 14,
    colorTextHeading: "rgba(0, 0, 0, 0.88)",
    colorText: "rgba(0, 0, 0, 0.88)",
    colorSplit: "rgba(0, 0, 0, 0.06)",
    lineHeight: 1.2,
    fontFamily: "Inter"
  },
  Descriptions: {
    paddingXS: 8,
    paddingSM: 12,
    paddingLG: 24,
    padding: 16,
    marginXXS: 4,
    marginXS: 8,
    lineWidth: 1,
    lineHeightSM: 20,
    lineHeightLG: 1.4,
    lineHeight: 1.2,
    fontWeightStrong: 600,
    fontSizeSM: 12,
    fontSizeLG: 16,
    fontSize: 14,
    borderRadiusLG: 8,
    colorTextTertiary: "rgba(0, 0, 0, 0.45)",
    colorTextSecondary: "rgba(0, 0, 0, 0.65)",
    colorText: "rgba(0, 0, 0, 0.88)",
    colorSplit: "rgba(0, 0, 0, 0.06)",
    colorFillAlter: "rgba(0, 0, 0, 0.02)",
    titleColor: "rgba(0, 0, 0, 0.88)",
    labelBg: "rgba(0, 0, 0, 0.02)",
    contentColor: "rgba(0, 0, 0, 0.88)",
    fontFamily: "Inter"
  },
  DatePicker: {
    sizePopupArrow: 16,
    paddingXXS: 4,
    paddingXS: 8,
    paddingSM: 12,
    padding: 16,
    marginXXS: 4,
    marginXS: 8,
    lineWidthBold: 2,
    lineWidth: 1,
    lineHeightLG: 1.4,
    lineHeight: 1.5714285714285714,
    fontWeightStrong: 600,
    fontSizeLG: 16,
    fontSize: 14,
    controlPaddingHorizontalSM: 8,
    controlPaddingHorizontal: 12,
    controlOutlineWidth: 2,
    controlOutline: "rgba(243, 112, 34, 0.1)",
    controlItemBgHover: "rgba(0, 0, 0, 0.04)",
    controlItemBgActive: "#fff8f0",
    controlHeightSM: 24,
    controlHeightLG: 40,
    controlHeight: 32,
    borderRadiusXS: 2,
    borderRadiusSM: 4,
    borderRadiusLG: 8,
    borderRadius: 6,
    colorWarningOutline: "rgba(255, 215, 5, 0.1)",
    colorWarningHover: "#ffd666",
    colorWarning: "#faad14",
    colorTextQuaternary: "rgba(0, 0, 0, 0.25)",
    colorTextPlaceholder: "rgba(0, 0, 0, 0.25)",
    colorTextLightSolid: "#ffffff",
    colorTextHeading: "rgba(0, 0, 0, 0.88)",
    colorTextDisabled: "rgba(0, 0, 0, 0.25)",
    colorTextDescription: "rgba(0, 0, 0, 0.45)",
    colorText: "rgba(0, 0, 0, 0.88)",
    colorSplit: "rgba(0, 0, 0, 0.06)",
    colorPrimaryHover: "#ff944d",
    colorPrimaryBorder: "#ffcb9e",
    colorPrimary: "#f37022",
    colorLinkHover: "#ff944d",
    colorLinkActive: "#cc5012",
    colorLink: "#f37022",
    colorIconHover: "rgba(0, 0, 0, 0.88)",
    colorIcon: "rgba(0, 0, 0, 0.45)",
    colorFillAlter: "rgba(0, 0, 0, 0.02)",
    colorErrorOutline: "rgba(255, 38, 6, 0.06)",
    colorErrorHover: "#ff7875",
    colorError: "#ff4d4f",
    colorBorder: "#d9d9d9",
    colorBgElevated: "#ffffff",
    colorBgContainerDisabled: "rgba(0, 0, 0, 0.04)",
    colorBgContainer: "#ffffff",
    hoverBorderColor: "#ff944d",
    cellHoverBg: "rgba(0, 0, 0, 0.04)",
    cellHeight: 24,
    activeBorderColor: "#f37022",
    paddingInline: 11,
    paddingInlineSM: 7,
    colorFillTertiary: "rgba(0, 0, 0, 0.04)",
    colorErrorBg: "#fff2f0",
    colorWarningBg: "#fffbe6",
    colorWarningText: "#faad14",
    colorErrorText: "#ff4d4f",
    colorWarningBgHover: "#fff1b8",
    colorErrorBgHover: "#fff1f0",
    activeBg: "#ffffff",
    hoverBg: "#ffffff",
    cellBgDisabled: "rgba(0, 0, 0, 0.04)",
    cellActiveWithRangeBg: "#fff8f0",
    cellHoverWithRangeBg: "#c8dfff",
    cellRangeBorderColor: "#7cb3ff",
    multipleItemBg: "rgba(0, 0, 0, 0.06)",
    multipleItemBorderColor: "rgba(0, 0, 0, 0)",
    multipleItemBorderColorDisabled: "rgba(0, 0, 0, 0)",
    multipleItemColorDisabled: "rgba(0, 0, 0, 0.25)",
    multipleSelectorBgDisabled: "rgba(0, 0, 0, 0.04)",
    cellWidth: 36,
    multipleItemHeight: 24,
    multipleItemHeightLG: 32,
    multipleItemHeightSM: 16,
    paddingBlock: 4,
    paddingBlockLG: 7,
    paddingBlockSM: 0,
    "paddingInline 2": 11,
    presetsMaxWidth: 200,
    presetsWidth: 120,
    textHeight: 40,
    timeCellHeight: 28,
    timeColumnHeight: 224,
    timeColumnWidth: 56,
    withoutTimeCellHeight: 66,
    inputFontSize: 14,
    inputFontSizeLG: 16,
    inputFontSizeSM: 12,
    fontHeight: 22,
    fontHeightLG: 24,
    fontFamily: "Inter"
  },
  Collapse: {
    paddingXXS: 4,
    paddingXS: 8,
    paddingSM: 12,
    paddingLG: 24,
    padding: 16,
    marginSM: 12,
    lineWidth: 1,
    lineHeight: 1.2,
    fontSizeLG: 16,
    fontSizeIcon: 16,
    fontSize: 14,
    borderRadiusLG: 8,
    colorTextHeading: "rgba(0, 0, 0, 0.88)",
    colorTextDisabled: "rgba(0, 0, 0, 0.25)",
    colorText: "rgba(0, 0, 0, 0.88)",
    colorFillAlter: "rgba(0, 0, 0, 0.02)",
    colorBorder: "#d9d9d9",
    colorBgContainer: "#ffffff",
    headerBg: "rgba(0, 0, 0, 0.02)",
    contentBg: "#ffffff",
    fontHeight: 22,
    fontHeightLG: 24,
    lineHeightLG: 1.4,
    fontFamily: "Inter"
  },
  Checkbox: {
    paddingXS: 8,
    marginXS: 8,
    lineWidthFocus: 4,
    lineWidthBold: 2,
    lineWidth: 1,
    lineHeight: 1.2,
    fontSizeLG: 16,
    fontSize: 14,
    controlInteractiveSize: 16,
    borderRadiusSM: 4,
    colorWhite: "#ffffff",
    colorTextDisabled: "rgba(0, 0, 0, 0.25)",
    colorText: "rgba(0, 0, 0, 0.88)",
    colorPrimaryHover: "#ff944d",
    colorPrimaryBorder: "#ffcb9e",
    colorPrimary: "#f37022",
    colorBorder: "#d9d9d9",
    colorBgContainerDisabled: "rgba(0, 0, 0, 0.04)",
    colorBgContainer: "#ffffff",
    fontFamily: "Inter"
  },
  Breadcrumb: {
    paddingXXS: 4,
    marginXXS: 4,
    marginXS: 8,
    lineWidthFocus: 4,
    lineHeight: 1.2,
    fontSizeIcon: 14,
    fontSize: 14,
    borderRadiusSM: 4,
    colorPrimaryBorder: "#ffcb9e",
    colorBgTextHover: "rgba(0, 0, 0, 0.06)",
    separatorColor: "rgba(0, 0, 0, 0.45)",
    linkHoverColor: "rgba(0, 0, 0, 0.88)",
    linkColor: "rgba(0, 0, 0, 0.45)",
    lastItemColor: "rgba(0, 0, 0, 0.88)",
    itemColor: "rgba(0, 0, 0, 0.45)",
    separatorMargin: 8,
    iconFontSize: 14,
    fontHeight: 22,
    fontFamily: "Inter"
  },
  Anchor: {
    paddingXXS: 4,
    lineWidthBold: 2,
    lineHeight: 1.2,
    fontSizeLG: 16,
    fontSize: 14,
    colorText: "rgba(0, 0, 0, 0.88)",
    colorSplit: "rgba(0, 0, 0, 0.06)",
    colorPrimary: "#f37022",
    linkPaddingInlineStart: 16,
    linkPaddingBlock: 4,
    fontFamily: "Inter"
  },
  Alert: {
    paddingMD: 20,
    paddingContentVerticalSM: 8,
    paddingContentHorizontalLG: 24,
    marginXS: 8,
    marginSM: 12,
    lineWidth: 1,
    lineHeight: 1.2,
    fontSizeLG: 16,
    fontSizeIcon: 12,
    fontSizeHeading3: 24,
    fontSize: 14,
    borderRadiusLG: 8,
    colorWarningBorder: "#ffe58f",
    colorWarningBg: "#fffbe6",
    colorWarning: "#faad14",
    colorTextHeading: "rgba(0, 0, 0, 0.88)",
    colorText: "rgba(0, 0, 0, 0.88)",
    colorSuccessBorder: "#b7eb8f",
    colorSuccessBg: "#f6ffed",
    colorSuccess: "#52c41a",
    colorInfoBorder: "#ffcb9e",
    colorInfoBg: "#fff8f0",
    colorInfo: "#f37022",
    colorIconHover: "rgba(0, 0, 0, 0.88)",
    colorIcon: "rgba(0, 0, 0, 0.45)",
    colorErrorBorder: "#ffccc7",
    colorErrorBg: "#fff2f0",
    colorError: "#ff4d4f",
    withDescriptionIconSize: 24,
    fontFamily: "Inter"
  },
  Space: {
    paddingXS: 8,
    paddingLG: 24,
    padding: 16
  },
  AutoComplete: {
    paddingXXS: 4,
    paddingXS: 8,
    paddingSM: 12,
    lineWidth: 1,
    lineHeight: 1.2,
    controlPaddingHorizontalSM: 8,
    controlPaddingHorizontal: 12,
    controlOutlineWidth: 2,
    controlOutline: "rgba(243, 112, 34, 0.1)",
    controlItemBgHover: "rgba(0, 0, 0, 0.04)",
    controlItemBgActive: "#fff8f0",
    controlHeightXS: 16,
    controlHeightSM: 24,
    controlHeightLG: 40,
    controlHeight: 32,
    borderRadiusXS: 2,
    borderRadiusSM: 4,
    borderRadiusLG: 8,
    borderRadius: 6,
    colorWarningOutline: "rgba(255, 215, 5, 0.1)",
    colorWarningHover: "#ffd666",
    colorWarning: "#faad14",
    colorTextTertiary: "rgba(0, 0, 0, 0.45)",
    colorTextQuaternary: "rgba(0, 0, 0, 0.25)",
    colorTextPlaceholder: "rgba(0, 0, 0, 0.25)",
    colorTextDisabled: "rgba(0, 0, 0, 0.25)",
    colorTextDescription: "rgba(0, 0, 0, 0.45)",
    colorText: "rgba(0, 0, 0, 0.88)",
    colorPrimaryHover: "#ff944d",
    colorPrimary: "#f37022",
    colorIconHover: "rgba(0, 0, 0, 0.88)",
    colorIcon: "rgba(0, 0, 0, 0.45)",
    colorFillSecondary: "rgba(0, 0, 0, 0.06)",
    colorErrorOutline: "rgba(255, 38, 6, 0.06)",
    colorErrorHover: "#ff7875",
    colorError: "#ff4d4f",
    colorBorder: "#d9d9d9",
    colorBgElevated: "#ffffff",
    colorBgContainerDisabled: "rgba(0, 0, 0, 0.04)",
    colorBgContainer: "#ffffff",
    optionActiveBg: "rgba(0, 0, 0, 0.04)",
    optionHeight: 32,
    optionFontSize: 14,
    fontFamily: "Inter",
    fontSize: 14,
    fontSizeIcon: 12,
    fontSizeLG: 16,
    fontSizeSM: 12
  },
  Layout: {
    bodyBg: "#ffffff",
    borderRadius: 6,
    colorText: "rgba(0, 0, 0, 0.88)",
    fontSize: 14,
    fontSizeXL: 20,
    footerBg: "#f5f5f5",
    headerBg: "#ffffff",
    headerColor: "rgba(0, 0, 0, 0.88)",
    headerHeight: 44,
    lightSiderBg: "#ffffff",
    lightTriggerBg: "#ffffff",
    lightTriggerColor: "rgba(0, 0, 0, 0.88)",
    siderBg: "#212121",
    triggerBg: "#002140",
    triggerColor: "#ffffff",
    triggerHeight: 48,
    zeroTriggerHeight: 40,
    zeroTriggerWidth: 40,
    headerSplitColor: "rgba(0, 0, 0, 0.06)",
    panelPadding: 24,
    panelMargin: 16,
    panelWidth: 300,
    panelSplitColor: "rgba(0, 0, 0, 0.06)"
  },
  Mentions: {
    fontFamily: "Inter",
    fontSize: 14,
    lineHeight: 1.2
  },
  Icon: {
    defaultColor: "rgba(0, 0, 0, 0.65)",
    primaryColor: "#f37022"
  }
}, DEFAULT_THEME = {
  $schema,
  algorithm,
  id,
  token,
  components
}, THEME_LOCAL_STORAGE_PROP_DEFAULT_NAME = "theme", DEFAULT_THEME_ID = DEFAULT_THEME.id, _ThemeRegistry = class _ThemeRegistry {
  constructor() {
    /**
     * Таблица тем с идентификаторами в роли ключей.
     */
    __publicField(this, "themes", {});
    const { algorithm: algorithm2, id: id2, token: token2, components: components2 } = DEFAULT_THEME;
    this.registerTheme(id2, algorithm2, token2, components2);
  }
  /**
   * Возвращает инстанс регистра тем.
   */
  static getInstance() {
    return this.instance || (this.instance = new this()), this.instance;
  }
  /**
   * Получает значение `id` выбранной темы из локального хранилища.
   */
  get selectedId() {
    return localStorage.getItem(_ThemeRegistry.themeLocalStoragePropertyName) || DEFAULT_THEME.id;
  }
  /**
   * Сохраняет значение `id` выбранной темы в локальное хранилище.
   */
  set selectedId(id2) {
    localStorage.setItem(_ThemeRegistry.themeLocalStoragePropertyName, id2);
  }
  /**
   * Readonly-геттер, возвращающий выбранную тему.
   */
  get theme() {
    return this.themes[this.selectedId];
  }
  /**
   * Сохраняет алгоритм и значения токенов выбранной темы по её `id`.
   */
  registerTheme(id2, algorithm2, token2, components2) {
    this.themes[id2] = {
      algorithm: _ThemeRegistry.ALGORITHM_MAP[algorithm2],
      token: token2,
      components: components2
    };
  }
  /**
   * Возвращает значение темы по её `id`.
   */
  getTheme(id2) {
    return this.themes[id2];
  }
};
__name(_ThemeRegistry, "ThemeRegistry"), __publicField(_ThemeRegistry, "instance"), /**
 * Имя свойства локального хранилища, в котором хранится `id` выбранной темы.
 * @default 'theme'
 */
__publicField(_ThemeRegistry, "themeLocalStoragePropertyName", THEME_LOCAL_STORAGE_PROP_DEFAULT_NAME), /**
 * Маппинг алгоритмов темы по имени, указанному в её конфиге.
 * Поддерживает два варианта: тёмная тема и светлая.
 */
__publicField(_ThemeRegistry, "ALGORITHM_MAP", {
  dark: theme.darkAlgorithm,
  light: theme.defaultAlgorithm
});
let ThemeRegistry = _ThemeRegistry;
const registerTheme = /* @__PURE__ */ __name(({ id: id2, algorithm: algorithm2, token: token2, components: components2 }) => {
  ThemeRegistry.getInstance().registerTheme(id2, algorithm2, token2, components2);
}, "registerTheme"), useThemeRegistry = /* @__PURE__ */ __name(() => {
  const [themeId, setThemeId] = React__default.useState(ThemeRegistry.getInstance().selectedId);
  return [
    ThemeRegistry.getInstance().getTheme(themeId),
    /**
     * Помечает выбранную тему в качестве активной.
     *
     * @param {string} id - Идентификатор темы.
     * @param {boolean} [isStrict] - Флаг строгости проверки.
     *
     * @throws {ReferenceError} Если флаг `strict` явно не отмечен как false, а тема не зарегистрирована.
     */
    (id2, isStrict = !0) => {
      setThemeId(() => {
        if (isStrict && !ThemeRegistry.getInstance().getTheme(id2))
          throw new ReferenceError(`Theme '${id2}' is not registered!`);
        return ThemeRegistry.getInstance().selectedId = id2, id2;
      });
    }
  ];
}, "useThemeRegistry"), ThemeContext = createContext$1({
  theme: ThemeRegistry.getInstance().theme,
  setTheme: /* @__PURE__ */ __name(() => {
  }, "setTheme")
}), useTheme = /* @__PURE__ */ __name(() => useContext$1(ThemeContext), "useTheme"), warn = /* @__PURE__ */ __name((...args) => {
  console != null && console.warn && (isString(args[0]) && (args[0] = `react-i18next:: ${args[0]}`), console.warn(...args));
}, "warn"), alreadyWarned = {}, warnOnce = /* @__PURE__ */ __name((...args) => {
  isString(args[0]) && alreadyWarned[args[0]] || (isString(args[0]) && (alreadyWarned[args[0]] = /* @__PURE__ */ new Date()), warn(...args));
}, "warnOnce"), loadedClb = /* @__PURE__ */ __name((i18n, cb) => () => {
  if (i18n.isInitialized)
    cb();
  else {
    const initialized = /* @__PURE__ */ __name(() => {
      setTimeout(() => {
        i18n.off("initialized", initialized);
      }, 0), cb();
    }, "initialized");
    i18n.on("initialized", initialized);
  }
}, "loadedClb"), loadNamespaces = /* @__PURE__ */ __name((i18n, ns, cb) => {
  i18n.loadNamespaces(ns, loadedClb(i18n, cb));
}, "loadNamespaces"), loadLanguages = /* @__PURE__ */ __name((i18n, lng, ns, cb) => {
  isString(ns) && (ns = [ns]), ns.forEach((n2) => {
    i18n.options.ns.indexOf(n2) < 0 && i18n.options.ns.push(n2);
  }), i18n.loadLanguages(lng, loadedClb(i18n, cb));
}, "loadLanguages"), hasLoadedNamespace = /* @__PURE__ */ __name((ns, i18n, options = {}) => !i18n.languages || !i18n.languages.length ? (warnOnce("i18n.languages were undefined or empty", i18n.languages), !0) : i18n.hasLoadedNamespace(ns, {
  lng: options.lng,
  precheck: /* @__PURE__ */ __name((i18nInstance2, loadNotPending) => {
    var _a;
    if (((_a = options.bindI18n) == null ? void 0 : _a.indexOf("languageChanging")) > -1 && i18nInstance2.services.backendConnector.backend && i18nInstance2.isLanguageChangingTo && !loadNotPending(i18nInstance2.isLanguageChangingTo, ns)) return !1;
  }, "precheck")
}), "hasLoadedNamespace"), isString = /* @__PURE__ */ __name((obj) => typeof obj == "string", "isString"), isObject = /* @__PURE__ */ __name((obj) => typeof obj == "object" && obj !== null, "isObject"), matchHtmlEntity = /&(?:amp|#38|lt|#60|gt|#62|apos|#39|quot|#34|nbsp|#160|copy|#169|reg|#174|hellip|#8230|#x2F|#47);/g, htmlEntities = {
  "&amp;": "&",
  "&#38;": "&",
  "&lt;": "<",
  "&#60;": "<",
  "&gt;": ">",
  "&#62;": ">",
  "&apos;": "'",
  "&#39;": "'",
  "&quot;": '"',
  "&#34;": '"',
  "&nbsp;": " ",
  "&#160;": " ",
  "&copy;": "©",
  "&#169;": "©",
  "&reg;": "®",
  "&#174;": "®",
  "&hellip;": "…",
  "&#8230;": "…",
  "&#x2F;": "/",
  "&#47;": "/"
}, unescapeHtmlEntity = /* @__PURE__ */ __name((m2) => htmlEntities[m2], "unescapeHtmlEntity"), unescape = /* @__PURE__ */ __name((text) => text.replace(matchHtmlEntity, unescapeHtmlEntity), "unescape");
let defaultOptions = {
  bindI18n: "languageChanged",
  bindI18nStore: "",
  transEmptyNodeValue: "",
  transSupportBasicHtmlNodes: !0,
  transWrapTextNodes: "",
  transKeepBasicHtmlNodesFor: ["br", "strong", "i", "p"],
  useSuspense: !0,
  unescape
};
const setDefaults = /* @__PURE__ */ __name((options = {}) => {
  defaultOptions = {
    ...defaultOptions,
    ...options
  };
}, "setDefaults"), getDefaults$2 = /* @__PURE__ */ __name(() => defaultOptions, "getDefaults$2");
let i18nInstance;
const setI18n = /* @__PURE__ */ __name((instance2) => {
  i18nInstance = instance2;
}, "setI18n"), getI18n = /* @__PURE__ */ __name(() => i18nInstance, "getI18n"), initReactI18next = {
  type: "3rdParty",
  init(instance2) {
    setDefaults(instance2.options.react), setI18n(instance2);
  }
}, I18nContext = createContext$1(), _ReportNamespaces = class _ReportNamespaces {
  constructor() {
    this.usedNamespaces = {};
  }
  addUsedNamespaces(namespaces) {
    namespaces.forEach((ns) => {
      var _a;
      (_a = this.usedNamespaces)[ns] ?? (_a[ns] = !0);
    });
  }
  getUsedNamespaces() {
    return Object.keys(this.usedNamespaces);
  }
};
__name(_ReportNamespaces, "ReportNamespaces");
let ReportNamespaces = _ReportNamespaces;
const usePrevious = /* @__PURE__ */ __name((value, ignore2) => {
  const ref = useRef();
  return useEffect(() => {
    ref.current = value;
  }, [value, ignore2]), ref.current;
}, "usePrevious"), alwaysNewT = /* @__PURE__ */ __name((i18n, language, namespace, keyPrefix) => i18n.getFixedT(language, namespace, keyPrefix), "alwaysNewT"), useMemoizedT = /* @__PURE__ */ __name((i18n, language, namespace, keyPrefix) => useCallback(alwaysNewT(i18n, language, namespace, keyPrefix), [i18n, language, namespace, keyPrefix]), "useMemoizedT"), useTranslation = /* @__PURE__ */ __name((ns, props = {}) => {
  var _a, _b, _c, _d;
  const {
    i18n: i18nFromProps
  } = props, {
    i18n: i18nFromContext,
    defaultNS: defaultNSFromContext
  } = useContext$1(I18nContext) || {}, i18n = i18nFromProps || i18nFromContext || getI18n();
  if (i18n && !i18n.reportNamespaces && (i18n.reportNamespaces = new ReportNamespaces()), !i18n) {
    warnOnce("You will need to pass in an i18next instance by using initReactI18next");
    const notReadyT = /* @__PURE__ */ __name((k, optsOrDefaultValue) => isString(optsOrDefaultValue) ? optsOrDefaultValue : isObject(optsOrDefaultValue) && isString(optsOrDefaultValue.defaultValue) ? optsOrDefaultValue.defaultValue : Array.isArray(k) ? k[k.length - 1] : k, "notReadyT"), retNotReady = [notReadyT, {}, !1];
    return retNotReady.t = notReadyT, retNotReady.i18n = {}, retNotReady.ready = !1, retNotReady;
  }
  (_a = i18n.options.react) != null && _a.wait && warnOnce("It seems you are still using the old wait option, you may migrate to the new useSuspense behaviour.");
  const i18nOptions = {
    ...getDefaults$2(),
    ...i18n.options.react,
    ...props
  }, {
    useSuspense,
    keyPrefix
  } = i18nOptions;
  let namespaces = defaultNSFromContext || ((_b = i18n.options) == null ? void 0 : _b.defaultNS);
  namespaces = isString(namespaces) ? [namespaces] : namespaces || ["translation"], (_d = (_c = i18n.reportNamespaces).addUsedNamespaces) == null || _d.call(_c, namespaces);
  const ready = (i18n.isInitialized || i18n.initializedStoreOnce) && namespaces.every((n2) => hasLoadedNamespace(n2, i18n, i18nOptions)), memoGetT = useMemoizedT(i18n, props.lng || null, i18nOptions.nsMode === "fallback" ? namespaces : namespaces[0], keyPrefix), getT = /* @__PURE__ */ __name(() => memoGetT, "getT"), getNewT = /* @__PURE__ */ __name(() => alwaysNewT(i18n, props.lng || null, i18nOptions.nsMode === "fallback" ? namespaces : namespaces[0], keyPrefix), "getNewT"), [t2, setT] = useState(getT);
  let joinedNS = namespaces.join();
  props.lng && (joinedNS = `${props.lng}${joinedNS}`);
  const previousJoinedNS = usePrevious(joinedNS), isMounted = useRef(!0);
  useEffect(() => {
    const {
      bindI18n,
      bindI18nStore
    } = i18nOptions;
    isMounted.current = !0, !ready && !useSuspense && (props.lng ? loadLanguages(i18n, props.lng, namespaces, () => {
      isMounted.current && setT(getNewT);
    }) : loadNamespaces(i18n, namespaces, () => {
      isMounted.current && setT(getNewT);
    })), ready && previousJoinedNS && previousJoinedNS !== joinedNS && isMounted.current && setT(getNewT);
    const boundReset = /* @__PURE__ */ __name(() => {
      isMounted.current && setT(getNewT);
    }, "boundReset");
    return bindI18n && (i18n == null || i18n.on(bindI18n, boundReset)), bindI18nStore && (i18n == null || i18n.store.on(bindI18nStore, boundReset)), () => {
      isMounted.current = !1, i18n && (bindI18n == null || bindI18n.split(" ").forEach((e2) => i18n.off(e2, boundReset))), bindI18nStore && i18n && bindI18nStore.split(" ").forEach((e2) => i18n.store.off(e2, boundReset));
    };
  }, [i18n, joinedNS]), useEffect(() => {
    isMounted.current && ready && setT(getT);
  }, [i18n, keyPrefix, ready]);
  const ret = [t2, i18n, ready];
  if (ret.t = t2, ret.i18n = i18n, ret.ready = ready, ready || !ready && !useSuspense) return ret;
  throw new Promise((resolve) => {
    props.lng ? loadLanguages(i18n, props.lng, namespaces, () => resolve()) : loadNamespaces(i18n, namespaces, () => resolve());
  });
}, "useTranslation");
var ru = { exports: {} };
(function(module2, exports) {
  (function(_2, t2) {
    module2.exports = t2(requireDayjs_min());
  })(commonjsGlobal, function(_2) {
    function t2(_3) {
      return _3 && typeof _3 == "object" && "default" in _3 ? _3 : { default: _3 };
    }
    __name(t2, "t");
    var e2 = t2(_2), n2 = "января_февраля_марта_апреля_мая_июня_июля_августа_сентября_октября_ноября_декабря".split("_"), s = "январь_февраль_март_апрель_май_июнь_июль_август_сентябрь_октябрь_ноябрь_декабрь".split("_"), r2 = "янв._февр._мар._апр._мая_июня_июля_авг._сент._окт._нояб._дек.".split("_"), o2 = "янв._февр._март_апр._май_июнь_июль_авг._сент._окт._нояб._дек.".split("_"), i = /D[oD]?(\[[^[\]]*\]|\s)+MMMM?/;
    function d(_3, t3, e3) {
      var n3, s2;
      return e3 === "m" ? t3 ? "минута" : "минуту" : _3 + " " + (n3 = +_3, s2 = { mm: t3 ? "минута_минуты_минут" : "минуту_минуты_минут", hh: "час_часа_часов", dd: "день_дня_дней", MM: "месяц_месяца_месяцев", yy: "год_года_лет" }[e3].split("_"), n3 % 10 == 1 && n3 % 100 != 11 ? s2[0] : n3 % 10 >= 2 && n3 % 10 <= 4 && (n3 % 100 < 10 || n3 % 100 >= 20) ? s2[1] : s2[2]);
    }
    __name(d, "d");
    var u = /* @__PURE__ */ __name(function(_3, t3) {
      return i.test(t3) ? n2[_3.month()] : s[_3.month()];
    }, "u");
    u.s = s, u.f = n2;
    var a = /* @__PURE__ */ __name(function(_3, t3) {
      return i.test(t3) ? r2[_3.month()] : o2[_3.month()];
    }, "a");
    a.s = o2, a.f = r2;
    var m2 = { name: "ru", weekdays: "воскресенье_понедельник_вторник_среда_четверг_пятница_суббота".split("_"), weekdaysShort: "вск_пнд_втр_срд_чтв_птн_сбт".split("_"), weekdaysMin: "вс_пн_вт_ср_чт_пт_сб".split("_"), months: u, monthsShort: a, weekStart: 1, yearStart: 4, formats: { LT: "H:mm", LTS: "H:mm:ss", L: "DD.MM.YYYY", LL: "D MMMM YYYY г.", LLL: "D MMMM YYYY г., H:mm", LLLL: "dddd, D MMMM YYYY г., H:mm" }, relativeTime: { future: "через %s", past: "%s назад", s: "несколько секунд", m: d, mm: d, h: "час", hh: d, d: "день", dd: d, M: "месяц", MM: d, y: "год", yy: d }, ordinal: /* @__PURE__ */ __name(function(_3) {
      return _3;
    }, "ordinal"), meridiem: /* @__PURE__ */ __name(function(_3) {
      return _3 < 4 ? "ночи" : _3 < 12 ? "утра" : _3 < 17 ? "дня" : "вечера";
    }, "meridiem") };
    return e2.default.locale(m2, null, !0), m2;
  });
})(ru);
const {
  slice,
  forEach
} = [];
function defaults(obj) {
  return forEach.call(slice.call(arguments, 1), (source) => {
    if (source)
      for (const prop in source)
        obj[prop] === void 0 && (obj[prop] = source[prop]);
  }), obj;
}
__name(defaults, "defaults");
const fieldContentRegExp = /^[\u0009\u0020-\u007e\u0080-\u00ff]+$/, serializeCookie = /* @__PURE__ */ __name(function(name, val) {
  const opt = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {
    path: "/"
  }, value = encodeURIComponent(val);
  let str = `${name}=${value}`;
  if (opt.maxAge > 0) {
    const maxAge = opt.maxAge - 0;
    if (Number.isNaN(maxAge)) throw new Error("maxAge should be a Number");
    str += `; Max-Age=${Math.floor(maxAge)}`;
  }
  if (opt.domain) {
    if (!fieldContentRegExp.test(opt.domain))
      throw new TypeError("option domain is invalid");
    str += `; Domain=${opt.domain}`;
  }
  if (opt.path) {
    if (!fieldContentRegExp.test(opt.path))
      throw new TypeError("option path is invalid");
    str += `; Path=${opt.path}`;
  }
  if (opt.expires) {
    if (typeof opt.expires.toUTCString != "function")
      throw new TypeError("option expires is invalid");
    str += `; Expires=${opt.expires.toUTCString()}`;
  }
  if (opt.httpOnly && (str += "; HttpOnly"), opt.secure && (str += "; Secure"), opt.sameSite)
    switch (typeof opt.sameSite == "string" ? opt.sameSite.toLowerCase() : opt.sameSite) {
      case !0:
        str += "; SameSite=Strict";
        break;
      case "lax":
        str += "; SameSite=Lax";
        break;
      case "strict":
        str += "; SameSite=Strict";
        break;
      case "none":
        str += "; SameSite=None";
        break;
      default:
        throw new TypeError("option sameSite is invalid");
    }
  return str;
}, "serializeCookie"), cookie = {
  create(name, value, minutes, domain) {
    let cookieOptions = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : {
      path: "/",
      sameSite: "strict"
    };
    minutes && (cookieOptions.expires = /* @__PURE__ */ new Date(), cookieOptions.expires.setTime(cookieOptions.expires.getTime() + minutes * 60 * 1e3)), domain && (cookieOptions.domain = domain), document.cookie = serializeCookie(name, encodeURIComponent(value), cookieOptions);
  },
  read(name) {
    const nameEQ = `${name}=`, ca = document.cookie.split(";");
    for (let i = 0; i < ca.length; i++) {
      let c = ca[i];
      for (; c.charAt(0) === " "; ) c = c.substring(1, c.length);
      if (c.indexOf(nameEQ) === 0) return c.substring(nameEQ.length, c.length);
    }
    return null;
  },
  remove(name) {
    this.create(name, "", -1);
  }
};
var cookie$1 = {
  name: "cookie",
  // Deconstruct the options object and extract the lookupCookie property
  lookup(_ref) {
    let {
      lookupCookie
    } = _ref;
    if (lookupCookie && typeof document < "u")
      return cookie.read(lookupCookie) || void 0;
  },
  // Deconstruct the options object and extract the lookupCookie, cookieMinutes, cookieDomain, and cookieOptions properties
  cacheUserLanguage(lng, _ref2) {
    let {
      lookupCookie,
      cookieMinutes,
      cookieDomain,
      cookieOptions
    } = _ref2;
    lookupCookie && typeof document < "u" && cookie.create(lookupCookie, lng, cookieMinutes, cookieDomain, cookieOptions);
  }
}, querystring = {
  name: "querystring",
  // Deconstruct the options object and extract the lookupQuerystring property
  lookup(_ref) {
    var _a;
    let {
      lookupQuerystring
    } = _ref, found;
    if (typeof window < "u") {
      let {
        search
      } = window.location;
      !window.location.search && ((_a = window.location.hash) == null ? void 0 : _a.indexOf("?")) > -1 && (search = window.location.hash.substring(window.location.hash.indexOf("?")));
      const params = search.substring(1).split("&");
      for (let i = 0; i < params.length; i++) {
        const pos = params[i].indexOf("=");
        pos > 0 && params[i].substring(0, pos) === lookupQuerystring && (found = params[i].substring(pos + 1));
      }
    }
    return found;
  }
};
let hasLocalStorageSupport = null;
const localStorageAvailable = /* @__PURE__ */ __name(() => {
  if (hasLocalStorageSupport !== null) return hasLocalStorageSupport;
  try {
    hasLocalStorageSupport = window !== "undefined" && window.localStorage !== null;
    const testKey = "i18next.translate.boo";
    window.localStorage.setItem(testKey, "foo"), window.localStorage.removeItem(testKey);
  } catch {
    hasLocalStorageSupport = !1;
  }
  return hasLocalStorageSupport;
}, "localStorageAvailable");
var localStorage$1 = {
  name: "localStorage",
  // Deconstruct the options object and extract the lookupLocalStorage property
  lookup(_ref) {
    let {
      lookupLocalStorage
    } = _ref;
    if (lookupLocalStorage && localStorageAvailable())
      return window.localStorage.getItem(lookupLocalStorage) || void 0;
  },
  // Deconstruct the options object and extract the lookupLocalStorage property
  cacheUserLanguage(lng, _ref2) {
    let {
      lookupLocalStorage
    } = _ref2;
    lookupLocalStorage && localStorageAvailable() && window.localStorage.setItem(lookupLocalStorage, lng);
  }
};
let hasSessionStorageSupport = null;
const sessionStorageAvailable = /* @__PURE__ */ __name(() => {
  if (hasSessionStorageSupport !== null) return hasSessionStorageSupport;
  try {
    hasSessionStorageSupport = window !== "undefined" && window.sessionStorage !== null;
    const testKey = "i18next.translate.boo";
    window.sessionStorage.setItem(testKey, "foo"), window.sessionStorage.removeItem(testKey);
  } catch {
    hasSessionStorageSupport = !1;
  }
  return hasSessionStorageSupport;
}, "sessionStorageAvailable");
var sessionStorage = {
  name: "sessionStorage",
  lookup(_ref) {
    let {
      lookupSessionStorage
    } = _ref;
    if (lookupSessionStorage && sessionStorageAvailable())
      return window.sessionStorage.getItem(lookupSessionStorage) || void 0;
  },
  cacheUserLanguage(lng, _ref2) {
    let {
      lookupSessionStorage
    } = _ref2;
    lookupSessionStorage && sessionStorageAvailable() && window.sessionStorage.setItem(lookupSessionStorage, lng);
  }
}, navigator$1 = {
  name: "navigator",
  lookup(options) {
    const found = [];
    if (typeof navigator < "u") {
      const {
        languages,
        userLanguage,
        language
      } = navigator;
      if (languages)
        for (let i = 0; i < languages.length; i++)
          found.push(languages[i]);
      userLanguage && found.push(userLanguage), language && found.push(language);
    }
    return found.length > 0 ? found : void 0;
  }
}, htmlTag = {
  name: "htmlTag",
  // Deconstruct the options object and extract the htmlTag property
  lookup(_ref) {
    let {
      htmlTag: htmlTag2
    } = _ref, found;
    const internalHtmlTag = htmlTag2 || (typeof document < "u" ? document.documentElement : null);
    return internalHtmlTag && typeof internalHtmlTag.getAttribute == "function" && (found = internalHtmlTag.getAttribute("lang")), found;
  }
}, path = {
  name: "path",
  // Deconstruct the options object and extract the lookupFromPathIndex property
  lookup(_ref) {
    var _a;
    let {
      lookupFromPathIndex
    } = _ref;
    if (typeof window > "u") return;
    const language = window.location.pathname.match(/\/([a-zA-Z-]*)/g);
    return Array.isArray(language) ? (_a = language[typeof lookupFromPathIndex == "number" ? lookupFromPathIndex : 0]) == null ? void 0 : _a.replace("/", "") : void 0;
  }
}, subdomain = {
  name: "subdomain",
  lookup(_ref) {
    var _a, _b;
    let {
      lookupFromSubdomainIndex
    } = _ref;
    const internalLookupFromSubdomainIndex = typeof lookupFromSubdomainIndex == "number" ? lookupFromSubdomainIndex + 1 : 1, language = typeof window < "u" && ((_b = (_a = window.location) == null ? void 0 : _a.hostname) == null ? void 0 : _b.match(/^(\w{2,5})\.(([a-z0-9-]{1,63}\.[a-z]{2,6})|localhost)/i));
    if (language)
      return language[internalLookupFromSubdomainIndex];
  }
};
let canCookies = !1;
try {
  document.cookie, canCookies = !0;
} catch {
}
const order = ["querystring", "cookie", "localStorage", "sessionStorage", "navigator", "htmlTag"];
canCookies || order.splice(1, 1);
const getDefaults$1 = /* @__PURE__ */ __name(() => ({
  order,
  lookupQuerystring: "lng",
  lookupCookie: "i18next",
  lookupLocalStorage: "i18nextLng",
  lookupSessionStorage: "i18nextLng",
  // cache user language
  caches: ["localStorage"],
  excludeCacheFor: ["cimode"],
  // cookieMinutes: 10,
  // cookieDomain: 'myDomain'
  convertDetectedLanguage: /* @__PURE__ */ __name((l2) => l2, "convertDetectedLanguage")
}), "getDefaults$1"), _Browser = class _Browser {
  constructor(services) {
    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    this.type = "languageDetector", this.detectors = {}, this.init(services, options);
  }
  init() {
    let services = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {
      languageUtils: {}
    }, options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, i18nOptions = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    this.services = services, this.options = defaults(options, this.options || {}, getDefaults$1()), typeof this.options.convertDetectedLanguage == "string" && this.options.convertDetectedLanguage.indexOf("15897") > -1 && (this.options.convertDetectedLanguage = (l2) => l2.replace("-", "_")), this.options.lookupFromUrlIndex && (this.options.lookupFromPathIndex = this.options.lookupFromUrlIndex), this.i18nOptions = i18nOptions, this.addDetector(cookie$1), this.addDetector(querystring), this.addDetector(localStorage$1), this.addDetector(sessionStorage), this.addDetector(navigator$1), this.addDetector(htmlTag), this.addDetector(path), this.addDetector(subdomain);
  }
  addDetector(detector) {
    return this.detectors[detector.name] = detector, this;
  }
  detect() {
    let detectionOrder = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this.options.order, detected = [];
    return detectionOrder.forEach((detectorName) => {
      if (this.detectors[detectorName]) {
        let lookup = this.detectors[detectorName].lookup(this.options);
        lookup && typeof lookup == "string" && (lookup = [lookup]), lookup && (detected = detected.concat(lookup));
      }
    }), detected = detected.map((d) => this.options.convertDetectedLanguage(d)), this.services && this.services.languageUtils && this.services.languageUtils.getBestMatchFromCodes ? detected : detected.length > 0 ? detected[0] : null;
  }
  cacheUserLanguage(lng) {
    let caches = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this.options.caches;
    caches && (this.options.excludeCacheFor && this.options.excludeCacheFor.indexOf(lng) > -1 || caches.forEach((cacheName) => {
      this.detectors[cacheName] && this.detectors[cacheName].cacheUserLanguage(lng, this.options);
    }));
  }
};
__name(_Browser, "Browser");
let Browser = _Browser;
Browser.type = "languageDetector";
function _typeof$3(o2) {
  "@babel/helpers - typeof";
  return _typeof$3 = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(o3) {
    return typeof o3;
  } : function(o3) {
    return o3 && typeof Symbol == "function" && o3.constructor === Symbol && o3 !== Symbol.prototype ? "symbol" : typeof o3;
  }, _typeof$3(o2);
}
__name(_typeof$3, "_typeof$3");
function hasXMLHttpRequest() {
  return typeof XMLHttpRequest == "function" || (typeof XMLHttpRequest > "u" ? "undefined" : _typeof$3(XMLHttpRequest)) === "object";
}
__name(hasXMLHttpRequest, "hasXMLHttpRequest");
function isPromise(maybePromise) {
  return !!maybePromise && typeof maybePromise.then == "function";
}
__name(isPromise, "isPromise");
function makePromise(maybePromise) {
  return isPromise(maybePromise) ? maybePromise : Promise.resolve(maybePromise);
}
__name(makePromise, "makePromise");
function ownKeys$1(e2, r2) {
  var t2 = Object.keys(e2);
  if (Object.getOwnPropertySymbols) {
    var o2 = Object.getOwnPropertySymbols(e2);
    r2 && (o2 = o2.filter(function(r3) {
      return Object.getOwnPropertyDescriptor(e2, r3).enumerable;
    })), t2.push.apply(t2, o2);
  }
  return t2;
}
__name(ownKeys$1, "ownKeys$1");
function _objectSpread$1(e2) {
  for (var r2 = 1; r2 < arguments.length; r2++) {
    var t2 = arguments[r2] != null ? arguments[r2] : {};
    r2 % 2 ? ownKeys$1(Object(t2), !0).forEach(function(r3) {
      _defineProperty$1(e2, r3, t2[r3]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(t2)) : ownKeys$1(Object(t2)).forEach(function(r3) {
      Object.defineProperty(e2, r3, Object.getOwnPropertyDescriptor(t2, r3));
    });
  }
  return e2;
}
__name(_objectSpread$1, "_objectSpread$1");
function _defineProperty$1(e2, r2, t2) {
  return (r2 = _toPropertyKey$1(r2)) in e2 ? Object.defineProperty(e2, r2, { value: t2, enumerable: !0, configurable: !0, writable: !0 }) : e2[r2] = t2, e2;
}
__name(_defineProperty$1, "_defineProperty$1");
function _toPropertyKey$1(t2) {
  var i = _toPrimitive$1(t2, "string");
  return _typeof$2(i) == "symbol" ? i : i + "";
}
__name(_toPropertyKey$1, "_toPropertyKey$1");
function _toPrimitive$1(t2, r2) {
  if (_typeof$2(t2) != "object" || !t2) return t2;
  var e2 = t2[Symbol.toPrimitive];
  if (e2 !== void 0) {
    var i = e2.call(t2, r2);
    if (_typeof$2(i) != "object") return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (r2 === "string" ? String : Number)(t2);
}
__name(_toPrimitive$1, "_toPrimitive$1");
function _typeof$2(o2) {
  "@babel/helpers - typeof";
  return _typeof$2 = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(o3) {
    return typeof o3;
  } : function(o3) {
    return o3 && typeof Symbol == "function" && o3.constructor === Symbol && o3 !== Symbol.prototype ? "symbol" : typeof o3;
  }, _typeof$2(o2);
}
__name(_typeof$2, "_typeof$2");
var fetchApi = typeof fetch == "function" ? fetch : void 0;
typeof global < "u" && global.fetch ? fetchApi = global.fetch : typeof window < "u" && window.fetch && (fetchApi = window.fetch);
var XmlHttpRequestApi;
hasXMLHttpRequest() && (typeof global < "u" && global.XMLHttpRequest ? XmlHttpRequestApi = global.XMLHttpRequest : typeof window < "u" && window.XMLHttpRequest && (XmlHttpRequestApi = window.XMLHttpRequest));
var ActiveXObjectApi;
typeof ActiveXObject == "function" && (typeof global < "u" && global.ActiveXObject ? ActiveXObjectApi = global.ActiveXObject : typeof window < "u" && window.ActiveXObject && (ActiveXObjectApi = window.ActiveXObject));
typeof fetchApi != "function" && (fetchApi = void 0);
if (!fetchApi && !XmlHttpRequestApi && !ActiveXObjectApi)
  try {
    import("./browser-ponyfill-DHQIa6DM.js").then((n2) => n2.b).then(function(mod) {
      fetchApi = mod.default;
    }).catch(function() {
    });
  } catch {
  }
var addQueryString = /* @__PURE__ */ __name(function(url2, params) {
  if (params && _typeof$2(params) === "object") {
    var queryString = "";
    for (var paramName in params)
      queryString += "&" + encodeURIComponent(paramName) + "=" + encodeURIComponent(params[paramName]);
    if (!queryString) return url2;
    url2 = url2 + (url2.indexOf("?") !== -1 ? "&" : "?") + queryString.slice(1);
  }
  return url2;
}, "addQueryString"), fetchIt = /* @__PURE__ */ __name(function(url2, fetchOptions, callback, altFetch) {
  var resolver = /* @__PURE__ */ __name(function(response) {
    if (!response.ok) return callback(response.statusText || "Error", {
      status: response.status
    });
    response.text().then(function(data) {
      callback(null, {
        status: response.status,
        data
      });
    }).catch(callback);
  }, "resolver");
  if (altFetch) {
    var altResponse = altFetch(url2, fetchOptions);
    if (altResponse instanceof Promise) {
      altResponse.then(resolver).catch(callback);
      return;
    }
  }
  typeof fetch == "function" ? fetch(url2, fetchOptions).then(resolver).catch(callback) : fetchApi(url2, fetchOptions).then(resolver).catch(callback);
}, "fetchIt"), omitFetchOptions = !1, requestWithFetch = /* @__PURE__ */ __name(function(options, url2, payload, callback) {
  options.queryStringParams && (url2 = addQueryString(url2, options.queryStringParams));
  var headers = _objectSpread$1({}, typeof options.customHeaders == "function" ? options.customHeaders() : options.customHeaders);
  typeof window > "u" && typeof global < "u" && typeof global.process < "u" && global.process.versions && global.process.versions.node && (headers["User-Agent"] = "i18next-http-backend (node/".concat(global.process.version, "; ").concat(global.process.platform, " ").concat(global.process.arch, ")")), payload && (headers["Content-Type"] = "application/json");
  var reqOptions = typeof options.requestOptions == "function" ? options.requestOptions(payload) : options.requestOptions, fetchOptions = _objectSpread$1({
    method: payload ? "POST" : "GET",
    body: payload ? options.stringify(payload) : void 0,
    headers
  }, omitFetchOptions ? {} : reqOptions), altFetch = typeof options.alternateFetch == "function" && options.alternateFetch.length >= 1 ? options.alternateFetch : void 0;
  try {
    fetchIt(url2, fetchOptions, callback, altFetch);
  } catch (e2) {
    if (!reqOptions || Object.keys(reqOptions).length === 0 || !e2.message || e2.message.indexOf("not implemented") < 0)
      return callback(e2);
    try {
      Object.keys(reqOptions).forEach(function(opt) {
        delete fetchOptions[opt];
      }), fetchIt(url2, fetchOptions, callback, altFetch), omitFetchOptions = !0;
    } catch (err) {
      callback(err);
    }
  }
}, "requestWithFetch"), requestWithXmlHttpRequest = /* @__PURE__ */ __name(function(options, url2, payload, callback) {
  payload && _typeof$2(payload) === "object" && (payload = addQueryString("", payload).slice(1)), options.queryStringParams && (url2 = addQueryString(url2, options.queryStringParams));
  try {
    var x = XmlHttpRequestApi ? new XmlHttpRequestApi() : new ActiveXObjectApi("MSXML2.XMLHTTP.3.0");
    x.open(payload ? "POST" : "GET", url2, 1), options.crossDomain || x.setRequestHeader("X-Requested-With", "XMLHttpRequest"), x.withCredentials = !!options.withCredentials, payload && x.setRequestHeader("Content-Type", "application/x-www-form-urlencoded"), x.overrideMimeType && x.overrideMimeType("application/json");
    var h = options.customHeaders;
    if (h = typeof h == "function" ? h() : h, h)
      for (var i in h)
        x.setRequestHeader(i, h[i]);
    x.onreadystatechange = function() {
      x.readyState > 3 && callback(x.status >= 400 ? x.statusText : null, {
        status: x.status,
        data: x.responseText
      });
    }, x.send(payload);
  } catch (e2) {
    console && console.log(e2);
  }
}, "requestWithXmlHttpRequest"), request = /* @__PURE__ */ __name(function(options, url2, payload, callback) {
  if (typeof payload == "function" && (callback = payload, payload = void 0), callback = callback || function() {
  }, fetchApi && url2.indexOf("file:") !== 0)
    return requestWithFetch(options, url2, payload, callback);
  if (hasXMLHttpRequest() || typeof ActiveXObject == "function")
    return requestWithXmlHttpRequest(options, url2, payload, callback);
  callback(new Error("No fetch and no xhr implementation found!"));
}, "request");
function _typeof$1(o2) {
  "@babel/helpers - typeof";
  return _typeof$1 = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(o3) {
    return typeof o3;
  } : function(o3) {
    return o3 && typeof Symbol == "function" && o3.constructor === Symbol && o3 !== Symbol.prototype ? "symbol" : typeof o3;
  }, _typeof$1(o2);
}
__name(_typeof$1, "_typeof$1");
function ownKeys(e2, r2) {
  var t2 = Object.keys(e2);
  if (Object.getOwnPropertySymbols) {
    var o2 = Object.getOwnPropertySymbols(e2);
    r2 && (o2 = o2.filter(function(r3) {
      return Object.getOwnPropertyDescriptor(e2, r3).enumerable;
    })), t2.push.apply(t2, o2);
  }
  return t2;
}
__name(ownKeys, "ownKeys");
function _objectSpread(e2) {
  for (var r2 = 1; r2 < arguments.length; r2++) {
    var t2 = arguments[r2] != null ? arguments[r2] : {};
    r2 % 2 ? ownKeys(Object(t2), !0).forEach(function(r3) {
      _defineProperty(e2, r3, t2[r3]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(t2)) : ownKeys(Object(t2)).forEach(function(r3) {
      Object.defineProperty(e2, r3, Object.getOwnPropertyDescriptor(t2, r3));
    });
  }
  return e2;
}
__name(_objectSpread, "_objectSpread");
function _classCallCheck(a, n2) {
  if (!(a instanceof n2)) throw new TypeError("Cannot call a class as a function");
}
__name(_classCallCheck, "_classCallCheck");
function _defineProperties(e2, r2) {
  for (var t2 = 0; t2 < r2.length; t2++) {
    var o2 = r2[t2];
    o2.enumerable = o2.enumerable || !1, o2.configurable = !0, "value" in o2 && (o2.writable = !0), Object.defineProperty(e2, _toPropertyKey(o2.key), o2);
  }
}
__name(_defineProperties, "_defineProperties");
function _createClass(e2, r2, t2) {
  return r2 && _defineProperties(e2.prototype, r2), Object.defineProperty(e2, "prototype", { writable: !1 }), e2;
}
__name(_createClass, "_createClass");
function _defineProperty(e2, r2, t2) {
  return (r2 = _toPropertyKey(r2)) in e2 ? Object.defineProperty(e2, r2, { value: t2, enumerable: !0, configurable: !0, writable: !0 }) : e2[r2] = t2, e2;
}
__name(_defineProperty, "_defineProperty");
function _toPropertyKey(t2) {
  var i = _toPrimitive(t2, "string");
  return _typeof$1(i) == "symbol" ? i : i + "";
}
__name(_toPropertyKey, "_toPropertyKey");
function _toPrimitive(t2, r2) {
  if (_typeof$1(t2) != "object" || !t2) return t2;
  var e2 = t2[Symbol.toPrimitive];
  if (e2 !== void 0) {
    var i = e2.call(t2, r2);
    if (_typeof$1(i) != "object") return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return String(t2);
}
__name(_toPrimitive, "_toPrimitive");
var getDefaults = /* @__PURE__ */ __name(function() {
  return {
    loadPath: "/locales/{{lng}}/{{ns}}.json",
    addPath: "/locales/add/{{lng}}/{{ns}}",
    parse: /* @__PURE__ */ __name(function(data) {
      return JSON.parse(data);
    }, "parse"),
    stringify: JSON.stringify,
    parsePayload: /* @__PURE__ */ __name(function(namespace, key, fallbackValue) {
      return _defineProperty({}, key, fallbackValue || "");
    }, "parsePayload"),
    parseLoadPayload: /* @__PURE__ */ __name(function(languages, namespaces) {
    }, "parseLoadPayload"),
    request,
    reloadInterval: typeof window < "u" ? !1 : 60 * 60 * 1e3,
    customHeaders: {},
    queryStringParams: {},
    crossDomain: !1,
    withCredentials: !1,
    overrideMimeType: !1,
    requestOptions: {
      mode: "cors",
      credentials: "same-origin",
      cache: "default"
    }
  };
}, "getDefaults"), Backend = function() {
  function Backend2(services) {
    var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, allOptions = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    _classCallCheck(this, Backend2), this.services = services, this.options = options, this.allOptions = allOptions, this.type = "backend", this.init(services, options, allOptions);
  }
  return __name(Backend2, "Backend"), _createClass(Backend2, [{
    key: "init",
    value: /* @__PURE__ */ __name(function(services) {
      var _this = this, options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, allOptions = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
      if (this.services = services, this.options = _objectSpread(_objectSpread(_objectSpread({}, getDefaults()), this.options || {}), options), this.allOptions = allOptions, this.services && this.options.reloadInterval) {
        var timer = setInterval(function() {
          return _this.reload();
        }, this.options.reloadInterval);
        _typeof$1(timer) === "object" && typeof timer.unref == "function" && timer.unref();
      }
    }, "init")
  }, {
    key: "readMulti",
    value: /* @__PURE__ */ __name(function(languages, namespaces, callback) {
      this._readAny(languages, languages, namespaces, namespaces, callback);
    }, "readMulti")
  }, {
    key: "read",
    value: /* @__PURE__ */ __name(function(language, namespace, callback) {
      this._readAny([language], language, [namespace], namespace, callback);
    }, "read")
  }, {
    key: "_readAny",
    value: /* @__PURE__ */ __name(function(languages, loadUrlLanguages, namespaces, loadUrlNamespaces, callback) {
      var _this2 = this, loadPath = this.options.loadPath;
      typeof this.options.loadPath == "function" && (loadPath = this.options.loadPath(languages, namespaces)), loadPath = makePromise(loadPath), loadPath.then(function(resolvedLoadPath) {
        if (!resolvedLoadPath) return callback(null, {});
        var url2 = _this2.services.interpolator.interpolate(resolvedLoadPath, {
          lng: languages.join("+"),
          ns: namespaces.join("+")
        });
        _this2.loadUrl(url2, callback, loadUrlLanguages, loadUrlNamespaces);
      });
    }, "_readAny")
  }, {
    key: "loadUrl",
    value: /* @__PURE__ */ __name(function(url2, callback, languages, namespaces) {
      var _this3 = this, lng = typeof languages == "string" ? [languages] : languages, ns = typeof namespaces == "string" ? [namespaces] : namespaces, payload = this.options.parseLoadPayload(lng, ns);
      this.options.request(this.options, url2, payload, function(err, res) {
        if (res && (res.status >= 500 && res.status < 600 || !res.status)) return callback("failed loading " + url2 + "; status code: " + res.status, !0);
        if (res && res.status >= 400 && res.status < 500) return callback("failed loading " + url2 + "; status code: " + res.status, !1);
        if (!res && err && err.message) {
          var errorMessage = err.message.toLowerCase(), isNetworkError = ["failed", "fetch", "network", "load"].find(function(term) {
            return errorMessage.indexOf(term) > -1;
          });
          if (isNetworkError)
            return callback("failed loading " + url2 + ": " + err.message, !0);
        }
        if (err) return callback(err, !1);
        var ret, parseErr;
        try {
          typeof res.data == "string" ? ret = _this3.options.parse(res.data, languages, namespaces) : ret = res.data;
        } catch {
          parseErr = "failed parsing " + url2 + " to json";
        }
        if (parseErr) return callback(parseErr, !1);
        callback(null, ret);
      });
    }, "loadUrl")
  }, {
    key: "create",
    value: /* @__PURE__ */ __name(function(languages, namespace, key, fallbackValue, callback) {
      var _this4 = this;
      if (this.options.addPath) {
        typeof languages == "string" && (languages = [languages]);
        var payload = this.options.parsePayload(namespace, key, fallbackValue), finished = 0, dataArray = [], resArray = [];
        languages.forEach(function(lng) {
          var addPath = _this4.options.addPath;
          typeof _this4.options.addPath == "function" && (addPath = _this4.options.addPath(lng, namespace));
          var url2 = _this4.services.interpolator.interpolate(addPath, {
            lng,
            ns: namespace
          });
          _this4.options.request(_this4.options, url2, payload, function(data, res) {
            finished += 1, dataArray.push(data), resArray.push(res), finished === languages.length && typeof callback == "function" && callback(dataArray, resArray);
          });
        });
      }
    }, "create")
  }, {
    key: "reload",
    value: /* @__PURE__ */ __name(function() {
      var _this5 = this, _this$services = this.services, backendConnector = _this$services.backendConnector, languageUtils = _this$services.languageUtils, logger = _this$services.logger, currentLanguage = backendConnector.language;
      if (!(currentLanguage && currentLanguage.toLowerCase() === "cimode")) {
        var toLoad = [], append2 = /* @__PURE__ */ __name(function(lng) {
          var lngs = languageUtils.toResolveHierarchy(lng);
          lngs.forEach(function(l2) {
            toLoad.indexOf(l2) < 0 && toLoad.push(l2);
          });
        }, "append");
        append2(currentLanguage), this.allOptions.preload && this.allOptions.preload.forEach(function(l2) {
          return append2(l2);
        }), toLoad.forEach(function(lng) {
          _this5.allOptions.ns.forEach(function(ns) {
            backendConnector.read(lng, ns, "read", null, null, function(err, data) {
              err && logger.warn("loading namespace ".concat(ns, " for language ").concat(lng, " failed"), err), !err && data && logger.log("loaded namespace ".concat(ns, " for language ").concat(lng), data), backendConnector.loaded("".concat(lng, "|").concat(ns), err, data);
            });
          });
        });
      }
    }, "reload")
  }]);
}();
Backend.type = "backend";
instance.use(Backend).use(Browser).use(initReactI18next).init({
  fallbackLng: "ru",
  debug: !1,
  interpolation: {
    escapeValue: !1
    // not needed for react as it escapes by default
  },
  backend: {
    loadPath: "@/../locales/{{lng}}/ui/{{ns}}/{{ns}}.json"
  },
  ns: [
    "any",
    "date-picker",
    "form",
    "modal",
    "popconfirm",
    "rc-pagination",
    "rc-picker",
    "table",
    "text",
    "time-picker",
    "tour",
    "transfer",
    "upload"
  ]
});
var en_US$7 = {}, interopRequireDefault = { exports: {} };
(function(module2) {
  function _interopRequireDefault2(e2) {
    return e2 && e2.__esModule ? e2 : {
      default: e2
    };
  }
  __name(_interopRequireDefault2, "_interopRequireDefault"), module2.exports = _interopRequireDefault2, module2.exports.__esModule = !0, module2.exports.default = module2.exports;
})(interopRequireDefault);
var interopRequireDefaultExports = interopRequireDefault.exports, en_US$6 = {};
Object.defineProperty(en_US$6, "__esModule", {
  value: !0
});
en_US$6.default = void 0;
var locale$3 = {
  // Options
  items_per_page: "/ page",
  jump_to: "Go to",
  jump_to_confirm: "confirm",
  page: "Page",
  // Pagination
  prev_page: "Previous Page",
  next_page: "Next Page",
  prev_5: "Previous 5 Pages",
  next_5: "Next 5 Pages",
  prev_3: "Previous 3 Pages",
  next_3: "Next 3 Pages",
  page_size: "Page Size"
};
en_US$6.default = locale$3;
var en_US$5 = {}, en_US$4 = {}, en_US$3 = {}, objectSpread2 = { exports: {} }, defineProperty = { exports: {} }, toPropertyKey = { exports: {} }, _typeof = { exports: {} };
(function(module2) {
  function _typeof2(o2) {
    "@babel/helpers - typeof";
    return module2.exports = _typeof2 = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(o3) {
      return typeof o3;
    } : function(o3) {
      return o3 && typeof Symbol == "function" && o3.constructor === Symbol && o3 !== Symbol.prototype ? "symbol" : typeof o3;
    }, module2.exports.__esModule = !0, module2.exports.default = module2.exports, _typeof2(o2);
  }
  __name(_typeof2, "_typeof"), module2.exports = _typeof2, module2.exports.__esModule = !0, module2.exports.default = module2.exports;
})(_typeof);
var _typeofExports = _typeof.exports, toPrimitive = { exports: {} };
(function(module2) {
  var _typeof2 = _typeofExports.default;
  function toPrimitive2(t2, r2) {
    if (_typeof2(t2) != "object" || !t2) return t2;
    var e2 = t2[Symbol.toPrimitive];
    if (e2 !== void 0) {
      var i = e2.call(t2, r2 || "default");
      if (_typeof2(i) != "object") return i;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (r2 === "string" ? String : Number)(t2);
  }
  __name(toPrimitive2, "toPrimitive"), module2.exports = toPrimitive2, module2.exports.__esModule = !0, module2.exports.default = module2.exports;
})(toPrimitive);
var toPrimitiveExports = toPrimitive.exports;
(function(module2) {
  var _typeof2 = _typeofExports.default, toPrimitive2 = toPrimitiveExports;
  function toPropertyKey2(t2) {
    var i = toPrimitive2(t2, "string");
    return _typeof2(i) == "symbol" ? i : i + "";
  }
  __name(toPropertyKey2, "toPropertyKey"), module2.exports = toPropertyKey2, module2.exports.__esModule = !0, module2.exports.default = module2.exports;
})(toPropertyKey);
var toPropertyKeyExports = toPropertyKey.exports;
(function(module2) {
  var toPropertyKey2 = toPropertyKeyExports;
  function _defineProperty2(e2, r2, t2) {
    return (r2 = toPropertyKey2(r2)) in e2 ? Object.defineProperty(e2, r2, {
      value: t2,
      enumerable: !0,
      configurable: !0,
      writable: !0
    }) : e2[r2] = t2, e2;
  }
  __name(_defineProperty2, "_defineProperty"), module2.exports = _defineProperty2, module2.exports.__esModule = !0, module2.exports.default = module2.exports;
})(defineProperty);
var definePropertyExports = defineProperty.exports;
(function(module2) {
  var defineProperty2 = definePropertyExports;
  function ownKeys2(e2, r2) {
    var t2 = Object.keys(e2);
    if (Object.getOwnPropertySymbols) {
      var o2 = Object.getOwnPropertySymbols(e2);
      r2 && (o2 = o2.filter(function(r3) {
        return Object.getOwnPropertyDescriptor(e2, r3).enumerable;
      })), t2.push.apply(t2, o2);
    }
    return t2;
  }
  __name(ownKeys2, "ownKeys");
  function _objectSpread22(e2) {
    for (var r2 = 1; r2 < arguments.length; r2++) {
      var t2 = arguments[r2] != null ? arguments[r2] : {};
      r2 % 2 ? ownKeys2(Object(t2), !0).forEach(function(r3) {
        defineProperty2(e2, r3, t2[r3]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(t2)) : ownKeys2(Object(t2)).forEach(function(r3) {
        Object.defineProperty(e2, r3, Object.getOwnPropertyDescriptor(t2, r3));
      });
    }
    return e2;
  }
  __name(_objectSpread22, "_objectSpread2"), module2.exports = _objectSpread22, module2.exports.__esModule = !0, module2.exports.default = module2.exports;
})(objectSpread2);
var objectSpread2Exports = objectSpread2.exports, common = {};
Object.defineProperty(common, "__esModule", {
  value: !0
});
common.commonLocale = void 0;
common.commonLocale = {
  yearFormat: "YYYY",
  dayFormat: "D",
  cellMeridiemFormat: "A",
  monthBeforeYear: !0
};
var _interopRequireDefault$3 = interopRequireDefaultExports.default;
Object.defineProperty(en_US$3, "__esModule", {
  value: !0
});
en_US$3.default = void 0;
var _objectSpread2 = _interopRequireDefault$3(objectSpread2Exports), _common = common, locale$2 = (0, _objectSpread2.default)((0, _objectSpread2.default)({}, _common.commonLocale), {}, {
  locale: "en_US",
  today: "Today",
  now: "Now",
  backToToday: "Back to today",
  ok: "OK",
  clear: "Clear",
  month: "Month",
  year: "Year",
  timeSelect: "select time",
  dateSelect: "select date",
  weekSelect: "Choose a week",
  monthSelect: "Choose a month",
  yearSelect: "Choose a year",
  decadeSelect: "Choose a decade",
  dateFormat: "M/D/YYYY",
  dateTimeFormat: "M/D/YYYY HH:mm:ss",
  previousMonth: "Previous month (PageUp)",
  nextMonth: "Next month (PageDown)",
  previousYear: "Last year (Control + left)",
  nextYear: "Next year (Control + right)",
  previousDecade: "Last decade",
  nextDecade: "Next decade",
  previousCentury: "Last century",
  nextCentury: "Next century"
});
en_US$3.default = locale$2;
var en_US$2 = {};
Object.defineProperty(en_US$2, "__esModule", {
  value: !0
});
en_US$2.default = void 0;
const locale$1 = {
  placeholder: "Select time",
  rangePlaceholder: ["Start time", "End time"]
};
en_US$2.default = locale$1;
var _interopRequireDefault$2 = interopRequireDefaultExports.default;
Object.defineProperty(en_US$4, "__esModule", {
  value: !0
});
en_US$4.default = void 0;
var _en_US$2 = _interopRequireDefault$2(en_US$3), _en_US2$1 = _interopRequireDefault$2(en_US$2);
const locale = {
  lang: Object.assign({
    placeholder: "Select date",
    yearPlaceholder: "Select year",
    quarterPlaceholder: "Select quarter",
    monthPlaceholder: "Select month",
    weekPlaceholder: "Select week",
    rangePlaceholder: ["Start date", "End date"],
    rangeYearPlaceholder: ["Start year", "End year"],
    rangeQuarterPlaceholder: ["Start quarter", "End quarter"],
    rangeMonthPlaceholder: ["Start month", "End month"],
    rangeWeekPlaceholder: ["Start week", "End week"]
  }, _en_US$2.default),
  timePickerLocale: Object.assign({}, _en_US2$1.default)
};
en_US$4.default = locale;
var _interopRequireDefault$1 = interopRequireDefaultExports.default;
Object.defineProperty(en_US$5, "__esModule", {
  value: !0
});
en_US$5.default = void 0;
var _en_US$1 = _interopRequireDefault$1(en_US$4);
en_US$5.default = _en_US$1.default;
var _interopRequireDefault = interopRequireDefaultExports.default;
Object.defineProperty(en_US$7, "__esModule", {
  value: !0
});
en_US$7.default = void 0;
var _en_US = _interopRequireDefault(en_US$6), _en_US2 = _interopRequireDefault(en_US$5), _en_US3 = _interopRequireDefault(en_US$4), _en_US4 = _interopRequireDefault(en_US$2);
const typeTemplate = "${label} is not a valid ${type}", localeValues = {
  locale: "en",
  Pagination: _en_US.default,
  DatePicker: _en_US3.default,
  TimePicker: _en_US4.default,
  Calendar: _en_US2.default,
  global: {
    placeholder: "Please select"
  },
  Table: {
    filterTitle: "Filter menu",
    filterConfirm: "OK",
    filterReset: "Reset",
    filterEmptyText: "No filters",
    filterCheckall: "Select all items",
    filterSearchPlaceholder: "Search in filters",
    emptyText: "No data",
    selectAll: "Select current page",
    selectInvert: "Invert current page",
    selectNone: "Clear all data",
    selectionAll: "Select all data",
    sortTitle: "Sort",
    expand: "Expand row",
    collapse: "Collapse row",
    triggerDesc: "Click to sort descending",
    triggerAsc: "Click to sort ascending",
    cancelSort: "Click to cancel sorting"
  },
  Tour: {
    Next: "Next",
    Previous: "Previous",
    Finish: "Finish"
  },
  Modal: {
    okText: "OK",
    cancelText: "Cancel",
    justOkText: "OK"
  },
  Popconfirm: {
    okText: "OK",
    cancelText: "Cancel"
  },
  Transfer: {
    titles: ["", ""],
    searchPlaceholder: "Search here",
    itemUnit: "item",
    itemsUnit: "items",
    remove: "Remove",
    selectCurrent: "Select current page",
    removeCurrent: "Remove current page",
    selectAll: "Select all data",
    deselectAll: "Deselect all data",
    removeAll: "Remove all data",
    selectInvert: "Invert current page"
  },
  Upload: {
    uploading: "Uploading...",
    removeFile: "Remove file",
    uploadError: "Upload error",
    previewFile: "Preview file",
    downloadFile: "Download file"
  },
  Empty: {
    description: "No data"
  },
  Icon: {
    icon: "icon"
  },
  Text: {
    edit: "Edit",
    copy: "Copy",
    copied: "Copied",
    expand: "Expand",
    collapse: "Collapse"
  },
  Form: {
    optional: "(optional)",
    defaultValidateMessages: {
      default: "Field validation error for ${label}",
      required: "Please enter ${label}",
      enum: "${label} must be one of [${enum}]",
      whitespace: "${label} cannot be a blank character",
      date: {
        format: "${label} date format is invalid",
        parse: "${label} cannot be converted to a date",
        invalid: "${label} is an invalid date"
      },
      types: {
        string: typeTemplate,
        method: typeTemplate,
        array: typeTemplate,
        object: typeTemplate,
        number: typeTemplate,
        date: typeTemplate,
        boolean: typeTemplate,
        integer: typeTemplate,
        float: typeTemplate,
        regexp: typeTemplate,
        email: typeTemplate,
        url: typeTemplate,
        hex: typeTemplate
      },
      string: {
        len: "${label} must be ${len} characters",
        min: "${label} must be at least ${min} characters",
        max: "${label} must be up to ${max} characters",
        range: "${label} must be between ${min}-${max} characters"
      },
      number: {
        len: "${label} must be equal to ${len}",
        min: "${label} must be minimum ${min}",
        max: "${label} must be maximum ${max}",
        range: "${label} must be between ${min}-${max}"
      },
      array: {
        len: "Must be ${len} ${label}",
        min: "At least ${min} ${label}",
        max: "At most ${max} ${label}",
        range: "The amount of ${label} must be between ${min}-${max}"
      },
      pattern: {
        mismatch: "${label} does not match the pattern ${pattern}"
      }
    }
  },
  Image: {
    preview: "Preview"
  },
  QRCode: {
    expired: "QR code expired",
    refresh: "Refresh",
    scanned: "Scanned"
  },
  ColorPicker: {
    presetEmpty: "Empty",
    transparent: "Transparent",
    singleColor: "Single",
    gradientColor: "Gradient"
  }
};
en_US$7.default = localeValues;
var en_US = en_US$7;
const en_US$1 = /* @__PURE__ */ getDefaultExportFromCjs(en_US), Locale$a = /* @__PURE__ */ __name((t2) => ({
  today: t2("rc-picker:today"),
  now: t2("rc-picker:now"),
  backToToday: t2("rc-picker:backToToday"),
  ok: t2("rc-picker:ok"),
  clear: t2("rc-picker:clear"),
  month: t2("rc-picker:month"),
  year: t2("rc-picker:year"),
  timeSelect: t2("rc-picker:timeSelect"),
  dateSelect: t2("rc-picker:dateSelect"),
  monthSelect: t2("rc-picker:monthSelect"),
  yearSelect: t2("rc-picker:yearSelect"),
  decadeSelect: t2("rc-picker:decadeSelect"),
  dateFormat: t2("rc-picker:dateFormat"),
  dateTimeFormat: t2("rc-picker:dateTimeFormat"),
  previousMonth: t2("rc-picker:previousMonth"),
  nextMonth: t2("rc-picker:nextMonth"),
  previousYear: t2("rc-picker:previousYear"),
  nextYear: t2("rc-picker:nextYear"),
  previousDecade: t2("rc-picker:previousDecade"),
  nextDecade: t2("rc-picker:nextDecade"),
  previousCentury: t2("rc-picker:previousCentury"),
  nextCentury: t2("rc-picker:nextCentury")
}), "Locale$a"), Locale$9 = /* @__PURE__ */ __name((t2) => ({
  placeholder: t2("time-picker:placeholder"),
  rangePlaceholder: [t2("time-picker:rangePlaceholder.start"), t2("time-picker:rangePlaceholder.end")]
}), "Locale$9"), Locale$8 = /* @__PURE__ */ __name((t2) => ({
  ...locale$5,
  lang: Object.assign(
    {
      ...locale$5.lang,
      placeholder: t2("date-picker:placeholder"),
      yearPlaceholder: t2("date-picker:yearPlaceholder"),
      quarterPlaceholder: t2("date-picker:quarterPlaceholder"),
      monthPlaceholder: t2("date-picker:monthPlaceholder"),
      weekPlaceholder: t2("date-picker:weekPlaceholder"),
      rangePlaceholder: [t2("date-picker:rangePlaceholder.start"), t2("date-picker:rangePlaceholder.end")],
      rangeYearPlaceholder: [t2("date-picker:rangeYearPlaceholder.start"), t2("date-picker:rangeYearPlaceholder.end")],
      rangeMonthPlaceholder: [
        t2("date-picker:rangeMonthPlaceholder.start"),
        t2("date-picker:rangeMonthPlaceholder.end")
      ],
      rangeWeekPlaceholder: [t2("date-picker:rangeWeekPlaceholder.start"), t2("date-picker:rangeWeekPlaceholder.end")],
      shortWeekDays: [
        t2("date-picker:shortWeekDays.Sunday"),
        t2("date-picker:shortWeekDays.Monday"),
        t2("date-picker:shortWeekDays.Tuesday"),
        t2("date-picker:shortWeekDays.Wednesday"),
        t2("date-picker:shortWeekDays.Thursday"),
        t2("date-picker:shortWeekDays.Friday"),
        t2("date-picker:shortWeekDays.Saturday")
      ],
      shortMonths: [
        t2("date-picker:shortMonths.January"),
        t2("date-picker:shortMonths.February"),
        t2("date-picker:shortMonths.March"),
        t2("date-picker:shortMonths.April"),
        t2("date-picker:shortMonths.May"),
        t2("date-picker:shortMonths.June"),
        t2("date-picker:shortMonths.July"),
        t2("date-picker:shortMonths.August"),
        t2("date-picker:shortMonths.September"),
        t2("date-picker:shortMonths.October"),
        t2("date-picker:shortMonths.November"),
        t2("date-picker:shortMonths.December")
      ]
    },
    Locale$a(t2)
  ),
  timePickerLocale: Object.assign({}, Locale$9(t2))
}), "Locale$8"), Locale$7 = /* @__PURE__ */ __name((t2) => {
  var _a, _b;
  return {
    optional: t2("form:optional"),
    defaultValidateMessages: {
      default: t2("form:defaultValidateMessages.default"),
      required: t2("form:defaultValidateMessages.required"),
      enum: t2("form:defaultValidateMessages.enum"),
      whitespace: t2("form:defaultValidateMessages.whitespace"),
      date: {
        format: t2("form:defaultValidateMessages.date.format"),
        parse: t2("form:defaultValidateMessages.date.parse"),
        invalid: t2("form:defaultValidateMessages.date.invalid")
      },
      types: (_b = (_a = en_US$1 == null ? void 0 : en_US$1.Form) == null ? void 0 : _a.defaultValidateMessages) == null ? void 0 : _b.types,
      string: {
        len: t2("form:defaultValidateMessages.string.len"),
        min: t2("form:defaultValidateMessages.string.min"),
        max: t2("form:defaultValidateMessages.string.max"),
        range: t2("form:defaultValidateMessages.string.range")
      },
      number: {
        len: t2("form:defaultValidateMessages.number.len"),
        min: t2("form:defaultValidateMessages.number.min"),
        max: t2("form:defaultValidateMessages.number.max"),
        range: t2("form:defaultValidateMessages.number.range")
      },
      array: {
        len: t2("form:defaultValidateMessages.array.len"),
        min: t2("form:defaultValidateMessages.array.min"),
        max: t2("form:defaultValidateMessages.array.max"),
        range: t2("form:defaultValidateMessages.array.range")
      },
      pattern: {
        mismatch: t2("form:defaultValidateMessages.pattern.mismatch")
      }
    }
  };
}, "Locale$7"), Locale$6 = /* @__PURE__ */ __name((t2) => ({
  okText: t2("modal:okText"),
  cancelText: t2("modal:cancelText"),
  justOkText: t2("modal:justOkText")
}), "Locale$6"), Locale$5 = /* @__PURE__ */ __name((t2) => ({
  okText: t2("popconfirm:okText"),
  cancelText: t2("popconfirm:okText")
}), "Locale$5"), Locale$4 = /* @__PURE__ */ __name((t2) => ({
  // Options
  items_per_page: t2("rc-pagination:items_per_page"),
  jump_to: t2("rc-pagination:jump_to"),
  jump_to_confirm: t2("rc-pagination:jump_to_confirm"),
  page: t2("rc-pagination:page"),
  // Pagination
  prev_page: t2("rc-pagination:prev_page"),
  next_page: t2("rc-pagination:next_page"),
  prev_5: t2("rc-pagination:prev_5"),
  next_5: t2("rc-pagination:next_5"),
  prev_3: t2("rc-pagination:prev_3"),
  next_3: t2("rc-pagination:next_3"),
  page_size: t2("rc-pagination:page_size")
}), "Locale$4"), Locale$3 = /* @__PURE__ */ __name((t2) => ({
  filterTitle: t2("table:filterTitle"),
  filterConfirm: t2("table:filterConfirm"),
  filterReset: t2("table:filterReset"),
  filterEmptyText: t2("table:filterEmptyText"),
  filterCheckall: t2("table:filterCheckall"),
  filterSearchPlaceholder: t2("table:filterSearchPlaceholder"),
  emptyText: t2("table:emptyText"),
  selectAll: t2("table:selectAll"),
  selectInvert: t2("table:selectInvert"),
  selectNone: t2("table:selectNone"),
  selectionAll: t2("table:selectionAll"),
  sortTitle: t2("table:sortTitle"),
  expand: t2("table:expand"),
  collapse: t2("table:collapse"),
  triggerDesc: t2("table:triggerDesc"),
  triggerAsc: t2("table:triggerAsc"),
  cancelSort: t2("table:cancelSort")
}), "Locale$3"), Locale$2 = /* @__PURE__ */ __name((t2) => ({
  Next: t2("tour:Next"),
  Previous: t2("tour:Previous"),
  Finish: t2("tour:Finish")
}), "Locale$2"), Locale$1 = /* @__PURE__ */ __name((t2) => ({
  titles: ["", ""],
  searchPlaceholder: t2("transfer:searchPlaceholder"),
  itemUnit: t2("transfer:itemUnit"),
  itemsUnit: t2("transfer:itemsUnit"),
  remove: t2("transfer:remove"),
  selectCurrent: t2("transfer:selectCurrent"),
  removeCurrent: t2("transfer:removeCurrent"),
  selectAll: t2("transfer:selectAll"),
  deselectAll: t2("transfer:deselectAll"),
  removeAll: t2("transfer:removeAll"),
  selectInvert: t2("transfer:selectInvert")
}), "Locale$1"), Locale = /* @__PURE__ */ __name((t2) => ({
  uploading: t2("upload:uploading"),
  removeFile: t2("upload:removeFile"),
  uploadError: t2("upload:uploadError"),
  previewFile: t2("upload:previewFile"),
  downloadFile: t2("upload:downloadFile")
}), "Locale"), globalLocale = /* @__PURE__ */ __name((t2) => ({
  ...en_US$1,
  Pagination: Locale$4(t2),
  DatePicker: Locale$8(t2),
  TimePicker: Locale$9(t2),
  Calendar: Locale$8(t2),
  Table: Locale$3(t2),
  Tour: Locale$2(t2),
  Modal: Locale$6(t2),
  Popconfirm: Locale$5(t2),
  Transfer: Locale$1(t2),
  Upload: Locale(t2),
  Empty: {
    description: t2("any:Empty.description")
  },
  Icon: {
    icon: t2("any:Icon.icon")
  },
  Text: {
    edit: t2("text:edit"),
    copy: t2("text:copy"),
    copied: t2("text:copied"),
    expand: t2("text:expand"),
    collapse: t2("text:collapse")
  },
  Form: Locale$7(t2),
  Image: {
    preview: t2("any:Image.preview")
  },
  QRCode: {
    expired: t2("any:QRCode.expired"),
    refresh: t2("any:QRCode.refresh"),
    scanned: t2("any:QRCode.scanned")
  },
  ColorPicker: {
    presetEmpty: t2("any:ColorPicker.presetEmpty"),
    transparent: t2("any:ColorPicker.transparent"),
    singleColor: t2("any:ColorPicker.singleColor"),
    gradientColor: t2("any:ColorPicker.gradientColor")
  }
}), "globalLocale");
dayjs.locale("ru");
function ThemeProvider({ children }) {
  const [theme2, setTheme] = useThemeRegistry(), { t: t2 } = useTranslation();
  theme2.cssVar = !0;
  const globalBuddhistLocale = globalLocale(t2);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(ThemeContext.Provider, { value: { theme: theme2, setTheme }, children: /* @__PURE__ */ jsxRuntimeExports.jsx(ConfigProvider, { locale: globalBuddhistLocale, theme: theme2, children }) });
}
__name(ThemeProvider, "ThemeProvider");
const Badge = /* @__PURE__ */ __name(({ type: type4, children, ...rest }) => {
  var _a, _b, _c, _d;
  const { theme: theme2 } = useTheme();
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    Badge$1,
    {
      ...rest,
      styles: {
        indicator: {
          ...type4 && {
            background: (_b = (_a = theme2 == null ? void 0 : theme2.components) == null ? void 0 : _a.Badge) == null ? void 0 : _b[`${type4}IndicatorBg`],
            color: (_d = (_c = theme2 == null ? void 0 : theme2.components) == null ? void 0 : _c.Badge) == null ? void 0 : _d[`${type4}TextColor`]
          }
        }
      },
      children
    }
  );
}, "Badge"), tooltipCombinedTitle = "_tooltipCombinedTitle_nanqp_1", singleRow = "_singleRow_nanqp_11", tooltipLabel = "_tooltipLabel_nanqp_23", tooltipValue = "_tooltipValue_nanqp_25", styles$a = {
  tooltipCombinedTitle,
  singleRow,
  tooltipLabel,
  tooltipValue
}, Component = /* @__PURE__ */ __name(({
  type: type4,
  children
}) => {
  switch (type4) {
    case "double":
      return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children });
    default:
      return /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children });
  }
}, "Component"), TooltipCombinedTitle = /* @__PURE__ */ __name(({ type: type4, rows }) => {
  const classNames = cn(
    styles$a.tooltipCombinedTitle,
    { [styles$a.singleRow]: type4 === "single" },
    { [styles$a.doubleRow]: type4 === "double" }
  );
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: classNames, children: rows == null ? void 0 : rows.map(({ label: label2, value }, index2) => /* @__PURE__ */ jsxRuntimeExports.jsxs(Component, { type: type4, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: styles$a.tooltipLabel, children: label2 }),
    " ",
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: styles$a.tooltipValue, children: value })
  ] }, index2)) });
}, "TooltipCombinedTitle"), Tooltip2 = /* @__PURE__ */ __name(({
  isDefaultOpen,
  isOpen,
  isDisabled,
  shouldDestroyTooltipOnHide,
  title: title2,
  combined,
  overlayStyle,
  width,
  ...restProps
}) => {
  const tooltipTitle = combined ? /* @__PURE__ */ jsxRuntimeExports.jsx(TooltipCombinedTitle, { ...combined }) : title2, overlayStyleTooltip = { ...overlayStyle, maxWidth: width, width };
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    Tooltip$1,
    {
      ...restProps,
      overlayStyle: overlayStyleTooltip,
      title: tooltipTitle,
      defaultOpen: isDefaultOpen,
      destroyTooltipOnHide: shouldDestroyTooltipOnHide,
      open: isDisabled ? !1 : isOpen
    }
  );
}, "Tooltip");
function Space(props) {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Space$1, { ...props });
}
__name(Space, "Space");
Space.Compact = Space$1.Compact;
const Button = /* @__PURE__ */ __name(({
  children,
  countBadge,
  icon,
  isBlock,
  isDanger,
  isDisabled,
  isGhost,
  isLoading,
  size,
  tooltip,
  placementTooltip,
  isDisabledTooltip,
  color,
  className,
  ...rest
}) => {
  var _a;
  const { theme: theme2 } = useTheme(), tokenButton = (_a = theme2 == null ? void 0 : theme2.components) == null ? void 0 : _a.Button;
  let badgeType = "default", styleIcon = {
    width: tokenButton == null ? void 0 : tokenButton.iconSize,
    height: tokenButton == null ? void 0 : tokenButton.iconSize,
    fontSize: tokenButton == null ? void 0 : tokenButton.iconSize
  };
  return isGhost && (badgeType = "primary"), isDanger && (badgeType = "danger"), size === "small" && (styleIcon = {
    width: tokenButton == null ? void 0 : tokenButton.iconSizeSM,
    height: tokenButton == null ? void 0 : tokenButton.iconSizeSM,
    fontSize: tokenButton == null ? void 0 : tokenButton.iconSizeSM
  }), size === "large" && (styleIcon = {
    width: tokenButton == null ? void 0 : tokenButton.iconSizeLG,
    height: tokenButton == null ? void 0 : tokenButton.iconSizeLG,
    fontSize: tokenButton == null ? void 0 : tokenButton.iconSizeLG
  }), /* @__PURE__ */ jsxRuntimeExports.jsx(Tooltip2, { title: tooltip, isDisabled: isDisabledTooltip ? isDisabled : !1, placement: placementTooltip, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
    Button$2,
    {
      ...rest,
      size,
      disabled: isDisabled,
      loading: isLoading,
      block: isBlock,
      danger: isDanger,
      ghost: isGhost,
      icon: icon ? cloneElement$1(icon, { style: styleIcon }) : null,
      color: color === "primary" && rest.variant === "outlined" ? "default" : color,
      className: cn(className, "ant-btn-icon"),
      children: (children || countBadge) && /* @__PURE__ */ jsxRuntimeExports.jsxs(Space, { children: [
        children,
        countBadge && /* @__PURE__ */ jsxRuntimeExports.jsx(Badge, { type: badgeType, count: countBadge })
      ] })
    }
  ) });
}, "Button");
var prism = { exports: {} };
(function(module2) {
  var _self = typeof window < "u" ? window : typeof WorkerGlobalScope < "u" && self instanceof WorkerGlobalScope ? self : {};
  /**
   * Prism: Lightweight, robust, elegant syntax highlighting
   *
   * @license MIT <https://opensource.org/licenses/MIT>
   * @author Lea Verou <https://lea.verou.me>
   * @namespace
   * @public
   */
  var Prism2 = function(_self2) {
    var lang = /(?:^|\s)lang(?:uage)?-([\w-]+)(?=\s|$)/i, uniqueId = 0, plainTextGrammar = {}, _2 = {
      /**
       * By default, Prism will attempt to highlight all code elements (by calling {@link Prism.highlightAll}) on the
       * current page after the page finished loading. This might be a problem if e.g. you wanted to asynchronously load
       * additional languages or plugins yourself.
       *
       * By setting this value to `true`, Prism will not automatically highlight all code elements on the page.
       *
       * You obviously have to change this value before the automatic highlighting started. To do this, you can add an
       * empty Prism object into the global scope before loading the Prism script like this:
       *
       * ```js
       * window.Prism = window.Prism || {};
       * Prism.manual = true;
       * // add a new <script> to load Prism's script
       * ```
       *
       * @default false
       * @type {boolean}
       * @memberof Prism
       * @public
       */
      manual: _self2.Prism && _self2.Prism.manual,
      /**
       * By default, if Prism is in a web worker, it assumes that it is in a worker it created itself, so it uses
       * `addEventListener` to communicate with its parent instance. However, if you're using Prism manually in your
       * own worker, you don't want it to do this.
       *
       * By setting this value to `true`, Prism will not add its own listeners to the worker.
       *
       * You obviously have to change this value before Prism executes. To do this, you can add an
       * empty Prism object into the global scope before loading the Prism script like this:
       *
       * ```js
       * window.Prism = window.Prism || {};
       * Prism.disableWorkerMessageHandler = true;
       * // Load Prism's script
       * ```
       *
       * @default false
       * @type {boolean}
       * @memberof Prism
       * @public
       */
      disableWorkerMessageHandler: _self2.Prism && _self2.Prism.disableWorkerMessageHandler,
      /**
       * A namespace for utility methods.
       *
       * All function in this namespace that are not explicitly marked as _public_ are for __internal use only__ and may
       * change or disappear at any time.
       *
       * @namespace
       * @memberof Prism
       */
      util: {
        encode: /* @__PURE__ */ __name(function encode(tokens) {
          return tokens instanceof Token ? new Token(tokens.type, encode(tokens.content), tokens.alias) : Array.isArray(tokens) ? tokens.map(encode) : tokens.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/\u00a0/g, " ");
        }, "encode"),
        /**
         * Returns the name of the type of the given value.
         *
         * @param {any} o
         * @returns {string}
         * @example
         * type(null)      === 'Null'
         * type(undefined) === 'Undefined'
         * type(123)       === 'Number'
         * type('foo')     === 'String'
         * type(true)      === 'Boolean'
         * type([1, 2])    === 'Array'
         * type({})        === 'Object'
         * type(String)    === 'Function'
         * type(/abc+/)    === 'RegExp'
         */
        type: /* @__PURE__ */ __name(function(o2) {
          return Object.prototype.toString.call(o2).slice(8, -1);
        }, "type"),
        /**
         * Returns a unique number for the given object. Later calls will still return the same number.
         *
         * @param {Object} obj
         * @returns {number}
         */
        objId: /* @__PURE__ */ __name(function(obj) {
          return obj.__id || Object.defineProperty(obj, "__id", { value: ++uniqueId }), obj.__id;
        }, "objId"),
        /**
         * Creates a deep clone of the given object.
         *
         * The main intended use of this function is to clone language definitions.
         *
         * @param {T} o
         * @param {Record<number, any>} [visited]
         * @returns {T}
         * @template T
         */
        clone: /* @__PURE__ */ __name(function deepClone(o2, visited) {
          visited = visited || {};
          var clone, id2;
          switch (_2.util.type(o2)) {
            case "Object":
              if (id2 = _2.util.objId(o2), visited[id2])
                return visited[id2];
              clone = /** @type {Record<string, any>} */
              {}, visited[id2] = clone;
              for (var key in o2)
                o2.hasOwnProperty(key) && (clone[key] = deepClone(o2[key], visited));
              return (
                /** @type {any} */
                clone
              );
            case "Array":
              return id2 = _2.util.objId(o2), visited[id2] ? visited[id2] : (clone = [], visited[id2] = clone, /** @type {Array} */
              /** @type {any} */
              o2.forEach(function(v, i) {
                clone[i] = deepClone(v, visited);
              }), /** @type {any} */
              clone);
            default:
              return o2;
          }
        }, "deepClone"),
        /**
         * Returns the Prism language of the given element set by a `language-xxxx` or `lang-xxxx` class.
         *
         * If no language is set for the element or the element is `null` or `undefined`, `none` will be returned.
         *
         * @param {Element} element
         * @returns {string}
         */
        getLanguage: /* @__PURE__ */ __name(function(element) {
          for (; element; ) {
            var m2 = lang.exec(element.className);
            if (m2)
              return m2[1].toLowerCase();
            element = element.parentElement;
          }
          return "none";
        }, "getLanguage"),
        /**
         * Sets the Prism `language-xxxx` class of the given element.
         *
         * @param {Element} element
         * @param {string} language
         * @returns {void}
         */
        setLanguage: /* @__PURE__ */ __name(function(element, language) {
          element.className = element.className.replace(RegExp(lang, "gi"), ""), element.classList.add("language-" + language);
        }, "setLanguage"),
        /**
         * Returns the script element that is currently executing.
         *
         * This does __not__ work for line script element.
         *
         * @returns {HTMLScriptElement | null}
         */
        currentScript: /* @__PURE__ */ __name(function() {
          if (typeof document > "u")
            return null;
          if ("currentScript" in document)
            return (
              /** @type {any} */
              document.currentScript
            );
          try {
            throw new Error();
          } catch (err) {
            var src = (/at [^(\r\n]*\((.*):[^:]+:[^:]+\)$/i.exec(err.stack) || [])[1];
            if (src) {
              var scripts = document.getElementsByTagName("script");
              for (var i in scripts)
                if (scripts[i].src == src)
                  return scripts[i];
            }
            return null;
          }
        }, "currentScript"),
        /**
         * Returns whether a given class is active for `element`.
         *
         * The class can be activated if `element` or one of its ancestors has the given class and it can be deactivated
         * if `element` or one of its ancestors has the negated version of the given class. The _negated version_ of the
         * given class is just the given class with a `no-` prefix.
         *
         * Whether the class is active is determined by the closest ancestor of `element` (where `element` itself is
         * closest ancestor) that has the given class or the negated version of it. If neither `element` nor any of its
         * ancestors have the given class or the negated version of it, then the default activation will be returned.
         *
         * In the paradoxical situation where the closest ancestor contains __both__ the given class and the negated
         * version of it, the class is considered active.
         *
         * @param {Element} element
         * @param {string} className
         * @param {boolean} [defaultActivation=false]
         * @returns {boolean}
         */
        isActive: /* @__PURE__ */ __name(function(element, className, defaultActivation) {
          for (var no = "no-" + className; element; ) {
            var classList = element.classList;
            if (classList.contains(className))
              return !0;
            if (classList.contains(no))
              return !1;
            element = element.parentElement;
          }
          return !!defaultActivation;
        }, "isActive")
      },
      /**
       * This namespace contains all currently loaded languages and the some helper functions to create and modify languages.
       *
       * @namespace
       * @memberof Prism
       * @public
       */
      languages: {
        /**
         * The grammar for plain, unformatted text.
         */
        plain: plainTextGrammar,
        plaintext: plainTextGrammar,
        text: plainTextGrammar,
        txt: plainTextGrammar,
        /**
         * Creates a deep copy of the language with the given id and appends the given tokens.
         *
         * If a token in `redef` also appears in the copied language, then the existing token in the copied language
         * will be overwritten at its original position.
         *
         * ## Best practices
         *
         * Since the position of overwriting tokens (token in `redef` that overwrite tokens in the copied language)
         * doesn't matter, they can technically be in any order. However, this can be confusing to others that trying to
         * understand the language definition because, normally, the order of tokens matters in Prism grammars.
         *
         * Therefore, it is encouraged to order overwriting tokens according to the positions of the overwritten tokens.
         * Furthermore, all non-overwriting tokens should be placed after the overwriting ones.
         *
         * @param {string} id The id of the language to extend. This has to be a key in `Prism.languages`.
         * @param {Grammar} redef The new tokens to append.
         * @returns {Grammar} The new language created.
         * @public
         * @example
         * Prism.languages['css-with-colors'] = Prism.languages.extend('css', {
         *     // Prism.languages.css already has a 'comment' token, so this token will overwrite CSS' 'comment' token
         *     // at its original position
         *     'comment': { ... },
         *     // CSS doesn't have a 'color' token, so this token will be appended
         *     'color': /\b(?:red|green|blue)\b/
         * });
         */
        extend: /* @__PURE__ */ __name(function(id2, redef) {
          var lang2 = _2.util.clone(_2.languages[id2]);
          for (var key in redef)
            lang2[key] = redef[key];
          return lang2;
        }, "extend"),
        /**
         * Inserts tokens _before_ another token in a language definition or any other grammar.
         *
         * ## Usage
         *
         * This helper method makes it easy to modify existing languages. For example, the CSS language definition
         * not only defines CSS highlighting for CSS documents, but also needs to define highlighting for CSS embedded
         * in HTML through `<style>` elements. To do this, it needs to modify `Prism.languages.markup` and add the
         * appropriate tokens. However, `Prism.languages.markup` is a regular JavaScript object literal, so if you do
         * this:
         *
         * ```js
         * Prism.languages.markup.style = {
         *     // token
         * };
         * ```
         *
         * then the `style` token will be added (and processed) at the end. `insertBefore` allows you to insert tokens
         * before existing tokens. For the CSS example above, you would use it like this:
         *
         * ```js
         * Prism.languages.insertBefore('markup', 'cdata', {
         *     'style': {
         *         // token
         *     }
         * });
         * ```
         *
         * ## Special cases
         *
         * If the grammars of `inside` and `insert` have tokens with the same name, the tokens in `inside`'s grammar
         * will be ignored.
         *
         * This behavior can be used to insert tokens after `before`:
         *
         * ```js
         * Prism.languages.insertBefore('markup', 'comment', {
         *     'comment': Prism.languages.markup.comment,
         *     // tokens after 'comment'
         * });
         * ```
         *
         * ## Limitations
         *
         * The main problem `insertBefore` has to solve is iteration order. Since ES2015, the iteration order for object
         * properties is guaranteed to be the insertion order (except for integer keys) but some browsers behave
         * differently when keys are deleted and re-inserted. So `insertBefore` can't be implemented by temporarily
         * deleting properties which is necessary to insert at arbitrary positions.
         *
         * To solve this problem, `insertBefore` doesn't actually insert the given tokens into the target object.
         * Instead, it will create a new object and replace all references to the target object with the new one. This
         * can be done without temporarily deleting properties, so the iteration order is well-defined.
         *
         * However, only references that can be reached from `Prism.languages` or `insert` will be replaced. I.e. if
         * you hold the target object in a variable, then the value of the variable will not change.
         *
         * ```js
         * var oldMarkup = Prism.languages.markup;
         * var newMarkup = Prism.languages.insertBefore('markup', 'comment', { ... });
         *
         * assert(oldMarkup !== Prism.languages.markup);
         * assert(newMarkup === Prism.languages.markup);
         * ```
         *
         * @param {string} inside The property of `root` (e.g. a language id in `Prism.languages`) that contains the
         * object to be modified.
         * @param {string} before The key to insert before.
         * @param {Grammar} insert An object containing the key-value pairs to be inserted.
         * @param {Object<string, any>} [root] The object containing `inside`, i.e. the object that contains the
         * object to be modified.
         *
         * Defaults to `Prism.languages`.
         * @returns {Grammar} The new grammar object.
         * @public
         */
        insertBefore: /* @__PURE__ */ __name(function(inside, before, insert, root) {
          root = root || /** @type {any} */
          _2.languages;
          var grammar = root[inside], ret = {};
          for (var token2 in grammar)
            if (grammar.hasOwnProperty(token2)) {
              if (token2 == before)
                for (var newToken in insert)
                  insert.hasOwnProperty(newToken) && (ret[newToken] = insert[newToken]);
              insert.hasOwnProperty(token2) || (ret[token2] = grammar[token2]);
            }
          var old = root[inside];
          return root[inside] = ret, _2.languages.DFS(_2.languages, function(key, value) {
            value === old && key != inside && (this[key] = ret);
          }), ret;
        }, "insertBefore"),
        // Traverse a language definition with Depth First Search
        DFS: /* @__PURE__ */ __name(function DFS(o2, callback, type4, visited) {
          visited = visited || {};
          var objId = _2.util.objId;
          for (var i in o2)
            if (o2.hasOwnProperty(i)) {
              callback.call(o2, i, o2[i], type4 || i);
              var property = o2[i], propertyType = _2.util.type(property);
              propertyType === "Object" && !visited[objId(property)] ? (visited[objId(property)] = !0, DFS(property, callback, null, visited)) : propertyType === "Array" && !visited[objId(property)] && (visited[objId(property)] = !0, DFS(property, callback, i, visited));
            }
        }, "DFS")
      },
      plugins: {},
      /**
       * This is the most high-level function in Prism’s API.
       * It fetches all the elements that have a `.language-xxxx` class and then calls {@link Prism.highlightElement} on
       * each one of them.
       *
       * This is equivalent to `Prism.highlightAllUnder(document, async, callback)`.
       *
       * @param {boolean} [async=false] Same as in {@link Prism.highlightAllUnder}.
       * @param {HighlightCallback} [callback] Same as in {@link Prism.highlightAllUnder}.
       * @memberof Prism
       * @public
       */
      highlightAll: /* @__PURE__ */ __name(function(async, callback) {
        _2.highlightAllUnder(document, async, callback);
      }, "highlightAll"),
      /**
       * Fetches all the descendants of `container` that have a `.language-xxxx` class and then calls
       * {@link Prism.highlightElement} on each one of them.
       *
       * The following hooks will be run:
       * 1. `before-highlightall`
       * 2. `before-all-elements-highlight`
       * 3. All hooks of {@link Prism.highlightElement} for each element.
       *
       * @param {ParentNode} container The root element, whose descendants that have a `.language-xxxx` class will be highlighted.
       * @param {boolean} [async=false] Whether each element is to be highlighted asynchronously using Web Workers.
       * @param {HighlightCallback} [callback] An optional callback to be invoked on each element after its highlighting is done.
       * @memberof Prism
       * @public
       */
      highlightAllUnder: /* @__PURE__ */ __name(function(container2, async, callback) {
        var env = {
          callback,
          container: container2,
          selector: 'code[class*="language-"], [class*="language-"] code, code[class*="lang-"], [class*="lang-"] code'
        };
        _2.hooks.run("before-highlightall", env), env.elements = Array.prototype.slice.apply(env.container.querySelectorAll(env.selector)), _2.hooks.run("before-all-elements-highlight", env);
        for (var i = 0, element; element = env.elements[i++]; )
          _2.highlightElement(element, async === !0, env.callback);
      }, "highlightAllUnder"),
      /**
       * Highlights the code inside a single element.
       *
       * The following hooks will be run:
       * 1. `before-sanity-check`
       * 2. `before-highlight`
       * 3. All hooks of {@link Prism.highlight}. These hooks will be run by an asynchronous worker if `async` is `true`.
       * 4. `before-insert`
       * 5. `after-highlight`
       * 6. `complete`
       *
       * Some the above hooks will be skipped if the element doesn't contain any text or there is no grammar loaded for
       * the element's language.
       *
       * @param {Element} element The element containing the code.
       * It must have a class of `language-xxxx` to be processed, where `xxxx` is a valid language identifier.
       * @param {boolean} [async=false] Whether the element is to be highlighted asynchronously using Web Workers
       * to improve performance and avoid blocking the UI when highlighting very large chunks of code. This option is
       * [disabled by default](https://prismjs.com/faq.html#why-is-asynchronous-highlighting-disabled-by-default).
       *
       * Note: All language definitions required to highlight the code must be included in the main `prism.js` file for
       * asynchronous highlighting to work. You can build your own bundle on the
       * [Download page](https://prismjs.com/download.html).
       * @param {HighlightCallback} [callback] An optional callback to be invoked after the highlighting is done.
       * Mostly useful when `async` is `true`, since in that case, the highlighting is done asynchronously.
       * @memberof Prism
       * @public
       */
      highlightElement: /* @__PURE__ */ __name(function(element, async, callback) {
        var language = _2.util.getLanguage(element), grammar = _2.languages[language];
        _2.util.setLanguage(element, language);
        var parent = element.parentElement;
        parent && parent.nodeName.toLowerCase() === "pre" && _2.util.setLanguage(parent, language);
        var code = element.textContent, env = {
          element,
          language,
          grammar,
          code
        };
        function insertHighlightedCode(highlightedCode) {
          env.highlightedCode = highlightedCode, _2.hooks.run("before-insert", env), env.element.innerHTML = env.highlightedCode, _2.hooks.run("after-highlight", env), _2.hooks.run("complete", env), callback && callback.call(env.element);
        }
        if (__name(insertHighlightedCode, "insertHighlightedCode"), _2.hooks.run("before-sanity-check", env), parent = env.element.parentElement, parent && parent.nodeName.toLowerCase() === "pre" && !parent.hasAttribute("tabindex") && parent.setAttribute("tabindex", "0"), !env.code) {
          _2.hooks.run("complete", env), callback && callback.call(env.element);
          return;
        }
        if (_2.hooks.run("before-highlight", env), !env.grammar) {
          insertHighlightedCode(_2.util.encode(env.code));
          return;
        }
        if (async && _self2.Worker) {
          var worker = new Worker(_2.filename);
          worker.onmessage = function(evt) {
            insertHighlightedCode(evt.data);
          }, worker.postMessage(JSON.stringify({
            language: env.language,
            code: env.code,
            immediateClose: !0
          }));
        } else
          insertHighlightedCode(_2.highlight(env.code, env.grammar, env.language));
      }, "highlightElement"),
      /**
       * Low-level function, only use if you know what you’re doing. It accepts a string of text as input
       * and the language definitions to use, and returns a string with the HTML produced.
       *
       * The following hooks will be run:
       * 1. `before-tokenize`
       * 2. `after-tokenize`
       * 3. `wrap`: On each {@link Token}.
       *
       * @param {string} text A string with the code to be highlighted.
       * @param {Grammar} grammar An object containing the tokens to use.
       *
       * Usually a language definition like `Prism.languages.markup`.
       * @param {string} language The name of the language definition passed to `grammar`.
       * @returns {string} The highlighted HTML.
       * @memberof Prism
       * @public
       * @example
       * Prism.highlight('var foo = true;', Prism.languages.javascript, 'javascript');
       */
      highlight: /* @__PURE__ */ __name(function(text, grammar, language) {
        var env = {
          code: text,
          grammar,
          language
        };
        if (_2.hooks.run("before-tokenize", env), !env.grammar)
          throw new Error('The language "' + env.language + '" has no grammar.');
        return env.tokens = _2.tokenize(env.code, env.grammar), _2.hooks.run("after-tokenize", env), Token.stringify(_2.util.encode(env.tokens), env.language);
      }, "highlight"),
      /**
       * This is the heart of Prism, and the most low-level function you can use. It accepts a string of text as input
       * and the language definitions to use, and returns an array with the tokenized code.
       *
       * When the language definition includes nested tokens, the function is called recursively on each of these tokens.
       *
       * This method could be useful in other contexts as well, as a very crude parser.
       *
       * @param {string} text A string with the code to be highlighted.
       * @param {Grammar} grammar An object containing the tokens to use.
       *
       * Usually a language definition like `Prism.languages.markup`.
       * @returns {TokenStream} An array of strings and tokens, a token stream.
       * @memberof Prism
       * @public
       * @example
       * let code = `var foo = 0;`;
       * let tokens = Prism.tokenize(code, Prism.languages.javascript);
       * tokens.forEach(token => {
       *     if (token instanceof Prism.Token && token.type === 'number') {
       *         console.log(`Found numeric literal: ${token.content}`);
       *     }
       * });
       */
      tokenize: /* @__PURE__ */ __name(function(text, grammar) {
        var rest = grammar.rest;
        if (rest) {
          for (var token2 in rest)
            grammar[token2] = rest[token2];
          delete grammar.rest;
        }
        var tokenList = new LinkedList();
        return addAfter(tokenList, tokenList.head, text), matchGrammar(text, tokenList, grammar, tokenList.head, 0), toArray2(tokenList);
      }, "tokenize"),
      /**
       * @namespace
       * @memberof Prism
       * @public
       */
      hooks: {
        all: {},
        /**
         * Adds the given callback to the list of callbacks for the given hook.
         *
         * The callback will be invoked when the hook it is registered for is run.
         * Hooks are usually directly run by a highlight function but you can also run hooks yourself.
         *
         * One callback function can be registered to multiple hooks and the same hook multiple times.
         *
         * @param {string} name The name of the hook.
         * @param {HookCallback} callback The callback function which is given environment variables.
         * @public
         */
        add: /* @__PURE__ */ __name(function(name, callback) {
          var hooks = _2.hooks.all;
          hooks[name] = hooks[name] || [], hooks[name].push(callback);
        }, "add"),
        /**
         * Runs a hook invoking all registered callbacks with the given environment variables.
         *
         * Callbacks will be invoked synchronously and in the order in which they were registered.
         *
         * @param {string} name The name of the hook.
         * @param {Object<string, any>} env The environment variables of the hook passed to all callbacks registered.
         * @public
         */
        run: /* @__PURE__ */ __name(function(name, env) {
          var callbacks = _2.hooks.all[name];
          if (!(!callbacks || !callbacks.length))
            for (var i = 0, callback; callback = callbacks[i++]; )
              callback(env);
        }, "run")
      },
      Token
    };
    _self2.Prism = _2;
    function Token(type4, content, alias, matchedStr) {
      this.type = type4, this.content = content, this.alias = alias, this.length = (matchedStr || "").length | 0;
    }
    __name(Token, "Token"), Token.stringify = /* @__PURE__ */ __name(function stringify2(o2, language) {
      if (typeof o2 == "string")
        return o2;
      if (Array.isArray(o2)) {
        var s = "";
        return o2.forEach(function(e2) {
          s += stringify2(e2, language);
        }), s;
      }
      var env = {
        type: o2.type,
        content: stringify2(o2.content, language),
        tag: "span",
        classes: ["token", o2.type],
        attributes: {},
        language
      }, aliases = o2.alias;
      aliases && (Array.isArray(aliases) ? Array.prototype.push.apply(env.classes, aliases) : env.classes.push(aliases)), _2.hooks.run("wrap", env);
      var attributes2 = "";
      for (var name in env.attributes)
        attributes2 += " " + name + '="' + (env.attributes[name] || "").replace(/"/g, "&quot;") + '"';
      return "<" + env.tag + ' class="' + env.classes.join(" ") + '"' + attributes2 + ">" + env.content + "</" + env.tag + ">";
    }, "stringify");
    function matchPattern(pattern4, pos, text, lookbehind) {
      pattern4.lastIndex = pos;
      var match2 = pattern4.exec(text);
      if (match2 && lookbehind && match2[1]) {
        var lookbehindLength = match2[1].length;
        match2.index += lookbehindLength, match2[0] = match2[0].slice(lookbehindLength);
      }
      return match2;
    }
    __name(matchPattern, "matchPattern");
    function matchGrammar(text, tokenList, grammar, startNode, startPos, rematch) {
      for (var token2 in grammar)
        if (!(!grammar.hasOwnProperty(token2) || !grammar[token2])) {
          var patterns = grammar[token2];
          patterns = Array.isArray(patterns) ? patterns : [patterns];
          for (var j = 0; j < patterns.length; ++j) {
            if (rematch && rematch.cause == token2 + "," + j)
              return;
            var patternObj = patterns[j], inside = patternObj.inside, lookbehind = !!patternObj.lookbehind, greedy = !!patternObj.greedy, alias = patternObj.alias;
            if (greedy && !patternObj.pattern.global) {
              var flags = patternObj.pattern.toString().match(/[imsuy]*$/)[0];
              patternObj.pattern = RegExp(patternObj.pattern.source, flags + "g");
            }
            for (var pattern4 = patternObj.pattern || patternObj, currentNode = startNode.next, pos = startPos; currentNode !== tokenList.tail && !(rematch && pos >= rematch.reach); pos += currentNode.value.length, currentNode = currentNode.next) {
              var str = currentNode.value;
              if (tokenList.length > text.length)
                return;
              if (!(str instanceof Token)) {
                var removeCount = 1, match2;
                if (greedy) {
                  if (match2 = matchPattern(pattern4, pos, text, lookbehind), !match2 || match2.index >= text.length)
                    break;
                  var from2 = match2.index, to = match2.index + match2[0].length, p = pos;
                  for (p += currentNode.value.length; from2 >= p; )
                    currentNode = currentNode.next, p += currentNode.value.length;
                  if (p -= currentNode.value.length, pos = p, currentNode.value instanceof Token)
                    continue;
                  for (var k = currentNode; k !== tokenList.tail && (p < to || typeof k.value == "string"); k = k.next)
                    removeCount++, p += k.value.length;
                  removeCount--, str = text.slice(pos, p), match2.index -= pos;
                } else if (match2 = matchPattern(pattern4, 0, str, lookbehind), !match2)
                  continue;
                var from2 = match2.index, matchStr = match2[0], before = str.slice(0, from2), after = str.slice(from2 + matchStr.length), reach = pos + str.length;
                rematch && reach > rematch.reach && (rematch.reach = reach);
                var removeFrom = currentNode.prev;
                before && (removeFrom = addAfter(tokenList, removeFrom, before), pos += before.length), removeRange(tokenList, removeFrom, removeCount);
                var wrapped = new Token(token2, inside ? _2.tokenize(matchStr, inside) : matchStr, alias, matchStr);
                if (currentNode = addAfter(tokenList, removeFrom, wrapped), after && addAfter(tokenList, currentNode, after), removeCount > 1) {
                  var nestedRematch = {
                    cause: token2 + "," + j,
                    reach
                  };
                  matchGrammar(text, tokenList, grammar, currentNode.prev, pos, nestedRematch), rematch && nestedRematch.reach > rematch.reach && (rematch.reach = nestedRematch.reach);
                }
              }
            }
          }
        }
    }
    __name(matchGrammar, "matchGrammar");
    function LinkedList() {
      var head = { value: null, prev: null, next: null }, tail = { value: null, prev: head, next: null };
      head.next = tail, this.head = head, this.tail = tail, this.length = 0;
    }
    __name(LinkedList, "LinkedList");
    function addAfter(list, node2, value) {
      var next2 = node2.next, newNode = { value, prev: node2, next: next2 };
      return node2.next = newNode, next2.prev = newNode, list.length++, newNode;
    }
    __name(addAfter, "addAfter");
    function removeRange(list, node2, count) {
      for (var next2 = node2.next, i = 0; i < count && next2 !== list.tail; i++)
        next2 = next2.next;
      node2.next = next2, next2.prev = node2, list.length -= i;
    }
    __name(removeRange, "removeRange");
    function toArray2(list) {
      for (var array4 = [], node2 = list.head.next; node2 !== list.tail; )
        array4.push(node2.value), node2 = node2.next;
      return array4;
    }
    if (__name(toArray2, "toArray"), !_self2.document)
      return _self2.addEventListener && (_2.disableWorkerMessageHandler || _self2.addEventListener("message", function(evt) {
        var message = JSON.parse(evt.data), lang2 = message.language, code = message.code, immediateClose = message.immediateClose;
        _self2.postMessage(_2.highlight(code, _2.languages[lang2], lang2)), immediateClose && _self2.close();
      }, !1)), _2;
    var script = _2.util.currentScript();
    script && (_2.filename = script.src, script.hasAttribute("data-manual") && (_2.manual = !0));
    function highlightAutomaticallyCallback() {
      _2.manual || _2.highlightAll();
    }
    if (__name(highlightAutomaticallyCallback, "highlightAutomaticallyCallback"), !_2.manual) {
      var readyState = document.readyState;
      readyState === "loading" || readyState === "interactive" && script && script.defer ? document.addEventListener("DOMContentLoaded", highlightAutomaticallyCallback) : window.requestAnimationFrame ? window.requestAnimationFrame(highlightAutomaticallyCallback) : window.setTimeout(highlightAutomaticallyCallback, 16);
    }
    return _2;
  }(_self);
  module2.exports && (module2.exports = Prism2), typeof commonjsGlobal < "u" && (commonjsGlobal.Prism = Prism2), Prism2.languages.markup = {
    comment: {
      pattern: /<!--(?:(?!<!--)[\s\S])*?-->/,
      greedy: !0
    },
    prolog: {
      pattern: /<\?[\s\S]+?\?>/,
      greedy: !0
    },
    doctype: {
      // https://www.w3.org/TR/xml/#NT-doctypedecl
      pattern: /<!DOCTYPE(?:[^>"'[\]]|"[^"]*"|'[^']*')+(?:\[(?:[^<"'\]]|"[^"]*"|'[^']*'|<(?!!--)|<!--(?:[^-]|-(?!->))*-->)*\]\s*)?>/i,
      greedy: !0,
      inside: {
        "internal-subset": {
          pattern: /(^[^\[]*\[)[\s\S]+(?=\]>$)/,
          lookbehind: !0,
          greedy: !0,
          inside: null
          // see below
        },
        string: {
          pattern: /"[^"]*"|'[^']*'/,
          greedy: !0
        },
        punctuation: /^<!|>$|[[\]]/,
        "doctype-tag": /^DOCTYPE/i,
        name: /[^\s<>'"]+/
      }
    },
    cdata: {
      pattern: /<!\[CDATA\[[\s\S]*?\]\]>/i,
      greedy: !0
    },
    tag: {
      pattern: /<\/?(?!\d)[^\s>\/=$<%]+(?:\s(?:\s*[^\s>\/=]+(?:\s*=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+(?=[\s>]))|(?=[\s/>])))+)?\s*\/?>/,
      greedy: !0,
      inside: {
        tag: {
          pattern: /^<\/?[^\s>\/]+/,
          inside: {
            punctuation: /^<\/?/,
            namespace: /^[^\s>\/:]+:/
          }
        },
        "special-attr": [],
        "attr-value": {
          pattern: /=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+)/,
          inside: {
            punctuation: [
              {
                pattern: /^=/,
                alias: "attr-equals"
              },
              {
                pattern: /^(\s*)["']|["']$/,
                lookbehind: !0
              }
            ]
          }
        },
        punctuation: /\/?>/,
        "attr-name": {
          pattern: /[^\s>\/]+/,
          inside: {
            namespace: /^[^\s>\/:]+:/
          }
        }
      }
    },
    entity: [
      {
        pattern: /&[\da-z]{1,8};/i,
        alias: "named-entity"
      },
      /&#x?[\da-f]{1,8};/i
    ]
  }, Prism2.languages.markup.tag.inside["attr-value"].inside.entity = Prism2.languages.markup.entity, Prism2.languages.markup.doctype.inside["internal-subset"].inside = Prism2.languages.markup, Prism2.hooks.add("wrap", function(env) {
    env.type === "entity" && (env.attributes.title = env.content.replace(/&amp;/, "&"));
  }), Object.defineProperty(Prism2.languages.markup.tag, "addInlined", {
    /**
     * Adds an inlined language to markup.
     *
     * An example of an inlined language is CSS with `<style>` tags.
     *
     * @param {string} tagName The name of the tag that contains the inlined language. This name will be treated as
     * case insensitive.
     * @param {string} lang The language key.
     * @example
     * addInlined('style', 'css');
     */
    value: /* @__PURE__ */ __name(function(tagName, lang) {
      var includedCdataInside = {};
      includedCdataInside["language-" + lang] = {
        pattern: /(^<!\[CDATA\[)[\s\S]+?(?=\]\]>$)/i,
        lookbehind: !0,
        inside: Prism2.languages[lang]
      }, includedCdataInside.cdata = /^<!\[CDATA\[|\]\]>$/i;
      var inside = {
        "included-cdata": {
          pattern: /<!\[CDATA\[[\s\S]*?\]\]>/i,
          inside: includedCdataInside
        }
      };
      inside["language-" + lang] = {
        pattern: /[\s\S]+/,
        inside: Prism2.languages[lang]
      };
      var def = {};
      def[tagName] = {
        pattern: RegExp(/(<__[^>]*>)(?:<!\[CDATA\[(?:[^\]]|\](?!\]>))*\]\]>|(?!<!\[CDATA\[)[\s\S])*?(?=<\/__>)/.source.replace(/__/g, function() {
          return tagName;
        }), "i"),
        lookbehind: !0,
        greedy: !0,
        inside
      }, Prism2.languages.insertBefore("markup", "cdata", def);
    }, "addInlined")
  }), Object.defineProperty(Prism2.languages.markup.tag, "addAttribute", {
    /**
     * Adds an pattern to highlight languages embedded in HTML attributes.
     *
     * An example of an inlined language is CSS with `style` attributes.
     *
     * @param {string} attrName The name of the tag that contains the inlined language. This name will be treated as
     * case insensitive.
     * @param {string} lang The language key.
     * @example
     * addAttribute('style', 'css');
     */
    value: /* @__PURE__ */ __name(function(attrName, lang) {
      Prism2.languages.markup.tag.inside["special-attr"].push({
        pattern: RegExp(
          /(^|["'\s])/.source + "(?:" + attrName + ")" + /\s*=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+(?=[\s>]))/.source,
          "i"
        ),
        lookbehind: !0,
        inside: {
          "attr-name": /^[^\s=]+/,
          "attr-value": {
            pattern: /=[\s\S]+/,
            inside: {
              value: {
                pattern: /(^=\s*(["']|(?!["'])))\S[\s\S]*(?=\2$)/,
                lookbehind: !0,
                alias: [lang, "language-" + lang],
                inside: Prism2.languages[lang]
              },
              punctuation: [
                {
                  pattern: /^=/,
                  alias: "attr-equals"
                },
                /"|'/
              ]
            }
          }
        }
      });
    }, "value")
  }), Prism2.languages.html = Prism2.languages.markup, Prism2.languages.mathml = Prism2.languages.markup, Prism2.languages.svg = Prism2.languages.markup, Prism2.languages.xml = Prism2.languages.extend("markup", {}), Prism2.languages.ssml = Prism2.languages.xml, Prism2.languages.atom = Prism2.languages.xml, Prism2.languages.rss = Prism2.languages.xml, function(Prism3) {
    var string3 = /(?:"(?:\\(?:\r\n|[\s\S])|[^"\\\r\n])*"|'(?:\\(?:\r\n|[\s\S])|[^'\\\r\n])*')/;
    Prism3.languages.css = {
      comment: /\/\*[\s\S]*?\*\//,
      atrule: {
        pattern: RegExp("@[\\w-](?:" + /[^;{\s"']|\s+(?!\s)/.source + "|" + string3.source + ")*?" + /(?:;|(?=\s*\{))/.source),
        inside: {
          rule: /^@[\w-]+/,
          "selector-function-argument": {
            pattern: /(\bselector\s*\(\s*(?![\s)]))(?:[^()\s]|\s+(?![\s)])|\((?:[^()]|\([^()]*\))*\))+(?=\s*\))/,
            lookbehind: !0,
            alias: "selector"
          },
          keyword: {
            pattern: /(^|[^\w-])(?:and|not|only|or)(?![\w-])/,
            lookbehind: !0
          }
          // See rest below
        }
      },
      url: {
        // https://drafts.csswg.org/css-values-3/#urls
        pattern: RegExp("\\burl\\((?:" + string3.source + "|" + /(?:[^\\\r\n()"']|\\[\s\S])*/.source + ")\\)", "i"),
        greedy: !0,
        inside: {
          function: /^url/i,
          punctuation: /^\(|\)$/,
          string: {
            pattern: RegExp("^" + string3.source + "$"),
            alias: "url"
          }
        }
      },
      selector: {
        pattern: RegExp(`(^|[{}\\s])[^{}\\s](?:[^{};"'\\s]|\\s+(?![\\s{])|` + string3.source + ")*(?=\\s*\\{)"),
        lookbehind: !0
      },
      string: {
        pattern: string3,
        greedy: !0
      },
      property: {
        pattern: /(^|[^-\w\xA0-\uFFFF])(?!\s)[-_a-z\xA0-\uFFFF](?:(?!\s)[-\w\xA0-\uFFFF])*(?=\s*:)/i,
        lookbehind: !0
      },
      important: /!important\b/i,
      function: {
        pattern: /(^|[^-a-z0-9])[-a-z0-9]+(?=\()/i,
        lookbehind: !0
      },
      punctuation: /[(){};:,]/
    }, Prism3.languages.css.atrule.inside.rest = Prism3.languages.css;
    var markup = Prism3.languages.markup;
    markup && (markup.tag.addInlined("style", "css"), markup.tag.addAttribute("style", "css"));
  }(Prism2), Prism2.languages.clike = {
    comment: [
      {
        pattern: /(^|[^\\])\/\*[\s\S]*?(?:\*\/|$)/,
        lookbehind: !0,
        greedy: !0
      },
      {
        pattern: /(^|[^\\:])\/\/.*/,
        lookbehind: !0,
        greedy: !0
      }
    ],
    string: {
      pattern: /(["'])(?:\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/,
      greedy: !0
    },
    "class-name": {
      pattern: /(\b(?:class|extends|implements|instanceof|interface|new|trait)\s+|\bcatch\s+\()[\w.\\]+/i,
      lookbehind: !0,
      inside: {
        punctuation: /[.\\]/
      }
    },
    keyword: /\b(?:break|catch|continue|do|else|finally|for|function|if|in|instanceof|new|null|return|throw|try|while)\b/,
    boolean: /\b(?:false|true)\b/,
    function: /\b\w+(?=\()/,
    number: /\b0x[\da-f]+\b|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:e[+-]?\d+)?/i,
    operator: /[<>]=?|[!=]=?=?|--?|\+\+?|&&?|\|\|?|[?*/~^%]/,
    punctuation: /[{}[\];(),.:]/
  }, Prism2.languages.javascript = Prism2.languages.extend("clike", {
    "class-name": [
      Prism2.languages.clike["class-name"],
      {
        pattern: /(^|[^$\w\xA0-\uFFFF])(?!\s)[_$A-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\.(?:constructor|prototype))/,
        lookbehind: !0
      }
    ],
    keyword: [
      {
        pattern: /((?:^|\})\s*)catch\b/,
        lookbehind: !0
      },
      {
        pattern: /(^|[^.]|\.\.\.\s*)\b(?:as|assert(?=\s*\{)|async(?=\s*(?:function\b|\(|[$\w\xA0-\uFFFF]|$))|await|break|case|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally(?=\s*(?:\{|$))|for|from(?=\s*(?:['"]|$))|function|(?:get|set)(?=\s*(?:[#\[$\w\xA0-\uFFFF]|$))|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)\b/,
        lookbehind: !0
      }
    ],
    // Allow for all non-ASCII characters (See http://stackoverflow.com/a/2008444)
    function: /#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*(?:\.\s*(?:apply|bind|call)\s*)?\()/,
    number: {
      pattern: RegExp(
        /(^|[^\w$])/.source + "(?:" + // constant
        (/NaN|Infinity/.source + "|" + // binary integer
        /0[bB][01]+(?:_[01]+)*n?/.source + "|" + // octal integer
        /0[oO][0-7]+(?:_[0-7]+)*n?/.source + "|" + // hexadecimal integer
        /0[xX][\dA-Fa-f]+(?:_[\dA-Fa-f]+)*n?/.source + "|" + // decimal bigint
        /\d+(?:_\d+)*n/.source + "|" + // decimal number (integer or float) but no bigint
        /(?:\d+(?:_\d+)*(?:\.(?:\d+(?:_\d+)*)?)?|\.\d+(?:_\d+)*)(?:[Ee][+-]?\d+(?:_\d+)*)?/.source) + ")" + /(?![\w$])/.source
      ),
      lookbehind: !0
    },
    operator: /--|\+\+|\*\*=?|=>|&&=?|\|\|=?|[!=]==|<<=?|>>>?=?|[-+*/%&|^!=<>]=?|\.{3}|\?\?=?|\?\.?|[~:]/
  }), Prism2.languages.javascript["class-name"][0].pattern = /(\b(?:class|extends|implements|instanceof|interface|new)\s+)[\w.\\]+/, Prism2.languages.insertBefore("javascript", "keyword", {
    regex: {
      pattern: RegExp(
        // lookbehind
        // eslint-disable-next-line regexp/no-dupe-characters-character-class
        /((?:^|[^$\w\xA0-\uFFFF."'\])\s]|\b(?:return|yield))\s*)/.source + // Regex pattern:
        // There are 2 regex patterns here. The RegExp set notation proposal added support for nested character
        // classes if the `v` flag is present. Unfortunately, nested CCs are both context-free and incompatible
        // with the only syntax, so we have to define 2 different regex patterns.
        /\//.source + "(?:" + /(?:\[(?:[^\]\\\r\n]|\\.)*\]|\\.|[^/\\\[\r\n])+\/[dgimyus]{0,7}/.source + "|" + // `v` flag syntax. This supports 3 levels of nested character classes.
        /(?:\[(?:[^[\]\\\r\n]|\\.|\[(?:[^[\]\\\r\n]|\\.|\[(?:[^[\]\\\r\n]|\\.)*\])*\])*\]|\\.|[^/\\\[\r\n])+\/[dgimyus]{0,7}v[dgimyus]{0,7}/.source + ")" + // lookahead
        /(?=(?:\s|\/\*(?:[^*]|\*(?!\/))*\*\/)*(?:$|[\r\n,.;:})\]]|\/\/))/.source
      ),
      lookbehind: !0,
      greedy: !0,
      inside: {
        "regex-source": {
          pattern: /^(\/)[\s\S]+(?=\/[a-z]*$)/,
          lookbehind: !0,
          alias: "language-regex",
          inside: Prism2.languages.regex
        },
        "regex-delimiter": /^\/|\/$/,
        "regex-flags": /^[a-z]+$/
      }
    },
    // This must be declared before keyword because we use "function" inside the look-forward
    "function-variable": {
      pattern: /#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*[=:]\s*(?:async\s*)?(?:\bfunction\b|(?:\((?:[^()]|\([^()]*\))*\)|(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*)\s*=>))/,
      alias: "function"
    },
    parameter: [
      {
        pattern: /(function(?:\s+(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*)?\s*\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\))/,
        lookbehind: !0,
        inside: Prism2.languages.javascript
      },
      {
        pattern: /(^|[^$\w\xA0-\uFFFF])(?!\s)[_$a-z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*=>)/i,
        lookbehind: !0,
        inside: Prism2.languages.javascript
      },
      {
        pattern: /(\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\)\s*=>)/,
        lookbehind: !0,
        inside: Prism2.languages.javascript
      },
      {
        pattern: /((?:\b|\s|^)(?!(?:as|async|await|break|case|catch|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally|for|from|function|get|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|set|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)(?![$\w\xA0-\uFFFF]))(?:(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*\s*)\(\s*|\]\s*\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\)\s*\{)/,
        lookbehind: !0,
        inside: Prism2.languages.javascript
      }
    ],
    constant: /\b[A-Z](?:[A-Z_]|\dx?)*\b/
  }), Prism2.languages.insertBefore("javascript", "string", {
    hashbang: {
      pattern: /^#!.*/,
      greedy: !0,
      alias: "comment"
    },
    "template-string": {
      pattern: /`(?:\\[\s\S]|\$\{(?:[^{}]|\{(?:[^{}]|\{[^}]*\})*\})+\}|(?!\$\{)[^\\`])*`/,
      greedy: !0,
      inside: {
        "template-punctuation": {
          pattern: /^`|`$/,
          alias: "string"
        },
        interpolation: {
          pattern: /((?:^|[^\\])(?:\\{2})*)\$\{(?:[^{}]|\{(?:[^{}]|\{[^}]*\})*\})+\}/,
          lookbehind: !0,
          inside: {
            "interpolation-punctuation": {
              pattern: /^\$\{|\}$/,
              alias: "punctuation"
            },
            rest: Prism2.languages.javascript
          }
        },
        string: /[\s\S]+/
      }
    },
    "string-property": {
      pattern: /((?:^|[,{])[ \t]*)(["'])(?:\\(?:\r\n|[\s\S])|(?!\2)[^\\\r\n])*\2(?=\s*:)/m,
      lookbehind: !0,
      greedy: !0,
      alias: "property"
    }
  }), Prism2.languages.insertBefore("javascript", "operator", {
    "literal-property": {
      pattern: /((?:^|[,{])[ \t]*)(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*:)/m,
      lookbehind: !0,
      alias: "property"
    }
  }), Prism2.languages.markup && (Prism2.languages.markup.tag.addInlined("script", "javascript"), Prism2.languages.markup.tag.addAttribute(
    /on(?:abort|blur|change|click|composition(?:end|start|update)|dblclick|error|focus(?:in|out)?|key(?:down|up)|load|mouse(?:down|enter|leave|move|out|over|up)|reset|resize|scroll|select|slotchange|submit|unload|wheel)/.source,
    "javascript"
  )), Prism2.languages.js = Prism2.languages.javascript, function() {
    if (typeof Prism2 > "u" || typeof document > "u")
      return;
    Element.prototype.matches || (Element.prototype.matches = Element.prototype.msMatchesSelector || Element.prototype.webkitMatchesSelector);
    var LOADING_MESSAGE = "Loading…", FAILURE_MESSAGE = /* @__PURE__ */ __name(function(status, message) {
      return "✖ Error " + status + " while fetching file: " + message;
    }, "FAILURE_MESSAGE"), FAILURE_EMPTY_MESSAGE = "✖ Error: File does not exist or is empty", EXTENSIONS = {
      js: "javascript",
      py: "python",
      rb: "ruby",
      ps1: "powershell",
      psm1: "powershell",
      sh: "bash",
      bat: "batch",
      h: "c",
      tex: "latex"
    }, STATUS_ATTR = "data-src-status", STATUS_LOADING = "loading", STATUS_LOADED = "loaded", STATUS_FAILED = "failed", SELECTOR = "pre[data-src]:not([" + STATUS_ATTR + '="' + STATUS_LOADED + '"]):not([' + STATUS_ATTR + '="' + STATUS_LOADING + '"])';
    function loadFile(src, success, error) {
      var xhr = new XMLHttpRequest();
      xhr.open("GET", src, !0), xhr.onreadystatechange = function() {
        xhr.readyState == 4 && (xhr.status < 400 && xhr.responseText ? success(xhr.responseText) : xhr.status >= 400 ? error(FAILURE_MESSAGE(xhr.status, xhr.statusText)) : error(FAILURE_EMPTY_MESSAGE));
      }, xhr.send(null);
    }
    __name(loadFile, "loadFile");
    function parseRange(range3) {
      var m2 = /^\s*(\d+)\s*(?:(,)\s*(?:(\d+)\s*)?)?$/.exec(range3 || "");
      if (m2) {
        var start = Number(m2[1]), comma = m2[2], end = m2[3];
        return comma ? end ? [start, Number(end)] : [start, void 0] : [start, start];
      }
    }
    __name(parseRange, "parseRange"), Prism2.hooks.add("before-highlightall", function(env) {
      env.selector += ", " + SELECTOR;
    }), Prism2.hooks.add("before-sanity-check", function(env) {
      var pre = (
        /** @type {HTMLPreElement} */
        env.element
      );
      if (pre.matches(SELECTOR)) {
        env.code = "", pre.setAttribute(STATUS_ATTR, STATUS_LOADING);
        var code = pre.appendChild(document.createElement("CODE"));
        code.textContent = LOADING_MESSAGE;
        var src = pre.getAttribute("data-src"), language = env.language;
        if (language === "none") {
          var extension = (/\.(\w+)$/.exec(src) || [, "none"])[1];
          language = EXTENSIONS[extension] || extension;
        }
        Prism2.util.setLanguage(code, language), Prism2.util.setLanguage(pre, language);
        var autoloader = Prism2.plugins.autoloader;
        autoloader && autoloader.loadLanguages(language), loadFile(
          src,
          function(text) {
            pre.setAttribute(STATUS_ATTR, STATUS_LOADED);
            var range3 = parseRange(pre.getAttribute("data-range"));
            if (range3) {
              var lines = text.split(/\r\n?|\n/g), start = range3[0], end = range3[1] == null ? lines.length : range3[1];
              start < 0 && (start += lines.length), start = Math.max(0, Math.min(start - 1, lines.length)), end < 0 && (end += lines.length), end = Math.max(0, Math.min(end, lines.length)), text = lines.slice(start, end).join(`
`), pre.hasAttribute("data-start") || pre.setAttribute("data-start", String(start + 1));
            }
            code.textContent = text, Prism2.highlightElement(code);
          },
          function(error) {
            pre.setAttribute(STATUS_ATTR, STATUS_FAILED), code.textContent = error;
          }
        );
      }
    }), Prism2.plugins.fileHighlight = {
      /**
       * Executes the File Highlight plugin for all matching `pre` elements under the given container.
       *
       * Note: Elements which are already loaded or currently loading will not be touched by this method.
       *
       * @param {ParentNode} [container=document]
       */
      highlight: /* @__PURE__ */ __name(function(container2) {
        for (var elements = (container2 || document).querySelectorAll(SELECTOR), i = 0, element; element = elements[i++]; )
          Prism2.highlightElement(element);
      }, "highlight")
    };
    var logged = !1;
    Prism2.fileHighlight = function() {
      logged || (console.warn("Prism.fileHighlight is deprecated. Use `Prism.plugins.fileHighlight.highlight` instead."), logged = !0), Prism2.plugins.fileHighlight.highlight.apply(this, arguments);
    };
  }();
})(prism);
var prismExports = prism.exports;
const Prism = /* @__PURE__ */ getDefaultExportFromCjs(prismExports), InputComponent = /* @__PURE__ */ __name(({ placeholder = "Введите значение", ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsx(Input$1, { ...props, disabled: props.isDisabled, placeholder, readOnly: props.isReadOnly, ref }), "InputComponent"), Input2 = forwardRef(InputComponent), getLabelStylesFromSize = /* @__PURE__ */ __name((theme2, size = "middle") => {
  var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y, _z, _A, _B, _C, _D;
  return {
    small: {
      inputFontSize: (_b = (_a = theme2.components) == null ? void 0 : _a.Input) == null ? void 0 : _b.inputFontSizeSM,
      labelFontSize: (_d = (_c = theme2.components) == null ? void 0 : _c.Input) == null ? void 0 : _d.labelFontSize,
      placeholderHeight: ((_f = (_e = theme2.components) == null ? void 0 : _e.Input) == null ? void 0 : _f.inputFontSizeSM) * ((_h = (_g = theme2.components) == null ? void 0 : _g.Input) == null ? void 0 : _h.lineHeight),
      left: (_j = (_i = theme2.components) == null ? void 0 : _i.Input) == null ? void 0 : _j.paddingInlineSM
    },
    middle: {
      inputFontSize: (_l = (_k = theme2.components) == null ? void 0 : _k.Input) == null ? void 0 : _l.inputFontSize,
      labelFontSize: (_n = (_m = theme2.components) == null ? void 0 : _m.Input) == null ? void 0 : _n.labelFontSize,
      placeholderHeight: ((_p = (_o = theme2.components) == null ? void 0 : _o.Input) == null ? void 0 : _p.inputFontSize) * ((_r = (_q = theme2.components) == null ? void 0 : _q.Input) == null ? void 0 : _r.lineHeight),
      left: (_t = (_s = theme2.components) == null ? void 0 : _s.Input) == null ? void 0 : _t.paddingInline
    },
    large: {
      inputFontSize: (_v = (_u = theme2.components) == null ? void 0 : _u.Input) == null ? void 0 : _v.inputFontSizeLG,
      labelFontSize: (_x = (_w = theme2.components) == null ? void 0 : _w.Input) == null ? void 0 : _x.labelFontSize,
      placeholderHeight: ((_z = (_y = theme2.components) == null ? void 0 : _y.Input) == null ? void 0 : _z.inputFontSizeLG) * ((_B = (_A = theme2.components) == null ? void 0 : _A.Input) == null ? void 0 : _B.lineHeight),
      left: (_D = (_C = theme2.components) == null ? void 0 : _C.Input) == null ? void 0 : _D.paddingInlineLG
    }
  }[size];
}, "getLabelStylesFromSize"), floatLabel = "_float-label_1rkir_1", label = "_label_1rkir_9", asLabel = "_as-label_1rkir_21", styles$9 = {
  floatLabel,
  label,
  asLabel
}, FloatInputComponent = /* @__PURE__ */ __name(({ placeholder, size, value, defaultValue, type: type4, title: title2, ...props }, ref) => {
  var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k;
  const currRef = useRef(null), { theme: theme2 } = useTheme(), labelStyles = getLabelStylesFromSize(theme2, size), [focus, setFocus] = useState(!1), labelHeight = labelStyles.placeholderHeight;
  useImperativeHandle(ref, () => {
    var _a2;
    return {
      input: ((_a2 = currRef.current) == null ? void 0 : _a2.input) || null
    };
  });
  const refValue = ((_b = (_a = currRef.current) == null ? void 0 : _a.input) == null ? void 0 : _b.value) || value || "", isOccupied = !!(focus || value || refValue && refValue.length !== 0), labelClass = isOccupied ? styles$9.asLabel : styles$9.asPlaceholder;
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { onBlur: /* @__PURE__ */ __name(() => setFocus(!1), "onBlur"), onFocus: /* @__PURE__ */ __name(() => setFocus(!0), "onFocus"), className: styles$9.floatLabel, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      Input$1,
      {
        ...props,
        defaultValue,
        onChange: props.onChange,
        ref: ref || currRef,
        size,
        type: type4,
        value
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      "label",
      {
        style: {
          fontSize: isOccupied ? (_d = (_c = theme2.components) == null ? void 0 : _c.Input) == null ? void 0 : _d.labelFontSize : labelStyles.inputFontSize,
          color: isOccupied ? (_f = (_e = theme2.components) == null ? void 0 : _e.Input) == null ? void 0 : _f.labelColor : (_h = (_g = theme2.components) == null ? void 0 : _g.Input) == null ? void 0 : _h.colorTextPlaceholder,
          fontFamily: (_i = theme2.token) == null ? void 0 : _i.fontFamily,
          lineHeight: isOccupied ? 1 : (_k = (_j = theme2.components) == null ? void 0 : _j.Input) == null ? void 0 : _k.lineHeight,
          top: isOccupied ? "calc(-7px)" : `calc(50% - ${labelHeight / 2}px)`,
          left: labelStyles.left
        },
        className: cn(styles$9.label, labelClass),
        children: !isOccupied && placeholder ? placeholder : title2
      }
    )
  ] });
}, "FloatInputComponent"), FloatInput = forwardRef(FloatInputComponent);
var reactTextMask = { exports: {} };
(function(module2, exports) {
  (function(e2, t2) {
    module2.exports = t2(React__default);
  })(commonjsGlobal, function(e2) {
    return function(e3) {
      function t2(n2) {
        if (r2[n2]) return r2[n2].exports;
        var o2 = r2[n2] = { exports: {}, id: n2, loaded: !1 };
        return e3[n2].call(o2.exports, o2, o2.exports, t2), o2.loaded = !0, o2.exports;
      }
      __name(t2, "t");
      var r2 = {};
      return t2.m = e3, t2.c = r2, t2.p = "", t2(0);
    }([function(e3, t2, r2) {
      function n2(e4) {
        return e4 && e4.__esModule ? e4 : { default: e4 };
      }
      __name(n2, "n");
      function o2(e4, t3) {
        var r3 = {};
        for (var n3 in e4) t3.indexOf(n3) >= 0 || Object.prototype.hasOwnProperty.call(e4, n3) && (r3[n3] = e4[n3]);
        return r3;
      }
      __name(o2, "o");
      function i(e4, t3) {
        if (!(e4 instanceof t3)) throw new TypeError("Cannot call a class as a function");
      }
      __name(i, "i");
      function a(e4, t3) {
        if (!e4) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        return !t3 || typeof t3 != "object" && typeof t3 != "function" ? e4 : t3;
      }
      __name(a, "a");
      function u(e4, t3) {
        if (typeof t3 != "function" && t3 !== null) throw new TypeError("Super expression must either be null or a function, not " + typeof t3);
        e4.prototype = Object.create(t3 && t3.prototype, { constructor: { value: e4, enumerable: !1, writable: !0, configurable: !0 } }), t3 && (Object.setPrototypeOf ? Object.setPrototypeOf(e4, t3) : e4.__proto__ = t3);
      }
      __name(u, "u"), Object.defineProperty(t2, "__esModule", { value: !0 }), t2.conformToMask = void 0;
      var s = Object.assign || function(e4) {
        for (var t3 = 1; t3 < arguments.length; t3++) {
          var r3 = arguments[t3];
          for (var n3 in r3) Object.prototype.hasOwnProperty.call(r3, n3) && (e4[n3] = r3[n3]);
        }
        return e4;
      }, l2 = function() {
        function e4(e5, t3) {
          for (var r3 = 0; r3 < t3.length; r3++) {
            var n3 = t3[r3];
            n3.enumerable = n3.enumerable || !1, n3.configurable = !0, "value" in n3 && (n3.writable = !0), Object.defineProperty(e5, n3.key, n3);
          }
        }
        return __name(e4, "e"), function(t3, r3, n3) {
          return r3 && e4(t3.prototype, r3), n3 && e4(t3, n3), t3;
        };
      }(), f = r2(3);
      Object.defineProperty(t2, "conformToMask", { enumerable: !0, get: /* @__PURE__ */ __name(function() {
        return n2(f).default;
      }, "get") });
      var c = r2(11), p = n2(c), d = r2(9), h = n2(d), v = r2(5), y = n2(v), m2 = r2(2), b = function(e4) {
        function t3() {
          var e5;
          i(this, t3);
          for (var r3 = arguments.length, n3 = Array(r3), o3 = 0; o3 < r3; o3++) n3[o3] = arguments[o3];
          var u2 = a(this, (e5 = t3.__proto__ || Object.getPrototypeOf(t3)).call.apply(e5, [this].concat(n3)));
          return u2.setRef = u2.setRef.bind(u2), u2.onBlur = u2.onBlur.bind(u2), u2.onChange = u2.onChange.bind(u2), u2;
        }
        return __name(t3, "t"), u(t3, e4), l2(t3, [{ key: "setRef", value: /* @__PURE__ */ __name(function(e5) {
          this.inputElement = e5;
        }, "value") }, { key: "initTextMask", value: /* @__PURE__ */ __name(function() {
          var e5 = this.props, t4 = this.props.value;
          this.textMaskInputElement = (0, y.default)(s({ inputElement: this.inputElement }, e5)), this.textMaskInputElement.update(t4);
        }, "value") }, { key: "componentDidMount", value: /* @__PURE__ */ __name(function() {
          this.initTextMask();
        }, "value") }, { key: "componentDidUpdate", value: /* @__PURE__ */ __name(function(e5) {
          var t4 = this.props, r3 = t4.value, n3 = t4.pipe, o3 = t4.mask, i2 = t4.guide, a2 = t4.placeholderChar, u2 = t4.showMask, s2 = { guide: i2, placeholderChar: a2, showMask: u2 }, l3 = typeof n3 == "function" && typeof e5.pipe == "function" ? n3.toString() !== e5.pipe.toString() : (0, m2.isNil)(n3) && !(0, m2.isNil)(e5.pipe) || !(0, m2.isNil)(n3) && (0, m2.isNil)(e5.pipe), f2 = o3.toString() !== e5.mask.toString(), c2 = Object.keys(s2).some(function(t5) {
            return s2[t5] !== e5[t5];
          }) || f2 || l3, p2 = r3 !== this.inputElement.value;
          (p2 || c2) && this.initTextMask();
        }, "value") }, { key: "render", value: /* @__PURE__ */ __name(function() {
          var t4 = this.props, e6 = t4.render, r3 = o2(t4, ["render"]);
          return delete r3.mask, delete r3.guide, delete r3.pipe, delete r3.placeholderChar, delete r3.keepCharPositions, delete r3.value, delete r3.onBlur, delete r3.onChange, delete r3.showMask, e6(this.setRef, s({ onBlur: this.onBlur, onChange: this.onChange, defaultValue: this.props.value }, r3));
        }, "e") }, { key: "onChange", value: /* @__PURE__ */ __name(function(e5) {
          this.textMaskInputElement.update(), typeof this.props.onChange == "function" && this.props.onChange(e5);
        }, "value") }, { key: "onBlur", value: /* @__PURE__ */ __name(function(e5) {
          typeof this.props.onBlur == "function" && this.props.onBlur(e5);
        }, "value") }]), t3;
      }(p.default.PureComponent);
      t2.default = b, b.propTypes = { mask: h.default.oneOfType([h.default.array, h.default.func, h.default.bool, h.default.shape({ mask: h.default.oneOfType([h.default.array, h.default.func]), pipe: h.default.func })]).isRequired, guide: h.default.bool, value: h.default.oneOfType([h.default.string, h.default.number]), pipe: h.default.func, placeholderChar: h.default.string, keepCharPositions: h.default.bool, showMask: h.default.bool }, b.defaultProps = { render: /* @__PURE__ */ __name(function(e4, t3) {
        return p.default.createElement("input", s({ ref: e4 }, t3));
      }, "render") };
    }, function(e3, t2) {
      Object.defineProperty(t2, "__esModule", { value: !0 }), t2.placeholderChar = "_", t2.strFunction = "function";
    }, function(e3, t2, r2) {
      function n2() {
        var e4 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : f, t3 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : l2.placeholderChar;
        if (!o2(e4)) throw new Error("Text-mask:convertMaskToPlaceholder; The mask property must be an array.");
        if (e4.indexOf(t3) !== -1) throw new Error(`Placeholder character must not be used as part of the mask. Please specify a character that is not present in your mask as your placeholder character.

` + ("The placeholder character that was received is: " + JSON.stringify(t3) + `

`) + ("The mask that was received is: " + JSON.stringify(e4)));
        return e4.map(function(e5) {
          return e5 instanceof RegExp ? t3 : e5;
        }).join("");
      }
      __name(n2, "n");
      function o2(e4) {
        return Array.isArray && Array.isArray(e4) || e4 instanceof Array;
      }
      __name(o2, "o");
      function i(e4) {
        return typeof e4 == "string" || e4 instanceof String;
      }
      __name(i, "i");
      function a(e4) {
        return typeof e4 == "number" && e4.length === void 0 && !isNaN(e4);
      }
      __name(a, "a");
      function u(e4) {
        return typeof e4 > "u" || e4 === null;
      }
      __name(u, "u");
      function s(e4) {
        for (var t3 = [], r3 = void 0; r3 = e4.indexOf(c), r3 !== -1; ) t3.push(r3), e4.splice(r3, 1);
        return { maskWithoutCaretTraps: e4, indexes: t3 };
      }
      __name(s, "s"), Object.defineProperty(t2, "__esModule", { value: !0 }), t2.convertMaskToPlaceholder = n2, t2.isArray = o2, t2.isString = i, t2.isNumber = a, t2.isNil = u, t2.processCaretTraps = s;
      var l2 = r2(1), f = [], c = "[]";
    }, function(e3, t2, r2) {
      function n2() {
        var e4 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : s, t3 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : u, r3 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
        if (!(0, i.isArray)(t3)) {
          if ((typeof t3 > "u" ? "undefined" : o2(t3)) !== a.strFunction) throw new Error("Text-mask:conformToMask; The mask property must be an array.");
          t3 = t3(e4, r3), t3 = (0, i.processCaretTraps)(t3).maskWithoutCaretTraps;
        }
        var n3 = r3.guide, l2 = n3 === void 0 || n3, f = r3.previousConformedValue, c = f === void 0 ? s : f, p = r3.placeholderChar, d = p === void 0 ? a.placeholderChar : p, h = r3.placeholder, v = h === void 0 ? (0, i.convertMaskToPlaceholder)(t3, d) : h, y = r3.currentCaretPosition, m2 = r3.keepCharPositions, b = l2 === !1 && c !== void 0, g = e4.length, k = c.length, C = v.length, O = t3.length, T = g - k, P = T > 0, x = y + (P ? -T : 0), w = x + Math.abs(T);
        if (m2 === !0 && !P) {
          for (var S = s, _2 = x; _2 < w; _2++) v[_2] === d && (S += d);
          e4 = e4.slice(0, x) + S + e4.slice(x, g);
        }
        for (var M = e4.split(s).map(function(e5, t4) {
          return { char: e5, isNew: t4 >= x && t4 < w };
        }), j = g - 1; j >= 0; j--) {
          var E = M[j].char;
          if (E !== d) {
            var R = j >= x && k === O;
            E === v[R ? j - T : j] && M.splice(j, 1);
          }
        }
        var V = s, N = !1;
        e: for (var A = 0; A < C; A++) {
          var B = v[A];
          if (B === d) {
            if (M.length > 0) for (; M.length > 0; ) {
              var I = M.shift(), F = I.char, q = I.isNew;
              if (F === d && b !== !0) {
                V += d;
                continue e;
              }
              if (t3[A].test(F)) {
                if (m2 === !0 && q !== !1 && c !== s && l2 !== !1 && P) {
                  for (var D = M.length, L = null, W = 0; W < D; W++) {
                    var J = M[W];
                    if (J.char !== d && J.isNew === !1) break;
                    if (J.char === d) {
                      L = W;
                      break;
                    }
                  }
                  L !== null ? (V += F, M.splice(L, 1)) : A--;
                } else V += F;
                continue e;
              }
              N = !0;
            }
            b === !1 && (V += v.substr(A, C));
            break;
          }
          V += B;
        }
        if (b && P === !1) {
          for (var U = null, H = 0; H < V.length; H++) v[H] === d && (U = H);
          V = U !== null ? V.substr(0, U + 1) : s;
        }
        return { conformedValue: V, meta: { someCharsRejected: N } };
      }
      __name(n2, "n"), Object.defineProperty(t2, "__esModule", { value: !0 });
      var o2 = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(e4) {
        return typeof e4;
      } : function(e4) {
        return e4 && typeof Symbol == "function" && e4.constructor === Symbol && e4 !== Symbol.prototype ? "symbol" : typeof e4;
      };
      t2.default = n2;
      var i = r2(2), a = r2(1), u = [], s = "";
    }, function(e3, t2) {
      function r2(e4) {
        var t3 = e4.previousConformedValue, r3 = t3 === void 0 ? o2 : t3, i = e4.previousPlaceholder, a = i === void 0 ? o2 : i, u = e4.currentCaretPosition, s = u === void 0 ? 0 : u, l2 = e4.conformedValue, f = e4.rawValue, c = e4.placeholderChar, p = e4.placeholder, d = e4.indexesOfPipedChars, h = d === void 0 ? n2 : d, v = e4.caretTrapIndexes, y = v === void 0 ? n2 : v;
        if (s === 0 || !f.length) return 0;
        var m2 = f.length, b = r3.length, g = p.length, k = l2.length, C = m2 - b, O = C > 0, T = b === 0, P = C > 1 && !O && !T;
        if (P) return s;
        var x = O && (r3 === l2 || l2 === p), w = 0, S = void 0, _2 = void 0;
        if (x) w = s - C;
        else {
          var M = l2.toLowerCase(), j = f.toLowerCase(), E = j.substr(0, s).split(o2), R = E.filter(function(e5) {
            return M.indexOf(e5) !== -1;
          });
          _2 = R[R.length - 1];
          var V = a.substr(0, R.length).split(o2).filter(function(e5) {
            return e5 !== c;
          }).length, N = p.substr(0, R.length).split(o2).filter(function(e5) {
            return e5 !== c;
          }).length, A = N !== V, B = a[R.length - 1] !== void 0 && p[R.length - 2] !== void 0 && a[R.length - 1] !== c && a[R.length - 1] !== p[R.length - 1] && a[R.length - 1] === p[R.length - 2];
          !O && (A || B) && V > 0 && p.indexOf(_2) > -1 && f[s] !== void 0 && (S = !0, _2 = f[s]);
          for (var I = h.map(function(e5) {
            return M[e5];
          }), F = I.filter(function(e5) {
            return e5 === _2;
          }).length, q = R.filter(function(e5) {
            return e5 === _2;
          }).length, D = p.substr(0, p.indexOf(c)).split(o2).filter(function(e5, t4) {
            return e5 === _2 && f[t4] !== e5;
          }).length, L = D + q + F + (S ? 1 : 0), W = 0, J = 0; J < k; J++) {
            var U = M[J];
            if (w = J + 1, U === _2 && W++, W >= L) break;
          }
        }
        if (O) {
          for (var H = w, Y = w; Y <= g; Y++) if (p[Y] === c && (H = Y), p[Y] === c || y.indexOf(Y) !== -1 || Y === g) return H;
        } else if (S) {
          for (var z = w - 1; z >= 0; z--) if (l2[z] === _2 || y.indexOf(z) !== -1 || z === 0) return z;
        } else for (var G = w; G >= 0; G--) if (p[G - 1] === c || y.indexOf(G) !== -1 || G === 0) return G;
      }
      __name(r2, "r"), Object.defineProperty(t2, "__esModule", { value: !0 }), t2.default = r2;
      var n2 = [], o2 = "";
    }, function(e3, t2, r2) {
      function n2(e4) {
        return e4 && e4.__esModule ? e4 : { default: e4 };
      }
      __name(n2, "n");
      function o2(e4) {
        var t3 = { previousConformedValue: void 0, previousPlaceholder: void 0 };
        return { state: t3, update: /* @__PURE__ */ __name(function(r3) {
          var n3 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : e4, o3 = n3.inputElement, l3 = n3.mask, c2 = n3.guide, y2 = n3.pipe, b2 = n3.placeholderChar, g2 = b2 === void 0 ? h.placeholderChar : b2, k = n3.keepCharPositions, C = k !== void 0 && k, O = n3.showMask, T = O !== void 0 && O;
          if (typeof r3 > "u" && (r3 = o3.value), r3 !== t3.previousConformedValue) {
            (typeof l3 > "u" ? "undefined" : s(l3)) === m2 && l3.pipe !== void 0 && l3.mask !== void 0 && (y2 = l3.pipe, l3 = l3.mask);
            var P = void 0, x = void 0;
            if (l3 instanceof Array && (P = (0, d.convertMaskToPlaceholder)(l3, g2)), l3 !== !1) {
              var w = a(r3), S = o3.selectionEnd, _2 = t3.previousConformedValue, M = t3.previousPlaceholder, j = void 0;
              if ((typeof l3 > "u" ? "undefined" : s(l3)) === h.strFunction) {
                if (x = l3(w, { currentCaretPosition: S, previousConformedValue: _2, placeholderChar: g2 }), x === !1) return;
                var E = (0, d.processCaretTraps)(x), R = E.maskWithoutCaretTraps, V = E.indexes;
                x = R, j = V, P = (0, d.convertMaskToPlaceholder)(x, g2);
              } else x = l3;
              var N = { previousConformedValue: _2, guide: c2, placeholderChar: g2, pipe: y2, placeholder: P, currentCaretPosition: S, keepCharPositions: C }, A = (0, p.default)(w, x, N), B = A.conformedValue, I = (typeof y2 > "u" ? "undefined" : s(y2)) === h.strFunction, F = {};
              I && (F = y2(B, u({ rawValue: w }, N)), F === !1 ? F = { value: _2, rejected: !0 } : (0, d.isString)(F) && (F = { value: F }));
              var q = I ? F.value : B, D = (0, f.default)({ previousConformedValue: _2, previousPlaceholder: M, conformedValue: q, placeholder: P, rawValue: w, currentCaretPosition: S, placeholderChar: g2, indexesOfPipedChars: F.indexesOfPipedChars, caretTrapIndexes: j }), L = q === P && D === 0, W = T ? P : v, J = L ? W : q;
              t3.previousConformedValue = J, t3.previousPlaceholder = P, o3.value !== J && (o3.value = J, i(o3, D));
            }
          }
        }, "update") };
      }
      __name(o2, "o");
      function i(e4, t3) {
        document.activeElement === e4 && (b ? g(function() {
          return e4.setSelectionRange(t3, t3, y);
        }, 0) : e4.setSelectionRange(t3, t3, y));
      }
      __name(i, "i");
      function a(e4) {
        if ((0, d.isString)(e4)) return e4;
        if ((0, d.isNumber)(e4)) return String(e4);
        if (e4 == null) return v;
        throw new Error(`The 'value' provided to Text Mask needs to be a string or a number. The value received was:

 ` + JSON.stringify(e4));
      }
      __name(a, "a"), Object.defineProperty(t2, "__esModule", { value: !0 });
      var u = Object.assign || function(e4) {
        for (var t3 = 1; t3 < arguments.length; t3++) {
          var r3 = arguments[t3];
          for (var n3 in r3) Object.prototype.hasOwnProperty.call(r3, n3) && (e4[n3] = r3[n3]);
        }
        return e4;
      }, s = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(e4) {
        return typeof e4;
      } : function(e4) {
        return e4 && typeof Symbol == "function" && e4.constructor === Symbol && e4 !== Symbol.prototype ? "symbol" : typeof e4;
      };
      t2.default = o2;
      var l2 = r2(4), f = n2(l2), c = r2(3), p = n2(c), d = r2(2), h = r2(1), v = "", y = "none", m2 = "object", b = typeof navigator < "u" && /Android/i.test(navigator.userAgent), g = typeof requestAnimationFrame < "u" ? requestAnimationFrame : setTimeout;
    }, function(e3, t2) {
      function r2(e4) {
        return function() {
          return e4;
        };
      }
      __name(r2, "r");
      var n2 = /* @__PURE__ */ __name(function() {
      }, "n");
      n2.thatReturns = r2, n2.thatReturnsFalse = r2(!1), n2.thatReturnsTrue = r2(!0), n2.thatReturnsNull = r2(null), n2.thatReturnsThis = function() {
        return this;
      }, n2.thatReturnsArgument = function(e4) {
        return e4;
      }, e3.exports = n2;
    }, function(e3, t2, r2) {
      function n2(e4, t3, r3, n3, i, a, u, s) {
        if (!e4) {
          var l2;
          if (t3 === void 0) l2 = new Error("Minified exception occurred; use the non-minified dev environment for the full error message and additional helpful warnings.");
          else {
            var f = [r3, n3, i, a, u, s], c = 0;
            l2 = new Error(t3.replace(/%s/g, function() {
              return f[c++];
            })), l2.name = "Invariant Violation";
          }
          throw l2.framesToPop = 1, l2;
        }
      }
      __name(n2, "n"), e3.exports = n2;
    }, function(e3, t2, r2) {
      var n2 = r2(6), o2 = r2(7), i = r2(10);
      e3.exports = function() {
        function e4(e5, t4, r4, n3, a, u) {
          u !== i && o2(!1, "Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types");
        }
        __name(e4, "e");
        function t3() {
          return e4;
        }
        __name(t3, "t"), e4.isRequired = e4;
        var r3 = { array: e4, bool: e4, func: e4, number: e4, object: e4, string: e4, symbol: e4, any: e4, arrayOf: t3, element: e4, instanceOf: t3, node: e4, objectOf: t3, oneOf: t3, oneOfType: t3, shape: t3, exact: t3 };
        return r3.checkPropTypes = n2, r3.PropTypes = r3, r3;
      };
    }, function(e3, t2, r2) {
      e3.exports = r2(8)();
    }, function(e3, t2) {
      var r2 = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED";
      e3.exports = r2;
    }, function(t2, r2) {
      t2.exports = e2;
    }]);
  });
})(reactTextMask);
var reactTextMaskExports = reactTextMask.exports;
const conversionMaskedValue = /* @__PURE__ */ __name((value = "", mask) => reactTextMaskExports.conformToMask(value, mask, {
  guide: !1
}).conformedValue, "conversionMaskedValue");
function useMask({ mask, value = "" }) {
  const [maskedValue, setMaskedValue] = useState(value), cursorPositionRef = useRef(0), getMask = /* @__PURE__ */ __name((value2) => typeof mask == "function" ? mask(value2) : mask, "getMask"), applyMask = /* @__PURE__ */ __name((rawValue) => {
    const currentMask = getMask(rawValue);
    let masked = "", rawIndex = 0;
    for (let i = 0; i < currentMask.length && rawIndex < rawValue.length; i++) {
      const maskItem = currentMask[i], char2 = rawValue[rawIndex];
      typeof maskItem == "string" ? (masked += maskItem, char2 === maskItem && rawIndex++) : maskItem.test(char2) && (masked += char2, rawIndex++);
    }
    return masked;
  }, "applyMask"), calculateCursorPosition = /* @__PURE__ */ __name((prevMaskedValue, newMaskedValue, prevCursorPosition) => {
    const currentMask = getMask(newMaskedValue), lengthDifference = newMaskedValue.length - prevMaskedValue.length;
    let newCursorPosition = prevCursorPosition;
    if (lengthDifference < 0)
      for (; newCursorPosition > 0 && typeof currentMask[newCursorPosition - 1] == "string"; )
        newCursorPosition--;
    else lengthDifference > 0 && (newCursorPosition += lengthDifference);
    return newCursorPosition < 0 && (newCursorPosition = 0), newCursorPosition > newMaskedValue.length && (newCursorPosition = newMaskedValue.length), newCursorPosition;
  }, "calculateCursorPosition");
  return {
    maskedValue,
    handleChange: /* @__PURE__ */ __name((inputValue, cursorPosition) => {
      const rawValue = inputValue.replace(/[^0-9a-zA-Z+()\s-]/g, ""), newMaskedValue = applyMask(rawValue);
      cursorPositionRef.current = calculateCursorPosition(maskedValue, newMaskedValue, cursorPosition), setMaskedValue(newMaskedValue);
    }, "handleChange"),
    handleCursorChange: /* @__PURE__ */ __name((input) => {
      input.setSelectionRange(cursorPositionRef.current, cursorPositionRef.current);
    }, "handleCursorChange")
  };
}
__name(useMask, "useMask");
const MaskedInput = /* @__PURE__ */ __name(({ mask, value = "", onChange, ...props }, ref) => {
  const inputRef = useRef(null), { maskedValue, handleChange, handleCursorChange } = useMask({ mask, value });
  useEffect(() => {
    if (inputRef.current) {
      const inputElement = inputRef.current.input;
      handleCursorChange(inputElement);
    }
  }, [maskedValue]), useEffect(() => {
    handleChange(value, value.length);
  }, [value, mask]);
  const onInputChange = /* @__PURE__ */ __name((e2) => {
    const { value: inputValue, selectionStart } = e2.target;
    selectionStart !== null && handleChange(inputValue, selectionStart), onChange == null || onChange(e2, maskedValue);
  }, "onInputChange");
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    Input2,
    {
      ...props,
      ref: /* @__PURE__ */ __name((element) => {
        inputRef.current = element, typeof ref == "function" ? ref(element) : ref && (ref.current = element);
      }, "ref"),
      value: maskedValue,
      onChange: onInputChange
    }
  );
}, "MaskedInput"), MaskedInput$1 = forwardRef(MaskedInput), InputNumberComponent = /* @__PURE__ */ __name(({ placeholder = "Введите значение", ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  TypedInputNumber,
  {
    ...props,
    disabled: props.isDisabled,
    placeholder,
    readOnly: props.isReadOnly,
    ref
  }
), "InputNumberComponent"), InputNumber = forwardRef(InputNumberComponent), inputPosition = "_input-position_1m04p_1", inputResize = "_input-resize_1m04p_15", textAreaContent = "_text-area-content_1m04p_23", inputRowOne$1 = "_input-row-one_1m04p_31", overlay = "_overlay_1m04p_43", overlayNone = "_overlay-none_1m04p_75", styles$8 = {
  inputPosition,
  inputResize,
  textAreaContent,
  inputRowOne: inputRowOne$1,
  overlay,
  overlayNone
}, TextAreaComponent = /* @__PURE__ */ __name(({
  isDisabled,
  isTopContent,
  inputValueClassName,
  placeholder = "Введите значение",
  value,
  ...props
}, ref) => {
  var _a, _b, _c, _d;
  const { theme: theme2 } = useTheme(), [isMaxTag, setIsMaxTag] = useState(!1), [inputValue, setValue] = useState();
  useEffect(() => {
    setValue(value);
  }, [value]);
  let autoSize = props.autoSize;
  isTopContent && (autoSize = props.autoSize ?? { maxRows: 10 });
  const handleFocus = /* @__PURE__ */ __name((e2) => {
    var _a2;
    e2.preventDefault(), isTopContent && setIsMaxTag(!0), (_a2 = props.onFocus) == null || _a2.call(props, e2);
  }, "handleFocus"), handleBlur = /* @__PURE__ */ __name((e2) => {
    var _a2;
    e2.preventDefault(), isTopContent && setIsMaxTag(!1), (_a2 = props.onBlur) == null || _a2.call(props, e2);
  }, "handleBlur"), handleChange = /* @__PURE__ */ __name((e2) => {
    var _a2;
    e2.preventDefault(), isTopContent && setValue(e2.target.value), (_a2 = props.onChange) == null || _a2.call(props, e2);
  }, "handleChange");
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: cn(styles$8.textAreaContent), children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      Input$1.TextArea,
      {
        ...props,
        value: inputValue,
        autoSize: !isMaxTag && isTopContent ? { maxRows: 1 } : autoSize,
        disabled: isDisabled,
        onBlur: handleBlur,
        onFocus: handleFocus,
        onChange: handleChange,
        placeholder,
        ref,
        className: cn(props.className, {
          [styles$8.inputPosition]: isTopContent,
          [styles$8.inputRowOne]: !isMaxTag && isTopContent,
          [styles$8.inputResize]: isTopContent && isMaxTag
        })
      }
    ),
    isTopContent && inputValue && /* @__PURE__ */ jsxRuntimeExports.jsx(
      "div",
      {
        className: cn(inputValueClassName, styles$8.overlay, { [styles$8.overlayNone]: isMaxTag }),
        style: {
          padding: `${(_b = (_a = theme2.components) == null ? void 0 : _a.Input) == null ? void 0 : _b.paddingBlockLG}px ${(_d = (_c = theme2.components) == null ? void 0 : _c.Input) == null ? void 0 : _d.paddingInline}px`
        },
        children: inputValue
      }
    )
  ] });
}, "TextAreaComponent"), TextArea = forwardRef(TextAreaComponent), MaskedTextArea = /* @__PURE__ */ __name(({ mask, placeholder, value, onChange, ...props }, ref) => {
  const [maskedValue, setMaskedValue] = useState();
  useEffect(() => {
    const maskedValue2 = conversionMaskedValue(value, mask);
    setMaskedValue(maskedValue2);
  }, [value, mask]);
  function handleChange(e2) {
    const maskedValue2 = conversionMaskedValue(e2.target.value, mask);
    setMaskedValue(maskedValue2), onChange == null || onChange(e2, maskedValue2);
  }
  return __name(handleChange, "handleChange"), /* @__PURE__ */ jsxRuntimeExports.jsx(TextArea, { ...props, ref, value: maskedValue, placeholder, onChange: handleChange });
}, "MaskedTextArea"), MaskedTextArea$1 = forwardRef(MaskedTextArea), inputRowOne = "_input-row-one_9j2p8_1", dateInputPosition = "_date-input-position_9j2p8_13", styles$7 = {
  inputRowOne,
  dateInputPosition
}, DatePicker = /* @__PURE__ */ __name(({
  autoSize,
  isTopContent,
  isDisabled,
  isDisabledDate,
  isOpen,
  isReadonly,
  suffixIcon,
  nextIcon,
  superNextIcon,
  prevIcon,
  superPrevIcon,
  isAllowClear,
  ...rest
}) => {
  var _a, _b;
  const { theme: theme2 } = useTheme(), iconSize = (_b = (_a = theme2 == null ? void 0 : theme2.components) == null ? void 0 : _a.DatePicker) == null ? void 0 : _b.fontSize, [isMaxTag, setIsMaxTag] = useState(), dateRef = useRef(null), handleFocus = /* @__PURE__ */ __name(() => {
    isTopContent && setIsMaxTag(!0);
  }, "handleFocus"), handleBlur = /* @__PURE__ */ __name((event) => {
    var _a2;
    isTopContent && setIsMaxTag(!1), (_a2 = rest == null ? void 0 : rest.onBlur) == null || _a2.call(rest, event);
  }, "handleBlur"), InputComponent2 = React__default.forwardRef((propsInput, ref) => {
    const maskRef = /* @__PURE__ */ __name((inputRef) => {
      inputRef && (ref.current = inputRef.input);
    }, "maskRef"), maskRefTextArea = /* @__PURE__ */ __name((inputRef) => {
      inputRef && inputRef.resizableTextArea && (ref.current = inputRef == null ? void 0 : inputRef.resizableTextArea.textArea, dateRef.current = inputRef == null ? void 0 : inputRef.resizableTextArea.textArea);
    }, "maskRefTextArea");
    return isTopContent ? /* @__PURE__ */ jsxRuntimeExports.jsx(
      MaskedTextArea$1,
      {
        ...propsInput,
        ref: maskRefTextArea,
        mask: rest.mask ?? [],
        autoSize: !isMaxTag && isTopContent ? { maxRows: 1 } : autoSize,
        className: cn({
          [styles$7.inputRowOne]: !isMaxTag && isTopContent
        }),
        style: {
          border: "initial",
          boxShadow: "initial",
          minHeight: 22,
          padding: 0
        }
      }
    ) : /* @__PURE__ */ jsxRuntimeExports.jsx(MaskedInput$1, { ...propsInput, ref: maskRef, mask: rest.mask ?? [] });
  });
  return InputComponent2.displayName = "InputComponent", /* @__PURE__ */ jsxRuntimeExports.jsx(
    DatePicker$1,
    {
      ...rest,
      disabled: isDisabled,
      className: cn({
        [styles$7.dateInputPosition]: isTopContent && isMaxTag
      }),
      onFocus: handleFocus,
      onBlur: handleBlur,
      disabledDate: isDisabledDate,
      open: isOpen,
      readOnly: isReadonly,
      components: rest.mask ? {
        input: InputComponent2
      } : void 0,
      suffixIcon: suffixIcon ?? /* @__PURE__ */ jsxRuntimeExports.jsx(IconCalendarEvent, { width: iconSize, height: iconSize }),
      nextIcon: nextIcon ?? /* @__PURE__ */ jsxRuntimeExports.jsx(IconChevronRight, { width: iconSize, height: iconSize }),
      superNextIcon: superNextIcon ?? /* @__PURE__ */ jsxRuntimeExports.jsx(IconChevronsRight, { width: iconSize, height: iconSize }),
      prevIcon: prevIcon ?? /* @__PURE__ */ jsxRuntimeExports.jsx(IconChevronLeft, { width: iconSize, height: iconSize }),
      superPrevIcon: superPrevIcon ?? /* @__PURE__ */ jsxRuntimeExports.jsx(IconChevronsLeft, { width: iconSize, height: iconSize }),
      allowClear: isAllowClear && { clearIcon: /* @__PURE__ */ jsxRuntimeExports.jsx(IconCircleXFilled, {}) }
    }
  );
}, "DatePicker"), { RangePicker: AntdRangePicker } = DatePicker$1, RangePicker = /* @__PURE__ */ __name(({
  isDisabled,
  isDisabledDate,
  isOpen,
  isReadonly,
  separator,
  isAllowClear,
  ...rest
}) => {
  var _a, _b;
  const { theme: theme2 } = useTheme(), separatorSize = (_b = (_a = theme2 == null ? void 0 : theme2.components) == null ? void 0 : _a.DatePicker) == null ? void 0 : _b.fontSizeLG, InputComponent2 = React__default.forwardRef((propsInput, ref) => {
    const maskRef = /* @__PURE__ */ __name((inputRef) => {
      inputRef && (ref.current = inputRef.input);
    }, "maskRef");
    return /* @__PURE__ */ jsxRuntimeExports.jsx(MaskedInput$1, { ...propsInput, ref: maskRef, mask: rest.mask ?? [] });
  });
  return InputComponent2.displayName = "InputComponent", /* @__PURE__ */ jsxRuntimeExports.jsx(
    AntdRangePicker,
    {
      ...rest,
      disabled: isDisabled,
      disabledDate: isDisabledDate,
      open: isOpen,
      readOnly: isReadonly,
      components: rest.mask ? {
        input: InputComponent2
      } : void 0,
      separator: separator ?? /* @__PURE__ */ jsxRuntimeExports.jsx(IconArrowNarrowRight, { height: separatorSize, stroke: 1 }),
      allowClear: isAllowClear && { clearIcon: /* @__PURE__ */ jsxRuntimeExports.jsx(IconCircleXFilled, {}) }
    }
  );
}, "RangePicker"), TimePicker = /* @__PURE__ */ __name(({
  isAllowClear,
  isChangeOnScroll,
  isDisabled,
  isNeedConfirm,
  shouldUse12Hours,
  suffixIcon,
  ...rest
}) => {
  var _a, _b;
  const { theme: theme2 } = useTheme(), iconSize = (_b = (_a = theme2 == null ? void 0 : theme2.components) == null ? void 0 : _a.DatePicker) == null ? void 0 : _b.fontSize;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    TimePicker$1,
    {
      ...rest,
      allowClear: isAllowClear && { clearIcon: /* @__PURE__ */ jsxRuntimeExports.jsx(IconCircleXFilled, {}) },
      changeOnScroll: isChangeOnScroll,
      disabled: isDisabled,
      needConfirm: isNeedConfirm,
      use12Hours: shouldUse12Hours,
      suffixIcon: suffixIcon ?? /* @__PURE__ */ jsxRuntimeExports.jsx(IconClock, { height: iconSize, width: iconSize })
    }
  );
}, "TimePicker"), innerStyle = "_innerStyle_1wuj6_1", styles$6 = {
  innerStyle
};
function Card({ isLoading, isHoverable, isBordered, isInner, isInnerStyle, className, ...rest }) {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    Card$1,
    {
      ...rest,
      type: isInner ? "inner" : void 0,
      loading: isLoading,
      hoverable: isHoverable,
      bordered: isBordered,
      className: cn(className, { [styles$6.innerStyle]: isInnerStyle })
    }
  );
}
__name(Card, "Card");
Card.Grid = Card$1.Grid;
Card.Meta = Card$1.Meta;
function Empty(props) {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Empty$1, { ...props, children: props.children });
}
__name(Empty, "Empty");
function Title({
  isEditable,
  isCopyable,
  isDisabled,
  isCode,
  isMark,
  isDelete,
  isUnderline,
  isKeyboard,
  isItalic,
  isRemoveAllMargins,
  ...props
}) {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    Typography.Title,
    {
      ...props,
      editable: isEditable,
      copyable: isCopyable,
      disabled: isDisabled,
      code: isCode,
      mark: isMark,
      delete: isDelete,
      underline: isUnderline,
      keyboard: isKeyboard,
      italic: isItalic,
      style: { margin: isRemoveAllMargins ? "0" : void 0, ...props.style },
      children: props.children
    }
  );
}
__name(Title, "Title");
const DefaultHeaderIcons = /* @__PURE__ */ __name(({
  isNotificationButtonHidden,
  isNotificationButtonDisabled,
  isUserButtonHidden,
  isUserButtonDisabled,
  isLogoutButtonHidden,
  isLogoutButtonDisabled,
  onNotificationButtonClick,
  onUserButtonClick,
  onLogoutButtonClick,
  customButtons,
  badgeCount
}) => {
  const renderButtons = /* @__PURE__ */ __name((config) => config.map((btn, index2) => btn.isHidden ? null : /* @__PURE__ */ jsxRuntimeExports.jsx(Badge, { count: btn.badgeCount, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
    Button,
    {
      type: "text",
      icon: btn.icon,
      size: "large",
      isDisabled: btn.isDisabled,
      onClick: btn.onClick
    },
    index2
  ) }, index2)), "renderButtons"), memoizedButtons = useMemo$1(() => renderButtons([
    {
      icon: /* @__PURE__ */ jsxRuntimeExports.jsx(IconBell, { stroke: 1.5 }),
      onClick: onNotificationButtonClick,
      isHidden: isNotificationButtonHidden,
      isDisabled: isNotificationButtonDisabled,
      badgeCount
    },
    {
      icon: /* @__PURE__ */ jsxRuntimeExports.jsx(IconUser, { stroke: 1.5 }),
      onClick: onUserButtonClick,
      isHidden: isUserButtonHidden,
      isDisabled: isUserButtonDisabled
    },
    {
      icon: /* @__PURE__ */ jsxRuntimeExports.jsx(IconLogout, { stroke: 1.5 }),
      onClick: onLogoutButtonClick,
      isHidden: isLogoutButtonHidden,
      isDisabled: isLogoutButtonDisabled
    }
  ]), [
    isNotificationButtonHidden,
    isNotificationButtonDisabled,
    onNotificationButtonClick,
    isUserButtonHidden,
    isUserButtonDisabled,
    onUserButtonClick,
    isLogoutButtonHidden,
    isLogoutButtonDisabled,
    onLogoutButtonClick,
    badgeCount
  ]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { display: "flex", alignItems: "center", justifyContent: "space-between", gap: 12 }, children: customButtons ?? memoizedButtons });
}, "DefaultHeaderIcons"), header$1 = "_header_1uu9n_9", title = "_title_1uu9n_43", breadcrumbs = "_breadcrumbs_1uu9n_51", menuIcon = "_menu-icon_1uu9n_73", container = "_container_1uu9n_81", siderPanel = "_sider-panel_1uu9n_93", siderPanelContent = "_sider-panel-content_1uu9n_99", siderTitle = "_sider-title_1uu9n_107", siderActive = "_sider-active_1uu9n_119", styles$5 = {
  header: header$1,
  title,
  breadcrumbs,
  menuIcon,
  container,
  siderPanel,
  siderPanelContent,
  siderTitle,
  siderActive
};
function Header2({
  isShowTab,
  isShowBreadCrumbs,
  isShowMenuBtn,
  Tab,
  Breadcrumbs,
  style: style2,
  children,
  title: title2,
  menuIcon: menuIcon2,
  menuIconSize,
  onToggleSider,
  className,
  defaultButtons,
  ...rest
}) {
  var _a;
  const { theme: theme2 } = useTheme(), { headerSplitColor: borderStyle, headerHeight } = ((_a = theme2 == null ? void 0 : theme2.components) == null ? void 0 : _a.Layout) || {}, borderStyleBottom = `1px solid ${borderStyle}`;
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    Layout.Header,
    {
      ...rest,
      className: cn(styles$5.header, className),
      style: { borderBottom: borderStyleBottom, ...style2 },
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$5.container, style: { height: headerHeight }, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$5.breadcrumbs, children: [
            isShowMenuBtn && /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { type: "text", size: menuIconSize, className: styles$5.menuIcon, onClick: onToggleSider, children: menuIcon2 }),
            isShowBreadCrumbs ? Breadcrumbs : /* @__PURE__ */ jsxRuntimeExports.jsx(Title, { level: 5, className: styles$5.title, children: title2 })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { display: "flex", gap: 12 }, children: [
            children,
            defaultButtons
          ] })
        ] }),
        isShowTab && Tab
      ]
    }
  );
}
__name(Header2, "Header");
Header2.DefaultHeaderIcons = DefaultHeaderIcons;
const Icon = /* @__PURE__ */ __name(({ icon, size = 24, style: style2, className, type: type4 = "default" }) => {
  var _a, _b;
  const { theme: theme2 } = useTheme(), baseColor = (_b = (_a = theme2 == null ? void 0 : theme2.components) == null ? void 0 : _a.Icon) == null ? void 0 : _b[`${type4}Color`], iconColor = style2 != null && style2.color ? style2 == null ? void 0 : style2.color : baseColor, combinedStyle = useMemo$1(
    () => ({
      width: size,
      height: size,
      display: "inline-flex",
      alignItems: "center",
      justifyContent: "center",
      fontSize: size,
      color: iconColor,
      ...style2
    }),
    [style2, size, iconColor]
  );
  return /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className, style: combinedStyle, children: icon });
}, "Icon");
var NTypography;
NTypography || (NTypography = {});
function Form2(props) {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Form$1, { ...props });
}
__name(Form2, "Form");
Form2.useForm = Form$1.useForm;
const urlAlphabet = "useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict";
let nanoid = /* @__PURE__ */ __name((size = 21) => {
  let id2 = "", bytes = crypto.getRandomValues(new Uint8Array(size |= 0));
  for (; size--; )
    id2 += urlAlphabet[bytes[size] & 63];
  return id2;
}, "nanoid");
const FormItem = /* @__PURE__ */ __name(({ isRequiredRight, ...props }) => {
  var _a, _b;
  const { theme: theme2 } = useTheme(), uuid2 = useMemo$1(() => `i${nanoid()}`, []), handleClick = /* @__PURE__ */ __name(() => {
    const controlElement = document.querySelector(`#${uuid2} .ant-input`);
    (controlElement instanceof HTMLInputElement || controlElement instanceof HTMLTextAreaElement) && controlElement.focus();
  }, "handleClick");
  return (
    // eslint-disable-next-line
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { onClick: handleClick, id: uuid2, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      Form$1.Item,
      {
        ...props,
        required: isRequiredRight ? !1 : props.required,
        label: isRequiredRight ? /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { children: [
          props.label,
          props.required && /* @__PURE__ */ jsxRuntimeExports.jsx("span", { style: { color: (_b = (_a = theme2.components) == null ? void 0 : _a.Form) == null ? void 0 : _b.labelRequiredMarkColor }, children: " *" })
        ] }) : props.label
      }
    ) })
  );
}, "FormItem");
var lodash = { exports: {} };
/**
 * @license
 * Lodash <https://lodash.com/>
 * Copyright OpenJS Foundation and other contributors <https://openjsf.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */
lodash.exports;
(function(module2, exports) {
  (function() {
    var undefined$1, VERSION = "4.17.21", LARGE_ARRAY_SIZE = 200, CORE_ERROR_TEXT = "Unsupported core-js use. Try https://npms.io/search?q=ponyfill.", FUNC_ERROR_TEXT = "Expected a function", INVALID_TEMPL_VAR_ERROR_TEXT = "Invalid `variable` option passed into `_.template`", HASH_UNDEFINED = "__lodash_hash_undefined__", MAX_MEMOIZE_SIZE = 500, PLACEHOLDER = "__lodash_placeholder__", CLONE_DEEP_FLAG = 1, CLONE_FLAT_FLAG = 2, CLONE_SYMBOLS_FLAG = 4, COMPARE_PARTIAL_FLAG = 1, COMPARE_UNORDERED_FLAG = 2, WRAP_BIND_FLAG = 1, WRAP_BIND_KEY_FLAG = 2, WRAP_CURRY_BOUND_FLAG = 4, WRAP_CURRY_FLAG = 8, WRAP_CURRY_RIGHT_FLAG = 16, WRAP_PARTIAL_FLAG = 32, WRAP_PARTIAL_RIGHT_FLAG = 64, WRAP_ARY_FLAG = 128, WRAP_REARG_FLAG = 256, WRAP_FLIP_FLAG = 512, DEFAULT_TRUNC_LENGTH = 30, DEFAULT_TRUNC_OMISSION = "...", HOT_COUNT = 800, HOT_SPAN = 16, LAZY_FILTER_FLAG = 1, LAZY_MAP_FLAG = 2, LAZY_WHILE_FLAG = 3, INFINITY = 1 / 0, MAX_SAFE_INTEGER = 9007199254740991, MAX_INTEGER = 17976931348623157e292, NAN = NaN, MAX_ARRAY_LENGTH = 4294967295, MAX_ARRAY_INDEX = MAX_ARRAY_LENGTH - 1, HALF_MAX_ARRAY_LENGTH = MAX_ARRAY_LENGTH >>> 1, wrapFlags = [
      ["ary", WRAP_ARY_FLAG],
      ["bind", WRAP_BIND_FLAG],
      ["bindKey", WRAP_BIND_KEY_FLAG],
      ["curry", WRAP_CURRY_FLAG],
      ["curryRight", WRAP_CURRY_RIGHT_FLAG],
      ["flip", WRAP_FLIP_FLAG],
      ["partial", WRAP_PARTIAL_FLAG],
      ["partialRight", WRAP_PARTIAL_RIGHT_FLAG],
      ["rearg", WRAP_REARG_FLAG]
    ], argsTag = "[object Arguments]", arrayTag = "[object Array]", asyncTag = "[object AsyncFunction]", boolTag = "[object Boolean]", dateTag = "[object Date]", domExcTag = "[object DOMException]", errorTag = "[object Error]", funcTag = "[object Function]", genTag = "[object GeneratorFunction]", mapTag = "[object Map]", numberTag = "[object Number]", nullTag = "[object Null]", objectTag = "[object Object]", promiseTag = "[object Promise]", proxyTag = "[object Proxy]", regexpTag = "[object RegExp]", setTag = "[object Set]", stringTag = "[object String]", symbolTag = "[object Symbol]", undefinedTag = "[object Undefined]", weakMapTag = "[object WeakMap]", weakSetTag = "[object WeakSet]", arrayBufferTag = "[object ArrayBuffer]", dataViewTag = "[object DataView]", float32Tag = "[object Float32Array]", float64Tag = "[object Float64Array]", int8Tag = "[object Int8Array]", int16Tag = "[object Int16Array]", int32Tag = "[object Int32Array]", uint8Tag = "[object Uint8Array]", uint8ClampedTag = "[object Uint8ClampedArray]", uint16Tag = "[object Uint16Array]", uint32Tag = "[object Uint32Array]", reEmptyStringLeading = /\b__p \+= '';/g, reEmptyStringMiddle = /\b(__p \+=) '' \+/g, reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g, reEscapedHtml = /&(?:amp|lt|gt|quot|#39);/g, reUnescapedHtml = /[&<>"']/g, reHasEscapedHtml = RegExp(reEscapedHtml.source), reHasUnescapedHtml = RegExp(reUnescapedHtml.source), reEscape = /<%-([\s\S]+?)%>/g, reEvaluate = /<%([\s\S]+?)%>/g, reInterpolate = /<%=([\s\S]+?)%>/g, reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, reIsPlainProp = /^\w*$/, rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g, reRegExpChar = /[\\^$.*+?()[\]{}|]/g, reHasRegExpChar = RegExp(reRegExpChar.source), reTrimStart = /^\s+/, reWhitespace = /\s/, reWrapComment = /\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/, reWrapDetails = /\{\n\/\* \[wrapped with (.+)\] \*/, reSplitDetails = /,? & /, reAsciiWord = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g, reForbiddenIdentifierChars = /[()=,{}\[\]\/\s]/, reEscapeChar = /\\(\\)?/g, reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g, reFlags = /\w*$/, reIsBadHex = /^[-+]0x[0-9a-f]+$/i, reIsBinary = /^0b[01]+$/i, reIsHostCtor = /^\[object .+?Constructor\]$/, reIsOctal = /^0o[0-7]+$/i, reIsUint = /^(?:0|[1-9]\d*)$/, reLatin = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g, reNoMatch = /($^)/, reUnescapedString = /['\n\r\u2028\u2029\\]/g, rsAstralRange = "\\ud800-\\udfff", rsComboMarksRange = "\\u0300-\\u036f", reComboHalfMarksRange = "\\ufe20-\\ufe2f", rsComboSymbolsRange = "\\u20d0-\\u20ff", rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange, rsDingbatRange = "\\u2700-\\u27bf", rsLowerRange = "a-z\\xdf-\\xf6\\xf8-\\xff", rsMathOpRange = "\\xac\\xb1\\xd7\\xf7", rsNonCharRange = "\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf", rsPunctuationRange = "\\u2000-\\u206f", rsSpaceRange = " \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000", rsUpperRange = "A-Z\\xc0-\\xd6\\xd8-\\xde", rsVarRange = "\\ufe0e\\ufe0f", rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange, rsApos = "['’]", rsAstral = "[" + rsAstralRange + "]", rsBreak = "[" + rsBreakRange + "]", rsCombo = "[" + rsComboRange + "]", rsDigits = "\\d+", rsDingbat = "[" + rsDingbatRange + "]", rsLower = "[" + rsLowerRange + "]", rsMisc = "[^" + rsAstralRange + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + "]", rsFitz = "\\ud83c[\\udffb-\\udfff]", rsModifier = "(?:" + rsCombo + "|" + rsFitz + ")", rsNonAstral = "[^" + rsAstralRange + "]", rsRegional = "(?:\\ud83c[\\udde6-\\uddff]){2}", rsSurrPair = "[\\ud800-\\udbff][\\udc00-\\udfff]", rsUpper = "[" + rsUpperRange + "]", rsZWJ = "\\u200d", rsMiscLower = "(?:" + rsLower + "|" + rsMisc + ")", rsMiscUpper = "(?:" + rsUpper + "|" + rsMisc + ")", rsOptContrLower = "(?:" + rsApos + "(?:d|ll|m|re|s|t|ve))?", rsOptContrUpper = "(?:" + rsApos + "(?:D|LL|M|RE|S|T|VE))?", reOptMod = rsModifier + "?", rsOptVar = "[" + rsVarRange + "]?", rsOptJoin = "(?:" + rsZWJ + "(?:" + [rsNonAstral, rsRegional, rsSurrPair].join("|") + ")" + rsOptVar + reOptMod + ")*", rsOrdLower = "\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])", rsOrdUpper = "\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])", rsSeq = rsOptVar + reOptMod + rsOptJoin, rsEmoji = "(?:" + [rsDingbat, rsRegional, rsSurrPair].join("|") + ")" + rsSeq, rsSymbol = "(?:" + [rsNonAstral + rsCombo + "?", rsCombo, rsRegional, rsSurrPair, rsAstral].join("|") + ")", reApos = RegExp(rsApos, "g"), reComboMark = RegExp(rsCombo, "g"), reUnicode = RegExp(rsFitz + "(?=" + rsFitz + ")|" + rsSymbol + rsSeq, "g"), reUnicodeWord = RegExp([
      rsUpper + "?" + rsLower + "+" + rsOptContrLower + "(?=" + [rsBreak, rsUpper, "$"].join("|") + ")",
      rsMiscUpper + "+" + rsOptContrUpper + "(?=" + [rsBreak, rsUpper + rsMiscLower, "$"].join("|") + ")",
      rsUpper + "?" + rsMiscLower + "+" + rsOptContrLower,
      rsUpper + "+" + rsOptContrUpper,
      rsOrdUpper,
      rsOrdLower,
      rsDigits,
      rsEmoji
    ].join("|"), "g"), reHasUnicode = RegExp("[" + rsZWJ + rsAstralRange + rsComboRange + rsVarRange + "]"), reHasUnicodeWord = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/, contextProps = [
      "Array",
      "Buffer",
      "DataView",
      "Date",
      "Error",
      "Float32Array",
      "Float64Array",
      "Function",
      "Int8Array",
      "Int16Array",
      "Int32Array",
      "Map",
      "Math",
      "Object",
      "Promise",
      "RegExp",
      "Set",
      "String",
      "Symbol",
      "TypeError",
      "Uint8Array",
      "Uint8ClampedArray",
      "Uint16Array",
      "Uint32Array",
      "WeakMap",
      "_",
      "clearTimeout",
      "isFinite",
      "parseInt",
      "setTimeout"
    ], templateCounter = -1, typedArrayTags = {};
    typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = !0, typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = !1;
    var cloneableTags = {};
    cloneableTags[argsTag] = cloneableTags[arrayTag] = cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] = cloneableTags[boolTag] = cloneableTags[dateTag] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[mapTag] = cloneableTags[numberTag] = cloneableTags[objectTag] = cloneableTags[regexpTag] = cloneableTags[setTag] = cloneableTags[stringTag] = cloneableTags[symbolTag] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = !0, cloneableTags[errorTag] = cloneableTags[funcTag] = cloneableTags[weakMapTag] = !1;
    var deburredLetters = {
      // Latin-1 Supplement block.
      À: "A",
      Á: "A",
      Â: "A",
      Ã: "A",
      Ä: "A",
      Å: "A",
      à: "a",
      á: "a",
      â: "a",
      ã: "a",
      ä: "a",
      å: "a",
      Ç: "C",
      ç: "c",
      Ð: "D",
      ð: "d",
      È: "E",
      É: "E",
      Ê: "E",
      Ë: "E",
      è: "e",
      é: "e",
      ê: "e",
      ë: "e",
      Ì: "I",
      Í: "I",
      Î: "I",
      Ï: "I",
      ì: "i",
      í: "i",
      î: "i",
      ï: "i",
      Ñ: "N",
      ñ: "n",
      Ò: "O",
      Ó: "O",
      Ô: "O",
      Õ: "O",
      Ö: "O",
      Ø: "O",
      ò: "o",
      ó: "o",
      ô: "o",
      õ: "o",
      ö: "o",
      ø: "o",
      Ù: "U",
      Ú: "U",
      Û: "U",
      Ü: "U",
      ù: "u",
      ú: "u",
      û: "u",
      ü: "u",
      Ý: "Y",
      ý: "y",
      ÿ: "y",
      Æ: "Ae",
      æ: "ae",
      Þ: "Th",
      þ: "th",
      ß: "ss",
      // Latin Extended-A block.
      Ā: "A",
      Ă: "A",
      Ą: "A",
      ā: "a",
      ă: "a",
      ą: "a",
      Ć: "C",
      Ĉ: "C",
      Ċ: "C",
      Č: "C",
      ć: "c",
      ĉ: "c",
      ċ: "c",
      č: "c",
      Ď: "D",
      Đ: "D",
      ď: "d",
      đ: "d",
      Ē: "E",
      Ĕ: "E",
      Ė: "E",
      Ę: "E",
      Ě: "E",
      ē: "e",
      ĕ: "e",
      ė: "e",
      ę: "e",
      ě: "e",
      Ĝ: "G",
      Ğ: "G",
      Ġ: "G",
      Ģ: "G",
      ĝ: "g",
      ğ: "g",
      ġ: "g",
      ģ: "g",
      Ĥ: "H",
      Ħ: "H",
      ĥ: "h",
      ħ: "h",
      Ĩ: "I",
      Ī: "I",
      Ĭ: "I",
      Į: "I",
      İ: "I",
      ĩ: "i",
      ī: "i",
      ĭ: "i",
      į: "i",
      ı: "i",
      Ĵ: "J",
      ĵ: "j",
      Ķ: "K",
      ķ: "k",
      ĸ: "k",
      Ĺ: "L",
      Ļ: "L",
      Ľ: "L",
      Ŀ: "L",
      Ł: "L",
      ĺ: "l",
      ļ: "l",
      ľ: "l",
      ŀ: "l",
      ł: "l",
      Ń: "N",
      Ņ: "N",
      Ň: "N",
      Ŋ: "N",
      ń: "n",
      ņ: "n",
      ň: "n",
      ŋ: "n",
      Ō: "O",
      Ŏ: "O",
      Ő: "O",
      ō: "o",
      ŏ: "o",
      ő: "o",
      Ŕ: "R",
      Ŗ: "R",
      Ř: "R",
      ŕ: "r",
      ŗ: "r",
      ř: "r",
      Ś: "S",
      Ŝ: "S",
      Ş: "S",
      Š: "S",
      ś: "s",
      ŝ: "s",
      ş: "s",
      š: "s",
      Ţ: "T",
      Ť: "T",
      Ŧ: "T",
      ţ: "t",
      ť: "t",
      ŧ: "t",
      Ũ: "U",
      Ū: "U",
      Ŭ: "U",
      Ů: "U",
      Ű: "U",
      Ų: "U",
      ũ: "u",
      ū: "u",
      ŭ: "u",
      ů: "u",
      ű: "u",
      ų: "u",
      Ŵ: "W",
      ŵ: "w",
      Ŷ: "Y",
      ŷ: "y",
      Ÿ: "Y",
      Ź: "Z",
      Ż: "Z",
      Ž: "Z",
      ź: "z",
      ż: "z",
      ž: "z",
      Ĳ: "IJ",
      ĳ: "ij",
      Œ: "Oe",
      œ: "oe",
      ŉ: "'n",
      ſ: "s"
    }, htmlEscapes = {
      "&": "&amp;",
      "<": "&lt;",
      ">": "&gt;",
      '"': "&quot;",
      "'": "&#39;"
    }, htmlUnescapes = {
      "&amp;": "&",
      "&lt;": "<",
      "&gt;": ">",
      "&quot;": '"',
      "&#39;": "'"
    }, stringEscapes = {
      "\\": "\\",
      "'": "'",
      "\n": "n",
      "\r": "r",
      "\u2028": "u2028",
      "\u2029": "u2029"
    }, freeParseFloat = parseFloat, freeParseInt = parseInt, freeGlobal = typeof commonjsGlobal == "object" && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal, freeSelf = typeof self == "object" && self && self.Object === Object && self, root = freeGlobal || freeSelf || Function("return this")(), freeExports = exports && !exports.nodeType && exports, freeModule = freeExports && !0 && module2 && !module2.nodeType && module2, moduleExports = freeModule && freeModule.exports === freeExports, freeProcess = moduleExports && freeGlobal.process, nodeUtil = function() {
      try {
        var types2 = freeModule && freeModule.require && freeModule.require("util").types;
        return types2 || freeProcess && freeProcess.binding && freeProcess.binding("util");
      } catch {
      }
    }(), nodeIsArrayBuffer = nodeUtil && nodeUtil.isArrayBuffer, nodeIsDate = nodeUtil && nodeUtil.isDate, nodeIsMap = nodeUtil && nodeUtil.isMap, nodeIsRegExp = nodeUtil && nodeUtil.isRegExp, nodeIsSet = nodeUtil && nodeUtil.isSet, nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
    function apply(func, thisArg, args) {
      switch (args.length) {
        case 0:
          return func.call(thisArg);
        case 1:
          return func.call(thisArg, args[0]);
        case 2:
          return func.call(thisArg, args[0], args[1]);
        case 3:
          return func.call(thisArg, args[0], args[1], args[2]);
      }
      return func.apply(thisArg, args);
    }
    __name(apply, "apply");
    function arrayAggregator(array4, setter, iteratee, accumulator) {
      for (var index2 = -1, length2 = array4 == null ? 0 : array4.length; ++index2 < length2; ) {
        var value = array4[index2];
        setter(accumulator, value, iteratee(value), array4);
      }
      return accumulator;
    }
    __name(arrayAggregator, "arrayAggregator");
    function arrayEach(array4, iteratee) {
      for (var index2 = -1, length2 = array4 == null ? 0 : array4.length; ++index2 < length2 && iteratee(array4[index2], index2, array4) !== !1; )
        ;
      return array4;
    }
    __name(arrayEach, "arrayEach");
    function arrayEachRight(array4, iteratee) {
      for (var length2 = array4 == null ? 0 : array4.length; length2-- && iteratee(array4[length2], length2, array4) !== !1; )
        ;
      return array4;
    }
    __name(arrayEachRight, "arrayEachRight");
    function arrayEvery(array4, predicate) {
      for (var index2 = -1, length2 = array4 == null ? 0 : array4.length; ++index2 < length2; )
        if (!predicate(array4[index2], index2, array4))
          return !1;
      return !0;
    }
    __name(arrayEvery, "arrayEvery");
    function arrayFilter(array4, predicate) {
      for (var index2 = -1, length2 = array4 == null ? 0 : array4.length, resIndex = 0, result = []; ++index2 < length2; ) {
        var value = array4[index2];
        predicate(value, index2, array4) && (result[resIndex++] = value);
      }
      return result;
    }
    __name(arrayFilter, "arrayFilter");
    function arrayIncludes(array4, value) {
      var length2 = array4 == null ? 0 : array4.length;
      return !!length2 && baseIndexOf(array4, value, 0) > -1;
    }
    __name(arrayIncludes, "arrayIncludes");
    function arrayIncludesWith(array4, value, comparator) {
      for (var index2 = -1, length2 = array4 == null ? 0 : array4.length; ++index2 < length2; )
        if (comparator(value, array4[index2]))
          return !0;
      return !1;
    }
    __name(arrayIncludesWith, "arrayIncludesWith");
    function arrayMap(array4, iteratee) {
      for (var index2 = -1, length2 = array4 == null ? 0 : array4.length, result = Array(length2); ++index2 < length2; )
        result[index2] = iteratee(array4[index2], index2, array4);
      return result;
    }
    __name(arrayMap, "arrayMap");
    function arrayPush(array4, values) {
      for (var index2 = -1, length2 = values.length, offset2 = array4.length; ++index2 < length2; )
        array4[offset2 + index2] = values[index2];
      return array4;
    }
    __name(arrayPush, "arrayPush");
    function arrayReduce(array4, iteratee, accumulator, initAccum) {
      var index2 = -1, length2 = array4 == null ? 0 : array4.length;
      for (initAccum && length2 && (accumulator = array4[++index2]); ++index2 < length2; )
        accumulator = iteratee(accumulator, array4[index2], index2, array4);
      return accumulator;
    }
    __name(arrayReduce, "arrayReduce");
    function arrayReduceRight(array4, iteratee, accumulator, initAccum) {
      var length2 = array4 == null ? 0 : array4.length;
      for (initAccum && length2 && (accumulator = array4[--length2]); length2--; )
        accumulator = iteratee(accumulator, array4[length2], length2, array4);
      return accumulator;
    }
    __name(arrayReduceRight, "arrayReduceRight");
    function arraySome(array4, predicate) {
      for (var index2 = -1, length2 = array4 == null ? 0 : array4.length; ++index2 < length2; )
        if (predicate(array4[index2], index2, array4))
          return !0;
      return !1;
    }
    __name(arraySome, "arraySome");
    var asciiSize = baseProperty("length");
    function asciiToArray(string3) {
      return string3.split("");
    }
    __name(asciiToArray, "asciiToArray");
    function asciiWords(string3) {
      return string3.match(reAsciiWord) || [];
    }
    __name(asciiWords, "asciiWords");
    function baseFindKey(collection, predicate, eachFunc) {
      var result;
      return eachFunc(collection, function(value, key, collection2) {
        if (predicate(value, key, collection2))
          return result = key, !1;
      }), result;
    }
    __name(baseFindKey, "baseFindKey");
    function baseFindIndex(array4, predicate, fromIndex, fromRight) {
      for (var length2 = array4.length, index2 = fromIndex + (fromRight ? 1 : -1); fromRight ? index2-- : ++index2 < length2; )
        if (predicate(array4[index2], index2, array4))
          return index2;
      return -1;
    }
    __name(baseFindIndex, "baseFindIndex");
    function baseIndexOf(array4, value, fromIndex) {
      return value === value ? strictIndexOf(array4, value, fromIndex) : baseFindIndex(array4, baseIsNaN, fromIndex);
    }
    __name(baseIndexOf, "baseIndexOf");
    function baseIndexOfWith(array4, value, fromIndex, comparator) {
      for (var index2 = fromIndex - 1, length2 = array4.length; ++index2 < length2; )
        if (comparator(array4[index2], value))
          return index2;
      return -1;
    }
    __name(baseIndexOfWith, "baseIndexOfWith");
    function baseIsNaN(value) {
      return value !== value;
    }
    __name(baseIsNaN, "baseIsNaN");
    function baseMean(array4, iteratee) {
      var length2 = array4 == null ? 0 : array4.length;
      return length2 ? baseSum(array4, iteratee) / length2 : NAN;
    }
    __name(baseMean, "baseMean");
    function baseProperty(key) {
      return function(object4) {
        return object4 == null ? undefined$1 : object4[key];
      };
    }
    __name(baseProperty, "baseProperty");
    function basePropertyOf(object4) {
      return function(key) {
        return object4 == null ? undefined$1 : object4[key];
      };
    }
    __name(basePropertyOf, "basePropertyOf");
    function baseReduce(collection, iteratee, accumulator, initAccum, eachFunc) {
      return eachFunc(collection, function(value, index2, collection2) {
        accumulator = initAccum ? (initAccum = !1, value) : iteratee(accumulator, value, index2, collection2);
      }), accumulator;
    }
    __name(baseReduce, "baseReduce");
    function baseSortBy(array4, comparer) {
      var length2 = array4.length;
      for (array4.sort(comparer); length2--; )
        array4[length2] = array4[length2].value;
      return array4;
    }
    __name(baseSortBy, "baseSortBy");
    function baseSum(array4, iteratee) {
      for (var result, index2 = -1, length2 = array4.length; ++index2 < length2; ) {
        var current = iteratee(array4[index2]);
        current !== undefined$1 && (result = result === undefined$1 ? current : result + current);
      }
      return result;
    }
    __name(baseSum, "baseSum");
    function baseTimes(n2, iteratee) {
      for (var index2 = -1, result = Array(n2); ++index2 < n2; )
        result[index2] = iteratee(index2);
      return result;
    }
    __name(baseTimes, "baseTimes");
    function baseToPairs(object4, props) {
      return arrayMap(props, function(key) {
        return [key, object4[key]];
      });
    }
    __name(baseToPairs, "baseToPairs");
    function baseTrim(string3) {
      return string3 && string3.slice(0, trimmedEndIndex(string3) + 1).replace(reTrimStart, "");
    }
    __name(baseTrim, "baseTrim");
    function baseUnary(func) {
      return function(value) {
        return func(value);
      };
    }
    __name(baseUnary, "baseUnary");
    function baseValues(object4, props) {
      return arrayMap(props, function(key) {
        return object4[key];
      });
    }
    __name(baseValues, "baseValues");
    function cacheHas(cache, key) {
      return cache.has(key);
    }
    __name(cacheHas, "cacheHas");
    function charsStartIndex(strSymbols, chrSymbols) {
      for (var index2 = -1, length2 = strSymbols.length; ++index2 < length2 && baseIndexOf(chrSymbols, strSymbols[index2], 0) > -1; )
        ;
      return index2;
    }
    __name(charsStartIndex, "charsStartIndex");
    function charsEndIndex(strSymbols, chrSymbols) {
      for (var index2 = strSymbols.length; index2-- && baseIndexOf(chrSymbols, strSymbols[index2], 0) > -1; )
        ;
      return index2;
    }
    __name(charsEndIndex, "charsEndIndex");
    function countHolders(array4, placeholder) {
      for (var length2 = array4.length, result = 0; length2--; )
        array4[length2] === placeholder && ++result;
      return result;
    }
    __name(countHolders, "countHolders");
    var deburrLetter = basePropertyOf(deburredLetters), escapeHtmlChar = basePropertyOf(htmlEscapes);
    function escapeStringChar(chr) {
      return "\\" + stringEscapes[chr];
    }
    __name(escapeStringChar, "escapeStringChar");
    function getValue2(object4, key) {
      return object4 == null ? undefined$1 : object4[key];
    }
    __name(getValue2, "getValue");
    function hasUnicode(string3) {
      return reHasUnicode.test(string3);
    }
    __name(hasUnicode, "hasUnicode");
    function hasUnicodeWord(string3) {
      return reHasUnicodeWord.test(string3);
    }
    __name(hasUnicodeWord, "hasUnicodeWord");
    function iteratorToArray(iterator) {
      for (var data, result = []; !(data = iterator.next()).done; )
        result.push(data.value);
      return result;
    }
    __name(iteratorToArray, "iteratorToArray");
    function mapToArray(map) {
      var index2 = -1, result = Array(map.size);
      return map.forEach(function(value, key) {
        result[++index2] = [key, value];
      }), result;
    }
    __name(mapToArray, "mapToArray");
    function overArg(func, transform) {
      return function(arg) {
        return func(transform(arg));
      };
    }
    __name(overArg, "overArg");
    function replaceHolders(array4, placeholder) {
      for (var index2 = -1, length2 = array4.length, resIndex = 0, result = []; ++index2 < length2; ) {
        var value = array4[index2];
        (value === placeholder || value === PLACEHOLDER) && (array4[index2] = PLACEHOLDER, result[resIndex++] = index2);
      }
      return result;
    }
    __name(replaceHolders, "replaceHolders");
    function setToArray(set2) {
      var index2 = -1, result = Array(set2.size);
      return set2.forEach(function(value) {
        result[++index2] = value;
      }), result;
    }
    __name(setToArray, "setToArray");
    function setToPairs(set2) {
      var index2 = -1, result = Array(set2.size);
      return set2.forEach(function(value) {
        result[++index2] = [value, value];
      }), result;
    }
    __name(setToPairs, "setToPairs");
    function strictIndexOf(array4, value, fromIndex) {
      for (var index2 = fromIndex - 1, length2 = array4.length; ++index2 < length2; )
        if (array4[index2] === value)
          return index2;
      return -1;
    }
    __name(strictIndexOf, "strictIndexOf");
    function strictLastIndexOf(array4, value, fromIndex) {
      for (var index2 = fromIndex + 1; index2--; )
        if (array4[index2] === value)
          return index2;
      return index2;
    }
    __name(strictLastIndexOf, "strictLastIndexOf");
    function stringSize(string3) {
      return hasUnicode(string3) ? unicodeSize(string3) : asciiSize(string3);
    }
    __name(stringSize, "stringSize");
    function stringToArray(string3) {
      return hasUnicode(string3) ? unicodeToArray(string3) : asciiToArray(string3);
    }
    __name(stringToArray, "stringToArray");
    function trimmedEndIndex(string3) {
      for (var index2 = string3.length; index2-- && reWhitespace.test(string3.charAt(index2)); )
        ;
      return index2;
    }
    __name(trimmedEndIndex, "trimmedEndIndex");
    var unescapeHtmlChar = basePropertyOf(htmlUnescapes);
    function unicodeSize(string3) {
      for (var result = reUnicode.lastIndex = 0; reUnicode.test(string3); )
        ++result;
      return result;
    }
    __name(unicodeSize, "unicodeSize");
    function unicodeToArray(string3) {
      return string3.match(reUnicode) || [];
    }
    __name(unicodeToArray, "unicodeToArray");
    function unicodeWords(string3) {
      return string3.match(reUnicodeWord) || [];
    }
    __name(unicodeWords, "unicodeWords");
    var runInContext = /* @__PURE__ */ __name(function runInContext2(context) {
      context = context == null ? root : _2.defaults(root.Object(), context, _2.pick(root, contextProps));
      var Array2 = context.Array, Date2 = context.Date, Error2 = context.Error, Function2 = context.Function, Math2 = context.Math, Object2 = context.Object, RegExp2 = context.RegExp, String2 = context.String, TypeError2 = context.TypeError, arrayProto = Array2.prototype, funcProto = Function2.prototype, objectProto = Object2.prototype, coreJsData = context["__core-js_shared__"], funcToString = funcProto.toString, hasOwnProperty = objectProto.hasOwnProperty, idCounter = 0, maskSrcKey = function() {
        var uid2 = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
        return uid2 ? "Symbol(src)_1." + uid2 : "";
      }(), nativeObjectToString = objectProto.toString, objectCtorString = funcToString.call(Object2), oldDash = root._, reIsNative = RegExp2(
        "^" + funcToString.call(hasOwnProperty).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
      ), Buffer2 = moduleExports ? context.Buffer : undefined$1, Symbol2 = context.Symbol, Uint8Array2 = context.Uint8Array, allocUnsafe = Buffer2 ? Buffer2.allocUnsafe : undefined$1, getPrototype = overArg(Object2.getPrototypeOf, Object2), objectCreate = Object2.create, propertyIsEnumerable = objectProto.propertyIsEnumerable, splice = arrayProto.splice, spreadableSymbol = Symbol2 ? Symbol2.isConcatSpreadable : undefined$1, symIterator = Symbol2 ? Symbol2.iterator : undefined$1, symToStringTag = Symbol2 ? Symbol2.toStringTag : undefined$1, defineProperty2 = function() {
        try {
          var func = getNative(Object2, "defineProperty");
          return func({}, "", {}), func;
        } catch {
        }
      }(), ctxClearTimeout = context.clearTimeout !== root.clearTimeout && context.clearTimeout, ctxNow = Date2 && Date2.now !== root.Date.now && Date2.now, ctxSetTimeout = context.setTimeout !== root.setTimeout && context.setTimeout, nativeCeil = Math2.ceil, nativeFloor = Math2.floor, nativeGetSymbols = Object2.getOwnPropertySymbols, nativeIsBuffer = Buffer2 ? Buffer2.isBuffer : undefined$1, nativeIsFinite = context.isFinite, nativeJoin = arrayProto.join, nativeKeys = overArg(Object2.keys, Object2), nativeMax = Math2.max, nativeMin = Math2.min, nativeNow = Date2.now, nativeParseInt = context.parseInt, nativeRandom = Math2.random, nativeReverse = arrayProto.reverse, DataView = getNative(context, "DataView"), Map2 = getNative(context, "Map"), Promise2 = getNative(context, "Promise"), Set2 = getNative(context, "Set"), WeakMap2 = getNative(context, "WeakMap"), nativeCreate = getNative(Object2, "create"), metaMap = WeakMap2 && new WeakMap2(), realNames = {}, dataViewCtorString = toSource(DataView), mapCtorString = toSource(Map2), promiseCtorString = toSource(Promise2), setCtorString = toSource(Set2), weakMapCtorString = toSource(WeakMap2), symbolProto = Symbol2 ? Symbol2.prototype : undefined$1, symbolValueOf = symbolProto ? symbolProto.valueOf : undefined$1, symbolToString = symbolProto ? symbolProto.toString : undefined$1;
      function lodash2(value) {
        if (isObjectLike(value) && !isArray(value) && !(value instanceof LazyWrapper)) {
          if (value instanceof LodashWrapper)
            return value;
          if (hasOwnProperty.call(value, "__wrapped__"))
            return wrapperClone(value);
        }
        return new LodashWrapper(value);
      }
      __name(lodash2, "lodash");
      var baseCreate = function() {
        function object4() {
        }
        return __name(object4, "object"), function(proto) {
          if (!isObject2(proto))
            return {};
          if (objectCreate)
            return objectCreate(proto);
          object4.prototype = proto;
          var result2 = new object4();
          return object4.prototype = undefined$1, result2;
        };
      }();
      function baseLodash() {
      }
      __name(baseLodash, "baseLodash");
      function LodashWrapper(value, chainAll) {
        this.__wrapped__ = value, this.__actions__ = [], this.__chain__ = !!chainAll, this.__index__ = 0, this.__values__ = undefined$1;
      }
      __name(LodashWrapper, "LodashWrapper"), lodash2.templateSettings = {
        /**
         * Used to detect `data` property values to be HTML-escaped.
         *
         * @memberOf _.templateSettings
         * @type {RegExp}
         */
        escape: reEscape,
        /**
         * Used to detect code to be evaluated.
         *
         * @memberOf _.templateSettings
         * @type {RegExp}
         */
        evaluate: reEvaluate,
        /**
         * Used to detect `data` property values to inject.
         *
         * @memberOf _.templateSettings
         * @type {RegExp}
         */
        interpolate: reInterpolate,
        /**
         * Used to reference the data object in the template text.
         *
         * @memberOf _.templateSettings
         * @type {string}
         */
        variable: "",
        /**
         * Used to import variables into the compiled template.
         *
         * @memberOf _.templateSettings
         * @type {Object}
         */
        imports: {
          /**
           * A reference to the `lodash` function.
           *
           * @memberOf _.templateSettings.imports
           * @type {Function}
           */
          _: lodash2
        }
      }, lodash2.prototype = baseLodash.prototype, lodash2.prototype.constructor = lodash2, LodashWrapper.prototype = baseCreate(baseLodash.prototype), LodashWrapper.prototype.constructor = LodashWrapper;
      function LazyWrapper(value) {
        this.__wrapped__ = value, this.__actions__ = [], this.__dir__ = 1, this.__filtered__ = !1, this.__iteratees__ = [], this.__takeCount__ = MAX_ARRAY_LENGTH, this.__views__ = [];
      }
      __name(LazyWrapper, "LazyWrapper");
      function lazyClone() {
        var result2 = new LazyWrapper(this.__wrapped__);
        return result2.__actions__ = copyArray(this.__actions__), result2.__dir__ = this.__dir__, result2.__filtered__ = this.__filtered__, result2.__iteratees__ = copyArray(this.__iteratees__), result2.__takeCount__ = this.__takeCount__, result2.__views__ = copyArray(this.__views__), result2;
      }
      __name(lazyClone, "lazyClone");
      function lazyReverse() {
        if (this.__filtered__) {
          var result2 = new LazyWrapper(this);
          result2.__dir__ = -1, result2.__filtered__ = !0;
        } else
          result2 = this.clone(), result2.__dir__ *= -1;
        return result2;
      }
      __name(lazyReverse, "lazyReverse");
      function lazyValue() {
        var array4 = this.__wrapped__.value(), dir = this.__dir__, isArr = isArray(array4), isRight = dir < 0, arrLength = isArr ? array4.length : 0, view = getView(0, arrLength, this.__views__), start = view.start, end = view.end, length2 = end - start, index2 = isRight ? end : start - 1, iteratees = this.__iteratees__, iterLength = iteratees.length, resIndex = 0, takeCount = nativeMin(length2, this.__takeCount__);
        if (!isArr || !isRight && arrLength == length2 && takeCount == length2)
          return baseWrapperValue(array4, this.__actions__);
        var result2 = [];
        outer:
          for (; length2-- && resIndex < takeCount; ) {
            index2 += dir;
            for (var iterIndex = -1, value = array4[index2]; ++iterIndex < iterLength; ) {
              var data = iteratees[iterIndex], iteratee2 = data.iteratee, type4 = data.type, computed = iteratee2(value);
              if (type4 == LAZY_MAP_FLAG)
                value = computed;
              else if (!computed) {
                if (type4 == LAZY_FILTER_FLAG)
                  continue outer;
                break outer;
              }
            }
            result2[resIndex++] = value;
          }
        return result2;
      }
      __name(lazyValue, "lazyValue"), LazyWrapper.prototype = baseCreate(baseLodash.prototype), LazyWrapper.prototype.constructor = LazyWrapper;
      function Hash(entries) {
        var index2 = -1, length2 = entries == null ? 0 : entries.length;
        for (this.clear(); ++index2 < length2; ) {
          var entry = entries[index2];
          this.set(entry[0], entry[1]);
        }
      }
      __name(Hash, "Hash");
      function hashClear() {
        this.__data__ = nativeCreate ? nativeCreate(null) : {}, this.size = 0;
      }
      __name(hashClear, "hashClear");
      function hashDelete(key) {
        var result2 = this.has(key) && delete this.__data__[key];
        return this.size -= result2 ? 1 : 0, result2;
      }
      __name(hashDelete, "hashDelete");
      function hashGet(key) {
        var data = this.__data__;
        if (nativeCreate) {
          var result2 = data[key];
          return result2 === HASH_UNDEFINED ? undefined$1 : result2;
        }
        return hasOwnProperty.call(data, key) ? data[key] : undefined$1;
      }
      __name(hashGet, "hashGet");
      function hashHas(key) {
        var data = this.__data__;
        return nativeCreate ? data[key] !== undefined$1 : hasOwnProperty.call(data, key);
      }
      __name(hashHas, "hashHas");
      function hashSet(key, value) {
        var data = this.__data__;
        return this.size += this.has(key) ? 0 : 1, data[key] = nativeCreate && value === undefined$1 ? HASH_UNDEFINED : value, this;
      }
      __name(hashSet, "hashSet"), Hash.prototype.clear = hashClear, Hash.prototype.delete = hashDelete, Hash.prototype.get = hashGet, Hash.prototype.has = hashHas, Hash.prototype.set = hashSet;
      function ListCache(entries) {
        var index2 = -1, length2 = entries == null ? 0 : entries.length;
        for (this.clear(); ++index2 < length2; ) {
          var entry = entries[index2];
          this.set(entry[0], entry[1]);
        }
      }
      __name(ListCache, "ListCache");
      function listCacheClear() {
        this.__data__ = [], this.size = 0;
      }
      __name(listCacheClear, "listCacheClear");
      function listCacheDelete(key) {
        var data = this.__data__, index2 = assocIndexOf(data, key);
        if (index2 < 0)
          return !1;
        var lastIndex = data.length - 1;
        return index2 == lastIndex ? data.pop() : splice.call(data, index2, 1), --this.size, !0;
      }
      __name(listCacheDelete, "listCacheDelete");
      function listCacheGet(key) {
        var data = this.__data__, index2 = assocIndexOf(data, key);
        return index2 < 0 ? undefined$1 : data[index2][1];
      }
      __name(listCacheGet, "listCacheGet");
      function listCacheHas(key) {
        return assocIndexOf(this.__data__, key) > -1;
      }
      __name(listCacheHas, "listCacheHas");
      function listCacheSet(key, value) {
        var data = this.__data__, index2 = assocIndexOf(data, key);
        return index2 < 0 ? (++this.size, data.push([key, value])) : data[index2][1] = value, this;
      }
      __name(listCacheSet, "listCacheSet"), ListCache.prototype.clear = listCacheClear, ListCache.prototype.delete = listCacheDelete, ListCache.prototype.get = listCacheGet, ListCache.prototype.has = listCacheHas, ListCache.prototype.set = listCacheSet;
      function MapCache(entries) {
        var index2 = -1, length2 = entries == null ? 0 : entries.length;
        for (this.clear(); ++index2 < length2; ) {
          var entry = entries[index2];
          this.set(entry[0], entry[1]);
        }
      }
      __name(MapCache, "MapCache");
      function mapCacheClear() {
        this.size = 0, this.__data__ = {
          hash: new Hash(),
          map: new (Map2 || ListCache)(),
          string: new Hash()
        };
      }
      __name(mapCacheClear, "mapCacheClear");
      function mapCacheDelete(key) {
        var result2 = getMapData(this, key).delete(key);
        return this.size -= result2 ? 1 : 0, result2;
      }
      __name(mapCacheDelete, "mapCacheDelete");
      function mapCacheGet(key) {
        return getMapData(this, key).get(key);
      }
      __name(mapCacheGet, "mapCacheGet");
      function mapCacheHas(key) {
        return getMapData(this, key).has(key);
      }
      __name(mapCacheHas, "mapCacheHas");
      function mapCacheSet(key, value) {
        var data = getMapData(this, key), size2 = data.size;
        return data.set(key, value), this.size += data.size == size2 ? 0 : 1, this;
      }
      __name(mapCacheSet, "mapCacheSet"), MapCache.prototype.clear = mapCacheClear, MapCache.prototype.delete = mapCacheDelete, MapCache.prototype.get = mapCacheGet, MapCache.prototype.has = mapCacheHas, MapCache.prototype.set = mapCacheSet;
      function SetCache(values2) {
        var index2 = -1, length2 = values2 == null ? 0 : values2.length;
        for (this.__data__ = new MapCache(); ++index2 < length2; )
          this.add(values2[index2]);
      }
      __name(SetCache, "SetCache");
      function setCacheAdd(value) {
        return this.__data__.set(value, HASH_UNDEFINED), this;
      }
      __name(setCacheAdd, "setCacheAdd");
      function setCacheHas(value) {
        return this.__data__.has(value);
      }
      __name(setCacheHas, "setCacheHas"), SetCache.prototype.add = SetCache.prototype.push = setCacheAdd, SetCache.prototype.has = setCacheHas;
      function Stack(entries) {
        var data = this.__data__ = new ListCache(entries);
        this.size = data.size;
      }
      __name(Stack, "Stack");
      function stackClear() {
        this.__data__ = new ListCache(), this.size = 0;
      }
      __name(stackClear, "stackClear");
      function stackDelete(key) {
        var data = this.__data__, result2 = data.delete(key);
        return this.size = data.size, result2;
      }
      __name(stackDelete, "stackDelete");
      function stackGet(key) {
        return this.__data__.get(key);
      }
      __name(stackGet, "stackGet");
      function stackHas(key) {
        return this.__data__.has(key);
      }
      __name(stackHas, "stackHas");
      function stackSet(key, value) {
        var data = this.__data__;
        if (data instanceof ListCache) {
          var pairs = data.__data__;
          if (!Map2 || pairs.length < LARGE_ARRAY_SIZE - 1)
            return pairs.push([key, value]), this.size = ++data.size, this;
          data = this.__data__ = new MapCache(pairs);
        }
        return data.set(key, value), this.size = data.size, this;
      }
      __name(stackSet, "stackSet"), Stack.prototype.clear = stackClear, Stack.prototype.delete = stackDelete, Stack.prototype.get = stackGet, Stack.prototype.has = stackHas, Stack.prototype.set = stackSet;
      function arrayLikeKeys(value, inherited) {
        var isArr = isArray(value), isArg = !isArr && isArguments(value), isBuff = !isArr && !isArg && isBuffer(value), isType = !isArr && !isArg && !isBuff && isTypedArray(value), skipIndexes = isArr || isArg || isBuff || isType, result2 = skipIndexes ? baseTimes(value.length, String2) : [], length2 = result2.length;
        for (var key in value)
          (inherited || hasOwnProperty.call(value, key)) && !(skipIndexes && // Safari 9 has enumerable `arguments.length` in strict mode.
          (key == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
          isBuff && (key == "offset" || key == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
          isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || // Skip index properties.
          isIndex(key, length2))) && result2.push(key);
        return result2;
      }
      __name(arrayLikeKeys, "arrayLikeKeys");
      function arraySample(array4) {
        var length2 = array4.length;
        return length2 ? array4[baseRandom(0, length2 - 1)] : undefined$1;
      }
      __name(arraySample, "arraySample");
      function arraySampleSize(array4, n2) {
        return shuffleSelf(copyArray(array4), baseClamp(n2, 0, array4.length));
      }
      __name(arraySampleSize, "arraySampleSize");
      function arrayShuffle(array4) {
        return shuffleSelf(copyArray(array4));
      }
      __name(arrayShuffle, "arrayShuffle");
      function assignMergeValue(object4, key, value) {
        (value !== undefined$1 && !eq(object4[key], value) || value === undefined$1 && !(key in object4)) && baseAssignValue(object4, key, value);
      }
      __name(assignMergeValue, "assignMergeValue");
      function assignValue(object4, key, value) {
        var objValue = object4[key];
        (!(hasOwnProperty.call(object4, key) && eq(objValue, value)) || value === undefined$1 && !(key in object4)) && baseAssignValue(object4, key, value);
      }
      __name(assignValue, "assignValue");
      function assocIndexOf(array4, key) {
        for (var length2 = array4.length; length2--; )
          if (eq(array4[length2][0], key))
            return length2;
        return -1;
      }
      __name(assocIndexOf, "assocIndexOf");
      function baseAggregator(collection, setter, iteratee2, accumulator) {
        return baseEach(collection, function(value, key, collection2) {
          setter(accumulator, value, iteratee2(value), collection2);
        }), accumulator;
      }
      __name(baseAggregator, "baseAggregator");
      function baseAssign(object4, source) {
        return object4 && copyObject(source, keys2(source), object4);
      }
      __name(baseAssign, "baseAssign");
      function baseAssignIn(object4, source) {
        return object4 && copyObject(source, keysIn(source), object4);
      }
      __name(baseAssignIn, "baseAssignIn");
      function baseAssignValue(object4, key, value) {
        key == "__proto__" && defineProperty2 ? defineProperty2(object4, key, {
          configurable: !0,
          enumerable: !0,
          value,
          writable: !0
        }) : object4[key] = value;
      }
      __name(baseAssignValue, "baseAssignValue");
      function baseAt(object4, paths) {
        for (var index2 = -1, length2 = paths.length, result2 = Array2(length2), skip = object4 == null; ++index2 < length2; )
          result2[index2] = skip ? undefined$1 : get2(object4, paths[index2]);
        return result2;
      }
      __name(baseAt, "baseAt");
      function baseClamp(number4, lower, upper) {
        return number4 === number4 && (upper !== undefined$1 && (number4 = number4 <= upper ? number4 : upper), lower !== undefined$1 && (number4 = number4 >= lower ? number4 : lower)), number4;
      }
      __name(baseClamp, "baseClamp");
      function baseClone(value, bitmask, customizer, key, object4, stack) {
        var result2, isDeep = bitmask & CLONE_DEEP_FLAG, isFlat = bitmask & CLONE_FLAT_FLAG, isFull = bitmask & CLONE_SYMBOLS_FLAG;
        if (customizer && (result2 = object4 ? customizer(value, key, object4, stack) : customizer(value)), result2 !== undefined$1)
          return result2;
        if (!isObject2(value))
          return value;
        var isArr = isArray(value);
        if (isArr) {
          if (result2 = initCloneArray(value), !isDeep)
            return copyArray(value, result2);
        } else {
          var tag = getTag(value), isFunc = tag == funcTag || tag == genTag;
          if (isBuffer(value))
            return cloneBuffer(value, isDeep);
          if (tag == objectTag || tag == argsTag || isFunc && !object4) {
            if (result2 = isFlat || isFunc ? {} : initCloneObject(value), !isDeep)
              return isFlat ? copySymbolsIn(value, baseAssignIn(result2, value)) : copySymbols(value, baseAssign(result2, value));
          } else {
            if (!cloneableTags[tag])
              return object4 ? value : {};
            result2 = initCloneByTag(value, tag, isDeep);
          }
        }
        stack || (stack = new Stack());
        var stacked = stack.get(value);
        if (stacked)
          return stacked;
        stack.set(value, result2), isSet(value) ? value.forEach(function(subValue) {
          result2.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));
        }) : isMap(value) && value.forEach(function(subValue, key2) {
          result2.set(key2, baseClone(subValue, bitmask, customizer, key2, value, stack));
        });
        var keysFunc = isFull ? isFlat ? getAllKeysIn : getAllKeys : isFlat ? keysIn : keys2, props = isArr ? undefined$1 : keysFunc(value);
        return arrayEach(props || value, function(subValue, key2) {
          props && (key2 = subValue, subValue = value[key2]), assignValue(result2, key2, baseClone(subValue, bitmask, customizer, key2, value, stack));
        }), result2;
      }
      __name(baseClone, "baseClone");
      function baseConforms(source) {
        var props = keys2(source);
        return function(object4) {
          return baseConformsTo(object4, source, props);
        };
      }
      __name(baseConforms, "baseConforms");
      function baseConformsTo(object4, source, props) {
        var length2 = props.length;
        if (object4 == null)
          return !length2;
        for (object4 = Object2(object4); length2--; ) {
          var key = props[length2], predicate = source[key], value = object4[key];
          if (value === undefined$1 && !(key in object4) || !predicate(value))
            return !1;
        }
        return !0;
      }
      __name(baseConformsTo, "baseConformsTo");
      function baseDelay(func, wait, args) {
        if (typeof func != "function")
          throw new TypeError2(FUNC_ERROR_TEXT);
        return setTimeout2(function() {
          func.apply(undefined$1, args);
        }, wait);
      }
      __name(baseDelay, "baseDelay");
      function baseDifference(array4, values2, iteratee2, comparator) {
        var index2 = -1, includes3 = arrayIncludes, isCommon = !0, length2 = array4.length, result2 = [], valuesLength = values2.length;
        if (!length2)
          return result2;
        iteratee2 && (values2 = arrayMap(values2, baseUnary(iteratee2))), comparator ? (includes3 = arrayIncludesWith, isCommon = !1) : values2.length >= LARGE_ARRAY_SIZE && (includes3 = cacheHas, isCommon = !1, values2 = new SetCache(values2));
        outer:
          for (; ++index2 < length2; ) {
            var value = array4[index2], computed = iteratee2 == null ? value : iteratee2(value);
            if (value = comparator || value !== 0 ? value : 0, isCommon && computed === computed) {
              for (var valuesIndex = valuesLength; valuesIndex--; )
                if (values2[valuesIndex] === computed)
                  continue outer;
              result2.push(value);
            } else includes3(values2, computed, comparator) || result2.push(value);
          }
        return result2;
      }
      __name(baseDifference, "baseDifference");
      var baseEach = createBaseEach(baseForOwn), baseEachRight = createBaseEach(baseForOwnRight, !0);
      function baseEvery(collection, predicate) {
        var result2 = !0;
        return baseEach(collection, function(value, index2, collection2) {
          return result2 = !!predicate(value, index2, collection2), result2;
        }), result2;
      }
      __name(baseEvery, "baseEvery");
      function baseExtremum(array4, iteratee2, comparator) {
        for (var index2 = -1, length2 = array4.length; ++index2 < length2; ) {
          var value = array4[index2], current = iteratee2(value);
          if (current != null && (computed === undefined$1 ? current === current && !isSymbol(current) : comparator(current, computed)))
            var computed = current, result2 = value;
        }
        return result2;
      }
      __name(baseExtremum, "baseExtremum");
      function baseFill(array4, value, start, end) {
        var length2 = array4.length;
        for (start = toInteger(start), start < 0 && (start = -start > length2 ? 0 : length2 + start), end = end === undefined$1 || end > length2 ? length2 : toInteger(end), end < 0 && (end += length2), end = start > end ? 0 : toLength(end); start < end; )
          array4[start++] = value;
        return array4;
      }
      __name(baseFill, "baseFill");
      function baseFilter(collection, predicate) {
        var result2 = [];
        return baseEach(collection, function(value, index2, collection2) {
          predicate(value, index2, collection2) && result2.push(value);
        }), result2;
      }
      __name(baseFilter, "baseFilter");
      function baseFlatten(array4, depth, predicate, isStrict, result2) {
        var index2 = -1, length2 = array4.length;
        for (predicate || (predicate = isFlattenable), result2 || (result2 = []); ++index2 < length2; ) {
          var value = array4[index2];
          depth > 0 && predicate(value) ? depth > 1 ? baseFlatten(value, depth - 1, predicate, isStrict, result2) : arrayPush(result2, value) : isStrict || (result2[result2.length] = value);
        }
        return result2;
      }
      __name(baseFlatten, "baseFlatten");
      var baseFor = createBaseFor(), baseForRight = createBaseFor(!0);
      function baseForOwn(object4, iteratee2) {
        return object4 && baseFor(object4, iteratee2, keys2);
      }
      __name(baseForOwn, "baseForOwn");
      function baseForOwnRight(object4, iteratee2) {
        return object4 && baseForRight(object4, iteratee2, keys2);
      }
      __name(baseForOwnRight, "baseForOwnRight");
      function baseFunctions(object4, props) {
        return arrayFilter(props, function(key) {
          return isFunction(object4[key]);
        });
      }
      __name(baseFunctions, "baseFunctions");
      function baseGet(object4, path2) {
        path2 = castPath(path2, object4);
        for (var index2 = 0, length2 = path2.length; object4 != null && index2 < length2; )
          object4 = object4[toKey(path2[index2++])];
        return index2 && index2 == length2 ? object4 : undefined$1;
      }
      __name(baseGet, "baseGet");
      function baseGetAllKeys(object4, keysFunc, symbolsFunc) {
        var result2 = keysFunc(object4);
        return isArray(object4) ? result2 : arrayPush(result2, symbolsFunc(object4));
      }
      __name(baseGetAllKeys, "baseGetAllKeys");
      function baseGetTag(value) {
        return value == null ? value === undefined$1 ? undefinedTag : nullTag : symToStringTag && symToStringTag in Object2(value) ? getRawTag(value) : objectToString(value);
      }
      __name(baseGetTag, "baseGetTag");
      function baseGt(value, other) {
        return value > other;
      }
      __name(baseGt, "baseGt");
      function baseHas(object4, key) {
        return object4 != null && hasOwnProperty.call(object4, key);
      }
      __name(baseHas, "baseHas");
      function baseHasIn(object4, key) {
        return object4 != null && key in Object2(object4);
      }
      __name(baseHasIn, "baseHasIn");
      function baseInRange(number4, start, end) {
        return number4 >= nativeMin(start, end) && number4 < nativeMax(start, end);
      }
      __name(baseInRange, "baseInRange");
      function baseIntersection(arrays, iteratee2, comparator) {
        for (var includes3 = comparator ? arrayIncludesWith : arrayIncludes, length2 = arrays[0].length, othLength = arrays.length, othIndex = othLength, caches = Array2(othLength), maxLength = 1 / 0, result2 = []; othIndex--; ) {
          var array4 = arrays[othIndex];
          othIndex && iteratee2 && (array4 = arrayMap(array4, baseUnary(iteratee2))), maxLength = nativeMin(array4.length, maxLength), caches[othIndex] = !comparator && (iteratee2 || length2 >= 120 && array4.length >= 120) ? new SetCache(othIndex && array4) : undefined$1;
        }
        array4 = arrays[0];
        var index2 = -1, seen = caches[0];
        outer:
          for (; ++index2 < length2 && result2.length < maxLength; ) {
            var value = array4[index2], computed = iteratee2 ? iteratee2(value) : value;
            if (value = comparator || value !== 0 ? value : 0, !(seen ? cacheHas(seen, computed) : includes3(result2, computed, comparator))) {
              for (othIndex = othLength; --othIndex; ) {
                var cache = caches[othIndex];
                if (!(cache ? cacheHas(cache, computed) : includes3(arrays[othIndex], computed, comparator)))
                  continue outer;
              }
              seen && seen.push(computed), result2.push(value);
            }
          }
        return result2;
      }
      __name(baseIntersection, "baseIntersection");
      function baseInverter(object4, setter, iteratee2, accumulator) {
        return baseForOwn(object4, function(value, key, object5) {
          setter(accumulator, iteratee2(value), key, object5);
        }), accumulator;
      }
      __name(baseInverter, "baseInverter");
      function baseInvoke(object4, path2, args) {
        path2 = castPath(path2, object4), object4 = parent(object4, path2);
        var func = object4 == null ? object4 : object4[toKey(last(path2))];
        return func == null ? undefined$1 : apply(func, object4, args);
      }
      __name(baseInvoke, "baseInvoke");
      function baseIsArguments(value) {
        return isObjectLike(value) && baseGetTag(value) == argsTag;
      }
      __name(baseIsArguments, "baseIsArguments");
      function baseIsArrayBuffer(value) {
        return isObjectLike(value) && baseGetTag(value) == arrayBufferTag;
      }
      __name(baseIsArrayBuffer, "baseIsArrayBuffer");
      function baseIsDate(value) {
        return isObjectLike(value) && baseGetTag(value) == dateTag;
      }
      __name(baseIsDate, "baseIsDate");
      function baseIsEqual(value, other, bitmask, customizer, stack) {
        return value === other ? !0 : value == null || other == null || !isObjectLike(value) && !isObjectLike(other) ? value !== value && other !== other : baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
      }
      __name(baseIsEqual, "baseIsEqual");
      function baseIsEqualDeep(object4, other, bitmask, customizer, equalFunc, stack) {
        var objIsArr = isArray(object4), othIsArr = isArray(other), objTag = objIsArr ? arrayTag : getTag(object4), othTag = othIsArr ? arrayTag : getTag(other);
        objTag = objTag == argsTag ? objectTag : objTag, othTag = othTag == argsTag ? objectTag : othTag;
        var objIsObj = objTag == objectTag, othIsObj = othTag == objectTag, isSameTag = objTag == othTag;
        if (isSameTag && isBuffer(object4)) {
          if (!isBuffer(other))
            return !1;
          objIsArr = !0, objIsObj = !1;
        }
        if (isSameTag && !objIsObj)
          return stack || (stack = new Stack()), objIsArr || isTypedArray(object4) ? equalArrays(object4, other, bitmask, customizer, equalFunc, stack) : equalByTag(object4, other, objTag, bitmask, customizer, equalFunc, stack);
        if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
          var objIsWrapped = objIsObj && hasOwnProperty.call(object4, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty.call(other, "__wrapped__");
          if (objIsWrapped || othIsWrapped) {
            var objUnwrapped = objIsWrapped ? object4.value() : object4, othUnwrapped = othIsWrapped ? other.value() : other;
            return stack || (stack = new Stack()), equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
          }
        }
        return isSameTag ? (stack || (stack = new Stack()), equalObjects(object4, other, bitmask, customizer, equalFunc, stack)) : !1;
      }
      __name(baseIsEqualDeep, "baseIsEqualDeep");
      function baseIsMap(value) {
        return isObjectLike(value) && getTag(value) == mapTag;
      }
      __name(baseIsMap, "baseIsMap");
      function baseIsMatch(object4, source, matchData, customizer) {
        var index2 = matchData.length, length2 = index2, noCustomizer = !customizer;
        if (object4 == null)
          return !length2;
        for (object4 = Object2(object4); index2--; ) {
          var data = matchData[index2];
          if (noCustomizer && data[2] ? data[1] !== object4[data[0]] : !(data[0] in object4))
            return !1;
        }
        for (; ++index2 < length2; ) {
          data = matchData[index2];
          var key = data[0], objValue = object4[key], srcValue = data[1];
          if (noCustomizer && data[2]) {
            if (objValue === undefined$1 && !(key in object4))
              return !1;
          } else {
            var stack = new Stack();
            if (customizer)
              var result2 = customizer(objValue, srcValue, key, object4, source, stack);
            if (!(result2 === undefined$1 ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG, customizer, stack) : result2))
              return !1;
          }
        }
        return !0;
      }
      __name(baseIsMatch, "baseIsMatch");
      function baseIsNative(value) {
        if (!isObject2(value) || isMasked(value))
          return !1;
        var pattern4 = isFunction(value) ? reIsNative : reIsHostCtor;
        return pattern4.test(toSource(value));
      }
      __name(baseIsNative, "baseIsNative");
      function baseIsRegExp(value) {
        return isObjectLike(value) && baseGetTag(value) == regexpTag;
      }
      __name(baseIsRegExp, "baseIsRegExp");
      function baseIsSet(value) {
        return isObjectLike(value) && getTag(value) == setTag;
      }
      __name(baseIsSet, "baseIsSet");
      function baseIsTypedArray(value) {
        return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
      }
      __name(baseIsTypedArray, "baseIsTypedArray");
      function baseIteratee(value) {
        return typeof value == "function" ? value : value == null ? identity : typeof value == "object" ? isArray(value) ? baseMatchesProperty(value[0], value[1]) : baseMatches(value) : property(value);
      }
      __name(baseIteratee, "baseIteratee");
      function baseKeys(object4) {
        if (!isPrototype(object4))
          return nativeKeys(object4);
        var result2 = [];
        for (var key in Object2(object4))
          hasOwnProperty.call(object4, key) && key != "constructor" && result2.push(key);
        return result2;
      }
      __name(baseKeys, "baseKeys");
      function baseKeysIn(object4) {
        if (!isObject2(object4))
          return nativeKeysIn(object4);
        var isProto = isPrototype(object4), result2 = [];
        for (var key in object4)
          key == "constructor" && (isProto || !hasOwnProperty.call(object4, key)) || result2.push(key);
        return result2;
      }
      __name(baseKeysIn, "baseKeysIn");
      function baseLt(value, other) {
        return value < other;
      }
      __name(baseLt, "baseLt");
      function baseMap(collection, iteratee2) {
        var index2 = -1, result2 = isArrayLike(collection) ? Array2(collection.length) : [];
        return baseEach(collection, function(value, key, collection2) {
          result2[++index2] = iteratee2(value, key, collection2);
        }), result2;
      }
      __name(baseMap, "baseMap");
      function baseMatches(source) {
        var matchData = getMatchData(source);
        return matchData.length == 1 && matchData[0][2] ? matchesStrictComparable(matchData[0][0], matchData[0][1]) : function(object4) {
          return object4 === source || baseIsMatch(object4, source, matchData);
        };
      }
      __name(baseMatches, "baseMatches");
      function baseMatchesProperty(path2, srcValue) {
        return isKey(path2) && isStrictComparable(srcValue) ? matchesStrictComparable(toKey(path2), srcValue) : function(object4) {
          var objValue = get2(object4, path2);
          return objValue === undefined$1 && objValue === srcValue ? hasIn(object4, path2) : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
        };
      }
      __name(baseMatchesProperty, "baseMatchesProperty");
      function baseMerge(object4, source, srcIndex, customizer, stack) {
        object4 !== source && baseFor(source, function(srcValue, key) {
          if (stack || (stack = new Stack()), isObject2(srcValue))
            baseMergeDeep(object4, source, key, srcIndex, baseMerge, customizer, stack);
          else {
            var newValue = customizer ? customizer(safeGet(object4, key), srcValue, key + "", object4, source, stack) : undefined$1;
            newValue === undefined$1 && (newValue = srcValue), assignMergeValue(object4, key, newValue);
          }
        }, keysIn);
      }
      __name(baseMerge, "baseMerge");
      function baseMergeDeep(object4, source, key, srcIndex, mergeFunc, customizer, stack) {
        var objValue = safeGet(object4, key), srcValue = safeGet(source, key), stacked = stack.get(srcValue);
        if (stacked) {
          assignMergeValue(object4, key, stacked);
          return;
        }
        var newValue = customizer ? customizer(objValue, srcValue, key + "", object4, source, stack) : undefined$1, isCommon = newValue === undefined$1;
        if (isCommon) {
          var isArr = isArray(srcValue), isBuff = !isArr && isBuffer(srcValue), isTyped = !isArr && !isBuff && isTypedArray(srcValue);
          newValue = srcValue, isArr || isBuff || isTyped ? isArray(objValue) ? newValue = objValue : isArrayLikeObject(objValue) ? newValue = copyArray(objValue) : isBuff ? (isCommon = !1, newValue = cloneBuffer(srcValue, !0)) : isTyped ? (isCommon = !1, newValue = cloneTypedArray(srcValue, !0)) : newValue = [] : isPlainObject(srcValue) || isArguments(srcValue) ? (newValue = objValue, isArguments(objValue) ? newValue = toPlainObject(objValue) : (!isObject2(objValue) || isFunction(objValue)) && (newValue = initCloneObject(srcValue))) : isCommon = !1;
        }
        isCommon && (stack.set(srcValue, newValue), mergeFunc(newValue, srcValue, srcIndex, customizer, stack), stack.delete(srcValue)), assignMergeValue(object4, key, newValue);
      }
      __name(baseMergeDeep, "baseMergeDeep");
      function baseNth(array4, n2) {
        var length2 = array4.length;
        if (length2)
          return n2 += n2 < 0 ? length2 : 0, isIndex(n2, length2) ? array4[n2] : undefined$1;
      }
      __name(baseNth, "baseNth");
      function baseOrderBy(collection, iteratees, orders) {
        iteratees.length ? iteratees = arrayMap(iteratees, function(iteratee2) {
          return isArray(iteratee2) ? function(value) {
            return baseGet(value, iteratee2.length === 1 ? iteratee2[0] : iteratee2);
          } : iteratee2;
        }) : iteratees = [identity];
        var index2 = -1;
        iteratees = arrayMap(iteratees, baseUnary(getIteratee()));
        var result2 = baseMap(collection, function(value, key, collection2) {
          var criteria = arrayMap(iteratees, function(iteratee2) {
            return iteratee2(value);
          });
          return { criteria, index: ++index2, value };
        });
        return baseSortBy(result2, function(object4, other) {
          return compareMultiple(object4, other, orders);
        });
      }
      __name(baseOrderBy, "baseOrderBy");
      function basePick(object4, paths) {
        return basePickBy(object4, paths, function(value, path2) {
          return hasIn(object4, path2);
        });
      }
      __name(basePick, "basePick");
      function basePickBy(object4, paths, predicate) {
        for (var index2 = -1, length2 = paths.length, result2 = {}; ++index2 < length2; ) {
          var path2 = paths[index2], value = baseGet(object4, path2);
          predicate(value, path2) && baseSet(result2, castPath(path2, object4), value);
        }
        return result2;
      }
      __name(basePickBy, "basePickBy");
      function basePropertyDeep(path2) {
        return function(object4) {
          return baseGet(object4, path2);
        };
      }
      __name(basePropertyDeep, "basePropertyDeep");
      function basePullAll(array4, values2, iteratee2, comparator) {
        var indexOf2 = comparator ? baseIndexOfWith : baseIndexOf, index2 = -1, length2 = values2.length, seen = array4;
        for (array4 === values2 && (values2 = copyArray(values2)), iteratee2 && (seen = arrayMap(array4, baseUnary(iteratee2))); ++index2 < length2; )
          for (var fromIndex = 0, value = values2[index2], computed = iteratee2 ? iteratee2(value) : value; (fromIndex = indexOf2(seen, computed, fromIndex, comparator)) > -1; )
            seen !== array4 && splice.call(seen, fromIndex, 1), splice.call(array4, fromIndex, 1);
        return array4;
      }
      __name(basePullAll, "basePullAll");
      function basePullAt(array4, indexes) {
        for (var length2 = array4 ? indexes.length : 0, lastIndex = length2 - 1; length2--; ) {
          var index2 = indexes[length2];
          if (length2 == lastIndex || index2 !== previous) {
            var previous = index2;
            isIndex(index2) ? splice.call(array4, index2, 1) : baseUnset(array4, index2);
          }
        }
        return array4;
      }
      __name(basePullAt, "basePullAt");
      function baseRandom(lower, upper) {
        return lower + nativeFloor(nativeRandom() * (upper - lower + 1));
      }
      __name(baseRandom, "baseRandom");
      function baseRange(start, end, step, fromRight) {
        for (var index2 = -1, length2 = nativeMax(nativeCeil((end - start) / (step || 1)), 0), result2 = Array2(length2); length2--; )
          result2[fromRight ? length2 : ++index2] = start, start += step;
        return result2;
      }
      __name(baseRange, "baseRange");
      function baseRepeat(string3, n2) {
        var result2 = "";
        if (!string3 || n2 < 1 || n2 > MAX_SAFE_INTEGER)
          return result2;
        do
          n2 % 2 && (result2 += string3), n2 = nativeFloor(n2 / 2), n2 && (string3 += string3);
        while (n2);
        return result2;
      }
      __name(baseRepeat, "baseRepeat");
      function baseRest(func, start) {
        return setToString(overRest(func, start, identity), func + "");
      }
      __name(baseRest, "baseRest");
      function baseSample(collection) {
        return arraySample(values(collection));
      }
      __name(baseSample, "baseSample");
      function baseSampleSize(collection, n2) {
        var array4 = values(collection);
        return shuffleSelf(array4, baseClamp(n2, 0, array4.length));
      }
      __name(baseSampleSize, "baseSampleSize");
      function baseSet(object4, path2, value, customizer) {
        if (!isObject2(object4))
          return object4;
        path2 = castPath(path2, object4);
        for (var index2 = -1, length2 = path2.length, lastIndex = length2 - 1, nested = object4; nested != null && ++index2 < length2; ) {
          var key = toKey(path2[index2]), newValue = value;
          if (key === "__proto__" || key === "constructor" || key === "prototype")
            return object4;
          if (index2 != lastIndex) {
            var objValue = nested[key];
            newValue = customizer ? customizer(objValue, key, nested) : undefined$1, newValue === undefined$1 && (newValue = isObject2(objValue) ? objValue : isIndex(path2[index2 + 1]) ? [] : {});
          }
          assignValue(nested, key, newValue), nested = nested[key];
        }
        return object4;
      }
      __name(baseSet, "baseSet");
      var baseSetData = metaMap ? function(func, data) {
        return metaMap.set(func, data), func;
      } : identity, baseSetToString = defineProperty2 ? function(func, string3) {
        return defineProperty2(func, "toString", {
          configurable: !0,
          enumerable: !1,
          value: constant(string3),
          writable: !0
        });
      } : identity;
      function baseShuffle(collection) {
        return shuffleSelf(values(collection));
      }
      __name(baseShuffle, "baseShuffle");
      function baseSlice(array4, start, end) {
        var index2 = -1, length2 = array4.length;
        start < 0 && (start = -start > length2 ? 0 : length2 + start), end = end > length2 ? length2 : end, end < 0 && (end += length2), length2 = start > end ? 0 : end - start >>> 0, start >>>= 0;
        for (var result2 = Array2(length2); ++index2 < length2; )
          result2[index2] = array4[index2 + start];
        return result2;
      }
      __name(baseSlice, "baseSlice");
      function baseSome(collection, predicate) {
        var result2;
        return baseEach(collection, function(value, index2, collection2) {
          return result2 = predicate(value, index2, collection2), !result2;
        }), !!result2;
      }
      __name(baseSome, "baseSome");
      function baseSortedIndex(array4, value, retHighest) {
        var low = 0, high = array4 == null ? low : array4.length;
        if (typeof value == "number" && value === value && high <= HALF_MAX_ARRAY_LENGTH) {
          for (; low < high; ) {
            var mid = low + high >>> 1, computed = array4[mid];
            computed !== null && !isSymbol(computed) && (retHighest ? computed <= value : computed < value) ? low = mid + 1 : high = mid;
          }
          return high;
        }
        return baseSortedIndexBy(array4, value, identity, retHighest);
      }
      __name(baseSortedIndex, "baseSortedIndex");
      function baseSortedIndexBy(array4, value, iteratee2, retHighest) {
        var low = 0, high = array4 == null ? 0 : array4.length;
        if (high === 0)
          return 0;
        value = iteratee2(value);
        for (var valIsNaN = value !== value, valIsNull = value === null, valIsSymbol = isSymbol(value), valIsUndefined = value === undefined$1; low < high; ) {
          var mid = nativeFloor((low + high) / 2), computed = iteratee2(array4[mid]), othIsDefined = computed !== undefined$1, othIsNull = computed === null, othIsReflexive = computed === computed, othIsSymbol = isSymbol(computed);
          if (valIsNaN)
            var setLow = retHighest || othIsReflexive;
          else valIsUndefined ? setLow = othIsReflexive && (retHighest || othIsDefined) : valIsNull ? setLow = othIsReflexive && othIsDefined && (retHighest || !othIsNull) : valIsSymbol ? setLow = othIsReflexive && othIsDefined && !othIsNull && (retHighest || !othIsSymbol) : othIsNull || othIsSymbol ? setLow = !1 : setLow = retHighest ? computed <= value : computed < value;
          setLow ? low = mid + 1 : high = mid;
        }
        return nativeMin(high, MAX_ARRAY_INDEX);
      }
      __name(baseSortedIndexBy, "baseSortedIndexBy");
      function baseSortedUniq(array4, iteratee2) {
        for (var index2 = -1, length2 = array4.length, resIndex = 0, result2 = []; ++index2 < length2; ) {
          var value = array4[index2], computed = iteratee2 ? iteratee2(value) : value;
          if (!index2 || !eq(computed, seen)) {
            var seen = computed;
            result2[resIndex++] = value === 0 ? 0 : value;
          }
        }
        return result2;
      }
      __name(baseSortedUniq, "baseSortedUniq");
      function baseToNumber(value) {
        return typeof value == "number" ? value : isSymbol(value) ? NAN : +value;
      }
      __name(baseToNumber, "baseToNumber");
      function baseToString(value) {
        if (typeof value == "string")
          return value;
        if (isArray(value))
          return arrayMap(value, baseToString) + "";
        if (isSymbol(value))
          return symbolToString ? symbolToString.call(value) : "";
        var result2 = value + "";
        return result2 == "0" && 1 / value == -1 / 0 ? "-0" : result2;
      }
      __name(baseToString, "baseToString");
      function baseUniq(array4, iteratee2, comparator) {
        var index2 = -1, includes3 = arrayIncludes, length2 = array4.length, isCommon = !0, result2 = [], seen = result2;
        if (comparator)
          isCommon = !1, includes3 = arrayIncludesWith;
        else if (length2 >= LARGE_ARRAY_SIZE) {
          var set3 = iteratee2 ? null : createSet(array4);
          if (set3)
            return setToArray(set3);
          isCommon = !1, includes3 = cacheHas, seen = new SetCache();
        } else
          seen = iteratee2 ? [] : result2;
        outer:
          for (; ++index2 < length2; ) {
            var value = array4[index2], computed = iteratee2 ? iteratee2(value) : value;
            if (value = comparator || value !== 0 ? value : 0, isCommon && computed === computed) {
              for (var seenIndex = seen.length; seenIndex--; )
                if (seen[seenIndex] === computed)
                  continue outer;
              iteratee2 && seen.push(computed), result2.push(value);
            } else includes3(seen, computed, comparator) || (seen !== result2 && seen.push(computed), result2.push(value));
          }
        return result2;
      }
      __name(baseUniq, "baseUniq");
      function baseUnset(object4, path2) {
        return path2 = castPath(path2, object4), object4 = parent(object4, path2), object4 == null || delete object4[toKey(last(path2))];
      }
      __name(baseUnset, "baseUnset");
      function baseUpdate(object4, path2, updater, customizer) {
        return baseSet(object4, path2, updater(baseGet(object4, path2)), customizer);
      }
      __name(baseUpdate, "baseUpdate");
      function baseWhile(array4, predicate, isDrop, fromRight) {
        for (var length2 = array4.length, index2 = fromRight ? length2 : -1; (fromRight ? index2-- : ++index2 < length2) && predicate(array4[index2], index2, array4); )
          ;
        return isDrop ? baseSlice(array4, fromRight ? 0 : index2, fromRight ? index2 + 1 : length2) : baseSlice(array4, fromRight ? index2 + 1 : 0, fromRight ? length2 : index2);
      }
      __name(baseWhile, "baseWhile");
      function baseWrapperValue(value, actions) {
        var result2 = value;
        return result2 instanceof LazyWrapper && (result2 = result2.value()), arrayReduce(actions, function(result3, action) {
          return action.func.apply(action.thisArg, arrayPush([result3], action.args));
        }, result2);
      }
      __name(baseWrapperValue, "baseWrapperValue");
      function baseXor(arrays, iteratee2, comparator) {
        var length2 = arrays.length;
        if (length2 < 2)
          return length2 ? baseUniq(arrays[0]) : [];
        for (var index2 = -1, result2 = Array2(length2); ++index2 < length2; )
          for (var array4 = arrays[index2], othIndex = -1; ++othIndex < length2; )
            othIndex != index2 && (result2[index2] = baseDifference(result2[index2] || array4, arrays[othIndex], iteratee2, comparator));
        return baseUniq(baseFlatten(result2, 1), iteratee2, comparator);
      }
      __name(baseXor, "baseXor");
      function baseZipObject(props, values2, assignFunc) {
        for (var index2 = -1, length2 = props.length, valsLength = values2.length, result2 = {}; ++index2 < length2; ) {
          var value = index2 < valsLength ? values2[index2] : undefined$1;
          assignFunc(result2, props[index2], value);
        }
        return result2;
      }
      __name(baseZipObject, "baseZipObject");
      function castArrayLikeObject(value) {
        return isArrayLikeObject(value) ? value : [];
      }
      __name(castArrayLikeObject, "castArrayLikeObject");
      function castFunction(value) {
        return typeof value == "function" ? value : identity;
      }
      __name(castFunction, "castFunction");
      function castPath(value, object4) {
        return isArray(value) ? value : isKey(value, object4) ? [value] : stringToPath(toString(value));
      }
      __name(castPath, "castPath");
      var castRest = baseRest;
      function castSlice(array4, start, end) {
        var length2 = array4.length;
        return end = end === undefined$1 ? length2 : end, !start && end >= length2 ? array4 : baseSlice(array4, start, end);
      }
      __name(castSlice, "castSlice");
      var clearTimeout2 = ctxClearTimeout || function(id2) {
        return root.clearTimeout(id2);
      };
      function cloneBuffer(buffer, isDeep) {
        if (isDeep)
          return buffer.slice();
        var length2 = buffer.length, result2 = allocUnsafe ? allocUnsafe(length2) : new buffer.constructor(length2);
        return buffer.copy(result2), result2;
      }
      __name(cloneBuffer, "cloneBuffer");
      function cloneArrayBuffer(arrayBuffer) {
        var result2 = new arrayBuffer.constructor(arrayBuffer.byteLength);
        return new Uint8Array2(result2).set(new Uint8Array2(arrayBuffer)), result2;
      }
      __name(cloneArrayBuffer, "cloneArrayBuffer");
      function cloneDataView(dataView, isDeep) {
        var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
        return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
      }
      __name(cloneDataView, "cloneDataView");
      function cloneRegExp(regexp4) {
        var result2 = new regexp4.constructor(regexp4.source, reFlags.exec(regexp4));
        return result2.lastIndex = regexp4.lastIndex, result2;
      }
      __name(cloneRegExp, "cloneRegExp");
      function cloneSymbol(symbol) {
        return symbolValueOf ? Object2(symbolValueOf.call(symbol)) : {};
      }
      __name(cloneSymbol, "cloneSymbol");
      function cloneTypedArray(typedArray, isDeep) {
        var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
        return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
      }
      __name(cloneTypedArray, "cloneTypedArray");
      function compareAscending(value, other) {
        if (value !== other) {
          var valIsDefined = value !== undefined$1, valIsNull = value === null, valIsReflexive = value === value, valIsSymbol = isSymbol(value), othIsDefined = other !== undefined$1, othIsNull = other === null, othIsReflexive = other === other, othIsSymbol = isSymbol(other);
          if (!othIsNull && !othIsSymbol && !valIsSymbol && value > other || valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol || valIsNull && othIsDefined && othIsReflexive || !valIsDefined && othIsReflexive || !valIsReflexive)
            return 1;
          if (!valIsNull && !valIsSymbol && !othIsSymbol && value < other || othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol || othIsNull && valIsDefined && valIsReflexive || !othIsDefined && valIsReflexive || !othIsReflexive)
            return -1;
        }
        return 0;
      }
      __name(compareAscending, "compareAscending");
      function compareMultiple(object4, other, orders) {
        for (var index2 = -1, objCriteria = object4.criteria, othCriteria = other.criteria, length2 = objCriteria.length, ordersLength = orders.length; ++index2 < length2; ) {
          var result2 = compareAscending(objCriteria[index2], othCriteria[index2]);
          if (result2) {
            if (index2 >= ordersLength)
              return result2;
            var order2 = orders[index2];
            return result2 * (order2 == "desc" ? -1 : 1);
          }
        }
        return object4.index - other.index;
      }
      __name(compareMultiple, "compareMultiple");
      function composeArgs(args, partials, holders, isCurried) {
        for (var argsIndex = -1, argsLength = args.length, holdersLength = holders.length, leftIndex = -1, leftLength = partials.length, rangeLength = nativeMax(argsLength - holdersLength, 0), result2 = Array2(leftLength + rangeLength), isUncurried = !isCurried; ++leftIndex < leftLength; )
          result2[leftIndex] = partials[leftIndex];
        for (; ++argsIndex < holdersLength; )
          (isUncurried || argsIndex < argsLength) && (result2[holders[argsIndex]] = args[argsIndex]);
        for (; rangeLength--; )
          result2[leftIndex++] = args[argsIndex++];
        return result2;
      }
      __name(composeArgs, "composeArgs");
      function composeArgsRight(args, partials, holders, isCurried) {
        for (var argsIndex = -1, argsLength = args.length, holdersIndex = -1, holdersLength = holders.length, rightIndex = -1, rightLength = partials.length, rangeLength = nativeMax(argsLength - holdersLength, 0), result2 = Array2(rangeLength + rightLength), isUncurried = !isCurried; ++argsIndex < rangeLength; )
          result2[argsIndex] = args[argsIndex];
        for (var offset2 = argsIndex; ++rightIndex < rightLength; )
          result2[offset2 + rightIndex] = partials[rightIndex];
        for (; ++holdersIndex < holdersLength; )
          (isUncurried || argsIndex < argsLength) && (result2[offset2 + holders[holdersIndex]] = args[argsIndex++]);
        return result2;
      }
      __name(composeArgsRight, "composeArgsRight");
      function copyArray(source, array4) {
        var index2 = -1, length2 = source.length;
        for (array4 || (array4 = Array2(length2)); ++index2 < length2; )
          array4[index2] = source[index2];
        return array4;
      }
      __name(copyArray, "copyArray");
      function copyObject(source, props, object4, customizer) {
        var isNew = !object4;
        object4 || (object4 = {});
        for (var index2 = -1, length2 = props.length; ++index2 < length2; ) {
          var key = props[index2], newValue = customizer ? customizer(object4[key], source[key], key, object4, source) : undefined$1;
          newValue === undefined$1 && (newValue = source[key]), isNew ? baseAssignValue(object4, key, newValue) : assignValue(object4, key, newValue);
        }
        return object4;
      }
      __name(copyObject, "copyObject");
      function copySymbols(source, object4) {
        return copyObject(source, getSymbols(source), object4);
      }
      __name(copySymbols, "copySymbols");
      function copySymbolsIn(source, object4) {
        return copyObject(source, getSymbolsIn(source), object4);
      }
      __name(copySymbolsIn, "copySymbolsIn");
      function createAggregator(setter, initializer) {
        return function(collection, iteratee2) {
          var func = isArray(collection) ? arrayAggregator : baseAggregator, accumulator = initializer ? initializer() : {};
          return func(collection, setter, getIteratee(iteratee2, 2), accumulator);
        };
      }
      __name(createAggregator, "createAggregator");
      function createAssigner(assigner) {
        return baseRest(function(object4, sources) {
          var index2 = -1, length2 = sources.length, customizer = length2 > 1 ? sources[length2 - 1] : undefined$1, guard = length2 > 2 ? sources[2] : undefined$1;
          for (customizer = assigner.length > 3 && typeof customizer == "function" ? (length2--, customizer) : undefined$1, guard && isIterateeCall(sources[0], sources[1], guard) && (customizer = length2 < 3 ? undefined$1 : customizer, length2 = 1), object4 = Object2(object4); ++index2 < length2; ) {
            var source = sources[index2];
            source && assigner(object4, source, index2, customizer);
          }
          return object4;
        });
      }
      __name(createAssigner, "createAssigner");
      function createBaseEach(eachFunc, fromRight) {
        return function(collection, iteratee2) {
          if (collection == null)
            return collection;
          if (!isArrayLike(collection))
            return eachFunc(collection, iteratee2);
          for (var length2 = collection.length, index2 = fromRight ? length2 : -1, iterable = Object2(collection); (fromRight ? index2-- : ++index2 < length2) && iteratee2(iterable[index2], index2, iterable) !== !1; )
            ;
          return collection;
        };
      }
      __name(createBaseEach, "createBaseEach");
      function createBaseFor(fromRight) {
        return function(object4, iteratee2, keysFunc) {
          for (var index2 = -1, iterable = Object2(object4), props = keysFunc(object4), length2 = props.length; length2--; ) {
            var key = props[fromRight ? length2 : ++index2];
            if (iteratee2(iterable[key], key, iterable) === !1)
              break;
          }
          return object4;
        };
      }
      __name(createBaseFor, "createBaseFor");
      function createBind(func, bitmask, thisArg) {
        var isBind = bitmask & WRAP_BIND_FLAG, Ctor = createCtor(func);
        function wrapper() {
          var fn = this && this !== root && this instanceof wrapper ? Ctor : func;
          return fn.apply(isBind ? thisArg : this, arguments);
        }
        return __name(wrapper, "wrapper"), wrapper;
      }
      __name(createBind, "createBind");
      function createCaseFirst(methodName) {
        return function(string3) {
          string3 = toString(string3);
          var strSymbols = hasUnicode(string3) ? stringToArray(string3) : undefined$1, chr = strSymbols ? strSymbols[0] : string3.charAt(0), trailing = strSymbols ? castSlice(strSymbols, 1).join("") : string3.slice(1);
          return chr[methodName]() + trailing;
        };
      }
      __name(createCaseFirst, "createCaseFirst");
      function createCompounder(callback) {
        return function(string3) {
          return arrayReduce(words(deburr(string3).replace(reApos, "")), callback, "");
        };
      }
      __name(createCompounder, "createCompounder");
      function createCtor(Ctor) {
        return function() {
          var args = arguments;
          switch (args.length) {
            case 0:
              return new Ctor();
            case 1:
              return new Ctor(args[0]);
            case 2:
              return new Ctor(args[0], args[1]);
            case 3:
              return new Ctor(args[0], args[1], args[2]);
            case 4:
              return new Ctor(args[0], args[1], args[2], args[3]);
            case 5:
              return new Ctor(args[0], args[1], args[2], args[3], args[4]);
            case 6:
              return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5]);
            case 7:
              return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5], args[6]);
          }
          var thisBinding = baseCreate(Ctor.prototype), result2 = Ctor.apply(thisBinding, args);
          return isObject2(result2) ? result2 : thisBinding;
        };
      }
      __name(createCtor, "createCtor");
      function createCurry(func, bitmask, arity) {
        var Ctor = createCtor(func);
        function wrapper() {
          for (var length2 = arguments.length, args = Array2(length2), index2 = length2, placeholder = getHolder(wrapper); index2--; )
            args[index2] = arguments[index2];
          var holders = length2 < 3 && args[0] !== placeholder && args[length2 - 1] !== placeholder ? [] : replaceHolders(args, placeholder);
          if (length2 -= holders.length, length2 < arity)
            return createRecurry(
              func,
              bitmask,
              createHybrid,
              wrapper.placeholder,
              undefined$1,
              args,
              holders,
              undefined$1,
              undefined$1,
              arity - length2
            );
          var fn = this && this !== root && this instanceof wrapper ? Ctor : func;
          return apply(fn, this, args);
        }
        return __name(wrapper, "wrapper"), wrapper;
      }
      __name(createCurry, "createCurry");
      function createFind(findIndexFunc) {
        return function(collection, predicate, fromIndex) {
          var iterable = Object2(collection);
          if (!isArrayLike(collection)) {
            var iteratee2 = getIteratee(predicate, 3);
            collection = keys2(collection), predicate = /* @__PURE__ */ __name(function(key) {
              return iteratee2(iterable[key], key, iterable);
            }, "predicate");
          }
          var index2 = findIndexFunc(collection, predicate, fromIndex);
          return index2 > -1 ? iterable[iteratee2 ? collection[index2] : index2] : undefined$1;
        };
      }
      __name(createFind, "createFind");
      function createFlow(fromRight) {
        return flatRest(function(funcs) {
          var length2 = funcs.length, index2 = length2, prereq = LodashWrapper.prototype.thru;
          for (fromRight && funcs.reverse(); index2--; ) {
            var func = funcs[index2];
            if (typeof func != "function")
              throw new TypeError2(FUNC_ERROR_TEXT);
            if (prereq && !wrapper && getFuncName(func) == "wrapper")
              var wrapper = new LodashWrapper([], !0);
          }
          for (index2 = wrapper ? index2 : length2; ++index2 < length2; ) {
            func = funcs[index2];
            var funcName = getFuncName(func), data = funcName == "wrapper" ? getData(func) : undefined$1;
            data && isLaziable(data[0]) && data[1] == (WRAP_ARY_FLAG | WRAP_CURRY_FLAG | WRAP_PARTIAL_FLAG | WRAP_REARG_FLAG) && !data[4].length && data[9] == 1 ? wrapper = wrapper[getFuncName(data[0])].apply(wrapper, data[3]) : wrapper = func.length == 1 && isLaziable(func) ? wrapper[funcName]() : wrapper.thru(func);
          }
          return function() {
            var args = arguments, value = args[0];
            if (wrapper && args.length == 1 && isArray(value))
              return wrapper.plant(value).value();
            for (var index3 = 0, result2 = length2 ? funcs[index3].apply(this, args) : value; ++index3 < length2; )
              result2 = funcs[index3].call(this, result2);
            return result2;
          };
        });
      }
      __name(createFlow, "createFlow");
      function createHybrid(func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary2, arity) {
        var isAry = bitmask & WRAP_ARY_FLAG, isBind = bitmask & WRAP_BIND_FLAG, isBindKey = bitmask & WRAP_BIND_KEY_FLAG, isCurried = bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG), isFlip = bitmask & WRAP_FLIP_FLAG, Ctor = isBindKey ? undefined$1 : createCtor(func);
        function wrapper() {
          for (var length2 = arguments.length, args = Array2(length2), index2 = length2; index2--; )
            args[index2] = arguments[index2];
          if (isCurried)
            var placeholder = getHolder(wrapper), holdersCount = countHolders(args, placeholder);
          if (partials && (args = composeArgs(args, partials, holders, isCurried)), partialsRight && (args = composeArgsRight(args, partialsRight, holdersRight, isCurried)), length2 -= holdersCount, isCurried && length2 < arity) {
            var newHolders = replaceHolders(args, placeholder);
            return createRecurry(
              func,
              bitmask,
              createHybrid,
              wrapper.placeholder,
              thisArg,
              args,
              newHolders,
              argPos,
              ary2,
              arity - length2
            );
          }
          var thisBinding = isBind ? thisArg : this, fn = isBindKey ? thisBinding[func] : func;
          return length2 = args.length, argPos ? args = reorder(args, argPos) : isFlip && length2 > 1 && args.reverse(), isAry && ary2 < length2 && (args.length = ary2), this && this !== root && this instanceof wrapper && (fn = Ctor || createCtor(fn)), fn.apply(thisBinding, args);
        }
        return __name(wrapper, "wrapper"), wrapper;
      }
      __name(createHybrid, "createHybrid");
      function createInverter(setter, toIteratee) {
        return function(object4, iteratee2) {
          return baseInverter(object4, setter, toIteratee(iteratee2), {});
        };
      }
      __name(createInverter, "createInverter");
      function createMathOperation(operator, defaultValue) {
        return function(value, other) {
          var result2;
          if (value === undefined$1 && other === undefined$1)
            return defaultValue;
          if (value !== undefined$1 && (result2 = value), other !== undefined$1) {
            if (result2 === undefined$1)
              return other;
            typeof value == "string" || typeof other == "string" ? (value = baseToString(value), other = baseToString(other)) : (value = baseToNumber(value), other = baseToNumber(other)), result2 = operator(value, other);
          }
          return result2;
        };
      }
      __name(createMathOperation, "createMathOperation");
      function createOver(arrayFunc) {
        return flatRest(function(iteratees) {
          return iteratees = arrayMap(iteratees, baseUnary(getIteratee())), baseRest(function(args) {
            var thisArg = this;
            return arrayFunc(iteratees, function(iteratee2) {
              return apply(iteratee2, thisArg, args);
            });
          });
        });
      }
      __name(createOver, "createOver");
      function createPadding(length2, chars2) {
        chars2 = chars2 === undefined$1 ? " " : baseToString(chars2);
        var charsLength = chars2.length;
        if (charsLength < 2)
          return charsLength ? baseRepeat(chars2, length2) : chars2;
        var result2 = baseRepeat(chars2, nativeCeil(length2 / stringSize(chars2)));
        return hasUnicode(chars2) ? castSlice(stringToArray(result2), 0, length2).join("") : result2.slice(0, length2);
      }
      __name(createPadding, "createPadding");
      function createPartial(func, bitmask, thisArg, partials) {
        var isBind = bitmask & WRAP_BIND_FLAG, Ctor = createCtor(func);
        function wrapper() {
          for (var argsIndex = -1, argsLength = arguments.length, leftIndex = -1, leftLength = partials.length, args = Array2(leftLength + argsLength), fn = this && this !== root && this instanceof wrapper ? Ctor : func; ++leftIndex < leftLength; )
            args[leftIndex] = partials[leftIndex];
          for (; argsLength--; )
            args[leftIndex++] = arguments[++argsIndex];
          return apply(fn, isBind ? thisArg : this, args);
        }
        return __name(wrapper, "wrapper"), wrapper;
      }
      __name(createPartial, "createPartial");
      function createRange(fromRight) {
        return function(start, end, step) {
          return step && typeof step != "number" && isIterateeCall(start, end, step) && (end = step = undefined$1), start = toFinite(start), end === undefined$1 ? (end = start, start = 0) : end = toFinite(end), step = step === undefined$1 ? start < end ? 1 : -1 : toFinite(step), baseRange(start, end, step, fromRight);
        };
      }
      __name(createRange, "createRange");
      function createRelationalOperation(operator) {
        return function(value, other) {
          return typeof value == "string" && typeof other == "string" || (value = toNumber(value), other = toNumber(other)), operator(value, other);
        };
      }
      __name(createRelationalOperation, "createRelationalOperation");
      function createRecurry(func, bitmask, wrapFunc, placeholder, thisArg, partials, holders, argPos, ary2, arity) {
        var isCurry = bitmask & WRAP_CURRY_FLAG, newHolders = isCurry ? holders : undefined$1, newHoldersRight = isCurry ? undefined$1 : holders, newPartials = isCurry ? partials : undefined$1, newPartialsRight = isCurry ? undefined$1 : partials;
        bitmask |= isCurry ? WRAP_PARTIAL_FLAG : WRAP_PARTIAL_RIGHT_FLAG, bitmask &= ~(isCurry ? WRAP_PARTIAL_RIGHT_FLAG : WRAP_PARTIAL_FLAG), bitmask & WRAP_CURRY_BOUND_FLAG || (bitmask &= -4);
        var newData = [
          func,
          bitmask,
          thisArg,
          newPartials,
          newHolders,
          newPartialsRight,
          newHoldersRight,
          argPos,
          ary2,
          arity
        ], result2 = wrapFunc.apply(undefined$1, newData);
        return isLaziable(func) && setData(result2, newData), result2.placeholder = placeholder, setWrapToString(result2, func, bitmask);
      }
      __name(createRecurry, "createRecurry");
      function createRound(methodName) {
        var func = Math2[methodName];
        return function(number4, precision) {
          if (number4 = toNumber(number4), precision = precision == null ? 0 : nativeMin(toInteger(precision), 292), precision && nativeIsFinite(number4)) {
            var pair = (toString(number4) + "e").split("e"), value = func(pair[0] + "e" + (+pair[1] + precision));
            return pair = (toString(value) + "e").split("e"), +(pair[0] + "e" + (+pair[1] - precision));
          }
          return func(number4);
        };
      }
      __name(createRound, "createRound");
      var createSet = Set2 && 1 / setToArray(new Set2([, -0]))[1] == INFINITY ? function(values2) {
        return new Set2(values2);
      } : noop3;
      function createToPairs(keysFunc) {
        return function(object4) {
          var tag = getTag(object4);
          return tag == mapTag ? mapToArray(object4) : tag == setTag ? setToPairs(object4) : baseToPairs(object4, keysFunc(object4));
        };
      }
      __name(createToPairs, "createToPairs");
      function createWrap(func, bitmask, thisArg, partials, holders, argPos, ary2, arity) {
        var isBindKey = bitmask & WRAP_BIND_KEY_FLAG;
        if (!isBindKey && typeof func != "function")
          throw new TypeError2(FUNC_ERROR_TEXT);
        var length2 = partials ? partials.length : 0;
        if (length2 || (bitmask &= -97, partials = holders = undefined$1), ary2 = ary2 === undefined$1 ? ary2 : nativeMax(toInteger(ary2), 0), arity = arity === undefined$1 ? arity : toInteger(arity), length2 -= holders ? holders.length : 0, bitmask & WRAP_PARTIAL_RIGHT_FLAG) {
          var partialsRight = partials, holdersRight = holders;
          partials = holders = undefined$1;
        }
        var data = isBindKey ? undefined$1 : getData(func), newData = [
          func,
          bitmask,
          thisArg,
          partials,
          holders,
          partialsRight,
          holdersRight,
          argPos,
          ary2,
          arity
        ];
        if (data && mergeData(newData, data), func = newData[0], bitmask = newData[1], thisArg = newData[2], partials = newData[3], holders = newData[4], arity = newData[9] = newData[9] === undefined$1 ? isBindKey ? 0 : func.length : nativeMax(newData[9] - length2, 0), !arity && bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG) && (bitmask &= -25), !bitmask || bitmask == WRAP_BIND_FLAG)
          var result2 = createBind(func, bitmask, thisArg);
        else bitmask == WRAP_CURRY_FLAG || bitmask == WRAP_CURRY_RIGHT_FLAG ? result2 = createCurry(func, bitmask, arity) : (bitmask == WRAP_PARTIAL_FLAG || bitmask == (WRAP_BIND_FLAG | WRAP_PARTIAL_FLAG)) && !holders.length ? result2 = createPartial(func, bitmask, thisArg, partials) : result2 = createHybrid.apply(undefined$1, newData);
        var setter = data ? baseSetData : setData;
        return setWrapToString(setter(result2, newData), func, bitmask);
      }
      __name(createWrap, "createWrap");
      function customDefaultsAssignIn(objValue, srcValue, key, object4) {
        return objValue === undefined$1 || eq(objValue, objectProto[key]) && !hasOwnProperty.call(object4, key) ? srcValue : objValue;
      }
      __name(customDefaultsAssignIn, "customDefaultsAssignIn");
      function customDefaultsMerge(objValue, srcValue, key, object4, source, stack) {
        return isObject2(objValue) && isObject2(srcValue) && (stack.set(srcValue, objValue), baseMerge(objValue, srcValue, undefined$1, customDefaultsMerge, stack), stack.delete(srcValue)), objValue;
      }
      __name(customDefaultsMerge, "customDefaultsMerge");
      function customOmitClone(value) {
        return isPlainObject(value) ? undefined$1 : value;
      }
      __name(customOmitClone, "customOmitClone");
      function equalArrays(array4, other, bitmask, customizer, equalFunc, stack) {
        var isPartial = bitmask & COMPARE_PARTIAL_FLAG, arrLength = array4.length, othLength = other.length;
        if (arrLength != othLength && !(isPartial && othLength > arrLength))
          return !1;
        var arrStacked = stack.get(array4), othStacked = stack.get(other);
        if (arrStacked && othStacked)
          return arrStacked == other && othStacked == array4;
        var index2 = -1, result2 = !0, seen = bitmask & COMPARE_UNORDERED_FLAG ? new SetCache() : undefined$1;
        for (stack.set(array4, other), stack.set(other, array4); ++index2 < arrLength; ) {
          var arrValue = array4[index2], othValue = other[index2];
          if (customizer)
            var compared = isPartial ? customizer(othValue, arrValue, index2, other, array4, stack) : customizer(arrValue, othValue, index2, array4, other, stack);
          if (compared !== undefined$1) {
            if (compared)
              continue;
            result2 = !1;
            break;
          }
          if (seen) {
            if (!arraySome(other, function(othValue2, othIndex) {
              if (!cacheHas(seen, othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, bitmask, customizer, stack)))
                return seen.push(othIndex);
            })) {
              result2 = !1;
              break;
            }
          } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
            result2 = !1;
            break;
          }
        }
        return stack.delete(array4), stack.delete(other), result2;
      }
      __name(equalArrays, "equalArrays");
      function equalByTag(object4, other, tag, bitmask, customizer, equalFunc, stack) {
        switch (tag) {
          case dataViewTag:
            if (object4.byteLength != other.byteLength || object4.byteOffset != other.byteOffset)
              return !1;
            object4 = object4.buffer, other = other.buffer;
          case arrayBufferTag:
            return !(object4.byteLength != other.byteLength || !equalFunc(new Uint8Array2(object4), new Uint8Array2(other)));
          case boolTag:
          case dateTag:
          case numberTag:
            return eq(+object4, +other);
          case errorTag:
            return object4.name == other.name && object4.message == other.message;
          case regexpTag:
          case stringTag:
            return object4 == other + "";
          case mapTag:
            var convert = mapToArray;
          case setTag:
            var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
            if (convert || (convert = setToArray), object4.size != other.size && !isPartial)
              return !1;
            var stacked = stack.get(object4);
            if (stacked)
              return stacked == other;
            bitmask |= COMPARE_UNORDERED_FLAG, stack.set(object4, other);
            var result2 = equalArrays(convert(object4), convert(other), bitmask, customizer, equalFunc, stack);
            return stack.delete(object4), result2;
          case symbolTag:
            if (symbolValueOf)
              return symbolValueOf.call(object4) == symbolValueOf.call(other);
        }
        return !1;
      }
      __name(equalByTag, "equalByTag");
      function equalObjects(object4, other, bitmask, customizer, equalFunc, stack) {
        var isPartial = bitmask & COMPARE_PARTIAL_FLAG, objProps = getAllKeys(object4), objLength = objProps.length, othProps = getAllKeys(other), othLength = othProps.length;
        if (objLength != othLength && !isPartial)
          return !1;
        for (var index2 = objLength; index2--; ) {
          var key = objProps[index2];
          if (!(isPartial ? key in other : hasOwnProperty.call(other, key)))
            return !1;
        }
        var objStacked = stack.get(object4), othStacked = stack.get(other);
        if (objStacked && othStacked)
          return objStacked == other && othStacked == object4;
        var result2 = !0;
        stack.set(object4, other), stack.set(other, object4);
        for (var skipCtor = isPartial; ++index2 < objLength; ) {
          key = objProps[index2];
          var objValue = object4[key], othValue = other[key];
          if (customizer)
            var compared = isPartial ? customizer(othValue, objValue, key, other, object4, stack) : customizer(objValue, othValue, key, object4, other, stack);
          if (!(compared === undefined$1 ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
            result2 = !1;
            break;
          }
          skipCtor || (skipCtor = key == "constructor");
        }
        if (result2 && !skipCtor) {
          var objCtor = object4.constructor, othCtor = other.constructor;
          objCtor != othCtor && "constructor" in object4 && "constructor" in other && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor) && (result2 = !1);
        }
        return stack.delete(object4), stack.delete(other), result2;
      }
      __name(equalObjects, "equalObjects");
      function flatRest(func) {
        return setToString(overRest(func, undefined$1, flatten), func + "");
      }
      __name(flatRest, "flatRest");
      function getAllKeys(object4) {
        return baseGetAllKeys(object4, keys2, getSymbols);
      }
      __name(getAllKeys, "getAllKeys");
      function getAllKeysIn(object4) {
        return baseGetAllKeys(object4, keysIn, getSymbolsIn);
      }
      __name(getAllKeysIn, "getAllKeysIn");
      var getData = metaMap ? function(func) {
        return metaMap.get(func);
      } : noop3;
      function getFuncName(func) {
        for (var result2 = func.name + "", array4 = realNames[result2], length2 = hasOwnProperty.call(realNames, result2) ? array4.length : 0; length2--; ) {
          var data = array4[length2], otherFunc = data.func;
          if (otherFunc == null || otherFunc == func)
            return data.name;
        }
        return result2;
      }
      __name(getFuncName, "getFuncName");
      function getHolder(func) {
        var object4 = hasOwnProperty.call(lodash2, "placeholder") ? lodash2 : func;
        return object4.placeholder;
      }
      __name(getHolder, "getHolder");
      function getIteratee() {
        var result2 = lodash2.iteratee || iteratee;
        return result2 = result2 === iteratee ? baseIteratee : result2, arguments.length ? result2(arguments[0], arguments[1]) : result2;
      }
      __name(getIteratee, "getIteratee");
      function getMapData(map2, key) {
        var data = map2.__data__;
        return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
      }
      __name(getMapData, "getMapData");
      function getMatchData(object4) {
        for (var result2 = keys2(object4), length2 = result2.length; length2--; ) {
          var key = result2[length2], value = object4[key];
          result2[length2] = [key, value, isStrictComparable(value)];
        }
        return result2;
      }
      __name(getMatchData, "getMatchData");
      function getNative(object4, key) {
        var value = getValue2(object4, key);
        return baseIsNative(value) ? value : undefined$1;
      }
      __name(getNative, "getNative");
      function getRawTag(value) {
        var isOwn = hasOwnProperty.call(value, symToStringTag), tag = value[symToStringTag];
        try {
          value[symToStringTag] = undefined$1;
          var unmasked = !0;
        } catch {
        }
        var result2 = nativeObjectToString.call(value);
        return unmasked && (isOwn ? value[symToStringTag] = tag : delete value[symToStringTag]), result2;
      }
      __name(getRawTag, "getRawTag");
      var getSymbols = nativeGetSymbols ? function(object4) {
        return object4 == null ? [] : (object4 = Object2(object4), arrayFilter(nativeGetSymbols(object4), function(symbol) {
          return propertyIsEnumerable.call(object4, symbol);
        }));
      } : stubArray, getSymbolsIn = nativeGetSymbols ? function(object4) {
        for (var result2 = []; object4; )
          arrayPush(result2, getSymbols(object4)), object4 = getPrototype(object4);
        return result2;
      } : stubArray, getTag = baseGetTag;
      (DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag || Map2 && getTag(new Map2()) != mapTag || Promise2 && getTag(Promise2.resolve()) != promiseTag || Set2 && getTag(new Set2()) != setTag || WeakMap2 && getTag(new WeakMap2()) != weakMapTag) && (getTag = /* @__PURE__ */ __name(function(value) {
        var result2 = baseGetTag(value), Ctor = result2 == objectTag ? value.constructor : undefined$1, ctorString = Ctor ? toSource(Ctor) : "";
        if (ctorString)
          switch (ctorString) {
            case dataViewCtorString:
              return dataViewTag;
            case mapCtorString:
              return mapTag;
            case promiseCtorString:
              return promiseTag;
            case setCtorString:
              return setTag;
            case weakMapCtorString:
              return weakMapTag;
          }
        return result2;
      }, "getTag"));
      function getView(start, end, transforms) {
        for (var index2 = -1, length2 = transforms.length; ++index2 < length2; ) {
          var data = transforms[index2], size2 = data.size;
          switch (data.type) {
            case "drop":
              start += size2;
              break;
            case "dropRight":
              end -= size2;
              break;
            case "take":
              end = nativeMin(end, start + size2);
              break;
            case "takeRight":
              start = nativeMax(start, end - size2);
              break;
          }
        }
        return { start, end };
      }
      __name(getView, "getView");
      function getWrapDetails(source) {
        var match2 = source.match(reWrapDetails);
        return match2 ? match2[1].split(reSplitDetails) : [];
      }
      __name(getWrapDetails, "getWrapDetails");
      function hasPath(object4, path2, hasFunc) {
        path2 = castPath(path2, object4);
        for (var index2 = -1, length2 = path2.length, result2 = !1; ++index2 < length2; ) {
          var key = toKey(path2[index2]);
          if (!(result2 = object4 != null && hasFunc(object4, key)))
            break;
          object4 = object4[key];
        }
        return result2 || ++index2 != length2 ? result2 : (length2 = object4 == null ? 0 : object4.length, !!length2 && isLength(length2) && isIndex(key, length2) && (isArray(object4) || isArguments(object4)));
      }
      __name(hasPath, "hasPath");
      function initCloneArray(array4) {
        var length2 = array4.length, result2 = new array4.constructor(length2);
        return length2 && typeof array4[0] == "string" && hasOwnProperty.call(array4, "index") && (result2.index = array4.index, result2.input = array4.input), result2;
      }
      __name(initCloneArray, "initCloneArray");
      function initCloneObject(object4) {
        return typeof object4.constructor == "function" && !isPrototype(object4) ? baseCreate(getPrototype(object4)) : {};
      }
      __name(initCloneObject, "initCloneObject");
      function initCloneByTag(object4, tag, isDeep) {
        var Ctor = object4.constructor;
        switch (tag) {
          case arrayBufferTag:
            return cloneArrayBuffer(object4);
          case boolTag:
          case dateTag:
            return new Ctor(+object4);
          case dataViewTag:
            return cloneDataView(object4, isDeep);
          case float32Tag:
          case float64Tag:
          case int8Tag:
          case int16Tag:
          case int32Tag:
          case uint8Tag:
          case uint8ClampedTag:
          case uint16Tag:
          case uint32Tag:
            return cloneTypedArray(object4, isDeep);
          case mapTag:
            return new Ctor();
          case numberTag:
          case stringTag:
            return new Ctor(object4);
          case regexpTag:
            return cloneRegExp(object4);
          case setTag:
            return new Ctor();
          case symbolTag:
            return cloneSymbol(object4);
        }
      }
      __name(initCloneByTag, "initCloneByTag");
      function insertWrapDetails(source, details) {
        var length2 = details.length;
        if (!length2)
          return source;
        var lastIndex = length2 - 1;
        return details[lastIndex] = (length2 > 1 ? "& " : "") + details[lastIndex], details = details.join(length2 > 2 ? ", " : " "), source.replace(reWrapComment, `{
/* [wrapped with ` + details + `] */
`);
      }
      __name(insertWrapDetails, "insertWrapDetails");
      function isFlattenable(value) {
        return isArray(value) || isArguments(value) || !!(spreadableSymbol && value && value[spreadableSymbol]);
      }
      __name(isFlattenable, "isFlattenable");
      function isIndex(value, length2) {
        var type4 = typeof value;
        return length2 = length2 ?? MAX_SAFE_INTEGER, !!length2 && (type4 == "number" || type4 != "symbol" && reIsUint.test(value)) && value > -1 && value % 1 == 0 && value < length2;
      }
      __name(isIndex, "isIndex");
      function isIterateeCall(value, index2, object4) {
        if (!isObject2(object4))
          return !1;
        var type4 = typeof index2;
        return (type4 == "number" ? isArrayLike(object4) && isIndex(index2, object4.length) : type4 == "string" && index2 in object4) ? eq(object4[index2], value) : !1;
      }
      __name(isIterateeCall, "isIterateeCall");
      function isKey(value, object4) {
        if (isArray(value))
          return !1;
        var type4 = typeof value;
        return type4 == "number" || type4 == "symbol" || type4 == "boolean" || value == null || isSymbol(value) ? !0 : reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object4 != null && value in Object2(object4);
      }
      __name(isKey, "isKey");
      function isKeyable(value) {
        var type4 = typeof value;
        return type4 == "string" || type4 == "number" || type4 == "symbol" || type4 == "boolean" ? value !== "__proto__" : value === null;
      }
      __name(isKeyable, "isKeyable");
      function isLaziable(func) {
        var funcName = getFuncName(func), other = lodash2[funcName];
        if (typeof other != "function" || !(funcName in LazyWrapper.prototype))
          return !1;
        if (func === other)
          return !0;
        var data = getData(other);
        return !!data && func === data[0];
      }
      __name(isLaziable, "isLaziable");
      function isMasked(func) {
        return !!maskSrcKey && maskSrcKey in func;
      }
      __name(isMasked, "isMasked");
      var isMaskable = coreJsData ? isFunction : stubFalse;
      function isPrototype(value) {
        var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto;
        return value === proto;
      }
      __name(isPrototype, "isPrototype");
      function isStrictComparable(value) {
        return value === value && !isObject2(value);
      }
      __name(isStrictComparable, "isStrictComparable");
      function matchesStrictComparable(key, srcValue) {
        return function(object4) {
          return object4 == null ? !1 : object4[key] === srcValue && (srcValue !== undefined$1 || key in Object2(object4));
        };
      }
      __name(matchesStrictComparable, "matchesStrictComparable");
      function memoizeCapped(func) {
        var result2 = memoize(func, function(key) {
          return cache.size === MAX_MEMOIZE_SIZE && cache.clear(), key;
        }), cache = result2.cache;
        return result2;
      }
      __name(memoizeCapped, "memoizeCapped");
      function mergeData(data, source) {
        var bitmask = data[1], srcBitmask = source[1], newBitmask = bitmask | srcBitmask, isCommon = newBitmask < (WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG | WRAP_ARY_FLAG), isCombo = srcBitmask == WRAP_ARY_FLAG && bitmask == WRAP_CURRY_FLAG || srcBitmask == WRAP_ARY_FLAG && bitmask == WRAP_REARG_FLAG && data[7].length <= source[8] || srcBitmask == (WRAP_ARY_FLAG | WRAP_REARG_FLAG) && source[7].length <= source[8] && bitmask == WRAP_CURRY_FLAG;
        if (!(isCommon || isCombo))
          return data;
        srcBitmask & WRAP_BIND_FLAG && (data[2] = source[2], newBitmask |= bitmask & WRAP_BIND_FLAG ? 0 : WRAP_CURRY_BOUND_FLAG);
        var value = source[3];
        if (value) {
          var partials = data[3];
          data[3] = partials ? composeArgs(partials, value, source[4]) : value, data[4] = partials ? replaceHolders(data[3], PLACEHOLDER) : source[4];
        }
        return value = source[5], value && (partials = data[5], data[5] = partials ? composeArgsRight(partials, value, source[6]) : value, data[6] = partials ? replaceHolders(data[5], PLACEHOLDER) : source[6]), value = source[7], value && (data[7] = value), srcBitmask & WRAP_ARY_FLAG && (data[8] = data[8] == null ? source[8] : nativeMin(data[8], source[8])), data[9] == null && (data[9] = source[9]), data[0] = source[0], data[1] = newBitmask, data;
      }
      __name(mergeData, "mergeData");
      function nativeKeysIn(object4) {
        var result2 = [];
        if (object4 != null)
          for (var key in Object2(object4))
            result2.push(key);
        return result2;
      }
      __name(nativeKeysIn, "nativeKeysIn");
      function objectToString(value) {
        return nativeObjectToString.call(value);
      }
      __name(objectToString, "objectToString");
      function overRest(func, start, transform2) {
        return start = nativeMax(start === undefined$1 ? func.length - 1 : start, 0), function() {
          for (var args = arguments, index2 = -1, length2 = nativeMax(args.length - start, 0), array4 = Array2(length2); ++index2 < length2; )
            array4[index2] = args[start + index2];
          index2 = -1;
          for (var otherArgs = Array2(start + 1); ++index2 < start; )
            otherArgs[index2] = args[index2];
          return otherArgs[start] = transform2(array4), apply(func, this, otherArgs);
        };
      }
      __name(overRest, "overRest");
      function parent(object4, path2) {
        return path2.length < 2 ? object4 : baseGet(object4, baseSlice(path2, 0, -1));
      }
      __name(parent, "parent");
      function reorder(array4, indexes) {
        for (var arrLength = array4.length, length2 = nativeMin(indexes.length, arrLength), oldArray = copyArray(array4); length2--; ) {
          var index2 = indexes[length2];
          array4[length2] = isIndex(index2, arrLength) ? oldArray[index2] : undefined$1;
        }
        return array4;
      }
      __name(reorder, "reorder");
      function safeGet(object4, key) {
        if (!(key === "constructor" && typeof object4[key] == "function") && key != "__proto__")
          return object4[key];
      }
      __name(safeGet, "safeGet");
      var setData = shortOut(baseSetData), setTimeout2 = ctxSetTimeout || function(func, wait) {
        return root.setTimeout(func, wait);
      }, setToString = shortOut(baseSetToString);
      function setWrapToString(wrapper, reference, bitmask) {
        var source = reference + "";
        return setToString(wrapper, insertWrapDetails(source, updateWrapDetails(getWrapDetails(source), bitmask)));
      }
      __name(setWrapToString, "setWrapToString");
      function shortOut(func) {
        var count = 0, lastCalled = 0;
        return function() {
          var stamp = nativeNow(), remaining = HOT_SPAN - (stamp - lastCalled);
          if (lastCalled = stamp, remaining > 0) {
            if (++count >= HOT_COUNT)
              return arguments[0];
          } else
            count = 0;
          return func.apply(undefined$1, arguments);
        };
      }
      __name(shortOut, "shortOut");
      function shuffleSelf(array4, size2) {
        var index2 = -1, length2 = array4.length, lastIndex = length2 - 1;
        for (size2 = size2 === undefined$1 ? length2 : size2; ++index2 < size2; ) {
          var rand = baseRandom(index2, lastIndex), value = array4[rand];
          array4[rand] = array4[index2], array4[index2] = value;
        }
        return array4.length = size2, array4;
      }
      __name(shuffleSelf, "shuffleSelf");
      var stringToPath = memoizeCapped(function(string3) {
        var result2 = [];
        return string3.charCodeAt(0) === 46 && result2.push(""), string3.replace(rePropName, function(match2, number4, quote, subString) {
          result2.push(quote ? subString.replace(reEscapeChar, "$1") : number4 || match2);
        }), result2;
      });
      function toKey(value) {
        if (typeof value == "string" || isSymbol(value))
          return value;
        var result2 = value + "";
        return result2 == "0" && 1 / value == -1 / 0 ? "-0" : result2;
      }
      __name(toKey, "toKey");
      function toSource(func) {
        if (func != null) {
          try {
            return funcToString.call(func);
          } catch {
          }
          try {
            return func + "";
          } catch {
          }
        }
        return "";
      }
      __name(toSource, "toSource");
      function updateWrapDetails(details, bitmask) {
        return arrayEach(wrapFlags, function(pair) {
          var value = "_." + pair[0];
          bitmask & pair[1] && !arrayIncludes(details, value) && details.push(value);
        }), details.sort();
      }
      __name(updateWrapDetails, "updateWrapDetails");
      function wrapperClone(wrapper) {
        if (wrapper instanceof LazyWrapper)
          return wrapper.clone();
        var result2 = new LodashWrapper(wrapper.__wrapped__, wrapper.__chain__);
        return result2.__actions__ = copyArray(wrapper.__actions__), result2.__index__ = wrapper.__index__, result2.__values__ = wrapper.__values__, result2;
      }
      __name(wrapperClone, "wrapperClone");
      function chunk(array4, size2, guard) {
        (guard ? isIterateeCall(array4, size2, guard) : size2 === undefined$1) ? size2 = 1 : size2 = nativeMax(toInteger(size2), 0);
        var length2 = array4 == null ? 0 : array4.length;
        if (!length2 || size2 < 1)
          return [];
        for (var index2 = 0, resIndex = 0, result2 = Array2(nativeCeil(length2 / size2)); index2 < length2; )
          result2[resIndex++] = baseSlice(array4, index2, index2 += size2);
        return result2;
      }
      __name(chunk, "chunk");
      function compact(array4) {
        for (var index2 = -1, length2 = array4 == null ? 0 : array4.length, resIndex = 0, result2 = []; ++index2 < length2; ) {
          var value = array4[index2];
          value && (result2[resIndex++] = value);
        }
        return result2;
      }
      __name(compact, "compact");
      function concat() {
        var length2 = arguments.length;
        if (!length2)
          return [];
        for (var args = Array2(length2 - 1), array4 = arguments[0], index2 = length2; index2--; )
          args[index2 - 1] = arguments[index2];
        return arrayPush(isArray(array4) ? copyArray(array4) : [array4], baseFlatten(args, 1));
      }
      __name(concat, "concat");
      var difference = baseRest(function(array4, values2) {
        return isArrayLikeObject(array4) ? baseDifference(array4, baseFlatten(values2, 1, isArrayLikeObject, !0)) : [];
      }), differenceBy = baseRest(function(array4, values2) {
        var iteratee2 = last(values2);
        return isArrayLikeObject(iteratee2) && (iteratee2 = undefined$1), isArrayLikeObject(array4) ? baseDifference(array4, baseFlatten(values2, 1, isArrayLikeObject, !0), getIteratee(iteratee2, 2)) : [];
      }), differenceWith = baseRest(function(array4, values2) {
        var comparator = last(values2);
        return isArrayLikeObject(comparator) && (comparator = undefined$1), isArrayLikeObject(array4) ? baseDifference(array4, baseFlatten(values2, 1, isArrayLikeObject, !0), undefined$1, comparator) : [];
      });
      function drop(array4, n2, guard) {
        var length2 = array4 == null ? 0 : array4.length;
        return length2 ? (n2 = guard || n2 === undefined$1 ? 1 : toInteger(n2), baseSlice(array4, n2 < 0 ? 0 : n2, length2)) : [];
      }
      __name(drop, "drop");
      function dropRight(array4, n2, guard) {
        var length2 = array4 == null ? 0 : array4.length;
        return length2 ? (n2 = guard || n2 === undefined$1 ? 1 : toInteger(n2), n2 = length2 - n2, baseSlice(array4, 0, n2 < 0 ? 0 : n2)) : [];
      }
      __name(dropRight, "dropRight");
      function dropRightWhile(array4, predicate) {
        return array4 && array4.length ? baseWhile(array4, getIteratee(predicate, 3), !0, !0) : [];
      }
      __name(dropRightWhile, "dropRightWhile");
      function dropWhile(array4, predicate) {
        return array4 && array4.length ? baseWhile(array4, getIteratee(predicate, 3), !0) : [];
      }
      __name(dropWhile, "dropWhile");
      function fill(array4, value, start, end) {
        var length2 = array4 == null ? 0 : array4.length;
        return length2 ? (start && typeof start != "number" && isIterateeCall(array4, value, start) && (start = 0, end = length2), baseFill(array4, value, start, end)) : [];
      }
      __name(fill, "fill");
      function findIndex(array4, predicate, fromIndex) {
        var length2 = array4 == null ? 0 : array4.length;
        if (!length2)
          return -1;
        var index2 = fromIndex == null ? 0 : toInteger(fromIndex);
        return index2 < 0 && (index2 = nativeMax(length2 + index2, 0)), baseFindIndex(array4, getIteratee(predicate, 3), index2);
      }
      __name(findIndex, "findIndex");
      function findLastIndex(array4, predicate, fromIndex) {
        var length2 = array4 == null ? 0 : array4.length;
        if (!length2)
          return -1;
        var index2 = length2 - 1;
        return fromIndex !== undefined$1 && (index2 = toInteger(fromIndex), index2 = fromIndex < 0 ? nativeMax(length2 + index2, 0) : nativeMin(index2, length2 - 1)), baseFindIndex(array4, getIteratee(predicate, 3), index2, !0);
      }
      __name(findLastIndex, "findLastIndex");
      function flatten(array4) {
        var length2 = array4 == null ? 0 : array4.length;
        return length2 ? baseFlatten(array4, 1) : [];
      }
      __name(flatten, "flatten");
      function flattenDeep(array4) {
        var length2 = array4 == null ? 0 : array4.length;
        return length2 ? baseFlatten(array4, INFINITY) : [];
      }
      __name(flattenDeep, "flattenDeep");
      function flattenDepth(array4, depth) {
        var length2 = array4 == null ? 0 : array4.length;
        return length2 ? (depth = depth === undefined$1 ? 1 : toInteger(depth), baseFlatten(array4, depth)) : [];
      }
      __name(flattenDepth, "flattenDepth");
      function fromPairs(pairs) {
        for (var index2 = -1, length2 = pairs == null ? 0 : pairs.length, result2 = {}; ++index2 < length2; ) {
          var pair = pairs[index2];
          result2[pair[0]] = pair[1];
        }
        return result2;
      }
      __name(fromPairs, "fromPairs");
      function head(array4) {
        return array4 && array4.length ? array4[0] : undefined$1;
      }
      __name(head, "head");
      function indexOf(array4, value, fromIndex) {
        var length2 = array4 == null ? 0 : array4.length;
        if (!length2)
          return -1;
        var index2 = fromIndex == null ? 0 : toInteger(fromIndex);
        return index2 < 0 && (index2 = nativeMax(length2 + index2, 0)), baseIndexOf(array4, value, index2);
      }
      __name(indexOf, "indexOf");
      function initial(array4) {
        var length2 = array4 == null ? 0 : array4.length;
        return length2 ? baseSlice(array4, 0, -1) : [];
      }
      __name(initial, "initial");
      var intersection = baseRest(function(arrays) {
        var mapped = arrayMap(arrays, castArrayLikeObject);
        return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped) : [];
      }), intersectionBy = baseRest(function(arrays) {
        var iteratee2 = last(arrays), mapped = arrayMap(arrays, castArrayLikeObject);
        return iteratee2 === last(mapped) ? iteratee2 = undefined$1 : mapped.pop(), mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped, getIteratee(iteratee2, 2)) : [];
      }), intersectionWith = baseRest(function(arrays) {
        var comparator = last(arrays), mapped = arrayMap(arrays, castArrayLikeObject);
        return comparator = typeof comparator == "function" ? comparator : undefined$1, comparator && mapped.pop(), mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped, undefined$1, comparator) : [];
      });
      function join(array4, separator) {
        return array4 == null ? "" : nativeJoin.call(array4, separator);
      }
      __name(join, "join");
      function last(array4) {
        var length2 = array4 == null ? 0 : array4.length;
        return length2 ? array4[length2 - 1] : undefined$1;
      }
      __name(last, "last");
      function lastIndexOf(array4, value, fromIndex) {
        var length2 = array4 == null ? 0 : array4.length;
        if (!length2)
          return -1;
        var index2 = length2;
        return fromIndex !== undefined$1 && (index2 = toInteger(fromIndex), index2 = index2 < 0 ? nativeMax(length2 + index2, 0) : nativeMin(index2, length2 - 1)), value === value ? strictLastIndexOf(array4, value, index2) : baseFindIndex(array4, baseIsNaN, index2, !0);
      }
      __name(lastIndexOf, "lastIndexOf");
      function nth(array4, n2) {
        return array4 && array4.length ? baseNth(array4, toInteger(n2)) : undefined$1;
      }
      __name(nth, "nth");
      var pull = baseRest(pullAll);
      function pullAll(array4, values2) {
        return array4 && array4.length && values2 && values2.length ? basePullAll(array4, values2) : array4;
      }
      __name(pullAll, "pullAll");
      function pullAllBy(array4, values2, iteratee2) {
        return array4 && array4.length && values2 && values2.length ? basePullAll(array4, values2, getIteratee(iteratee2, 2)) : array4;
      }
      __name(pullAllBy, "pullAllBy");
      function pullAllWith(array4, values2, comparator) {
        return array4 && array4.length && values2 && values2.length ? basePullAll(array4, values2, undefined$1, comparator) : array4;
      }
      __name(pullAllWith, "pullAllWith");
      var pullAt = flatRest(function(array4, indexes) {
        var length2 = array4 == null ? 0 : array4.length, result2 = baseAt(array4, indexes);
        return basePullAt(array4, arrayMap(indexes, function(index2) {
          return isIndex(index2, length2) ? +index2 : index2;
        }).sort(compareAscending)), result2;
      });
      function remove(array4, predicate) {
        var result2 = [];
        if (!(array4 && array4.length))
          return result2;
        var index2 = -1, indexes = [], length2 = array4.length;
        for (predicate = getIteratee(predicate, 3); ++index2 < length2; ) {
          var value = array4[index2];
          predicate(value, index2, array4) && (result2.push(value), indexes.push(index2));
        }
        return basePullAt(array4, indexes), result2;
      }
      __name(remove, "remove");
      function reverse(array4) {
        return array4 == null ? array4 : nativeReverse.call(array4);
      }
      __name(reverse, "reverse");
      function slice2(array4, start, end) {
        var length2 = array4 == null ? 0 : array4.length;
        return length2 ? (end && typeof end != "number" && isIterateeCall(array4, start, end) ? (start = 0, end = length2) : (start = start == null ? 0 : toInteger(start), end = end === undefined$1 ? length2 : toInteger(end)), baseSlice(array4, start, end)) : [];
      }
      __name(slice2, "slice");
      function sortedIndex(array4, value) {
        return baseSortedIndex(array4, value);
      }
      __name(sortedIndex, "sortedIndex");
      function sortedIndexBy(array4, value, iteratee2) {
        return baseSortedIndexBy(array4, value, getIteratee(iteratee2, 2));
      }
      __name(sortedIndexBy, "sortedIndexBy");
      function sortedIndexOf(array4, value) {
        var length2 = array4 == null ? 0 : array4.length;
        if (length2) {
          var index2 = baseSortedIndex(array4, value);
          if (index2 < length2 && eq(array4[index2], value))
            return index2;
        }
        return -1;
      }
      __name(sortedIndexOf, "sortedIndexOf");
      function sortedLastIndex(array4, value) {
        return baseSortedIndex(array4, value, !0);
      }
      __name(sortedLastIndex, "sortedLastIndex");
      function sortedLastIndexBy(array4, value, iteratee2) {
        return baseSortedIndexBy(array4, value, getIteratee(iteratee2, 2), !0);
      }
      __name(sortedLastIndexBy, "sortedLastIndexBy");
      function sortedLastIndexOf(array4, value) {
        var length2 = array4 == null ? 0 : array4.length;
        if (length2) {
          var index2 = baseSortedIndex(array4, value, !0) - 1;
          if (eq(array4[index2], value))
            return index2;
        }
        return -1;
      }
      __name(sortedLastIndexOf, "sortedLastIndexOf");
      function sortedUniq(array4) {
        return array4 && array4.length ? baseSortedUniq(array4) : [];
      }
      __name(sortedUniq, "sortedUniq");
      function sortedUniqBy(array4, iteratee2) {
        return array4 && array4.length ? baseSortedUniq(array4, getIteratee(iteratee2, 2)) : [];
      }
      __name(sortedUniqBy, "sortedUniqBy");
      function tail(array4) {
        var length2 = array4 == null ? 0 : array4.length;
        return length2 ? baseSlice(array4, 1, length2) : [];
      }
      __name(tail, "tail");
      function take(array4, n2, guard) {
        return array4 && array4.length ? (n2 = guard || n2 === undefined$1 ? 1 : toInteger(n2), baseSlice(array4, 0, n2 < 0 ? 0 : n2)) : [];
      }
      __name(take, "take");
      function takeRight(array4, n2, guard) {
        var length2 = array4 == null ? 0 : array4.length;
        return length2 ? (n2 = guard || n2 === undefined$1 ? 1 : toInteger(n2), n2 = length2 - n2, baseSlice(array4, n2 < 0 ? 0 : n2, length2)) : [];
      }
      __name(takeRight, "takeRight");
      function takeRightWhile(array4, predicate) {
        return array4 && array4.length ? baseWhile(array4, getIteratee(predicate, 3), !1, !0) : [];
      }
      __name(takeRightWhile, "takeRightWhile");
      function takeWhile(array4, predicate) {
        return array4 && array4.length ? baseWhile(array4, getIteratee(predicate, 3)) : [];
      }
      __name(takeWhile, "takeWhile");
      var union = baseRest(function(arrays) {
        return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, !0));
      }), unionBy = baseRest(function(arrays) {
        var iteratee2 = last(arrays);
        return isArrayLikeObject(iteratee2) && (iteratee2 = undefined$1), baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, !0), getIteratee(iteratee2, 2));
      }), unionWith = baseRest(function(arrays) {
        var comparator = last(arrays);
        return comparator = typeof comparator == "function" ? comparator : undefined$1, baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, !0), undefined$1, comparator);
      });
      function uniq(array4) {
        return array4 && array4.length ? baseUniq(array4) : [];
      }
      __name(uniq, "uniq");
      function uniqBy(array4, iteratee2) {
        return array4 && array4.length ? baseUniq(array4, getIteratee(iteratee2, 2)) : [];
      }
      __name(uniqBy, "uniqBy");
      function uniqWith(array4, comparator) {
        return comparator = typeof comparator == "function" ? comparator : undefined$1, array4 && array4.length ? baseUniq(array4, undefined$1, comparator) : [];
      }
      __name(uniqWith, "uniqWith");
      function unzip(array4) {
        if (!(array4 && array4.length))
          return [];
        var length2 = 0;
        return array4 = arrayFilter(array4, function(group) {
          if (isArrayLikeObject(group))
            return length2 = nativeMax(group.length, length2), !0;
        }), baseTimes(length2, function(index2) {
          return arrayMap(array4, baseProperty(index2));
        });
      }
      __name(unzip, "unzip");
      function unzipWith(array4, iteratee2) {
        if (!(array4 && array4.length))
          return [];
        var result2 = unzip(array4);
        return iteratee2 == null ? result2 : arrayMap(result2, function(group) {
          return apply(iteratee2, undefined$1, group);
        });
      }
      __name(unzipWith, "unzipWith");
      var without = baseRest(function(array4, values2) {
        return isArrayLikeObject(array4) ? baseDifference(array4, values2) : [];
      }), xor = baseRest(function(arrays) {
        return baseXor(arrayFilter(arrays, isArrayLikeObject));
      }), xorBy = baseRest(function(arrays) {
        var iteratee2 = last(arrays);
        return isArrayLikeObject(iteratee2) && (iteratee2 = undefined$1), baseXor(arrayFilter(arrays, isArrayLikeObject), getIteratee(iteratee2, 2));
      }), xorWith = baseRest(function(arrays) {
        var comparator = last(arrays);
        return comparator = typeof comparator == "function" ? comparator : undefined$1, baseXor(arrayFilter(arrays, isArrayLikeObject), undefined$1, comparator);
      }), zip = baseRest(unzip);
      function zipObject(props, values2) {
        return baseZipObject(props || [], values2 || [], assignValue);
      }
      __name(zipObject, "zipObject");
      function zipObjectDeep(props, values2) {
        return baseZipObject(props || [], values2 || [], baseSet);
      }
      __name(zipObjectDeep, "zipObjectDeep");
      var zipWith = baseRest(function(arrays) {
        var length2 = arrays.length, iteratee2 = length2 > 1 ? arrays[length2 - 1] : undefined$1;
        return iteratee2 = typeof iteratee2 == "function" ? (arrays.pop(), iteratee2) : undefined$1, unzipWith(arrays, iteratee2);
      });
      function chain(value) {
        var result2 = lodash2(value);
        return result2.__chain__ = !0, result2;
      }
      __name(chain, "chain");
      function tap(value, interceptor) {
        return interceptor(value), value;
      }
      __name(tap, "tap");
      function thru(value, interceptor) {
        return interceptor(value);
      }
      __name(thru, "thru");
      var wrapperAt = flatRest(function(paths) {
        var length2 = paths.length, start = length2 ? paths[0] : 0, value = this.__wrapped__, interceptor = /* @__PURE__ */ __name(function(object4) {
          return baseAt(object4, paths);
        }, "interceptor");
        return length2 > 1 || this.__actions__.length || !(value instanceof LazyWrapper) || !isIndex(start) ? this.thru(interceptor) : (value = value.slice(start, +start + (length2 ? 1 : 0)), value.__actions__.push({
          func: thru,
          args: [interceptor],
          thisArg: undefined$1
        }), new LodashWrapper(value, this.__chain__).thru(function(array4) {
          return length2 && !array4.length && array4.push(undefined$1), array4;
        }));
      });
      function wrapperChain() {
        return chain(this);
      }
      __name(wrapperChain, "wrapperChain");
      function wrapperCommit() {
        return new LodashWrapper(this.value(), this.__chain__);
      }
      __name(wrapperCommit, "wrapperCommit");
      function wrapperNext() {
        this.__values__ === undefined$1 && (this.__values__ = toArray2(this.value()));
        var done = this.__index__ >= this.__values__.length, value = done ? undefined$1 : this.__values__[this.__index__++];
        return { done, value };
      }
      __name(wrapperNext, "wrapperNext");
      function wrapperToIterator() {
        return this;
      }
      __name(wrapperToIterator, "wrapperToIterator");
      function wrapperPlant(value) {
        for (var result2, parent2 = this; parent2 instanceof baseLodash; ) {
          var clone2 = wrapperClone(parent2);
          clone2.__index__ = 0, clone2.__values__ = undefined$1, result2 ? previous.__wrapped__ = clone2 : result2 = clone2;
          var previous = clone2;
          parent2 = parent2.__wrapped__;
        }
        return previous.__wrapped__ = value, result2;
      }
      __name(wrapperPlant, "wrapperPlant");
      function wrapperReverse() {
        var value = this.__wrapped__;
        if (value instanceof LazyWrapper) {
          var wrapped = value;
          return this.__actions__.length && (wrapped = new LazyWrapper(this)), wrapped = wrapped.reverse(), wrapped.__actions__.push({
            func: thru,
            args: [reverse],
            thisArg: undefined$1
          }), new LodashWrapper(wrapped, this.__chain__);
        }
        return this.thru(reverse);
      }
      __name(wrapperReverse, "wrapperReverse");
      function wrapperValue() {
        return baseWrapperValue(this.__wrapped__, this.__actions__);
      }
      __name(wrapperValue, "wrapperValue");
      var countBy = createAggregator(function(result2, value, key) {
        hasOwnProperty.call(result2, key) ? ++result2[key] : baseAssignValue(result2, key, 1);
      });
      function every(collection, predicate, guard) {
        var func = isArray(collection) ? arrayEvery : baseEvery;
        return guard && isIterateeCall(collection, predicate, guard) && (predicate = undefined$1), func(collection, getIteratee(predicate, 3));
      }
      __name(every, "every");
      function filter2(collection, predicate) {
        var func = isArray(collection) ? arrayFilter : baseFilter;
        return func(collection, getIteratee(predicate, 3));
      }
      __name(filter2, "filter");
      var find = createFind(findIndex), findLast = createFind(findLastIndex);
      function flatMap(collection, iteratee2) {
        return baseFlatten(map(collection, iteratee2), 1);
      }
      __name(flatMap, "flatMap");
      function flatMapDeep(collection, iteratee2) {
        return baseFlatten(map(collection, iteratee2), INFINITY);
      }
      __name(flatMapDeep, "flatMapDeep");
      function flatMapDepth(collection, iteratee2, depth) {
        return depth = depth === undefined$1 ? 1 : toInteger(depth), baseFlatten(map(collection, iteratee2), depth);
      }
      __name(flatMapDepth, "flatMapDepth");
      function forEach2(collection, iteratee2) {
        var func = isArray(collection) ? arrayEach : baseEach;
        return func(collection, getIteratee(iteratee2, 3));
      }
      __name(forEach2, "forEach");
      function forEachRight(collection, iteratee2) {
        var func = isArray(collection) ? arrayEachRight : baseEachRight;
        return func(collection, getIteratee(iteratee2, 3));
      }
      __name(forEachRight, "forEachRight");
      var groupBy = createAggregator(function(result2, value, key) {
        hasOwnProperty.call(result2, key) ? result2[key].push(value) : baseAssignValue(result2, key, [value]);
      });
      function includes2(collection, value, fromIndex, guard) {
        collection = isArrayLike(collection) ? collection : values(collection), fromIndex = fromIndex && !guard ? toInteger(fromIndex) : 0;
        var length2 = collection.length;
        return fromIndex < 0 && (fromIndex = nativeMax(length2 + fromIndex, 0)), isString2(collection) ? fromIndex <= length2 && collection.indexOf(value, fromIndex) > -1 : !!length2 && baseIndexOf(collection, value, fromIndex) > -1;
      }
      __name(includes2, "includes");
      var invokeMap = baseRest(function(collection, path2, args) {
        var index2 = -1, isFunc = typeof path2 == "function", result2 = isArrayLike(collection) ? Array2(collection.length) : [];
        return baseEach(collection, function(value) {
          result2[++index2] = isFunc ? apply(path2, value, args) : baseInvoke(value, path2, args);
        }), result2;
      }), keyBy = createAggregator(function(result2, value, key) {
        baseAssignValue(result2, key, value);
      });
      function map(collection, iteratee2) {
        var func = isArray(collection) ? arrayMap : baseMap;
        return func(collection, getIteratee(iteratee2, 3));
      }
      __name(map, "map");
      function orderBy(collection, iteratees, orders, guard) {
        return collection == null ? [] : (isArray(iteratees) || (iteratees = iteratees == null ? [] : [iteratees]), orders = guard ? undefined$1 : orders, isArray(orders) || (orders = orders == null ? [] : [orders]), baseOrderBy(collection, iteratees, orders));
      }
      __name(orderBy, "orderBy");
      var partition = createAggregator(function(result2, value, key) {
        result2[key ? 0 : 1].push(value);
      }, function() {
        return [[], []];
      });
      function reduce(collection, iteratee2, accumulator) {
        var func = isArray(collection) ? arrayReduce : baseReduce, initAccum = arguments.length < 3;
        return func(collection, getIteratee(iteratee2, 4), accumulator, initAccum, baseEach);
      }
      __name(reduce, "reduce");
      function reduceRight(collection, iteratee2, accumulator) {
        var func = isArray(collection) ? arrayReduceRight : baseReduce, initAccum = arguments.length < 3;
        return func(collection, getIteratee(iteratee2, 4), accumulator, initAccum, baseEachRight);
      }
      __name(reduceRight, "reduceRight");
      function reject(collection, predicate) {
        var func = isArray(collection) ? arrayFilter : baseFilter;
        return func(collection, negate(getIteratee(predicate, 3)));
      }
      __name(reject, "reject");
      function sample(collection) {
        var func = isArray(collection) ? arraySample : baseSample;
        return func(collection);
      }
      __name(sample, "sample");
      function sampleSize(collection, n2, guard) {
        (guard ? isIterateeCall(collection, n2, guard) : n2 === undefined$1) ? n2 = 1 : n2 = toInteger(n2);
        var func = isArray(collection) ? arraySampleSize : baseSampleSize;
        return func(collection, n2);
      }
      __name(sampleSize, "sampleSize");
      function shuffle(collection) {
        var func = isArray(collection) ? arrayShuffle : baseShuffle;
        return func(collection);
      }
      __name(shuffle, "shuffle");
      function size(collection) {
        if (collection == null)
          return 0;
        if (isArrayLike(collection))
          return isString2(collection) ? stringSize(collection) : collection.length;
        var tag = getTag(collection);
        return tag == mapTag || tag == setTag ? collection.size : baseKeys(collection).length;
      }
      __name(size, "size");
      function some(collection, predicate, guard) {
        var func = isArray(collection) ? arraySome : baseSome;
        return guard && isIterateeCall(collection, predicate, guard) && (predicate = undefined$1), func(collection, getIteratee(predicate, 3));
      }
      __name(some, "some");
      var sortBy = baseRest(function(collection, iteratees) {
        if (collection == null)
          return [];
        var length2 = iteratees.length;
        return length2 > 1 && isIterateeCall(collection, iteratees[0], iteratees[1]) ? iteratees = [] : length2 > 2 && isIterateeCall(iteratees[0], iteratees[1], iteratees[2]) && (iteratees = [iteratees[0]]), baseOrderBy(collection, baseFlatten(iteratees, 1), []);
      }), now2 = ctxNow || function() {
        return root.Date.now();
      };
      function after(n2, func) {
        if (typeof func != "function")
          throw new TypeError2(FUNC_ERROR_TEXT);
        return n2 = toInteger(n2), function() {
          if (--n2 < 1)
            return func.apply(this, arguments);
        };
      }
      __name(after, "after");
      function ary(func, n2, guard) {
        return n2 = guard ? undefined$1 : n2, n2 = func && n2 == null ? func.length : n2, createWrap(func, WRAP_ARY_FLAG, undefined$1, undefined$1, undefined$1, undefined$1, n2);
      }
      __name(ary, "ary");
      function before(n2, func) {
        var result2;
        if (typeof func != "function")
          throw new TypeError2(FUNC_ERROR_TEXT);
        return n2 = toInteger(n2), function() {
          return --n2 > 0 && (result2 = func.apply(this, arguments)), n2 <= 1 && (func = undefined$1), result2;
        };
      }
      __name(before, "before");
      var bind = baseRest(function(func, thisArg, partials) {
        var bitmask = WRAP_BIND_FLAG;
        if (partials.length) {
          var holders = replaceHolders(partials, getHolder(bind));
          bitmask |= WRAP_PARTIAL_FLAG;
        }
        return createWrap(func, bitmask, thisArg, partials, holders);
      }), bindKey = baseRest(function(object4, key, partials) {
        var bitmask = WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG;
        if (partials.length) {
          var holders = replaceHolders(partials, getHolder(bindKey));
          bitmask |= WRAP_PARTIAL_FLAG;
        }
        return createWrap(key, bitmask, object4, partials, holders);
      });
      function curry(func, arity, guard) {
        arity = guard ? undefined$1 : arity;
        var result2 = createWrap(func, WRAP_CURRY_FLAG, undefined$1, undefined$1, undefined$1, undefined$1, undefined$1, arity);
        return result2.placeholder = curry.placeholder, result2;
      }
      __name(curry, "curry");
      function curryRight(func, arity, guard) {
        arity = guard ? undefined$1 : arity;
        var result2 = createWrap(func, WRAP_CURRY_RIGHT_FLAG, undefined$1, undefined$1, undefined$1, undefined$1, undefined$1, arity);
        return result2.placeholder = curryRight.placeholder, result2;
      }
      __name(curryRight, "curryRight");
      function debounce2(func, wait, options) {
        var lastArgs, lastThis, maxWait, result2, timerId, lastCallTime, lastInvokeTime = 0, leading = !1, maxing = !1, trailing = !0;
        if (typeof func != "function")
          throw new TypeError2(FUNC_ERROR_TEXT);
        wait = toNumber(wait) || 0, isObject2(options) && (leading = !!options.leading, maxing = "maxWait" in options, maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait, trailing = "trailing" in options ? !!options.trailing : trailing);
        function invokeFunc(time) {
          var args = lastArgs, thisArg = lastThis;
          return lastArgs = lastThis = undefined$1, lastInvokeTime = time, result2 = func.apply(thisArg, args), result2;
        }
        __name(invokeFunc, "invokeFunc");
        function leadingEdge(time) {
          return lastInvokeTime = time, timerId = setTimeout2(timerExpired, wait), leading ? invokeFunc(time) : result2;
        }
        __name(leadingEdge, "leadingEdge");
        function remainingWait(time) {
          var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime, timeWaiting = wait - timeSinceLastCall;
          return maxing ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke) : timeWaiting;
        }
        __name(remainingWait, "remainingWait");
        function shouldInvoke(time) {
          var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime;
          return lastCallTime === undefined$1 || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
        }
        __name(shouldInvoke, "shouldInvoke");
        function timerExpired() {
          var time = now2();
          if (shouldInvoke(time))
            return trailingEdge(time);
          timerId = setTimeout2(timerExpired, remainingWait(time));
        }
        __name(timerExpired, "timerExpired");
        function trailingEdge(time) {
          return timerId = undefined$1, trailing && lastArgs ? invokeFunc(time) : (lastArgs = lastThis = undefined$1, result2);
        }
        __name(trailingEdge, "trailingEdge");
        function cancel() {
          timerId !== undefined$1 && clearTimeout2(timerId), lastInvokeTime = 0, lastArgs = lastCallTime = lastThis = timerId = undefined$1;
        }
        __name(cancel, "cancel");
        function flush() {
          return timerId === undefined$1 ? result2 : trailingEdge(now2());
        }
        __name(flush, "flush");
        function debounced() {
          var time = now2(), isInvoking = shouldInvoke(time);
          if (lastArgs = arguments, lastThis = this, lastCallTime = time, isInvoking) {
            if (timerId === undefined$1)
              return leadingEdge(lastCallTime);
            if (maxing)
              return clearTimeout2(timerId), timerId = setTimeout2(timerExpired, wait), invokeFunc(lastCallTime);
          }
          return timerId === undefined$1 && (timerId = setTimeout2(timerExpired, wait)), result2;
        }
        return __name(debounced, "debounced"), debounced.cancel = cancel, debounced.flush = flush, debounced;
      }
      __name(debounce2, "debounce");
      var defer2 = baseRest(function(func, args) {
        return baseDelay(func, 1, args);
      }), delay = baseRest(function(func, wait, args) {
        return baseDelay(func, toNumber(wait) || 0, args);
      });
      function flip(func) {
        return createWrap(func, WRAP_FLIP_FLAG);
      }
      __name(flip, "flip");
      function memoize(func, resolver) {
        if (typeof func != "function" || resolver != null && typeof resolver != "function")
          throw new TypeError2(FUNC_ERROR_TEXT);
        var memoized = /* @__PURE__ */ __name(function() {
          var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache = memoized.cache;
          if (cache.has(key))
            return cache.get(key);
          var result2 = func.apply(this, args);
          return memoized.cache = cache.set(key, result2) || cache, result2;
        }, "memoized");
        return memoized.cache = new (memoize.Cache || MapCache)(), memoized;
      }
      __name(memoize, "memoize"), memoize.Cache = MapCache;
      function negate(predicate) {
        if (typeof predicate != "function")
          throw new TypeError2(FUNC_ERROR_TEXT);
        return function() {
          var args = arguments;
          switch (args.length) {
            case 0:
              return !predicate.call(this);
            case 1:
              return !predicate.call(this, args[0]);
            case 2:
              return !predicate.call(this, args[0], args[1]);
            case 3:
              return !predicate.call(this, args[0], args[1], args[2]);
          }
          return !predicate.apply(this, args);
        };
      }
      __name(negate, "negate");
      function once(func) {
        return before(2, func);
      }
      __name(once, "once");
      var overArgs = castRest(function(func, transforms) {
        transforms = transforms.length == 1 && isArray(transforms[0]) ? arrayMap(transforms[0], baseUnary(getIteratee())) : arrayMap(baseFlatten(transforms, 1), baseUnary(getIteratee()));
        var funcsLength = transforms.length;
        return baseRest(function(args) {
          for (var index2 = -1, length2 = nativeMin(args.length, funcsLength); ++index2 < length2; )
            args[index2] = transforms[index2].call(this, args[index2]);
          return apply(func, this, args);
        });
      }), partial = baseRest(function(func, partials) {
        var holders = replaceHolders(partials, getHolder(partial));
        return createWrap(func, WRAP_PARTIAL_FLAG, undefined$1, partials, holders);
      }), partialRight = baseRest(function(func, partials) {
        var holders = replaceHolders(partials, getHolder(partialRight));
        return createWrap(func, WRAP_PARTIAL_RIGHT_FLAG, undefined$1, partials, holders);
      }), rearg = flatRest(function(func, indexes) {
        return createWrap(func, WRAP_REARG_FLAG, undefined$1, undefined$1, undefined$1, indexes);
      });
      function rest(func, start) {
        if (typeof func != "function")
          throw new TypeError2(FUNC_ERROR_TEXT);
        return start = start === undefined$1 ? start : toInteger(start), baseRest(func, start);
      }
      __name(rest, "rest");
      function spread(func, start) {
        if (typeof func != "function")
          throw new TypeError2(FUNC_ERROR_TEXT);
        return start = start == null ? 0 : nativeMax(toInteger(start), 0), baseRest(function(args) {
          var array4 = args[start], otherArgs = castSlice(args, 0, start);
          return array4 && arrayPush(otherArgs, array4), apply(func, this, otherArgs);
        });
      }
      __name(spread, "spread");
      function throttle2(func, wait, options) {
        var leading = !0, trailing = !0;
        if (typeof func != "function")
          throw new TypeError2(FUNC_ERROR_TEXT);
        return isObject2(options) && (leading = "leading" in options ? !!options.leading : leading, trailing = "trailing" in options ? !!options.trailing : trailing), debounce2(func, wait, {
          leading,
          maxWait: wait,
          trailing
        });
      }
      __name(throttle2, "throttle");
      function unary(func) {
        return ary(func, 1);
      }
      __name(unary, "unary");
      function wrap(value, wrapper) {
        return partial(castFunction(wrapper), value);
      }
      __name(wrap, "wrap");
      function castArray() {
        if (!arguments.length)
          return [];
        var value = arguments[0];
        return isArray(value) ? value : [value];
      }
      __name(castArray, "castArray");
      function clone(value) {
        return baseClone(value, CLONE_SYMBOLS_FLAG);
      }
      __name(clone, "clone");
      function cloneWith(value, customizer) {
        return customizer = typeof customizer == "function" ? customizer : undefined$1, baseClone(value, CLONE_SYMBOLS_FLAG, customizer);
      }
      __name(cloneWith, "cloneWith");
      function cloneDeep(value) {
        return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG);
      }
      __name(cloneDeep, "cloneDeep");
      function cloneDeepWith(value, customizer) {
        return customizer = typeof customizer == "function" ? customizer : undefined$1, baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG, customizer);
      }
      __name(cloneDeepWith, "cloneDeepWith");
      function conformsTo(object4, source) {
        return source == null || baseConformsTo(object4, source, keys2(source));
      }
      __name(conformsTo, "conformsTo");
      function eq(value, other) {
        return value === other || value !== value && other !== other;
      }
      __name(eq, "eq");
      var gt = createRelationalOperation(baseGt), gte = createRelationalOperation(function(value, other) {
        return value >= other;
      }), isArguments = baseIsArguments(/* @__PURE__ */ function() {
        return arguments;
      }()) ? baseIsArguments : function(value) {
        return isObjectLike(value) && hasOwnProperty.call(value, "callee") && !propertyIsEnumerable.call(value, "callee");
      }, isArray = Array2.isArray, isArrayBuffer = nodeIsArrayBuffer ? baseUnary(nodeIsArrayBuffer) : baseIsArrayBuffer;
      function isArrayLike(value) {
        return value != null && isLength(value.length) && !isFunction(value);
      }
      __name(isArrayLike, "isArrayLike");
      function isArrayLikeObject(value) {
        return isObjectLike(value) && isArrayLike(value);
      }
      __name(isArrayLikeObject, "isArrayLikeObject");
      function isBoolean(value) {
        return value === !0 || value === !1 || isObjectLike(value) && baseGetTag(value) == boolTag;
      }
      __name(isBoolean, "isBoolean");
      var isBuffer = nativeIsBuffer || stubFalse, isDate = nodeIsDate ? baseUnary(nodeIsDate) : baseIsDate;
      function isElement(value) {
        return isObjectLike(value) && value.nodeType === 1 && !isPlainObject(value);
      }
      __name(isElement, "isElement");
      function isEmpty2(value) {
        if (value == null)
          return !0;
        if (isArrayLike(value) && (isArray(value) || typeof value == "string" || typeof value.splice == "function" || isBuffer(value) || isTypedArray(value) || isArguments(value)))
          return !value.length;
        var tag = getTag(value);
        if (tag == mapTag || tag == setTag)
          return !value.size;
        if (isPrototype(value))
          return !baseKeys(value).length;
        for (var key in value)
          if (hasOwnProperty.call(value, key))
            return !1;
        return !0;
      }
      __name(isEmpty2, "isEmpty");
      function isEqual2(value, other) {
        return baseIsEqual(value, other);
      }
      __name(isEqual2, "isEqual");
      function isEqualWith(value, other, customizer) {
        customizer = typeof customizer == "function" ? customizer : undefined$1;
        var result2 = customizer ? customizer(value, other) : undefined$1;
        return result2 === undefined$1 ? baseIsEqual(value, other, undefined$1, customizer) : !!result2;
      }
      __name(isEqualWith, "isEqualWith");
      function isError(value) {
        if (!isObjectLike(value))
          return !1;
        var tag = baseGetTag(value);
        return tag == errorTag || tag == domExcTag || typeof value.message == "string" && typeof value.name == "string" && !isPlainObject(value);
      }
      __name(isError, "isError");
      function isFinite2(value) {
        return typeof value == "number" && nativeIsFinite(value);
      }
      __name(isFinite2, "isFinite");
      function isFunction(value) {
        if (!isObject2(value))
          return !1;
        var tag = baseGetTag(value);
        return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
      }
      __name(isFunction, "isFunction");
      function isInteger2(value) {
        return typeof value == "number" && value == toInteger(value);
      }
      __name(isInteger2, "isInteger");
      function isLength(value) {
        return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
      }
      __name(isLength, "isLength");
      function isObject2(value) {
        var type4 = typeof value;
        return value != null && (type4 == "object" || type4 == "function");
      }
      __name(isObject2, "isObject");
      function isObjectLike(value) {
        return value != null && typeof value == "object";
      }
      __name(isObjectLike, "isObjectLike");
      var isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;
      function isMatch(object4, source) {
        return object4 === source || baseIsMatch(object4, source, getMatchData(source));
      }
      __name(isMatch, "isMatch");
      function isMatchWith(object4, source, customizer) {
        return customizer = typeof customizer == "function" ? customizer : undefined$1, baseIsMatch(object4, source, getMatchData(source), customizer);
      }
      __name(isMatchWith, "isMatchWith");
      function isNaN2(value) {
        return isNumber(value) && value != +value;
      }
      __name(isNaN2, "isNaN");
      function isNative(value) {
        if (isMaskable(value))
          throw new Error2(CORE_ERROR_TEXT);
        return baseIsNative(value);
      }
      __name(isNative, "isNative");
      function isNull(value) {
        return value === null;
      }
      __name(isNull, "isNull");
      function isNil(value) {
        return value == null;
      }
      __name(isNil, "isNil");
      function isNumber(value) {
        return typeof value == "number" || isObjectLike(value) && baseGetTag(value) == numberTag;
      }
      __name(isNumber, "isNumber");
      function isPlainObject(value) {
        if (!isObjectLike(value) || baseGetTag(value) != objectTag)
          return !1;
        var proto = getPrototype(value);
        if (proto === null)
          return !0;
        var Ctor = hasOwnProperty.call(proto, "constructor") && proto.constructor;
        return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;
      }
      __name(isPlainObject, "isPlainObject");
      var isRegExp = nodeIsRegExp ? baseUnary(nodeIsRegExp) : baseIsRegExp;
      function isSafeInteger(value) {
        return isInteger2(value) && value >= -9007199254740991 && value <= MAX_SAFE_INTEGER;
      }
      __name(isSafeInteger, "isSafeInteger");
      var isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;
      function isString2(value) {
        return typeof value == "string" || !isArray(value) && isObjectLike(value) && baseGetTag(value) == stringTag;
      }
      __name(isString2, "isString");
      function isSymbol(value) {
        return typeof value == "symbol" || isObjectLike(value) && baseGetTag(value) == symbolTag;
      }
      __name(isSymbol, "isSymbol");
      var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
      function isUndefined(value) {
        return value === undefined$1;
      }
      __name(isUndefined, "isUndefined");
      function isWeakMap(value) {
        return isObjectLike(value) && getTag(value) == weakMapTag;
      }
      __name(isWeakMap, "isWeakMap");
      function isWeakSet(value) {
        return isObjectLike(value) && baseGetTag(value) == weakSetTag;
      }
      __name(isWeakSet, "isWeakSet");
      var lt = createRelationalOperation(baseLt), lte = createRelationalOperation(function(value, other) {
        return value <= other;
      });
      function toArray2(value) {
        if (!value)
          return [];
        if (isArrayLike(value))
          return isString2(value) ? stringToArray(value) : copyArray(value);
        if (symIterator && value[symIterator])
          return iteratorToArray(value[symIterator]());
        var tag = getTag(value), func = tag == mapTag ? mapToArray : tag == setTag ? setToArray : values;
        return func(value);
      }
      __name(toArray2, "toArray");
      function toFinite(value) {
        if (!value)
          return value === 0 ? value : 0;
        if (value = toNumber(value), value === INFINITY || value === -1 / 0) {
          var sign = value < 0 ? -1 : 1;
          return sign * MAX_INTEGER;
        }
        return value === value ? value : 0;
      }
      __name(toFinite, "toFinite");
      function toInteger(value) {
        var result2 = toFinite(value), remainder = result2 % 1;
        return result2 === result2 ? remainder ? result2 - remainder : result2 : 0;
      }
      __name(toInteger, "toInteger");
      function toLength(value) {
        return value ? baseClamp(toInteger(value), 0, MAX_ARRAY_LENGTH) : 0;
      }
      __name(toLength, "toLength");
      function toNumber(value) {
        if (typeof value == "number")
          return value;
        if (isSymbol(value))
          return NAN;
        if (isObject2(value)) {
          var other = typeof value.valueOf == "function" ? value.valueOf() : value;
          value = isObject2(other) ? other + "" : other;
        }
        if (typeof value != "string")
          return value === 0 ? value : +value;
        value = baseTrim(value);
        var isBinary = reIsBinary.test(value);
        return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
      }
      __name(toNumber, "toNumber");
      function toPlainObject(value) {
        return copyObject(value, keysIn(value));
      }
      __name(toPlainObject, "toPlainObject");
      function toSafeInteger(value) {
        return value ? baseClamp(toInteger(value), -9007199254740991, MAX_SAFE_INTEGER) : value === 0 ? value : 0;
      }
      __name(toSafeInteger, "toSafeInteger");
      function toString(value) {
        return value == null ? "" : baseToString(value);
      }
      __name(toString, "toString");
      var assign = createAssigner(function(object4, source) {
        if (isPrototype(source) || isArrayLike(source)) {
          copyObject(source, keys2(source), object4);
          return;
        }
        for (var key in source)
          hasOwnProperty.call(source, key) && assignValue(object4, key, source[key]);
      }), assignIn = createAssigner(function(object4, source) {
        copyObject(source, keysIn(source), object4);
      }), assignInWith = createAssigner(function(object4, source, srcIndex, customizer) {
        copyObject(source, keysIn(source), object4, customizer);
      }), assignWith = createAssigner(function(object4, source, srcIndex, customizer) {
        copyObject(source, keys2(source), object4, customizer);
      }), at = flatRest(baseAt);
      function create(prototype, properties) {
        var result2 = baseCreate(prototype);
        return properties == null ? result2 : baseAssign(result2, properties);
      }
      __name(create, "create");
      var defaults2 = baseRest(function(object4, sources) {
        object4 = Object2(object4);
        var index2 = -1, length2 = sources.length, guard = length2 > 2 ? sources[2] : undefined$1;
        for (guard && isIterateeCall(sources[0], sources[1], guard) && (length2 = 1); ++index2 < length2; )
          for (var source = sources[index2], props = keysIn(source), propsIndex = -1, propsLength = props.length; ++propsIndex < propsLength; ) {
            var key = props[propsIndex], value = object4[key];
            (value === undefined$1 || eq(value, objectProto[key]) && !hasOwnProperty.call(object4, key)) && (object4[key] = source[key]);
          }
        return object4;
      }), defaultsDeep = baseRest(function(args) {
        return args.push(undefined$1, customDefaultsMerge), apply(mergeWith, undefined$1, args);
      });
      function findKey(object4, predicate) {
        return baseFindKey(object4, getIteratee(predicate, 3), baseForOwn);
      }
      __name(findKey, "findKey");
      function findLastKey(object4, predicate) {
        return baseFindKey(object4, getIteratee(predicate, 3), baseForOwnRight);
      }
      __name(findLastKey, "findLastKey");
      function forIn(object4, iteratee2) {
        return object4 == null ? object4 : baseFor(object4, getIteratee(iteratee2, 3), keysIn);
      }
      __name(forIn, "forIn");
      function forInRight(object4, iteratee2) {
        return object4 == null ? object4 : baseForRight(object4, getIteratee(iteratee2, 3), keysIn);
      }
      __name(forInRight, "forInRight");
      function forOwn(object4, iteratee2) {
        return object4 && baseForOwn(object4, getIteratee(iteratee2, 3));
      }
      __name(forOwn, "forOwn");
      function forOwnRight(object4, iteratee2) {
        return object4 && baseForOwnRight(object4, getIteratee(iteratee2, 3));
      }
      __name(forOwnRight, "forOwnRight");
      function functions(object4) {
        return object4 == null ? [] : baseFunctions(object4, keys2(object4));
      }
      __name(functions, "functions");
      function functionsIn(object4) {
        return object4 == null ? [] : baseFunctions(object4, keysIn(object4));
      }
      __name(functionsIn, "functionsIn");
      function get2(object4, path2, defaultValue) {
        var result2 = object4 == null ? undefined$1 : baseGet(object4, path2);
        return result2 === undefined$1 ? defaultValue : result2;
      }
      __name(get2, "get");
      function has(object4, path2) {
        return object4 != null && hasPath(object4, path2, baseHas);
      }
      __name(has, "has");
      function hasIn(object4, path2) {
        return object4 != null && hasPath(object4, path2, baseHasIn);
      }
      __name(hasIn, "hasIn");
      var invert = createInverter(function(result2, value, key) {
        value != null && typeof value.toString != "function" && (value = nativeObjectToString.call(value)), result2[value] = key;
      }, constant(identity)), invertBy = createInverter(function(result2, value, key) {
        value != null && typeof value.toString != "function" && (value = nativeObjectToString.call(value)), hasOwnProperty.call(result2, value) ? result2[value].push(key) : result2[value] = [key];
      }, getIteratee), invoke = baseRest(baseInvoke);
      function keys2(object4) {
        return isArrayLike(object4) ? arrayLikeKeys(object4) : baseKeys(object4);
      }
      __name(keys2, "keys");
      function keysIn(object4) {
        return isArrayLike(object4) ? arrayLikeKeys(object4, !0) : baseKeysIn(object4);
      }
      __name(keysIn, "keysIn");
      function mapKeys(object4, iteratee2) {
        var result2 = {};
        return iteratee2 = getIteratee(iteratee2, 3), baseForOwn(object4, function(value, key, object5) {
          baseAssignValue(result2, iteratee2(value, key, object5), value);
        }), result2;
      }
      __name(mapKeys, "mapKeys");
      function mapValues(object4, iteratee2) {
        var result2 = {};
        return iteratee2 = getIteratee(iteratee2, 3), baseForOwn(object4, function(value, key, object5) {
          baseAssignValue(result2, key, iteratee2(value, key, object5));
        }), result2;
      }
      __name(mapValues, "mapValues");
      var merge2 = createAssigner(function(object4, source, srcIndex) {
        baseMerge(object4, source, srcIndex);
      }), mergeWith = createAssigner(function(object4, source, srcIndex, customizer) {
        baseMerge(object4, source, srcIndex, customizer);
      }), omit2 = flatRest(function(object4, paths) {
        var result2 = {};
        if (object4 == null)
          return result2;
        var isDeep = !1;
        paths = arrayMap(paths, function(path2) {
          return path2 = castPath(path2, object4), isDeep || (isDeep = path2.length > 1), path2;
        }), copyObject(object4, getAllKeysIn(object4), result2), isDeep && (result2 = baseClone(result2, CLONE_DEEP_FLAG | CLONE_FLAT_FLAG | CLONE_SYMBOLS_FLAG, customOmitClone));
        for (var length2 = paths.length; length2--; )
          baseUnset(result2, paths[length2]);
        return result2;
      });
      function omitBy(object4, predicate) {
        return pickBy(object4, negate(getIteratee(predicate)));
      }
      __name(omitBy, "omitBy");
      var pick = flatRest(function(object4, paths) {
        return object4 == null ? {} : basePick(object4, paths);
      });
      function pickBy(object4, predicate) {
        if (object4 == null)
          return {};
        var props = arrayMap(getAllKeysIn(object4), function(prop) {
          return [prop];
        });
        return predicate = getIteratee(predicate), basePickBy(object4, props, function(value, path2) {
          return predicate(value, path2[0]);
        });
      }
      __name(pickBy, "pickBy");
      function result(object4, path2, defaultValue) {
        path2 = castPath(path2, object4);
        var index2 = -1, length2 = path2.length;
        for (length2 || (length2 = 1, object4 = undefined$1); ++index2 < length2; ) {
          var value = object4 == null ? undefined$1 : object4[toKey(path2[index2])];
          value === undefined$1 && (index2 = length2, value = defaultValue), object4 = isFunction(value) ? value.call(object4) : value;
        }
        return object4;
      }
      __name(result, "result");
      function set2(object4, path2, value) {
        return object4 == null ? object4 : baseSet(object4, path2, value);
      }
      __name(set2, "set");
      function setWith(object4, path2, value, customizer) {
        return customizer = typeof customizer == "function" ? customizer : undefined$1, object4 == null ? object4 : baseSet(object4, path2, value, customizer);
      }
      __name(setWith, "setWith");
      var toPairs = createToPairs(keys2), toPairsIn = createToPairs(keysIn);
      function transform(object4, iteratee2, accumulator) {
        var isArr = isArray(object4), isArrLike = isArr || isBuffer(object4) || isTypedArray(object4);
        if (iteratee2 = getIteratee(iteratee2, 4), accumulator == null) {
          var Ctor = object4 && object4.constructor;
          isArrLike ? accumulator = isArr ? new Ctor() : [] : isObject2(object4) ? accumulator = isFunction(Ctor) ? baseCreate(getPrototype(object4)) : {} : accumulator = {};
        }
        return (isArrLike ? arrayEach : baseForOwn)(object4, function(value, index2, object5) {
          return iteratee2(accumulator, value, index2, object5);
        }), accumulator;
      }
      __name(transform, "transform");
      function unset(object4, path2) {
        return object4 == null ? !0 : baseUnset(object4, path2);
      }
      __name(unset, "unset");
      function update(object4, path2, updater) {
        return object4 == null ? object4 : baseUpdate(object4, path2, castFunction(updater));
      }
      __name(update, "update");
      function updateWith(object4, path2, updater, customizer) {
        return customizer = typeof customizer == "function" ? customizer : undefined$1, object4 == null ? object4 : baseUpdate(object4, path2, castFunction(updater), customizer);
      }
      __name(updateWith, "updateWith");
      function values(object4) {
        return object4 == null ? [] : baseValues(object4, keys2(object4));
      }
      __name(values, "values");
      function valuesIn(object4) {
        return object4 == null ? [] : baseValues(object4, keysIn(object4));
      }
      __name(valuesIn, "valuesIn");
      function clamp(number4, lower, upper) {
        return upper === undefined$1 && (upper = lower, lower = undefined$1), upper !== undefined$1 && (upper = toNumber(upper), upper = upper === upper ? upper : 0), lower !== undefined$1 && (lower = toNumber(lower), lower = lower === lower ? lower : 0), baseClamp(toNumber(number4), lower, upper);
      }
      __name(clamp, "clamp");
      function inRange(number4, start, end) {
        return start = toFinite(start), end === undefined$1 ? (end = start, start = 0) : end = toFinite(end), number4 = toNumber(number4), baseInRange(number4, start, end);
      }
      __name(inRange, "inRange");
      function random(lower, upper, floating) {
        if (floating && typeof floating != "boolean" && isIterateeCall(lower, upper, floating) && (upper = floating = undefined$1), floating === undefined$1 && (typeof upper == "boolean" ? (floating = upper, upper = undefined$1) : typeof lower == "boolean" && (floating = lower, lower = undefined$1)), lower === undefined$1 && upper === undefined$1 ? (lower = 0, upper = 1) : (lower = toFinite(lower), upper === undefined$1 ? (upper = lower, lower = 0) : upper = toFinite(upper)), lower > upper) {
          var temp = lower;
          lower = upper, upper = temp;
        }
        if (floating || lower % 1 || upper % 1) {
          var rand = nativeRandom();
          return nativeMin(lower + rand * (upper - lower + freeParseFloat("1e-" + ((rand + "").length - 1))), upper);
        }
        return baseRandom(lower, upper);
      }
      __name(random, "random");
      var camelCase2 = createCompounder(function(result2, word, index2) {
        return word = word.toLowerCase(), result2 + (index2 ? capitalize2(word) : word);
      });
      function capitalize2(string3) {
        return upperFirst(toString(string3).toLowerCase());
      }
      __name(capitalize2, "capitalize");
      function deburr(string3) {
        return string3 = toString(string3), string3 && string3.replace(reLatin, deburrLetter).replace(reComboMark, "");
      }
      __name(deburr, "deburr");
      function endsWith(string3, target, position2) {
        string3 = toString(string3), target = baseToString(target);
        var length2 = string3.length;
        position2 = position2 === undefined$1 ? length2 : baseClamp(toInteger(position2), 0, length2);
        var end = position2;
        return position2 -= target.length, position2 >= 0 && string3.slice(position2, end) == target;
      }
      __name(endsWith, "endsWith");
      function escape2(string3) {
        return string3 = toString(string3), string3 && reHasUnescapedHtml.test(string3) ? string3.replace(reUnescapedHtml, escapeHtmlChar) : string3;
      }
      __name(escape2, "escape");
      function escapeRegExp(string3) {
        return string3 = toString(string3), string3 && reHasRegExpChar.test(string3) ? string3.replace(reRegExpChar, "\\$&") : string3;
      }
      __name(escapeRegExp, "escapeRegExp");
      var kebabCase = createCompounder(function(result2, word, index2) {
        return result2 + (index2 ? "-" : "") + word.toLowerCase();
      }), lowerCase = createCompounder(function(result2, word, index2) {
        return result2 + (index2 ? " " : "") + word.toLowerCase();
      }), lowerFirst = createCaseFirst("toLowerCase");
      function pad(string3, length2, chars2) {
        string3 = toString(string3), length2 = toInteger(length2);
        var strLength = length2 ? stringSize(string3) : 0;
        if (!length2 || strLength >= length2)
          return string3;
        var mid = (length2 - strLength) / 2;
        return createPadding(nativeFloor(mid), chars2) + string3 + createPadding(nativeCeil(mid), chars2);
      }
      __name(pad, "pad");
      function padEnd(string3, length2, chars2) {
        string3 = toString(string3), length2 = toInteger(length2);
        var strLength = length2 ? stringSize(string3) : 0;
        return length2 && strLength < length2 ? string3 + createPadding(length2 - strLength, chars2) : string3;
      }
      __name(padEnd, "padEnd");
      function padStart(string3, length2, chars2) {
        string3 = toString(string3), length2 = toInteger(length2);
        var strLength = length2 ? stringSize(string3) : 0;
        return length2 && strLength < length2 ? createPadding(length2 - strLength, chars2) + string3 : string3;
      }
      __name(padStart, "padStart");
      function parseInt2(string3, radix, guard) {
        return guard || radix == null ? radix = 0 : radix && (radix = +radix), nativeParseInt(toString(string3).replace(reTrimStart, ""), radix || 0);
      }
      __name(parseInt2, "parseInt");
      function repeat(string3, n2, guard) {
        return (guard ? isIterateeCall(string3, n2, guard) : n2 === undefined$1) ? n2 = 1 : n2 = toInteger(n2), baseRepeat(toString(string3), n2);
      }
      __name(repeat, "repeat");
      function replace2() {
        var args = arguments, string3 = toString(args[0]);
        return args.length < 3 ? string3 : string3.replace(args[1], args[2]);
      }
      __name(replace2, "replace");
      var snakeCase = createCompounder(function(result2, word, index2) {
        return result2 + (index2 ? "_" : "") + word.toLowerCase();
      });
      function split(string3, separator, limit) {
        return limit && typeof limit != "number" && isIterateeCall(string3, separator, limit) && (separator = limit = undefined$1), limit = limit === undefined$1 ? MAX_ARRAY_LENGTH : limit >>> 0, limit ? (string3 = toString(string3), string3 && (typeof separator == "string" || separator != null && !isRegExp(separator)) && (separator = baseToString(separator), !separator && hasUnicode(string3)) ? castSlice(stringToArray(string3), 0, limit) : string3.split(separator, limit)) : [];
      }
      __name(split, "split");
      var startCase = createCompounder(function(result2, word, index2) {
        return result2 + (index2 ? " " : "") + upperFirst(word);
      });
      function startsWith(string3, target, position2) {
        return string3 = toString(string3), position2 = position2 == null ? 0 : baseClamp(toInteger(position2), 0, string3.length), target = baseToString(target), string3.slice(position2, position2 + target.length) == target;
      }
      __name(startsWith, "startsWith");
      function template(string3, options, guard) {
        var settings = lodash2.templateSettings;
        guard && isIterateeCall(string3, options, guard) && (options = undefined$1), string3 = toString(string3), options = assignInWith({}, options, settings, customDefaultsAssignIn);
        var imports = assignInWith({}, options.imports, settings.imports, customDefaultsAssignIn), importsKeys = keys2(imports), importsValues = baseValues(imports, importsKeys), isEscaping, isEvaluating, index2 = 0, interpolate = options.interpolate || reNoMatch, source = "__p += '", reDelimiters = RegExp2(
          (options.escape || reNoMatch).source + "|" + interpolate.source + "|" + (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + "|" + (options.evaluate || reNoMatch).source + "|$",
          "g"
        ), sourceURL = "//# sourceURL=" + (hasOwnProperty.call(options, "sourceURL") ? (options.sourceURL + "").replace(/\s/g, " ") : "lodash.templateSources[" + ++templateCounter + "]") + `
`;
        string3.replace(reDelimiters, function(match2, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset2) {
          return interpolateValue || (interpolateValue = esTemplateValue), source += string3.slice(index2, offset2).replace(reUnescapedString, escapeStringChar), escapeValue && (isEscaping = !0, source += `' +
__e(` + escapeValue + `) +
'`), evaluateValue && (isEvaluating = !0, source += `';
` + evaluateValue + `;
__p += '`), interpolateValue && (source += `' +
((__t = (` + interpolateValue + `)) == null ? '' : __t) +
'`), index2 = offset2 + match2.length, match2;
        }), source += `';
`;
        var variable = hasOwnProperty.call(options, "variable") && options.variable;
        if (!variable)
          source = `with (obj) {
` + source + `
}
`;
        else if (reForbiddenIdentifierChars.test(variable))
          throw new Error2(INVALID_TEMPL_VAR_ERROR_TEXT);
        source = (isEvaluating ? source.replace(reEmptyStringLeading, "") : source).replace(reEmptyStringMiddle, "$1").replace(reEmptyStringTrailing, "$1;"), source = "function(" + (variable || "obj") + `) {
` + (variable ? "" : `obj || (obj = {});
`) + "var __t, __p = ''" + (isEscaping ? ", __e = _.escape" : "") + (isEvaluating ? `, __j = Array.prototype.join;
function print() { __p += __j.call(arguments, '') }
` : `;
`) + source + `return __p
}`;
        var result2 = attempt(function() {
          return Function2(importsKeys, sourceURL + "return " + source).apply(undefined$1, importsValues);
        });
        if (result2.source = source, isError(result2))
          throw result2;
        return result2;
      }
      __name(template, "template");
      function toLower(value) {
        return toString(value).toLowerCase();
      }
      __name(toLower, "toLower");
      function toUpper(value) {
        return toString(value).toUpperCase();
      }
      __name(toUpper, "toUpper");
      function trim2(string3, chars2, guard) {
        if (string3 = toString(string3), string3 && (guard || chars2 === undefined$1))
          return baseTrim(string3);
        if (!string3 || !(chars2 = baseToString(chars2)))
          return string3;
        var strSymbols = stringToArray(string3), chrSymbols = stringToArray(chars2), start = charsStartIndex(strSymbols, chrSymbols), end = charsEndIndex(strSymbols, chrSymbols) + 1;
        return castSlice(strSymbols, start, end).join("");
      }
      __name(trim2, "trim");
      function trimEnd(string3, chars2, guard) {
        if (string3 = toString(string3), string3 && (guard || chars2 === undefined$1))
          return string3.slice(0, trimmedEndIndex(string3) + 1);
        if (!string3 || !(chars2 = baseToString(chars2)))
          return string3;
        var strSymbols = stringToArray(string3), end = charsEndIndex(strSymbols, stringToArray(chars2)) + 1;
        return castSlice(strSymbols, 0, end).join("");
      }
      __name(trimEnd, "trimEnd");
      function trimStart(string3, chars2, guard) {
        if (string3 = toString(string3), string3 && (guard || chars2 === undefined$1))
          return string3.replace(reTrimStart, "");
        if (!string3 || !(chars2 = baseToString(chars2)))
          return string3;
        var strSymbols = stringToArray(string3), start = charsStartIndex(strSymbols, stringToArray(chars2));
        return castSlice(strSymbols, start).join("");
      }
      __name(trimStart, "trimStart");
      function truncate(string3, options) {
        var length2 = DEFAULT_TRUNC_LENGTH, omission = DEFAULT_TRUNC_OMISSION;
        if (isObject2(options)) {
          var separator = "separator" in options ? options.separator : separator;
          length2 = "length" in options ? toInteger(options.length) : length2, omission = "omission" in options ? baseToString(options.omission) : omission;
        }
        string3 = toString(string3);
        var strLength = string3.length;
        if (hasUnicode(string3)) {
          var strSymbols = stringToArray(string3);
          strLength = strSymbols.length;
        }
        if (length2 >= strLength)
          return string3;
        var end = length2 - stringSize(omission);
        if (end < 1)
          return omission;
        var result2 = strSymbols ? castSlice(strSymbols, 0, end).join("") : string3.slice(0, end);
        if (separator === undefined$1)
          return result2 + omission;
        if (strSymbols && (end += result2.length - end), isRegExp(separator)) {
          if (string3.slice(end).search(separator)) {
            var match2, substring = result2;
            for (separator.global || (separator = RegExp2(separator.source, toString(reFlags.exec(separator)) + "g")), separator.lastIndex = 0; match2 = separator.exec(substring); )
              var newEnd = match2.index;
            result2 = result2.slice(0, newEnd === undefined$1 ? end : newEnd);
          }
        } else if (string3.indexOf(baseToString(separator), end) != end) {
          var index2 = result2.lastIndexOf(separator);
          index2 > -1 && (result2 = result2.slice(0, index2));
        }
        return result2 + omission;
      }
      __name(truncate, "truncate");
      function unescape2(string3) {
        return string3 = toString(string3), string3 && reHasEscapedHtml.test(string3) ? string3.replace(reEscapedHtml, unescapeHtmlChar) : string3;
      }
      __name(unescape2, "unescape");
      var upperCase = createCompounder(function(result2, word, index2) {
        return result2 + (index2 ? " " : "") + word.toUpperCase();
      }), upperFirst = createCaseFirst("toUpperCase");
      function words(string3, pattern4, guard) {
        return string3 = toString(string3), pattern4 = guard ? undefined$1 : pattern4, pattern4 === undefined$1 ? hasUnicodeWord(string3) ? unicodeWords(string3) : asciiWords(string3) : string3.match(pattern4) || [];
      }
      __name(words, "words");
      var attempt = baseRest(function(func, args) {
        try {
          return apply(func, undefined$1, args);
        } catch (e2) {
          return isError(e2) ? e2 : new Error2(e2);
        }
      }), bindAll = flatRest(function(object4, methodNames) {
        return arrayEach(methodNames, function(key) {
          key = toKey(key), baseAssignValue(object4, key, bind(object4[key], object4));
        }), object4;
      });
      function cond(pairs) {
        var length2 = pairs == null ? 0 : pairs.length, toIteratee = getIteratee();
        return pairs = length2 ? arrayMap(pairs, function(pair) {
          if (typeof pair[1] != "function")
            throw new TypeError2(FUNC_ERROR_TEXT);
          return [toIteratee(pair[0]), pair[1]];
        }) : [], baseRest(function(args) {
          for (var index2 = -1; ++index2 < length2; ) {
            var pair = pairs[index2];
            if (apply(pair[0], this, args))
              return apply(pair[1], this, args);
          }
        });
      }
      __name(cond, "cond");
      function conforms(source) {
        return baseConforms(baseClone(source, CLONE_DEEP_FLAG));
      }
      __name(conforms, "conforms");
      function constant(value) {
        return function() {
          return value;
        };
      }
      __name(constant, "constant");
      function defaultTo(value, defaultValue) {
        return value == null || value !== value ? defaultValue : value;
      }
      __name(defaultTo, "defaultTo");
      var flow = createFlow(), flowRight = createFlow(!0);
      function identity(value) {
        return value;
      }
      __name(identity, "identity");
      function iteratee(func) {
        return baseIteratee(typeof func == "function" ? func : baseClone(func, CLONE_DEEP_FLAG));
      }
      __name(iteratee, "iteratee");
      function matches(source) {
        return baseMatches(baseClone(source, CLONE_DEEP_FLAG));
      }
      __name(matches, "matches");
      function matchesProperty(path2, srcValue) {
        return baseMatchesProperty(path2, baseClone(srcValue, CLONE_DEEP_FLAG));
      }
      __name(matchesProperty, "matchesProperty");
      var method4 = baseRest(function(path2, args) {
        return function(object4) {
          return baseInvoke(object4, path2, args);
        };
      }), methodOf = baseRest(function(object4, args) {
        return function(path2) {
          return baseInvoke(object4, path2, args);
        };
      });
      function mixin(object4, source, options) {
        var props = keys2(source), methodNames = baseFunctions(source, props);
        options == null && !(isObject2(source) && (methodNames.length || !props.length)) && (options = source, source = object4, object4 = this, methodNames = baseFunctions(source, keys2(source)));
        var chain2 = !(isObject2(options) && "chain" in options) || !!options.chain, isFunc = isFunction(object4);
        return arrayEach(methodNames, function(methodName) {
          var func = source[methodName];
          object4[methodName] = func, isFunc && (object4.prototype[methodName] = function() {
            var chainAll = this.__chain__;
            if (chain2 || chainAll) {
              var result2 = object4(this.__wrapped__), actions = result2.__actions__ = copyArray(this.__actions__);
              return actions.push({ func, args: arguments, thisArg: object4 }), result2.__chain__ = chainAll, result2;
            }
            return func.apply(object4, arrayPush([this.value()], arguments));
          });
        }), object4;
      }
      __name(mixin, "mixin");
      function noConflict() {
        return root._ === this && (root._ = oldDash), this;
      }
      __name(noConflict, "noConflict");
      function noop3() {
      }
      __name(noop3, "noop");
      function nthArg(n2) {
        return n2 = toInteger(n2), baseRest(function(args) {
          return baseNth(args, n2);
        });
      }
      __name(nthArg, "nthArg");
      var over = createOver(arrayMap), overEvery = createOver(arrayEvery), overSome = createOver(arraySome);
      function property(path2) {
        return isKey(path2) ? baseProperty(toKey(path2)) : basePropertyDeep(path2);
      }
      __name(property, "property");
      function propertyOf(object4) {
        return function(path2) {
          return object4 == null ? undefined$1 : baseGet(object4, path2);
        };
      }
      __name(propertyOf, "propertyOf");
      var range3 = createRange(), rangeRight = createRange(!0);
      function stubArray() {
        return [];
      }
      __name(stubArray, "stubArray");
      function stubFalse() {
        return !1;
      }
      __name(stubFalse, "stubFalse");
      function stubObject() {
        return {};
      }
      __name(stubObject, "stubObject");
      function stubString() {
        return "";
      }
      __name(stubString, "stubString");
      function stubTrue() {
        return !0;
      }
      __name(stubTrue, "stubTrue");
      function times(n2, iteratee2) {
        if (n2 = toInteger(n2), n2 < 1 || n2 > MAX_SAFE_INTEGER)
          return [];
        var index2 = MAX_ARRAY_LENGTH, length2 = nativeMin(n2, MAX_ARRAY_LENGTH);
        iteratee2 = getIteratee(iteratee2), n2 -= MAX_ARRAY_LENGTH;
        for (var result2 = baseTimes(length2, iteratee2); ++index2 < n2; )
          iteratee2(index2);
        return result2;
      }
      __name(times, "times");
      function toPath(value) {
        return isArray(value) ? arrayMap(value, toKey) : isSymbol(value) ? [value] : copyArray(stringToPath(toString(value)));
      }
      __name(toPath, "toPath");
      function uniqueId(prefix) {
        var id2 = ++idCounter;
        return toString(prefix) + id2;
      }
      __name(uniqueId, "uniqueId");
      var add = createMathOperation(function(augend, addend) {
        return augend + addend;
      }, 0), ceil = createRound("ceil"), divide = createMathOperation(function(dividend, divisor) {
        return dividend / divisor;
      }, 1), floor = createRound("floor");
      function max(array4) {
        return array4 && array4.length ? baseExtremum(array4, identity, baseGt) : undefined$1;
      }
      __name(max, "max");
      function maxBy(array4, iteratee2) {
        return array4 && array4.length ? baseExtremum(array4, getIteratee(iteratee2, 2), baseGt) : undefined$1;
      }
      __name(maxBy, "maxBy");
      function mean(array4) {
        return baseMean(array4, identity);
      }
      __name(mean, "mean");
      function meanBy(array4, iteratee2) {
        return baseMean(array4, getIteratee(iteratee2, 2));
      }
      __name(meanBy, "meanBy");
      function min(array4) {
        return array4 && array4.length ? baseExtremum(array4, identity, baseLt) : undefined$1;
      }
      __name(min, "min");
      function minBy(array4, iteratee2) {
        return array4 && array4.length ? baseExtremum(array4, getIteratee(iteratee2, 2), baseLt) : undefined$1;
      }
      __name(minBy, "minBy");
      var multiply = createMathOperation(function(multiplier, multiplicand) {
        return multiplier * multiplicand;
      }, 1), round2 = createRound("round"), subtract = createMathOperation(function(minuend, subtrahend) {
        return minuend - subtrahend;
      }, 0);
      function sum(array4) {
        return array4 && array4.length ? baseSum(array4, identity) : 0;
      }
      __name(sum, "sum");
      function sumBy(array4, iteratee2) {
        return array4 && array4.length ? baseSum(array4, getIteratee(iteratee2, 2)) : 0;
      }
      return __name(sumBy, "sumBy"), lodash2.after = after, lodash2.ary = ary, lodash2.assign = assign, lodash2.assignIn = assignIn, lodash2.assignInWith = assignInWith, lodash2.assignWith = assignWith, lodash2.at = at, lodash2.before = before, lodash2.bind = bind, lodash2.bindAll = bindAll, lodash2.bindKey = bindKey, lodash2.castArray = castArray, lodash2.chain = chain, lodash2.chunk = chunk, lodash2.compact = compact, lodash2.concat = concat, lodash2.cond = cond, lodash2.conforms = conforms, lodash2.constant = constant, lodash2.countBy = countBy, lodash2.create = create, lodash2.curry = curry, lodash2.curryRight = curryRight, lodash2.debounce = debounce2, lodash2.defaults = defaults2, lodash2.defaultsDeep = defaultsDeep, lodash2.defer = defer2, lodash2.delay = delay, lodash2.difference = difference, lodash2.differenceBy = differenceBy, lodash2.differenceWith = differenceWith, lodash2.drop = drop, lodash2.dropRight = dropRight, lodash2.dropRightWhile = dropRightWhile, lodash2.dropWhile = dropWhile, lodash2.fill = fill, lodash2.filter = filter2, lodash2.flatMap = flatMap, lodash2.flatMapDeep = flatMapDeep, lodash2.flatMapDepth = flatMapDepth, lodash2.flatten = flatten, lodash2.flattenDeep = flattenDeep, lodash2.flattenDepth = flattenDepth, lodash2.flip = flip, lodash2.flow = flow, lodash2.flowRight = flowRight, lodash2.fromPairs = fromPairs, lodash2.functions = functions, lodash2.functionsIn = functionsIn, lodash2.groupBy = groupBy, lodash2.initial = initial, lodash2.intersection = intersection, lodash2.intersectionBy = intersectionBy, lodash2.intersectionWith = intersectionWith, lodash2.invert = invert, lodash2.invertBy = invertBy, lodash2.invokeMap = invokeMap, lodash2.iteratee = iteratee, lodash2.keyBy = keyBy, lodash2.keys = keys2, lodash2.keysIn = keysIn, lodash2.map = map, lodash2.mapKeys = mapKeys, lodash2.mapValues = mapValues, lodash2.matches = matches, lodash2.matchesProperty = matchesProperty, lodash2.memoize = memoize, lodash2.merge = merge2, lodash2.mergeWith = mergeWith, lodash2.method = method4, lodash2.methodOf = methodOf, lodash2.mixin = mixin, lodash2.negate = negate, lodash2.nthArg = nthArg, lodash2.omit = omit2, lodash2.omitBy = omitBy, lodash2.once = once, lodash2.orderBy = orderBy, lodash2.over = over, lodash2.overArgs = overArgs, lodash2.overEvery = overEvery, lodash2.overSome = overSome, lodash2.partial = partial, lodash2.partialRight = partialRight, lodash2.partition = partition, lodash2.pick = pick, lodash2.pickBy = pickBy, lodash2.property = property, lodash2.propertyOf = propertyOf, lodash2.pull = pull, lodash2.pullAll = pullAll, lodash2.pullAllBy = pullAllBy, lodash2.pullAllWith = pullAllWith, lodash2.pullAt = pullAt, lodash2.range = range3, lodash2.rangeRight = rangeRight, lodash2.rearg = rearg, lodash2.reject = reject, lodash2.remove = remove, lodash2.rest = rest, lodash2.reverse = reverse, lodash2.sampleSize = sampleSize, lodash2.set = set2, lodash2.setWith = setWith, lodash2.shuffle = shuffle, lodash2.slice = slice2, lodash2.sortBy = sortBy, lodash2.sortedUniq = sortedUniq, lodash2.sortedUniqBy = sortedUniqBy, lodash2.split = split, lodash2.spread = spread, lodash2.tail = tail, lodash2.take = take, lodash2.takeRight = takeRight, lodash2.takeRightWhile = takeRightWhile, lodash2.takeWhile = takeWhile, lodash2.tap = tap, lodash2.throttle = throttle2, lodash2.thru = thru, lodash2.toArray = toArray2, lodash2.toPairs = toPairs, lodash2.toPairsIn = toPairsIn, lodash2.toPath = toPath, lodash2.toPlainObject = toPlainObject, lodash2.transform = transform, lodash2.unary = unary, lodash2.union = union, lodash2.unionBy = unionBy, lodash2.unionWith = unionWith, lodash2.uniq = uniq, lodash2.uniqBy = uniqBy, lodash2.uniqWith = uniqWith, lodash2.unset = unset, lodash2.unzip = unzip, lodash2.unzipWith = unzipWith, lodash2.update = update, lodash2.updateWith = updateWith, lodash2.values = values, lodash2.valuesIn = valuesIn, lodash2.without = without, lodash2.words = words, lodash2.wrap = wrap, lodash2.xor = xor, lodash2.xorBy = xorBy, lodash2.xorWith = xorWith, lodash2.zip = zip, lodash2.zipObject = zipObject, lodash2.zipObjectDeep = zipObjectDeep, lodash2.zipWith = zipWith, lodash2.entries = toPairs, lodash2.entriesIn = toPairsIn, lodash2.extend = assignIn, lodash2.extendWith = assignInWith, mixin(lodash2, lodash2), lodash2.add = add, lodash2.attempt = attempt, lodash2.camelCase = camelCase2, lodash2.capitalize = capitalize2, lodash2.ceil = ceil, lodash2.clamp = clamp, lodash2.clone = clone, lodash2.cloneDeep = cloneDeep, lodash2.cloneDeepWith = cloneDeepWith, lodash2.cloneWith = cloneWith, lodash2.conformsTo = conformsTo, lodash2.deburr = deburr, lodash2.defaultTo = defaultTo, lodash2.divide = divide, lodash2.endsWith = endsWith, lodash2.eq = eq, lodash2.escape = escape2, lodash2.escapeRegExp = escapeRegExp, lodash2.every = every, lodash2.find = find, lodash2.findIndex = findIndex, lodash2.findKey = findKey, lodash2.findLast = findLast, lodash2.findLastIndex = findLastIndex, lodash2.findLastKey = findLastKey, lodash2.floor = floor, lodash2.forEach = forEach2, lodash2.forEachRight = forEachRight, lodash2.forIn = forIn, lodash2.forInRight = forInRight, lodash2.forOwn = forOwn, lodash2.forOwnRight = forOwnRight, lodash2.get = get2, lodash2.gt = gt, lodash2.gte = gte, lodash2.has = has, lodash2.hasIn = hasIn, lodash2.head = head, lodash2.identity = identity, lodash2.includes = includes2, lodash2.indexOf = indexOf, lodash2.inRange = inRange, lodash2.invoke = invoke, lodash2.isArguments = isArguments, lodash2.isArray = isArray, lodash2.isArrayBuffer = isArrayBuffer, lodash2.isArrayLike = isArrayLike, lodash2.isArrayLikeObject = isArrayLikeObject, lodash2.isBoolean = isBoolean, lodash2.isBuffer = isBuffer, lodash2.isDate = isDate, lodash2.isElement = isElement, lodash2.isEmpty = isEmpty2, lodash2.isEqual = isEqual2, lodash2.isEqualWith = isEqualWith, lodash2.isError = isError, lodash2.isFinite = isFinite2, lodash2.isFunction = isFunction, lodash2.isInteger = isInteger2, lodash2.isLength = isLength, lodash2.isMap = isMap, lodash2.isMatch = isMatch, lodash2.isMatchWith = isMatchWith, lodash2.isNaN = isNaN2, lodash2.isNative = isNative, lodash2.isNil = isNil, lodash2.isNull = isNull, lodash2.isNumber = isNumber, lodash2.isObject = isObject2, lodash2.isObjectLike = isObjectLike, lodash2.isPlainObject = isPlainObject, lodash2.isRegExp = isRegExp, lodash2.isSafeInteger = isSafeInteger, lodash2.isSet = isSet, lodash2.isString = isString2, lodash2.isSymbol = isSymbol, lodash2.isTypedArray = isTypedArray, lodash2.isUndefined = isUndefined, lodash2.isWeakMap = isWeakMap, lodash2.isWeakSet = isWeakSet, lodash2.join = join, lodash2.kebabCase = kebabCase, lodash2.last = last, lodash2.lastIndexOf = lastIndexOf, lodash2.lowerCase = lowerCase, lodash2.lowerFirst = lowerFirst, lodash2.lt = lt, lodash2.lte = lte, lodash2.max = max, lodash2.maxBy = maxBy, lodash2.mean = mean, lodash2.meanBy = meanBy, lodash2.min = min, lodash2.minBy = minBy, lodash2.stubArray = stubArray, lodash2.stubFalse = stubFalse, lodash2.stubObject = stubObject, lodash2.stubString = stubString, lodash2.stubTrue = stubTrue, lodash2.multiply = multiply, lodash2.nth = nth, lodash2.noConflict = noConflict, lodash2.noop = noop3, lodash2.now = now2, lodash2.pad = pad, lodash2.padEnd = padEnd, lodash2.padStart = padStart, lodash2.parseInt = parseInt2, lodash2.random = random, lodash2.reduce = reduce, lodash2.reduceRight = reduceRight, lodash2.repeat = repeat, lodash2.replace = replace2, lodash2.result = result, lodash2.round = round2, lodash2.runInContext = runInContext2, lodash2.sample = sample, lodash2.size = size, lodash2.snakeCase = snakeCase, lodash2.some = some, lodash2.sortedIndex = sortedIndex, lodash2.sortedIndexBy = sortedIndexBy, lodash2.sortedIndexOf = sortedIndexOf, lodash2.sortedLastIndex = sortedLastIndex, lodash2.sortedLastIndexBy = sortedLastIndexBy, lodash2.sortedLastIndexOf = sortedLastIndexOf, lodash2.startCase = startCase, lodash2.startsWith = startsWith, lodash2.subtract = subtract, lodash2.sum = sum, lodash2.sumBy = sumBy, lodash2.template = template, lodash2.times = times, lodash2.toFinite = toFinite, lodash2.toInteger = toInteger, lodash2.toLength = toLength, lodash2.toLower = toLower, lodash2.toNumber = toNumber, lodash2.toSafeInteger = toSafeInteger, lodash2.toString = toString, lodash2.toUpper = toUpper, lodash2.trim = trim2, lodash2.trimEnd = trimEnd, lodash2.trimStart = trimStart, lodash2.truncate = truncate, lodash2.unescape = unescape2, lodash2.uniqueId = uniqueId, lodash2.upperCase = upperCase, lodash2.upperFirst = upperFirst, lodash2.each = forEach2, lodash2.eachRight = forEachRight, lodash2.first = head, mixin(lodash2, function() {
        var source = {};
        return baseForOwn(lodash2, function(func, methodName) {
          hasOwnProperty.call(lodash2.prototype, methodName) || (source[methodName] = func);
        }), source;
      }(), { chain: !1 }), lodash2.VERSION = VERSION, arrayEach(["bind", "bindKey", "curry", "curryRight", "partial", "partialRight"], function(methodName) {
        lodash2[methodName].placeholder = lodash2;
      }), arrayEach(["drop", "take"], function(methodName, index2) {
        LazyWrapper.prototype[methodName] = function(n2) {
          n2 = n2 === undefined$1 ? 1 : nativeMax(toInteger(n2), 0);
          var result2 = this.__filtered__ && !index2 ? new LazyWrapper(this) : this.clone();
          return result2.__filtered__ ? result2.__takeCount__ = nativeMin(n2, result2.__takeCount__) : result2.__views__.push({
            size: nativeMin(n2, MAX_ARRAY_LENGTH),
            type: methodName + (result2.__dir__ < 0 ? "Right" : "")
          }), result2;
        }, LazyWrapper.prototype[methodName + "Right"] = function(n2) {
          return this.reverse()[methodName](n2).reverse();
        };
      }), arrayEach(["filter", "map", "takeWhile"], function(methodName, index2) {
        var type4 = index2 + 1, isFilter = type4 == LAZY_FILTER_FLAG || type4 == LAZY_WHILE_FLAG;
        LazyWrapper.prototype[methodName] = function(iteratee2) {
          var result2 = this.clone();
          return result2.__iteratees__.push({
            iteratee: getIteratee(iteratee2, 3),
            type: type4
          }), result2.__filtered__ = result2.__filtered__ || isFilter, result2;
        };
      }), arrayEach(["head", "last"], function(methodName, index2) {
        var takeName = "take" + (index2 ? "Right" : "");
        LazyWrapper.prototype[methodName] = function() {
          return this[takeName](1).value()[0];
        };
      }), arrayEach(["initial", "tail"], function(methodName, index2) {
        var dropName = "drop" + (index2 ? "" : "Right");
        LazyWrapper.prototype[methodName] = function() {
          return this.__filtered__ ? new LazyWrapper(this) : this[dropName](1);
        };
      }), LazyWrapper.prototype.compact = function() {
        return this.filter(identity);
      }, LazyWrapper.prototype.find = function(predicate) {
        return this.filter(predicate).head();
      }, LazyWrapper.prototype.findLast = function(predicate) {
        return this.reverse().find(predicate);
      }, LazyWrapper.prototype.invokeMap = baseRest(function(path2, args) {
        return typeof path2 == "function" ? new LazyWrapper(this) : this.map(function(value) {
          return baseInvoke(value, path2, args);
        });
      }), LazyWrapper.prototype.reject = function(predicate) {
        return this.filter(negate(getIteratee(predicate)));
      }, LazyWrapper.prototype.slice = function(start, end) {
        start = toInteger(start);
        var result2 = this;
        return result2.__filtered__ && (start > 0 || end < 0) ? new LazyWrapper(result2) : (start < 0 ? result2 = result2.takeRight(-start) : start && (result2 = result2.drop(start)), end !== undefined$1 && (end = toInteger(end), result2 = end < 0 ? result2.dropRight(-end) : result2.take(end - start)), result2);
      }, LazyWrapper.prototype.takeRightWhile = function(predicate) {
        return this.reverse().takeWhile(predicate).reverse();
      }, LazyWrapper.prototype.toArray = function() {
        return this.take(MAX_ARRAY_LENGTH);
      }, baseForOwn(LazyWrapper.prototype, function(func, methodName) {
        var checkIteratee = /^(?:filter|find|map|reject)|While$/.test(methodName), isTaker = /^(?:head|last)$/.test(methodName), lodashFunc = lodash2[isTaker ? "take" + (methodName == "last" ? "Right" : "") : methodName], retUnwrapped = isTaker || /^find/.test(methodName);
        lodashFunc && (lodash2.prototype[methodName] = function() {
          var value = this.__wrapped__, args = isTaker ? [1] : arguments, isLazy = value instanceof LazyWrapper, iteratee2 = args[0], useLazy = isLazy || isArray(value), interceptor = /* @__PURE__ */ __name(function(value2) {
            var result3 = lodashFunc.apply(lodash2, arrayPush([value2], args));
            return isTaker && chainAll ? result3[0] : result3;
          }, "interceptor");
          useLazy && checkIteratee && typeof iteratee2 == "function" && iteratee2.length != 1 && (isLazy = useLazy = !1);
          var chainAll = this.__chain__, isHybrid = !!this.__actions__.length, isUnwrapped = retUnwrapped && !chainAll, onlyLazy = isLazy && !isHybrid;
          if (!retUnwrapped && useLazy) {
            value = onlyLazy ? value : new LazyWrapper(this);
            var result2 = func.apply(value, args);
            return result2.__actions__.push({ func: thru, args: [interceptor], thisArg: undefined$1 }), new LodashWrapper(result2, chainAll);
          }
          return isUnwrapped && onlyLazy ? func.apply(this, args) : (result2 = this.thru(interceptor), isUnwrapped ? isTaker ? result2.value()[0] : result2.value() : result2);
        });
      }), arrayEach(["pop", "push", "shift", "sort", "splice", "unshift"], function(methodName) {
        var func = arrayProto[methodName], chainName = /^(?:push|sort|unshift)$/.test(methodName) ? "tap" : "thru", retUnwrapped = /^(?:pop|shift)$/.test(methodName);
        lodash2.prototype[methodName] = function() {
          var args = arguments;
          if (retUnwrapped && !this.__chain__) {
            var value = this.value();
            return func.apply(isArray(value) ? value : [], args);
          }
          return this[chainName](function(value2) {
            return func.apply(isArray(value2) ? value2 : [], args);
          });
        };
      }), baseForOwn(LazyWrapper.prototype, function(func, methodName) {
        var lodashFunc = lodash2[methodName];
        if (lodashFunc) {
          var key = lodashFunc.name + "";
          hasOwnProperty.call(realNames, key) || (realNames[key] = []), realNames[key].push({ name: methodName, func: lodashFunc });
        }
      }), realNames[createHybrid(undefined$1, WRAP_BIND_KEY_FLAG).name] = [{
        name: "wrapper",
        func: undefined$1
      }], LazyWrapper.prototype.clone = lazyClone, LazyWrapper.prototype.reverse = lazyReverse, LazyWrapper.prototype.value = lazyValue, lodash2.prototype.at = wrapperAt, lodash2.prototype.chain = wrapperChain, lodash2.prototype.commit = wrapperCommit, lodash2.prototype.next = wrapperNext, lodash2.prototype.plant = wrapperPlant, lodash2.prototype.reverse = wrapperReverse, lodash2.prototype.toJSON = lodash2.prototype.valueOf = lodash2.prototype.value = wrapperValue, lodash2.prototype.first = lodash2.prototype.head, symIterator && (lodash2.prototype[symIterator] = wrapperToIterator), lodash2;
    }, "runInContext"), _2 = runInContext();
    freeModule ? ((freeModule.exports = _2)._ = _2, freeExports._ = _2) : root._ = _2;
  }).call(commonjsGlobal);
})(lodash, lodash.exports);
var lodashExports = lodash.exports;
const _ = /* @__PURE__ */ getDefaultExportFromCjs(lodashExports), Segmented = /* @__PURE__ */ __name(({ isDisabled, options, ...restProps }) => {
  var _a, _b;
  const { theme: theme2 } = useTheme(), iconSize = (_b = (_a = theme2 == null ? void 0 : theme2.components) == null ? void 0 : _a.Segmented) == null ? void 0 : _b.fontSize, menuItems = useMemo$1(() => options.map((item) => {
    if (typeof item == "string" || typeof item == "number")
      return item;
    const clonedIcon = item.icon ? React__default.cloneElement(item.icon, {
      style: {
        width: iconSize,
        height: iconSize
      }
    }) : null;
    return {
      ...item,
      label: /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
        clonedIcon,
        /* @__PURE__ */ jsxRuntimeExports.jsx("span", { style: { marginLeft: "6px" }, children: item.label })
      ] }),
      //убираем иконку, чтобы не было задвоения
      icon: null
    };
  }), [options, iconSize]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Segmented$1, { ...restProps, disabled: isDisabled, options: menuItems });
}, "Segmented"), Option2 = /* @__PURE__ */ __name((props) => {
  var _a;
  const { theme: theme2 } = useTheme();
  return props != null && props.customRenderOption ? props == null ? void 0 : props.customRenderOption(props) : props != null && props.optionsSegmentedValue ? props.optionsSegmentedValue && ((_a = Object.entries(props.optionsSegmentedValue)) == null ? void 0 : _a.map(([key, value], index2) => {
    var _a2, _b, _c, _d, _e, _f;
    const subtextFontSize = index2 > 0 ? { fontSize: (_b = (_a2 = theme2 == null ? void 0 : theme2.components) == null ? void 0 : _a2.Select) == null ? void 0 : _b.subtextFontSize } : {}, menuItemColor = props.segmentedValue !== key ? { color: (_d = (_c = theme2 == null ? void 0 : theme2.components) == null ? void 0 : _c.Select) == null ? void 0 : _d.menuItemSubtleColor } : { color: (_f = (_e = theme2 == null ? void 0 : theme2.components) == null ? void 0 : _e.Select) == null ? void 0 : _f.menuItemDefaultColor };
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      "div",
      {
        style: {
          ...subtextFontSize,
          ...menuItemColor
        },
        children: value
      },
      key
    );
  })) : /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: props.label });
}, "Option"), selectPosition = "_select-position_1kvyz_1", selectScrollSm = "_select-scroll-sm_1kvyz_13", selectScroll = "_select-scroll_1kvyz_13", selectScrollLg = "_select-scroll-lg_1kvyz_35", selectNewValueBorder = "_select-new-value-border_1kvyz_55", selectNewValueContent = "_select-new-value-content_1kvyz_65", selectNewValue = "_select-new-value_1kvyz_55", iconOptions = "_icon-options_1kvyz_107", compactAfter = "_compact-after_1kvyz_133", popupItem = "_popup-item_1kvyz_151", styles$4 = {
  selectPosition,
  selectScrollSm,
  selectScroll,
  selectScrollLg,
  selectNewValueBorder,
  selectNewValueContent,
  selectNewValue,
  iconOptions,
  compactAfter,
  popupItem
}, CommonSelect = /* @__PURE__ */ __name(({
  isAllowClear,
  compactAddonAfter,
  isAddOption,
  isDebounceSearch,
  isDisabled,
  isFullContent = !0,
  isLoading,
  isOpen,
  isPopupMatchSelectWidth,
  isSegmented,
  maxLengthSearch,
  menuItemSelectedIcon,
  onAddOption,
  onSearch,
  onSearchFormat,
  optionLabelProp,
  options,
  optionsPage,
  optionsSegmented,
  placeholder = "Выберите значение",
  removeIcon,
  suffixIcon,
  ...props
}) => {
  var _a, _b, _c, _d, _e, _f, _g;
  const { theme: theme2 } = useTheme(), [searchValue, setSearchValue] = useState(""), [segmentedValue, setSegmentedValue] = useState((_a = optionsSegmented == null ? void 0 : optionsSegmented[0]) == null ? void 0 : _a.value), [isLoadingScroll, setIsLoadingScroll] = useState(!1), iconSize = (_c = (_b = theme2 == null ? void 0 : theme2.components) == null ? void 0 : _b.Select) == null ? void 0 : _c.fontSizeIcon, optionsIconSize = (_e = (_d = theme2 == null ? void 0 : theme2.components) == null ? void 0 : _d.Select) == null ? void 0 : _e.optionFontSizeIcon, selectStyle = {
    ...isFullContent ? { width: "100%" } : {},
    ...props == null ? void 0 : props.style
  }, handleSearch = useCallback(
    (value, pageNumber) => {
      let newValueSearch = value;
      setIsLoadingScroll(!1), onSearchFormat && (newValueSearch = onSearchFormat(value)), maxLengthSearch && newValueSearch && (newValueSearch = newValueSearch == null ? void 0 : newValueSearch.slice(0, maxLengthSearch)), setSearchValue(newValueSearch), onSearch && onSearch(newValueSearch, pageNumber, segmentedValue);
    },
    [segmentedValue, onSearch, onSearchFormat, maxLengthSearch]
  ), debounceFetcher = useMemo$1(() => {
    const loadOptions = /* @__PURE__ */ __name((value) => {
      handleSearch(value);
    }, "loadOptions");
    return lodashExports.debounce(loadOptions, 800);
  }, [handleSearch]), handleDebounceSearch = /* @__PURE__ */ __name((value) => {
    const newValueSearch = onSearchFormat ? onSearchFormat(value) : value;
    setSearchValue(newValueSearch), debounceFetcher(newValueSearch);
  }, "handleDebounceSearch"), handleChangeSegmented = /* @__PURE__ */ __name((value) => {
    setSegmentedValue(value), onSearch && searchValue && onSearch(searchValue, 1, value);
  }, "handleChangeSegmented"), handleScroll = /* @__PURE__ */ __name((e2) => {
    var _a2, _b2, _c2;
    ((_a2 = e2 == null ? void 0 : e2.currentTarget) == null ? void 0 : _a2.scrollHeight) - (((_b2 = e2 == null ? void 0 : e2.currentTarget) == null ? void 0 : _b2.scrollTop) + ((_c2 = e2 == null ? void 0 : e2.currentTarget) == null ? void 0 : _c2.clientHeight)) < 1 && optionsPage && (optionsPage == null ? void 0 : optionsPage.numberOfPages) >= (optionsPage == null ? void 0 : optionsPage.pageNumber) + 1 && (setIsLoadingScroll(!0), onSearch && onSearch(searchValue, (optionsPage == null ? void 0 : optionsPage.pageNumber) + 1, segmentedValue));
  }, "handleScroll"), handleAddOption = /* @__PURE__ */ __name(() => {
    searchValue && (onAddOption == null || onAddOption(searchValue), setSearchValue(""));
  }, "handleAddOption"), handleDropdownVisibleChange = /* @__PURE__ */ __name((open) => {
    var _a2;
    (_a2 = props.onDropdownVisibleChange) == null || _a2.call(props, open), !open && searchValue && (setSearchValue(""), handleSearch(""));
  }, "handleDropdownVisibleChange"), handleChange = /* @__PURE__ */ __name((value, option) => {
    var _a2;
    props.mode === "tags" && setSearchValue(""), (_a2 = props.onChange) == null || _a2.call(props, value, option);
  }, "handleChange"), customClearIcon = typeof isAllowClear != "boolean" ? { clearIcon: isAllowClear == null ? void 0 : isAllowClear.clearIcon } : {};
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(Space.Compact, { style: isFullContent ? { width: "100%" } : {}, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs(
      Select$1,
      {
        ...props,
        popupMatchSelectWidth: isPopupMatchSelectWidth,
        searchValue,
        placeholder,
        listHeight: (_g = (_f = theme2 == null ? void 0 : theme2.components) == null ? void 0 : _f.Select) == null ? void 0 : _g.menuMaxHeight,
        style: selectStyle,
        open: isOpen,
        optionLabelProp: optionLabelProp || "label",
        optionFilterProp: props.optionFilterProp ?? "label",
        filterOption: isDebounceSearch ? !1 : props == null ? void 0 : props.filterOption,
        onSearch: isDebounceSearch ? handleDebounceSearch : handleSearch,
        disabled: isDisabled,
        popupClassName: styles$4.popupItem,
        className: cn(styles$4.iconOptions, props.className),
        onChange: handleChange,
        onDropdownVisibleChange: handleDropdownVisibleChange,
        onPopupScroll: handleScroll,
        removeIcon: removeIcon ?? /* @__PURE__ */ jsxRuntimeExports.jsx(IconX, { width: 10, height: 10, stroke: 1.5 }),
        suffixIcon: suffixIcon !== null ? suffixIcon ?? /* @__PURE__ */ jsxRuntimeExports.jsx(IconChevronDown, { width: iconSize, height: iconSize, stroke: 1.5 }) : null,
        allowClear: isAllowClear && {
          clearIcon: /* @__PURE__ */ jsxRuntimeExports.jsx(IconX, { width: iconSize, height: iconSize, stroke: 1.5 }),
          ...customClearIcon
        },
        menuItemSelectedIcon: menuItemSelectedIcon ?? /* @__PURE__ */ jsxRuntimeExports.jsx(IconCheck, { width: optionsIconSize, height: optionsIconSize, stroke: 1.5 }),
        dropdownRender: /* @__PURE__ */ __name((menu) => {
          var _a2, _b2, _c2, _d2, _e2, _f2;
          return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
            isSegmented && optionsSegmented && /* @__PURE__ */ jsxRuntimeExports.jsx(
              Segmented,
              {
                options: optionsSegmented,
                block: !0,
                style: { marginBottom: 4, width: "100%" },
                onChange: handleChangeSegmented
              }
            ),
            isLoading && !isLoadingScroll ? /* @__PURE__ */ jsxRuntimeExports.jsx(Skeleton, { loading: isLoading && !isLoadingScroll, active: !0 }) : menu,
            isAddOption && !isSegmented && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: styles$4.selectNewValueBorder, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
              "div",
              {
                role: "presentation",
                className: cn(styles$4.selectNewValueContent, {
                  [styles$4.selectNewValue]: searchValue
                }),
                onClick: handleAddOption,
                children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { color: (_b2 = (_a2 = theme2.components) == null ? void 0 : _a2.Select) == null ? void 0 : _b2.customValueDescriptionColor }, children: "Добавить собственное значение" }),
                  searchValue ? /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { color: (_d2 = (_c2 = theme2.components) == null ? void 0 : _c2.Select) == null ? void 0 : _d2.customValueDefaultColor }, children: searchValue }) : /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { color: (_f2 = (_e2 = theme2.components) == null ? void 0 : _e2.Select) == null ? void 0 : _f2.customValueDescriptionColor }, children: "Введите значение в поле" })
                ]
              }
            ) })
          ] });
        }, "dropdownRender"),
        notFoundContent: /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: props.notFoundContent ?? /* @__PURE__ */ jsxRuntimeExports.jsx(Empty, { image: Empty$1.PRESENTED_IMAGE_SIMPLE, description: "Записи не найдены" }) }),
        children: [
          options == null ? void 0 : options.map((option) => /* @__PURE__ */ createElement(
            Select$1.Option,
            {
              ...option,
              className: option.className,
              disabled: option.isDisabled,
              label: option.label,
              key: option.value,
              title: (option == null ? void 0 : option.title) || option.label,
              value: option.value,
              optionsSegmentedValue: option.optionsSegmentedValue
            },
            /* @__PURE__ */ jsxRuntimeExports.jsx(Option2, { ...option, segmentedValue })
          )),
          isLoadingScroll && isLoading && /* @__PURE__ */ jsxRuntimeExports.jsx(Select$1.Option, { disabled: !0, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Skeleton, { loading: isLoading && isLoadingScroll, active: !0 }) }),
          props.children
        ]
      }
    ),
    compactAddonAfter && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: styles$4.compactAfter, children: compactAddonAfter })
  ] });
}, "CommonSelect"), Select = /* @__PURE__ */ __name(({ children, ...restProps }) => /* @__PURE__ */ jsxRuntimeExports.jsx(CommonSelect, { ...restProps, children }), "Select"), MultipleSelect = /* @__PURE__ */ __name(({
  mode = "multiple",
  isTopContent,
  isLimitInputHeight,
  ...props
}) => {
  var _a;
  const [isMaxTag, setIsMaxTag] = useState(!1), [dropdownVisible, setDropdownVisible] = useState();
  let maxTagCount = props.maxTagCount, maxTagTextLength = props.maxTagTextLength;
  isTopContent && !isMaxTag && (maxTagCount = "responsive", props.maxTagTextLength || (maxTagTextLength = 10));
  const handleFocus = /* @__PURE__ */ __name((e2) => {
    e2.preventDefault(), isTopContent && setIsMaxTag(!0), props.onFocus && props.onFocus(e2);
  }, "handleFocus"), handleBlur = /* @__PURE__ */ __name((e2) => {
    e2.preventDefault(), isTopContent && setIsMaxTag(!1), props.onBlur && props.onBlur(e2);
  }, "handleBlur"), selectElement = (_a = document.querySelector(".ant-select-focused")) == null ? void 0 : _a.classList;
  return useEffect(() => {
    !dropdownVisible && dropdownVisible !== void 0 ? selectElement == null || selectElement.remove("ant-select-focused") : isTopContent && setIsMaxTag(!0);
  }, [selectElement, dropdownVisible, isTopContent]), /* @__PURE__ */ jsxRuntimeExports.jsx(
    CommonSelect,
    {
      ...props,
      className: cn("select", props.className, {
        [styles$4.selectPosition]: isTopContent && isMaxTag,
        [styles$4.selectScroll]: isLimitInputHeight,
        [styles$4.selectScrollSm]: isLimitInputHeight && props.size === "small",
        [styles$4.selectScrollLg]: isLimitInputHeight && props.size === "large"
      }),
      maxTagCount,
      maxTagTextLength,
      mode,
      onFocus: handleFocus,
      autoFocus: props.autoFocus || dropdownVisible && isTopContent,
      onBlur: handleBlur,
      maxTagPlaceholder: /* @__PURE__ */ __name((omittedValues) => /* @__PURE__ */ jsxRuntimeExports.jsx(Tooltip2, { overlayStyle: { pointerEvents: "none" }, title: omittedValues.map(({ label: label2 }) => label2).join(", "), children: /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: `+${omittedValues == null ? void 0 : omittedValues.length}` }) }), "maxTagPlaceholder"),
      onDropdownVisibleChange: /* @__PURE__ */ __name((visible) => {
        var _a2;
        visible || setIsMaxTag(!1), setDropdownVisible(visible), (_a2 = props == null ? void 0 : props.onDropdownVisibleChange) == null || _a2.call(props, visible);
      }, "onDropdownVisibleChange"),
      children: props.children
    }
  );
}, "MultipleSelect"), fileListDragger = "_file-list-dragger_16hg2_1", styles$3 = {
  fileListDragger
};
function FileInput({
  shouldShowUploadList,
  shouldOpenFileDialogOnClick,
  isMultiple: isMultiple3,
  isDisabled,
  isDirectory,
  ...restProps
}) {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    Upload,
    {
      ...restProps,
      showUploadList: shouldShowUploadList,
      openFileDialogOnClick: shouldOpenFileDialogOnClick,
      multiple: isMultiple3,
      disabled: isDisabled,
      directory: isDirectory
    }
  );
}
__name(FileInput, "FileInput");
function FileInputDragger({
  shouldShowUploadList,
  shouldOpenFileDialogOnClick,
  isMultiple: isMultiple3,
  isDisabled,
  isDirectory,
  ...restProps
}) {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    Upload.Dragger,
    {
      ...restProps,
      className: styles$3.fileListDragger,
      showUploadList: shouldShowUploadList,
      openFileDialogOnClick: shouldOpenFileDialogOnClick,
      multiple: isMultiple3,
      disabled: isDisabled,
      directory: isDirectory
    }
  );
}
__name(FileInputDragger, "FileInputDragger");
FileInput.Dragger = FileInputDragger;
FileInput.LIST_IGNORE = Upload.LIST_IGNORE;
const Checkbox = /* @__PURE__ */ __name(({
  isChecked,
  isDisabled,
  shouldDefaultChecked,
  isRequired,
  ...restProps
}) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  Checkbox$1,
  {
    ...restProps,
    checked: isChecked,
    disabled: isDisabled,
    defaultChecked: shouldDefaultChecked,
    required: isRequired
  }
), "Checkbox");
var client = {}, createRoot, m = ReactDOM__default;
if (process.env.NODE_ENV === "production")
  createRoot = client.createRoot = m.createRoot, client.hydrateRoot = m.hydrateRoot;
else {
  var i = m.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
  createRoot = client.createRoot = function(c, o2) {
    i.usingClientEntryPoint = !0;
    try {
      return m.createRoot(c, o2);
    } finally {
      i.usingClientEntryPoint = !1;
    }
  }, client.hydrateRoot = function(c, h, o2) {
    i.usingClientEntryPoint = !0;
    try {
      return m.hydrateRoot(c, h, o2);
    } finally {
      i.usingClientEntryPoint = !1;
    }
  };
}
function Popover({
  title: title2,
  headerButton,
  maxWidth,
  minWidth,
  maxHeight,
  showHeaderButtons,
  showCloseIcon,
  content,
  isOpen: isOpenProp,
  onOpenChange,
  trigger,
  isArrow,
  ...restProps
}) {
  var _a;
  const { theme: theme2 } = useTheme(), tokenPopover = (_a = theme2 == null ? void 0 : theme2.components) == null ? void 0 : _a.Popover, effectiveMaxWidth = maxWidth ?? (tokenPopover == null ? void 0 : tokenPopover.maxWidth), effectiveMinWidth = minWidth ?? (tokenPopover == null ? void 0 : tokenPopover.titleMinWidth), effectiveMaxHeight = maxHeight ?? (tokenPopover == null ? void 0 : tokenPopover.maxHeight), isControlled = isOpenProp !== void 0, [isOpen, setIsOpen] = useState(isOpenProp ?? !1);
  useEffect(() => {
    isControlled && setIsOpen(isOpenProp);
  }, [isOpenProp, isControlled]);
  const handleClose = /* @__PURE__ */ __name(() => {
    isControlled || setIsOpen(!1), onOpenChange == null || onOpenChange(!1);
  }, "handleClose"), handleOpenChange = /* @__PURE__ */ __name((open) => {
    isControlled || setIsOpen(open), onOpenChange == null || onOpenChange(open);
  }, "handleOpenChange"), effectiveTrigger = (showCloseIcon || showHeaderButtons) && isOpen ? [] : trigger, renderTitle = /* @__PURE__ */ __name(() => !title2 && !headerButton && !showCloseIcon ? null : /* @__PURE__ */ jsxRuntimeExports.jsx(
    PopoverTitle,
    {
      title: title2,
      headerButton,
      showHeaderButtons,
      showCloseIcon,
      handleClose
    }
  ), "renderTitle");
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    Popover$1,
    {
      ...restProps,
      open: isOpen,
      arrow: isArrow,
      overlayStyle: { maxWidth: effectiveMaxWidth, minWidth: effectiveMinWidth, ...restProps.style },
      title: renderTitle(),
      content: /* @__PURE__ */ jsxRuntimeExports.jsx(
        "span",
        {
          className: "uiKitPopoverContent",
          style: { maxHeight: effectiveMaxHeight, display: "block", overflow: "auto" },
          children: typeof content == "function" ? content() : content
        }
      ),
      trigger: effectiveTrigger,
      onOpenChange: handleOpenChange
    }
  );
}
__name(Popover, "Popover");
const header = "_header_1bpuc_1", button = "_button_1bpuc_15", styles$2 = {
  header,
  button
}, PopoverTitle = /* @__PURE__ */ __name(({
  title: title2,
  headerButton,
  showHeaderButtons,
  showCloseIcon,
  handleClose
}) => {
  const titleContent = typeof title2 == "function" ? title2() : title2;
  return showHeaderButtons ? /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$2.header, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: titleContent }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
      headerButton,
      /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { className: styles$2.button, size: "middle", type: "text", onClick: handleClose, icon: /* @__PURE__ */ jsxRuntimeExports.jsx(IconX, {}) })
    ] })
  ] }) : showCloseIcon ? /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$2.header, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: titleContent }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { className: styles$2.button, size: "middle", type: "text", onClick: handleClose, icon: /* @__PURE__ */ jsxRuntimeExports.jsx(IconX, {}) })
  ] }) : titleContent;
}, "PopoverTitle"), optionRow = "_option-row_10jqp_1", optionTitle = "_option-title_10jqp_27", optionChecked = "_option-checked_10jqp_39", optionIconSize = "_option-icon-size_10jqp_47", optionContent = "_option-content_10jqp_57", style = {
  optionRow,
  optionTitle,
  optionChecked,
  optionIconSize,
  optionContent
}, MIN_VISIBLE_COLUMNS = 1, SETTINGS_TEXT = "Выбор колонок", ColumnsSettingsCell = /* @__PURE__ */ __name((props) => {
  var _a, _b, _c;
  const { theme: theme2 } = useTheme(), {
    columnChooserOptionIconColor: color,
    columnChooserOptionIconWidth: width,
    columnChooserOptionIconHeight: height
  } = ((_a = theme2 == null ? void 0 : theme2.components) == null ? void 0 : _a.Table) || {}, handleOnOptionClick = /* @__PURE__ */ __name((value) => {
    var _a2, _b2;
    if ((_a2 = props.checkedColumns) != null && _a2.includes(value)) {
      if (props.checkedColumns.length <= MIN_VISIBLE_COLUMNS) return;
      props.setCheckedColumns((_b2 = props.checkedColumns) == null ? void 0 : _b2.filter((option) => option !== value));
    } else
      props.setCheckedColumns([...props.checkedColumns, value]);
  }, "handleOnOptionClick"), renderPopoverContent = /* @__PURE__ */ __name(() => {
    var _a2;
    return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "css-var-r0 ant-table-css-var", children: (_a2 = props.columns) == null ? void 0 : _a2.map((option) => {
      var _a3, _b2;
      return /* @__PURE__ */ jsxRuntimeExports.jsxs(
        "div",
        {
          className: style.optionRow,
          onClick: /* @__PURE__ */ __name(() => handleOnOptionClick(option.value), "onClick"),
          onKeyDown: /* @__PURE__ */ __name(() => handleOnOptionClick(option.value), "onKeyDown"),
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "span",
              {
                className: cn(style.optionTitle, {
                  [style.optionChecked]: (_a3 = props.checkedColumns) == null ? void 0 : _a3.includes(option.value)
                }),
                children: option.label
              }
            ),
            (_b2 = props.checkedColumns) != null && _b2.includes(option.value) ? /* @__PURE__ */ jsxRuntimeExports.jsx(
              Icon,
              {
                icon: props.iconSettingsCheck ?? /* @__PURE__ */ jsxRuntimeExports.jsx(RefIcon$x, {}),
                style: {
                  color,
                  width,
                  height,
                  fontSize: height
                }
              }
            ) : /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: style.optionIconSize })
          ]
        },
        option.value
      );
    }) });
  }, "renderPopoverContent");
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    Popover,
    {
      content: renderPopoverContent(),
      trigger: "click",
      className: style.settingBtn,
      maxHeight: (_c = (_b = theme2 == null ? void 0 : theme2.components) == null ? void 0 : _b.Table) == null ? void 0 : _c.columnChooserMaxHeight,
      rootClassName: cn("css-var-r0 ant-table-css-var", style.optionContent),
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(Tooltip2, { title: SETTINGS_TEXT, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { type: "text", icon: props.iconSettings ?? /* @__PURE__ */ jsxRuntimeExports.jsx(IconSettings, {}) }) })
    }
  );
}, "ColumnsSettingsCell"), rowTable = "_row-table_ivdbz_1", actionBtn = "_action-btn_ivdbz_3", columnSettingsCell = "_column-settings-cell_ivdbz_25", tableHeaderTransparent = "_table-header-transparent_ivdbz_45", styles$1 = {
  rowTable,
  actionBtn,
  columnSettingsCell,
  tableHeaderTransparent
};
function Table(props) {
  var _a, _b, _c, _d, _e;
  const defaultCheckedList = ((_c = (_b = (_a = props.columns) == null ? void 0 : _a.map((item) => item.key)) == null ? void 0 : _b.filter((value) => value !== void 0)) == null ? void 0 : _c.filter((item) => {
    var _a2, _b2;
    return props.defaultVisibleColumnsList && ((_a2 = props == null ? void 0 : props.defaultVisibleColumnsList) == null ? void 0 : _a2.length) > 0 ? (_b2 = props == null ? void 0 : props.defaultVisibleColumnsList) == null ? void 0 : _b2.includes(item) : item;
  })) || [], [checkedList, setCheckedList] = useState(defaultCheckedList);
  useEffect(() => {
    setCheckedList(defaultCheckedList);
  }, [props.columns]);
  const options = useMemo$1(
    () => {
      var _a2;
      return ((_a2 = props.columns) == null ? void 0 : _a2.map(({ key, title: title2 }) => ({
        label: title2,
        value: key ?? ""
      }))) || [];
    },
    [props.columns]
  ), newColumns = useMemo$1(
    () => {
      var _a2;
      return ((_a2 = props.columns) == null ? void 0 : _a2.map((item) => item.key === void 0 ? item : {
        ...item,
        hidden: !(checkedList != null && checkedList.includes(item.key))
      })) || [];
    },
    [props.columns, checkedList]
  );
  return /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
    ForwardTable,
    {
      ...props,
      className: cn(props.className, { [styles$1.tableHeaderTransparent]: props.withHeaderTransparent }),
      loading: props.isLoading,
      showHeader: props.shouldShowHeader,
      bordered: props.isBordered,
      sticky: props.isSticky,
      virtual: props.isVirtual,
      dataSource: props.data,
      rowClassName: cn(styles$1.rowTable, props.rowClassName),
      columns: props.isNeedToShowSettingsCell || props.renderAction || props.columnActionSettings ? [
        ...newColumns,
        {
          title: props.isNeedToShowSettingsCell && /* @__PURE__ */ jsxRuntimeExports.jsx(
            ColumnsSettingsCell,
            {
              columns: options,
              checkedColumns: checkedList,
              setCheckedColumns: setCheckedList,
              iconSettings: props.iconSettings,
              iconSettingsCheck: props.iconSettingsCheck
            }
          ),
          key: "columnsSettings",
          align: "right",
          render: /* @__PURE__ */ __name((_value, record) => {
            var _a2;
            return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: styles$1.actionBtn, children: (_a2 = props.renderAction) == null ? void 0 : _a2.call(props, record) });
          }, "render"),
          ...props.columnActionSettings,
          className: cn((_d = props.columnActionSettings) == null ? void 0 : _d.className, {
            [styles$1.columnSettingsCell]: !((_e = props.columnActionSettings) != null && _e.title)
          })
        }
      ] : props.columns,
      rowSelection: props.rowSelection,
      onChange: props.onChange,
      onHeaderRow: props.onHeaderRow
    }
  ) });
}
__name(Table, "Table");
Table.Summary = ForwardTable.Summary;
const useTablerIcons = /* @__PURE__ */ __name((wrapperRef) => {
  useEffect(() => {
    if (wrapperRef.current) {
      const spanRightIcon = wrapperRef.current.querySelector(".ant-transfer-operation span.anticon-right");
      spanRightIcon && (spanRightIcon.innerHTML = "", spanRightIcon.parentElement && (spanRightIcon.parentElement.style.marginLeft = "1px"), client.createRoot(spanRightIcon).render(/* @__PURE__ */ jsxRuntimeExports.jsx(IconChevronRight, { width: 16, height: 16 })));
      const spanLeftIcon = wrapperRef.current.querySelector(".ant-transfer-operation span.anticon-left");
      spanLeftIcon && (spanLeftIcon.innerHTML = "", spanLeftIcon.parentElement && (spanLeftIcon.parentElement.style.marginRight = "1px"), client.createRoot(spanLeftIcon).render(/* @__PURE__ */ jsxRuntimeExports.jsx(IconChevronLeft, { width: 16, height: 16 })));
    }
  }, [wrapperRef]);
}, "useTablerIcons"), hidden = "_hidden_1e486_1", titles = "_titles_1e486_13", transferWrapper = "_transfer-wrapper_1e486_25", transferNoSelectionActions = "_transfer-no-selection-actions_1e486_43", styles = {
  hidden,
  titles,
  transferWrapper,
  transferNoSelectionActions
}, { Search: AntSearch } = Input$1, Transfer = /* @__PURE__ */ __name(({
  isDisabled,
  isOneWay,
  isShowSearch,
  isShowSelectAll,
  isFilterOption,
  children,
  listsWidths,
  customNotFoundText,
  locale: locale2,
  withDefaultSelectionActions = !1,
  ...restProps
}) => {
  var _a, _b;
  const { theme: theme2 } = useTheme(), hiddenAntDefaultSearchesRefs = useRef([]);
  useEffect(() => {
    var _a2, _b2, _c, _d, _e, _f;
    if (transferWrapperRef.current) {
      transferWrapperRef.current.querySelectorAll(".ant-transfer-list-header").forEach((header2) => {
        var _a3, _b3;
        header2.style.background = (_b3 = (_a3 = theme2.components) == null ? void 0 : _a3.Transfer) == null ? void 0 : _b3.headerBg;
      }), transferWrapperRef.current.querySelectorAll(".ant-transfer-list-body-search-wrapper").forEach((searchEl) => {
        searchEl.classList.add(styles.hidden);
        const defaultTransferInput = searchEl.querySelector(".ant-input");
        defaultTransferInput && hiddenAntDefaultSearchesRefs.current.push(defaultTransferInput);
      });
      const transferLists = transferWrapperRef.current.querySelectorAll(".ant-transfer-list"), panelsWidths = listsWidths != null && listsWidths.length ? listsWidths.length === 1 ? [listsWidths[0], (_b2 = (_a2 = theme2.components) == null ? void 0 : _a2.Transfer) == null ? void 0 : _b2.panelRightMaxWidth] : listsWidths : [(_d = (_c = theme2.components) == null ? void 0 : _c.Transfer) == null ? void 0 : _d.panelLeftMaxWidth, (_f = (_e = theme2.components) == null ? void 0 : _e.Transfer) == null ? void 0 : _f.panelRightMaxWidth];
      transferLists.length && transferLists.forEach((el, i) => {
        const panelWidth = panelsWidths[i], element = el;
        typeof panelWidth == "number" ? element.style.width = `${panelWidth}px` : typeof panelWidth == "string" && (element.style.width = panelWidth);
      });
    }
  }, []);
  const handleSearch = /* @__PURE__ */ __name((e2) => {
    const searchPosition = e2.target.id === "left" ? 0 : 1;
    hiddenAntDefaultSearchesRefs.current[searchPosition].setAttribute("value", e2.target.value);
    const event = new Event("input", { bubbles: !0 });
    hiddenAntDefaultSearchesRefs.current[searchPosition].dispatchEvent(event);
  }, "handleSearch"), transferWrapperRef = useRef(null);
  return useTablerIcons(transferWrapperRef), /* @__PURE__ */ jsxRuntimeExports.jsx(
    "div",
    {
      ref: transferWrapperRef,
      className: cn(styles.transferWrapper, { [styles.transferNoSelectionActions]: !withDefaultSelectionActions }),
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        Transfer$1,
        {
          ...restProps,
          listStyle: { maxHeight: (_b = (_a = theme2.components) == null ? void 0 : _a.Transfer) == null ? void 0 : _b.maxHeight, ...restProps.listStyle },
          disabled: isDisabled,
          oneWay: isOneWay,
          showSearch: isShowSearch,
          showSelectAll: isShowSelectAll,
          filterOption: isFilterOption,
          selectionsIcon: /* @__PURE__ */ jsxRuntimeExports.jsx(IconChevronDown, { width: 16, height: 16 }),
          titles: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles.titles, children: [
              isShowSearch && /* @__PURE__ */ jsxRuntimeExports.jsx(AntSearch, { placeholder: "Поиск", id: "left", onChange: handleSearch }),
              restProps.titles && restProps.titles[0]
            ] }, "first-list"),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles.titles, children: [
              isShowSearch && /* @__PURE__ */ jsxRuntimeExports.jsx(AntSearch, { placeholder: "Поиск", id: "right", onChange: handleSearch }),
              restProps.titles && restProps.titles[1]
            ] }, "second-list")
          ],
          locale: {
            ...locale2,
            notFoundContent: customNotFoundText ? /* @__PURE__ */ jsxRuntimeExports.jsx(Empty$1, { image: Empty$1.PRESENTED_IMAGE_SIMPLE, description: customNotFoundText }) : void 0
          },
          children
        }
      )
    }
  );
}, "Transfer");
export {
  getConfirmLocale as $,
  toArray$7 as A,
  useMergedState as B,
  ConfigContext as C,
  warningOnce as D,
  merge as E,
  genCollapseMotion as F,
  resetIcon as G,
  useSize as H,
  Icon$3 as I,
  RefIcon$y as J,
  KeyCode as K,
  cloneElement as L,
  initCollapseMotion as M,
  omit as N,
  useSafeState as O,
  Button$2 as P,
  convertLegacyProps as Q,
  RefIcon$A as R,
  useComposeRef as S,
  warning$3 as T,
  useId$2 as U,
  contains as V,
  Portal as W,
  canUseDom as X,
  useEvent as Y,
  useLocale$1 as Z,
  _extends as _,
  cn as a,
  genTreeStyle as a$,
  DisabledContextProvider as a0,
  initFadeMotion as a1,
  initZoomMotion as a2,
  genFocusStyle as a3,
  useCSSVarCls as a4,
  useZIndex as a5,
  ContextIsolator as a6,
  zIndexContext as a7,
  getTransitionName as a8,
  Skeleton as a9,
  extendsObject as aA,
  Pagination2 as aB,
  useBreakpoint as aC,
  responsiveArray as aD,
  Row as aE,
  DefaultRenderEmpty as aF,
  Spin as aG,
  withPureRenderTheme as aH,
  _unsupportedIterableToArray as aI,
  genFocusOutline as aJ,
  RefIcon$x as aK,
  Progress as aL,
  Tooltip$1 as aM,
  DisabledContext as aN,
  Wave as aO,
  RefIcon$z as aP,
  genPresetColor as aQ,
  isPresetColor as aR,
  isPresetStatusColor as aS,
  conductCheck as aT,
  convertDataToEntities as aU,
  useBaseProps as aV,
  useMemo as aW,
  Tree$2 as aX,
  useId$1 as aY,
  BaseSelect as aZ,
  initComponentToken as a_,
  genSubStyleComponent as aa,
  clearFix as ab,
  ConfigProvider as ac,
  useToken as ad,
  CONTAINER_MAX_OFFSET as ae,
  globalConfig as af,
  warnContext as ag,
  getReactRender as ah,
  warning$2 as ai,
  localeValues$1 as aj,
  Keyframe as ak,
  Select$1 as al,
  genPurePanel as am,
  Dropdown$1 as an,
  RefIcon$w as ao,
  useLayoutEffect$1 as ap,
  isEqual as aq,
  wrapperRaf as ar,
  getClientSize as as,
  addEventListenerWrap as at,
  getOffset as au,
  TinyColor as av,
  textEllipsis as aw,
  RefIcon$t as ax,
  RefIcon$o as ay,
  Col as az,
  CSSMotion as b,
  FloatInput as b$,
  getStyle as b0,
  useCompactItemContext as b1,
  useSelectStyle as b2,
  useVariant as b3,
  useShowArrow as b4,
  FormItemInputContext as b5,
  useIcons$1 as b6,
  getStatusClassNames as b7,
  mergedBuiltinPlacements as b8,
  getMergedStatus as b9,
  Tabs as bA,
  Menu as bB,
  IconChevronsRight as bC,
  IconChevronsLeft as bD,
  IconChevronLeft as bE,
  _ as bF,
  IconChevronDown as bG,
  Table as bH,
  Tree as bI,
  lodashExports as bJ,
  Empty as bK,
  Empty$1 as bL,
  instance as bM,
  registerTheme as bN,
  useThemeRegistry as bO,
  THEME_LOCAL_STORAGE_PROP_DEFAULT_NAME as bP,
  DEFAULT_THEME_ID as bQ,
  DEFAULT_THEME as bR,
  ThemeRegistry as bS,
  ThemeContext as bT,
  DatePicker as bU,
  RangePicker as bV,
  TimePicker as bW,
  Form2 as bX,
  FormItem as bY,
  Input2 as bZ,
  MaskedInput$1 as b_,
  SwitcherIconCom as ba,
  useTheme as bb,
  jsxRuntimeExports as bc,
  IconX as bd,
  IconCircleXFilled as be,
  GlobalNotificationContext as bf,
  IconChevronRight as bg,
  Button as bh,
  Prism as bi,
  Layout as bj,
  styles$5 as bk,
  Title as bl,
  Typography as bm,
  Tooltip2 as bn,
  Dropdown as bo,
  Space as bp,
  Badge as bq,
  TypedInputNumber as br,
  Select as bs,
  Checkbox$1 as bt,
  Radio as bu,
  Icon as bv,
  FileInput as bw,
  createRoot as bx,
  ThemeProvider as by,
  nanoid as bz,
  createReactComponent as c,
  MultipleSelect as c0,
  TextArea as c1,
  Checkbox as c2,
  Popover as c3,
  PopoverTitle as c4,
  Segmented as c5,
  Transfer as c6,
  NTypography as c7,
  Card as c8,
  Header2 as c9,
  dayjs as ca,
  InputNumber as cb,
  getDefaultExportFromCjs as cc,
  commonjsGlobal as cd,
  devUseWarning as d,
  composeRef as e,
  replaceElement as f,
  genStyleHooks as g,
  RefIcon$C as h,
  RefIcon$D as i,
  RefIcon$B as j,
  _possibleConstructorReturn as k,
  _getPrototypeOf as l,
  _isNativeReflectConstruct as m,
  _inherits as n,
  _createClass$1 as o,
  pickAttrs as p,
  _classCallCheck$1 as q,
  resetComponent as r,
  _slicedToArray as s,
  _typeof$4 as t,
  unit$1 as u,
  _defineProperty$2 as v,
  CSSMotionList as w,
  _objectWithoutProperties as x,
  _objectSpread2$1 as y,
  _toConsumableArray as z
};
